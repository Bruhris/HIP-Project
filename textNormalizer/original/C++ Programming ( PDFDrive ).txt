Buy. Rent. Access.

Access student data files and other study
tools on cengagebrain.com.

For detailed instructions visit
http://solutions.cengage.com/ctdownloads/
Store your Data Files on a USB drive for maximum efficiency in
organizing and working with the files.
Macintosh users should use a program to expand WinZip or PKZip archives.
Ask your instructor or lab coordinator for assistance.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

C++ PROGRAMMING:
PROGRAM DESIGN INCLUDING DATA STRUCTURES
SEVENTH EDITION

D.S. MALIK

Australia  Brazil  Japan  Korea  Mexico  Singapore  Spain  United Kingdom  United States
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

This is an electronic version of the print textbook. Due to electronic rights restrictions,
some third party content may be suppressed. Editorial review has deemed that any suppressed
content does not materially affect the overall learning experience. The publisher reserves the right
to remove content from this title at any time if subsequent rights restrictions require it. For
valuable information on pricing, previous editions, changes to current editions, and alternate
formats, please visit www.cengage.com/highered to search by ISBN#, author, title, or keyword for
materials in your areas of interest.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

C++ Programming: Program Design
Including Data Structures, Seventh Edition
D.S. Malik
Product Director: Kathleen McMahon
Senior Product Manager: Jim Gish
Senior Content Developer: Alyssa Pratt
Product Assistant: Gillian Daniels
Content Project Manager: Jennifer
Feltri-George
Art Director: GEX Publishing Services
Print Buyer: Julio Esperas
Cover Designer: GEX Publishing Services

ª

Cengage Learning

WCN: 02-200-203
ALL RIGHTS RESERVED. No part of this work covered by the copyright
herein may be reproduced, transmitted, stored or used in any form or by
any means—graphic, electronic, or mechanical, including but not limited
to photocopying, recording, scanning, digitizing, taping, Web distribution,
information networks, or information storage and retrieval systems,
or
of the
United States
except as permitted under Section
Copyright Act—without the prior written permission of the publisher.
For product information and technology assistance, contact us at
Cengage Learning Customer & Sales Support, www.cengage.com/
support.
For permission to use material from this text or product,
submit all requests online at www.cengage.com/permissions.

Cover Photo: ª OlegDoroshin/Shutterstock.com

Further permissions questions can be emailed to
permissionrequest@cengage.com.

Proofreader: Andrea Schein
Indexer: Sharon Hilgenberg
Compositor: Integra Software Services

Library of Congress Control Number:
ISBN- :

--

-

-

Cengage Learning
First Stamford Place, 4th Floor
Stamford, CT
USA
Cengage Learning is a leading provider of customized learning solutions
with office locations around the globe, including Singapore, the United
Kingdom, Australia, Mexico, Brazil, and Japan. Locate your local office
at: www.cengage.com/global
Cengage Learning products are represented in Canada by Nelson
Education, Ltd.
Purchase any of our products at your local college store or at our
preferred online store: www.cengagebrain.com
Some of the product names and company names used in this book have
been used for identification purposes only and may be trademarks or
registered trademarks of their respective manufacturers and sellers.
Microsoft product screenshots used with permission from Microsoft
Corporation.
Unless otherwise credited, all art and tables ª 2015 Cengage Learning,
produced by Integra.
Cengage Learning reserves the right to revise this publication and make
changes from time to time in its content without notice.
Any fictional data related to persons or companies or URLs used
throughout this book is intended for instructional purposes only. At the
time this book was printed, any such data was fictional and not
belonging to any real persons or companies.
The programs in this book are for instructional purposes only. They have
been tested with care, but are not guaranteed for any particular intent
beyond educational purposes. The author and the publisher do not offer
any warranties or representations, nor do they accept any liabilities with
respect to the programs.

Printed in the United States of America
1 2 3 4 5 6 7 20 19 18 17 16 15 14

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

TO
My Parents

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

B RIEF C ONTENTS

ª HunThomas/Shutterstock.com

PREFACE
1. An Overview of Computers and Programming Languages
2. Basic Elements of C++

xxxv
1
27

3. Input/Output

123

4. Control Structures I (Selection)

185

5. Control Structures II (Repetition)

263

6. User-Defined Functions

345

7. User-Defined Simple Data Types, Namespaces,
and the string Type

465

8. Arrays and Strings

519

9. Records (structs)

609

10. Classes and Data Abstraction

649

11. Inheritance and Composition

737

12. Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

811

13. Overloading and Templates

901

14. Exception Handling

997

15. Recursion

1039

16. Linked Lists

1071

17. Stacks and Queues

1165

18. Searching and Sorting Algorithms

1265

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

vi |

C++ Programming: Program Design Including Data Structures, Seventh Edition

19. Binary Trees

1347

20. Graphs

1403

21. Standard Template Library (STL)

1441

APPENDIX A

Reserved Words

1561

APPENDIX B

Operator Precedence

1563

APPENDIX C

Character Sets

1565

APPENDIX D

Operator Overloading

1569

APPENDIX E

Additional C++ Topics

1571

APPENDIX F

Header Files

1593

APPENDIX G

Memory Size on a System and Random
Number Generator

1603

APPENDIX H

References

1605

APPENDIX I

Answers to Odd-Numbered Exercises

1607

INDEX

1649

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

TABLE OF C ONTENTS

ª HunThomas/Shutterstock.com

Preface

1

AN OVERVIEW OF COMPUTERS AND
PROGRAMMING LANGUAGES

xxxv

1

Introduction

2

A Brief Overview of the History
of Computers

2

Elements of a Computer System
Hardware
Central Processing Unit and Main Memory
Input /Output Devices
Software

3
4
4
5
5

The Language of a Computer

5

The Evolution of Programming Languages

7

Processing a C++ Program

9

Programming with the Problem
Analysis–Coding–Execution Cycle

11

Programming Methodologies
Structured Programming
Object-Oriented Programming

20
20
20

ANSI/ISO Standard C++

22

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

viii |

C++ Programming: Program Design Including Data Structures, Seventh Edition

2

Quick Review

22

Exercises

24

BASIC ELEMENTS OF C++

27

A Quick Look at a C++ Program

28

The Basics of a C++ Program
Comments
Special Symbols
Reserved Words (Keywords)
Identifiers
Whitespaces

34
34
35
36
36
37

Data Types
Simple Data Types
Floating-Point Data Types

38
38
41

Data Types, Variables, and Assignment
Statements

42

Arithmetic Operators, Operator Precedence,
and Expressions
Order of Precedence
Expressions
Mixed Expressions

43
46
48
49

Type Conversion (Casting)

51

string Type

53

Variables, Assignment Statements, and Input
Statements
Allocating Memory with Constants and Variables
Putting Data into Variables
Assignment Statement
Saving and Using the Value of an Expression
Declaring and Initializing Variables

54
54
57
57
61
62

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

Input (Read) Statement
Variable Initialization

|

ix

63
66

Increment and Decrement Operators

70

Output

72

Preprocessor Directives
namespace and Using cin and cout
in a Program
Using the string Data Type in a Program

79
80
81

Creating a C++ Program

81

Debugging: Understanding and Fixing
Syntax Errors

85

Program Style and Form
Syntax
Use of Blanks
Use of Semicolons, Brackets, and Commas
Semantics
Naming Identifiers
Prompt Lines
Documentation
Form and Style

89
89
90
90
90
90
91
92
92

More on Assignment Statements

94

Programming Example: Convert Length

96

Programming Example: Make Change

99

Quick Review

103

Exercises

106

Programming Exercises

115

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

x

| C++ Programming: Program Design Including Data Structures, Seventh Edition

3

INPUT/OUTPUT

123

I/O Streams and Standard I/O Devices
cin and the Extraction Operator >>

124
125

Using Predefined Functions in a Program
cin and the get Function
cin and the ignore Function
The putback and peek Functions
The Dot Notation between I/O Stream
Variables and I/O Functions: A Precaution

130
133
135
136

Input Failure
The clear Function

140
142

Output and Formatting Output
setprecision Manipulator
fixed Manipulator
showpoint Manipulator
setw

144
144
145
146
149

Additional Output Formatting Tools
setfill Manipulator
left and right Manipulators

151
151
154

Input/Output and the string Type

156

Debugging: Understanding Logic Errors
and Debugging with cout Statements

157

File Input/Output

160

Programming Example: Movie Tickets
Sale and Donation to Charity

164

Programming Example: Student Grade

170

Quick Review

173

Exercises

174

Programming Exercises

180

139

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

4

|

CONTROL STRUCTURES I (SELECTION)

185

Control Structures
SELECTION: if AND if...else
Relational Operators and Simple Data Types
Comparing Characters
One-Way Selection
Two-Way Selection
int Data Type and Logical (Boolean)
Expressions
bool Data Type and Logical (Boolean)
Expressions
Logical (Boolean) Operators and Logical
Expressions
Order of Precedence

186
187
187
188
189
192

Relational Operators and the string Type
Compound (Block of) Statements
Multiple Selections: Nested if
Comparing if...else Statements with
a Series of if Statements
Short-Circuit Evaluation
Comparing Floating-Point Numbers for Equality:
A Precaution
Associativity of Relational Operators:
A Precaution
Avoiding Bugs by Avoiding Partially Understood
Concepts and Techniques
Input Failure and the if Statement
Confusion between the Equality Operator
(==) and the Assignment Operator (=)
Conditional Operator (?:)
Program Style and Form (Revisited): Indentation

203
205
205

xi

196
196
197
199

208
209
210
211
213
217
220
221
222

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xii

| C++ Programming: Program Design Including Data Structures, Seventh Edition

Using Pseudocode to Develop, Test,
and Debug a Program
switch Structures
Avoiding Bugs by Avoiding Partially Understood
Concepts and Techniques (Revisited)

5

223
225
232

Terminating a Program with the assert
Function

234

Programming Example: Cable Company
Billing

236

Quick Review

242

Exercises

243

Programming Exercises

255

CONTROL STRUCTURES II (REPETITION)

263

Why Is Repetition Needed?

264

while Looping (Repetition) Structure
Designing while Loops
Case 1: Counter-Controlled while Loops
Case 2: Sentinel-Controlled while Loops
Telephone Digits
Case 3: Flag-Controlled while Loops
Number Guessing Game
Case 4: EOF-Controlled while Loops
eof Function
More on Expressions in while Statements

267
271
272
275
278
281
282
284
285
290

Programming Example: Fibonacci Number

291

for Looping (Repetition) Structure

295

Programming Example: Classifying Numbers

303

do ... while Looping (Repetition) Structure

307

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

6

| xiii

Divisibility Test by 3 and 9
Choosing the Right Looping Structure

309
311

break and continue Statements

311

Nested Control Structures

314

Avoiding Bugs by Avoiding Patches

319

Debugging Loops

322

Quick Review

323

Exercises

324

Programming Exercises

337

USER-DEFINED FUNCTIONS

345

Predefined Functions

346

User-Defined Functions

350

Value-Returning Functions
Syntax: Value-Returning Function
Syntax: Formal Parameter List
Function Call
Syntax: Actual Parameter List
return Statement
Syntax: return Statement
Function Prototype
Syntax: Function Prototype
Value-Returning Functions: Some Peculiarities
More Examples of Value-Returning Functions
Flow of Compilation and Execution

351
353
353
353
354
354
354
358
359
360
362
373

Programming Example: Largest Number

374

Void Functions

376

Value Parameters

382

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xiv

|

C++ Programming: Program Design Including Data Structures, Seventh Edition

7

Reference Variables as Parameters
Calculate Grade

384
385

Value and Reference Parameters and
Memory Allocation

388

Reference Parameters and Value-Returning
Functions

397

Scope of an Identifier

397

Global Variables, Named Constants,
and Side Effects

401

Static and Automatic Variables

409

Debugging: Using Drivers and Stubs

411

Function Overloading: An Introduction

413

Functions with Default Parameters

415

Programming Example: Classify Numbers

418

Programming Example: Data Comparison

423

Quick Review

433

Exercises

436

Programming Exercises

451

USER-DEFINED SIMPLE DATA TYPES,
NAMESPACES, AND THE STRING TYPE
Enumeration Type
Declaring Variables
Assignment
Operations on Enumeration Types
Relational Operators
Input /Output of Enumeration Types

465
466
468
468
469
469
470

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

Functions and Enumeration Types
Declaring Variables When Defining the
Enumeration Type
Anonymous Data Types
typedef Statement

xv

473
474
475
475

Programming Example: The Game of Rock,
Paper, and Scissors

477

Namespaces

485

string Type

490

Additional string Operations

8

|

494

Programming Example: Pig Latin Strings

504

Quick Review

508

Exercises

510

Programming Exercises

516

ARRAYS AND STRINGS

519

Arrays
Accessing Array Components
Processing One-Dimensional Arrays
Array Index Out of Bounds
Array Initialization during Declaration
Partial Initialization of Arrays during Declaration
Some Restrictions on Array Processing
Arrays as Parameters to Functions
Constant Arrays as Formal Parameters
Base Address of an Array and Array in Computer
Memory
Functions Cannot Return a Value of the
Type Array

521
523
525
529
530
530
531
532
533
535
538

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xvi

|

C++ Programming: Program Design Including Data Structures, Seventh Edition

Integral Data Type and Array Indices
Other Ways to Declare Arrays

541
542

Searching an Array for a Specific Item
Sorting

542
545

Auto Declaration and Range-Based For Loops

549

C-Strings (Character Arrays)
String Comparison
Reading and Writing Strings
String Input
String Output
Specifying Input/Output Files at Execution Time
string Type and Input/Output Files

550
553
554
554
556
557
557

Parallel Arrays

558

Two- and Multidimensional Arrays
Accessing Array Components
Two-Dimensional Array Initialization during
Declaration
Two-Dimensional Arrays and Enumeration Types
Initialization
Print
Input
Sum by Row
Sum by Column
Largest Element in Each Row and Each Column
Passing Two-Dimensional Arrays as Parameters
to Functions
Arrays of Strings
Arrays of Strings and the string Type
Arrays of Strings and C-Strings (Character Arrays)
Another Way to Declare a Two-Dimensional Array
Multidimensional Arrays

559
561
562
563
566
566
567
567
567
568
568
572
572
572
573
574

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

9

10

|

xvii

Programming Example: Code Detection

576

Programming Example: Text Processing

582

Quick Review

589

Exercises

590

Programming Exercises

602

RECORDS ( STRUCT S)

609

Records ( struct s)
Accessing struct Members
Assignment
Comparison (Relational Operators)
Input /Output
struct Variables and Functions
Arrays versus structs
Arrays in structs
structs in Arrays
structs within a struct

610
612
615
616
617
617
618
619
621
623

Programming Example: Sales Data Analysis

627

Quick Review

641

Exercises

641

Programming Exercises

646

CLASSES AND DATA ABSTRACTION

649

Classes
Unified Modeling Language Class Diagrams
Variable (Object) Declaration
Accessing Class Members
Built-in Operations on Classes

650
654
654
655
657

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xviii

|

C++ Programming: Program Design Including Data Structures, Seventh Edition

Assignment Operator and Classes
Class Scope
Functions and Classes
Reference Parameters and Class Objects
(Variables)
Implementation of Member Functions
Accessor and Mutator Functions
Order of public and private Members of
a Class
Constructors
Invoking a Constructor
Invoking the Default Constructor
Invoking a Constructor with Parameters
Constructors and Default Parameters
Classes and Constructors: A Precaution
In-line Initialization of Data Members and the
Default Constructor
Arrays of Class Objects (Variables) and Constructors
Destructors

657
658
658
658
659
664
668
669
671
671
672
675
675
676
677
679

Data Abstraction, Classes, and Abstract
Data Types

680

A struct Versus a class

682

Information Hiding

683

Executable Code

687

More Examples of Classes

689

Static Members of a Class

698

Programming Example: Juice Machine

705

Quick Review

718

Exercises

720

Programming Exercises

730

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

11

12

| xix

INHERITANCE AND COMPOSITION

737

Inheritance
Redefining (Overriding) Member Functions
of the Base Class
Constructors of Derived and Base Classes
Destructors in a Derived Class
Multiple Inclusions of a Header File
C++ Stream Classes
Protected Members of a Class
Inheritance as public, protected, or private
(Accessing protected Members in the Derived
Class)

738
741
748
757
758
762
763
763
764

Composition (Aggregation)

767

Object-Oriented Design (OOD) and
Object-Oriented Programming (OOP)
Identifying Classes, Objects, and Operations

772
774

Programming Example: Grade Report

775

Quick Review

796

Exercises

797

Programming Exercises

806

POINTERS, CLASSES, VIRTUAL FUNCTIONS,
ABSTRACT CLASSES, AND LISTS
811
Pointer Data Type and Pointer Variables
Declaring Pointer Variables

812
812

Address of Operator (&)

814

Dereferencing Operator (*)

815

Classes, Structs, and Pointer Variables

820

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xx

| C++ Programming: Program Design Including Data Structures, Seventh Edition

Initializing Pointer Variables
Initializing Pointer Variables Using nullptr

823
823

Dynamic Variables
Operator new
Operator delete

824
824
825

Operations on Pointer Variables

829

Dynamic Arrays
Arrays and Range-Based for Loops (Revisited)
Functions and Pointers
Pointers and Function Return Values
Dynamic Two-Dimensional Arrays

831
834
836
836
836

Shallow versus Deep Copy and Pointers

839

Classes and Pointers: Some Peculiarities
Destructor
Assignment Operator
Copy Constructor

841
842
843
845

Inheritance, Pointers, and Virtual Functions
Classes and Virtual Destructors

852
859

Abstract Classes and Pure Virtual Functions

859

Array-Based Lists

868

Unordered Lists

875

Ordered Lists

879

Address of Operator and Classes

881

Quick Review

884

Exercises

887

Programming Exercises

896

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

13

| xxi

OVERLOADING AND TEMPLATES

901

Why Operator Overloading Is Needed

902

Operator Overloading
903
Syntax for Operator Functions
904
Overloading an Operator: Some Restrictions
904
907
Pointer this
Friend Functions of Classes
912
Operator Functions as Member Functions
and Nonmember Functions
915
Overloading Binary Operators
918
Overloading the Stream Insertion (<<)
and Extraction (>>) Operators
924
Overloading the Assignment Operator (=)
929
Overloading Unary Operators
937
Operator Overloading: Member versus Nonmember 943
Classes and Pointer Member Variables (Revisited) 944
Operator Overloading: One Final Word
944
Programming Example: clockType

944

Programming Example: Complex Numbers

953

Overloading the Array Index (Subscript)
Operator ([])

958

Programming Example: newString

960

Function Overloading

966

Templates

967

Function Templates
Class Templates
Array-Based Lists (Revisited)

967
969
972

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xxii |

C++ Programming: Program Design Including Data Structures, Seventh Edition

14

Quick Review

978

Exercises

981

Programming Exercises

987

EXCEPTION HANDLING
Handling Exceptions within a Program
C++ Mechanisms of Exception Handling
try/catch Block
Using C++ Exception Classes

15

997
998
1002
1002
1009

Creating Your Own Exception Classes
Rethrowing and Throwing an Exception

1013
1022

Exception-Handling Techniques
Terminate the Program
Fix the Error and Continue
Log the Error and Continue

1026
1026
1026
1027

Stack Unwinding

1028

Quick Review

1031

Exercises

1033

Programming Exercises

1038

RECURSION
Recursive Definitions
Direct and Indirect Recursion
Infinite Recursion

1039
1040
1042
1042

Problem Solving Using Recursion
Tower of Hanoi: Analysis

1043
1053

Recursion or Iteration?

1053

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

16

| xxiii

Programming Example: Converting a
Number from Binary to Decimal

1055

Programming Example: Converting a
Number from Decimal to Binary

1059

Quick Review

1062

Exercises

1063

Programming Exercises

1067

LINKED LISTS

1071

Linked Lists
Linked Lists: Some Properties
Deletion
Building a Linked List

1072
1073
1079
1080

Linked List as an ADT
Structure of Linked List Nodes
Member Variables of the class
linkedListType
Linked List Iterators
Print the List
Length of a List
Retrieve the Data of the First Node
Retrieve the Data of the Last Node
Begin and End
Copy the List
Destructor
Copy Constructor
Overloading the Assignment Operator

1085
1086
1086
1087
1093
1093
1094
1094
1094
1095
1096
1096
1097

Unordered Linked Lists
Search the List
Insert the First Node

1097
1098
1099

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xxiv

|

C++ Programming: Program Design Including Data Structures, Seventh Edition

Insert the Last Node
Header File of the Unordered Linked List

17

1100
1105

Ordered Linked Lists
Search the List
Insert a Node
Insert First and Insert Last
Delete a Node
Header File of the Ordered Linked List

1106
1107
1108
1112
1113
1114

Print a Linked List in Reverse Order
(Recursion Revisited)
printListReverse

1117
1119

Doubly Linked Lists
Default Constructor
isEmptyList
Destroy the List
Initialize the List
Length of the List
Print the List
Reverse Print the List
Search the List
First and Last Elements

1120
1123
1123
1123
1124
1124
1124
1124
1125
1125

Circular Linked Lists

1131

Programming Example: DVD Store

1132

Quick Review

1152

Exercises

1152

Programming Exercises

1158

STACKS AND QUEUES
Stacks
Stack Operations

1165
1166
1168

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

|

xxv

Implementation of Stacks as Arrays
Initialize Stack
Empty Stack
Full Stack
Push
Return the Top Element
Pop
Copy Stack
Constructor and Destructor
Copy Constructor
Overloading the Assignment Operator (=)
Stack Header File

1170
1173
1174
1174
1174
1176
1176
1178
1178
1179
1179
1180

Programming Example: Highest GPA

1184

Linked Implementation of Stacks
Default Constructor
Empty Stack and Full Stack
Initialize Stack
Push
Return the Top Element
Pop
Copy Stack
Constructors and Destructors
Overloading the Assignment Operator (=)
Stack as Derived from the class
unorderedLinkedList

1188
1191
1191
1192
1192
1194
1194
1196
1197
1197

Application of Stacks: Postfix Expressions
Calculator
Main Algorithm
Function evaluateExpression
Function evaluateOpr
Function discardExp
Function printResult

1200
1201
1204
1204
1206
1208
1208

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xxvi

|

C++ Programming: Program Design Including Data Structures, Seventh Edition

Removing Recursion: Nonrecursive
Algorithm to Print a Linked List Backward

18

1211

Queues
Queue Operations
Implementation of Queues as Arrays
Linked Implementation of Queues
Queue Derived from the class
unorderedLinkedListType

1215
1216
1218
1227
1232

Application of Queues: Simulation
Designing a Queuing System
Customer
Server
Server List
Waiting Customers Queue
Main Program

1233
1234
1235
1238
1241
1245
1247

Quick Review

1251

Exercises

1252

Programming Exercises

1261

SEARCHING AND SORTING ALGORITHMS 1265
Searching and Sorting Algorithms

1266

Search Algorithms
Sequential Search
Binary Search
Performance of Binary Search
Binary Search Algorithm and the class
orderedArrayListType

1266
1267
1269
1274

Asymptotic Notation: Big-O Notation
Lower Bound on Comparison-Based Search
Algorithms

1275
1276
1284

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

19

|

xxvii

Sorting Algorithms

1284

Sorting a List: Bubble Sort
Analysis: Bubble Sort
Bubble Sort Algorithm and the class
unorderedArrayListType

1284
1288
1289

Selection Sort: Array-Based Lists
Analysis: Selection Sort

1290
1292

Insertion Sort: Array-Based Lists
Analysis: Insertion Sort

1292
1296

Lower Bound on Comparison-Based
Sort Algorithms

1297

Quick Sort: Array-Based Lists
Analysis: Quick Sort

1298
1305

Merge Sort: Linked List-Based Lists
Divide
Merge
Analysis: Merge Sort

1306
1308
1310
1313

Programming Example: Election Results

1316

Quick Review

1337

Exercises

1338

Programming Exercises

1343

BINARY TREES

1347

Binary Trees
Copy Tree
Binary Tree Traversal

1348
1353
1354

Implementing Binary Trees

1359

Binary Search Trees
Binary Search Tree: Analysis

1367
1378

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xxviii

| C++ Programming: Program Design Including Data Structures, Seventh Edition

Nonrecursive Binary Tree Traversal Algorithms 1379
Nonrecursive Inorder Traversal
1379
Nonrecursive Preorder Traversal
1381
Nonrecursive Postorder Traversal
1382
Binary Tree Traversal Algorithms
and Functions as Parameters

1383

Programming Example: DVD Store (Revisited) 1387

20

Quick Review

1396

Exercises

1398

Programming Exercises

1401

GRAPHS

1403

Introduction

1404

Graph Definitions and Notations

1405

Graph Representation
Adjacency Matrix
Adjacency Lists

1408
1408
1409

Operations on Graphs

1409

Graphs as ADTs

1410

Graph Traversals
Depth First Traversal
Breadth First Traversal

1414
1414
1416

Shortest Path Algorithm
Shortest Path

1418
1420

Minimal Spanning Tree

1426

Quick Review

1433

Exercises

1435

Programming Exercises

1438

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

21

STANDARD TEMPLATE LIBRARY (STL)

|

xxix

1441

Components of the STL
Container Types
Sequence Containers
Sequence Container: vector
Member Functions Common to All Containers
Member Functions Common to Sequence
Containers
The copy Algorithm
Range-Based for Loops
Initializing vector Objects During Declaration
Sequence Container: deque
Sequence Container: list

1442
1443
1443
1443
1452

Iterators
Types of Iterators
Stream Iterators

1473
1473
1479

Associative Containers
Associative Containers: set and multiset
Declaring set or multiset Associative
Containers
Item Insertion and Deletion from set/multiset

1479
1480

Container Adapters
Stack
Queue

1486
1486
1488

Containers, Associated Header Files,
and Iterator Support

1489

Algorithms
STL Algorithm Classification
Function Objects
Insert Iterator

1490
1491
1493
1499

1454
1455
1458
1461
1462
1466

1480
1482

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xxx |

C++ Programming: Program Design Including Data Structures, Seventh Edition

STL Algorithms
1501
1501
The Functions fill and fill_n
1503
The Functions generate and generate_n
The Functions find, find_if, find_end,
1505
and find_first_of
The Functions remove, remove_if,
remove_copy, and remove_copy_if
1510
The Functions replace, replace_if,
replace_copy, and replace_copy_if
1513
The Functions swap, iter_swap, and
swap_ranges
1517
The Functions search, search_n, sort,
1520
and binary_search
The Functions adjacent_find, merge,
and inplace_merge
1524
The Functions reverse, reverse_copy,
rotate, and rotate_copy
1528
The Functions count, count_if, max,
max_element, min, min_element, and
random_shuffle
1531
1535
The Functions for_each and transform
The Functions includes, set_intersection,
set_union, set_difference, and
set_symmetric_difference
1538
The Functions accumulate,
adjacent_difference,
inner_product, and partial_sum
1546
Quick Review

1551

Exercises

1555

Programming Exercises

1560

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

|

xxxi

APPENDIX A: RESERVED WORDS

1561

APPENDIX B: OPERATOR PRECEDENCE

1563

APPENDIX C: CHARACTER SETS

1565

ASCII (American Standard Code for
Information Interchange)

1565

EBCDIC (Extended Binary Coded Decimal
Interchange Code)

1566

APPENDIX D: OPERATOR OVERLOADING

1569

APPENDIX E: ADDITIONAL C++ TOPICS

1571

Binary (Base 2) Representation of a
Nonnegative Integer
Converting a Base 10 Number to a Binary
Number (Base 2)
Converting a Binary Number (Base 2)
to Base 10
Converting a Binary Number (Base 2)
to Octal (Base 8) and Hexadecimal (Base 16)

1574

More on File Input/Output
Binary Files
Random File Access

1576
1576
1582

Naming Conventions of Header Files in
ANSI/ISO Standard C++ and Standard C++

1590

APPENDIX F: HEADER FILES

1571
1571
1573

1593

Header File cassert (assert.h)

1593

Header File cctype (ctype.h)

1594

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xxxii |

C++ Programming: Program Design Including Data Structures, Seventh Edition

Header File cfloat (float.h)

1595

Header File climits (limits.h)

1596

Header File cmath (math.h)
Header File cstddef (stddef.h)
Header File cstring (string.h)

1598
1599
1599

APPENDIX G: MEMORY SIZE ON A SYSTEM
AND RANDOM NUMBER GENERATOR

Random Number Generator
APPENDIX H: REFERENCES

1603

1604
1605

APPENDIX I: ANSWERS TO ODD-NUMBERED
EXERCISES

1607

Chapter 1

1607

Chapter 2

1610

Chapter 3

1613

Chapter 4

1614

Chapter 5

1617

Chapter 6

1619

Chapter 7

1622

Chapter 8

1623

Chapter 9

1626

Chapter 10

1627

Chapter 11

1630

Chapter 12

1633

Chapter 13

1634

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Table of Contents

|

xxxiii

Chapter 14

1635

Chapter 15

1637

Chapter 16

1638

Chapter 17

1640

Chapter 18

1641

Chapter 19

1643

Chapter 20

1646

Chapter 21

1647

INDEX

1649

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

P REFACE

ª HunThomas/Shutterstock.com

WELCOME TO THE SEVENTH EDITION OF C++ Programming: Program Design Including Data
Structures. Designed for a two semester (CS1 and CS2) C++ course, this text will provide a breath
of fresh air to you and your students. The CS1 and CS2 courses serve as the cornerstone of the
Computer Science curriculum. My primary goal is to motivate and excite all introductory programming students, regardless of their level. Motivation breeds excitement for
learning. Motivation and excitement are critical factors that lead to the success of the
programming student. This text is a culmination and development of my classroom notes
throughout more than fifty semesters of teaching successful programming to Computer
Science students.
Warning: This text can be expected to create a serious reduction in the demand for programming help during your office hours. Other side effects include significantly diminished student
dependency on others while learning to program.
C++ Programming: Program Design Including Data Structures started as a collection of brief
examples, exercises, and lengthy programming examples to supplement the books that were
in use at our university. It soon turned into a collection large enough to develop into a text.
The approach taken in this book is, in fact, driven by the students’ demand for clarity and readability.
The material was written and rewritten until the students felt comfortable with it. Most of the
examples in this book resulted from student interaction in the classroom.
As with any profession, practice is essential. Cooking students practice their recipes. Budding
violinists practice their scales. New programmers must practice solving problems and writing
code. This is not a C++ cookbook. We do not simply list the C++ syntax followed by an
example; we dissect the ‘‘why?’’ behind all the concepts. The crucial question of ‘‘why?’’ is
answered for every topic when first introduced. This technique offers a bridge to learning
C++. Students must understand the ‘‘why?’’ in order to be motivated to learn.
Traditionally, a C++ programming neophyte needed a working knowledge of another
programming language. This book assumes no prior programming experience. However,
some adequate mathematics background such as college algebra is required.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xxxvi

| C++ Programming: Program Design Including Data Structures, Seventh Edition

Changes in the Seventh Edition
The seventh edition contains more than 200 new exercises and more than 30 new programming exercises. A special feature of the seventh edition is the mapping of end-of-chapter
exercises with their respective learning objective(s) listed at the beginning of the chapter.
The first part of Chapter 4 is reorganized by introducing the if and if...else structures
earlier. Also, the first part of Chapter 5 is rewritten. This edition also introduces some features
of C++11, such as range-based for loops, in Chapter 8, and illustrates how to use them to
process the elements of an array, in Chapters 8 and 12, and on sequence containers, in
Chapter 21. We have also included various new examples, such as Examples 2-19, 3-12,
3-13, 3-14, 4-14, 6-5, 6-16, 8-7, 10-11, 11-4, 13-1, and 21-6.

Approach
The programming language C++, which evolved from C, is no longer considered an
industry-only language. Numerous colleges and universities use C++ for their first programming language course. C++ is a combination of structured programming and object-oriented
programming, and this book addresses both types.
This book is intended for a two-semester course, CS1 and CS2, in Computer Science. The first
10 or 11 chapters can be covered in the first course and the remaining in the second course.
In July 1998, ANSI/ISO Standard C++ was officially approved. This book focuses on ANSI/
ISO Standard C++. Even though the syntax of Standard C++ and ANSI/ISO Standard C++
is very similar, Chapter 7 discusses some of the features of ANSI/ISO Standard C++ that are
not available in Standard C++.
Chapter 1 briefly reviews the history of computers and programming languages. The reader can
quickly skim through this chapter and become familiar with some of the hardware components
and the software parts of the computer. This chapter contains a section on processing a C++
program. This chapter also describes structured and object-oriented programming.
Chapter 2 discusses the basic elements of C++. After completing this chapter, students
become familiar with the basics of C++ and are ready to write programs that are complicated
enough to do some computations. Input/output is fundamental to any programming language. It is introduced early, in Chapter 3, and is covered in detail.
Chapters 4 and 5 introduce control structures to alter the sequential flow of execution.
Chapter 6 studies user-defined functions. It is recommended that readers with no prior
programming background spend extra time on Chapter 6. Several examples are provided to
help readers understand the concepts of parameter passing and the scope of an identifier.
Chapter 7 discusses the user-defined simple data type (enumeration type), the namespace
mechanism of ANSI/ISO Standard C++, and the string type. The earlier versions of C did
not include the enumeration type. Enumeration types have very limited use; their main
purpose is to make the program readable. This book is organized such that readers can skip

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Preface

| xxxvii

the section on enumeration types during the first reading without experiencing any discontinuity, and then later go through this section.
Chapter 8 discusses arrays in detail. This chapter also introduces range-based for loops, a feature
of C++11 Standard, and explains how to use them to process the elements of an array.
Limitations of ranged-based for loops on arrays passed as parameters to functions are also
discussed. Chapter 8 also discusses a sequential search algorithm and a selection sort algorithm.
Chapter 9 introduces records (structs). The introduction of structs in this book is similar to
C structs. This chapter is optional; it is not a prerequisite for any of the remaining chapters.
Chapter 10 begins the study of object-oriented programming (OOP) and introduces classes.
The first half of this chapter shows how classes are defined and used in a program. The second
half of the chapter introduces abstract data types (ADTs). This chapter shows how classes in
C++ are a natural way to implement ADTs. Chapter 11 continues with the fundamentals of
object-oriented design (OOD) and OOP, and discusses inheritance and composition. It
explains how classes in C++ provide a natural mechanism for OOD and how C++ supports
OOP. Chapter 11 also discusses how to find the objects in a given problem.
Chapter 12 studies pointers in detail. After introducing pointers and how to use them in a
program, this chapter highlights the peculiarities of classes with pointer data members and
how to avoid them. Moreover, this chapter discusses how to create and work with dynamic
two-dimensional arrays, and also explains why ranged-based for loops cannot be used on
dynamic arrays. Chapter 12 also discusses abstract classes and a type of polymorphism
accomplished via virtual functions.
Chapter 13 continues the study of OOD and OOP. In particular, it studies polymorphism in C++.
Chapter 13 specifically discusses two types of polymorphism—overloading and templates.
Chapter 14 discusses exception handling in detail. Chapter 15 introduces and discusses
recursion. This is a stand-alone chapter, so it can be studied anytime after Chapter 9.
Chapters 16 and 17 are devoted to the study of data structures. Discussed in detail are linked
lists in Chapter 16 and stacks and queues in Chapter 17. The programming code developed in
these chapters is generic. These chapters effectively use the fundamentals of OOD.
Chapter 18 discusses various searching and sorting algorithms. In addition to showing how
these algorithms work, it also provides relevant analysis and results concerning the performance of the algorithms. The algorithm analysis allows the user to decide which algorithm to
use in a particular application. This chapter also includes several sorting algorithms. The
instructor can decide which algorithms to cover.
Chapter 19 provides an introduction to binary trees. Various traversal algorithms, as well as the
basic properties of binary trees, are discussed and illustrated. Special binary trees, called binary
search trees, are introduced. Searching, as well as item insertion and deletion from a binary search
tree, are described and illustrated. Chapter 19 also discusses nonrecursive binary tree traversal
algorithms. Furthermore, to enhance the flexibility of traversal algorithms, it shows how to
construct and pass functions as parameters to other functions. This chapter also discusses AVL
(height balanced) trees in detail. Because of text length considerations, discussion on AVL trees is
provided as a separate section and is available on the Web site accompanying this book.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

xxxviii

| C++ Programming: Program Design Including Data Structures, Seventh Edition

Graph algorithms are discussed in Chapter 20. After introducing the basic graph theory
terminology, the representation of graphs in computer memory is discussed. This chapter
also discusses graph traversal algorithms, the shortest path algorithm, and the minimal spanning tree algorithm. Topological sort is also discussed in this chapter and is available on the
Web site accompanying this book.
C++ is equipped with a powerful library—the Standard Template Library (STL)—of data
structures and algorithms that can be used effectively in a wide variety of applications. Chapter
21 describes the STL in detail. After introducing the three basic components of the STL, it shows
how sequence containers are used in a program. Special containers, such as stacks and queues, are
also discussed. The latter half of this chapter shows how various STL algorithms can be used in a
program. This chapter is fairly long; depending on the availability of time, the instructor can at least
cover the sequence containers, iterators, the classes stack and queue, and certain algorithms.
Appendix A lists the reserved words in C++. Appendix B shows the precedence and
associativity of the C++ operators. Appendix C lists the ASCII (American Standard Code
for Information Interchange) and EBCDIC (Extended Binary Coded Decimal Interchange
Code) character sets. Appendix D lists the C++ operators that can be overloaded.
Appendix E has three objectives. First, we discuss how to convert a number from decimal to
binary and binary to decimal. We then discuss binary and random access files in detail. Finally,
we describe the naming conventions of the header files in both ANSI/ISO Standard C++ and
Standard C++. Appendix F discusses some of the most widely used library routines, and
includes the names of the standard C++ header files. The programs in Appendix G show
how to print the memory size for the built-in data types on your system as well as how to use a
random number generator. Appendix H gives selected references for further study. Appendix I
provides the answers to odd-numbered exercises in the book.
In Figure 1, dotted lines mean that the preceding chapter is used in one of the sections of the
chapter and is not necessarily a prerequisite for the next chapter. For example, Chapter 8
covers arrays in detail. In Chapters 9 and 10, we show the relationship between arrays and
structs and arrays and classes, respectively. However, if Chapter 10 is studied before
Chapter 8, then the section dealing with arrays in Chapter 10 can be skipped without any
discontinuation. This particular section can be studied after studying Chapter 8.
It is recommended that the first six chapters be covered sequentially. After covering the first
six chapters, if the reader is interested in learning OOD and OOP early, then Chapter 10 can
be studied right after Chapter 6. Chapter 7 can be studied anytime after Chapter 6. After
studying the first six chapters in sequence, some of the approaches are:
1.
2.
3.

Study chapters in the sequence: 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21.
Study chapters in the sequence: 8, 10, 12, 13, 11, 15, 16, 17, 14, 18, 19, 20, 21
Study chapters in the sequence: 10, 8, 12, 13, 11, 15, 16, 17, 14, 18, 19, 20, 21.

As the chapter dependency diagram shows, Chapters 17 and 18 can be covered in any sequence.
However, typically, Chapters 17 and 18 are studied in sequence. Ideally, one should study
Chapters 16, 17, 18, and 19 in sequence. Chapters 20 and 21 can be studied in any sequence.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Preface

|

xxxix

How to Use the Book
This book can be used in various ways. Figure 1 shows the dependency of the chapters.
Chapter 1
Chapter 2
Chapter 3
Chapter 4
Chapter 5
Chapter 6

Chapter 7

Chapter 8*

Chapter 9

Chapter 10

Chapter 11

Chapter 12

Chapter 14

Chapter 13
Chapter 15
Chapter 16

Chapter 17

Chapter 19*

Chapter 18

Chapter 20

Chapter 21

FIGURE 1

Chapter dependency diagram

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

FEATURES

OF THE

BOOK

Four-color interior
design shows
accurate C++
code and related
comments.

One video is
available for each
chapter on the
optional
CourseMate that
accompanies this
text. Each video is
designed to
explain how a
program works.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More than 400
visual diagrams,
both extensive
and exhaustive,
illustrate difficult
concepts.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Numbered Examples
illustrate the key
concepts with their
relevant code. The
programming code in
these examples is
followed by a Sample
Run. An explanation
then follows that
describes what each
line in the code does.

Notes highlight
important facts
about the concepts
introduced in the
chapter.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Examples are
where everything in the
chapter comes together.
These examples teach
problem-solving skills and
include the concrete stages
of input, output, problem
analysis and algorithm
design, class design, and
a program listing. All
programs are designed to
be methodical, consistent,
and user-friendly. Each
Programming Example
starts with a problem
analysis that is followed
by the algorithm design
and/or class design, and
every step of the algorithm
is coded in C++. In
addition to helping
students learn problemsolving techniques, these
detailed programs show
the student how to
implement concepts in
an actual C++ program.
We strongly recommend
that students study the
Programming Examples
carefully in order to learn
C++ effectively. Students
typically learn much from
completely worked-out
programs. Further,
programming examples considerably reduce students’ need for help outside the classroom and bolster students’
self-confidence.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises further
reinforce learning
and ensure that
students have, in
fact, mastered the
material.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming
Exercises challenge
students to write
C++ programs with
a specified
outcome.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

S UPPLEMENTAL
R ESOURCES

ª HunThomas/Shutterstock.com

CourseMate
Make the most of your study time with everything you need to succeed in one place. Read
your textbook, highlight and take notes, review flashcards, watch videos, and take practice
quizzes online. Learn more at www.cengage.com/coursemate.
The C++ Programming CourseMate includes the following features:

•

Videos step you through programs in each chapter, while integrated quizzes provide
immediate feedback to gauge your understanding.

•
•

Lab Manual lets you apply material with a wealth of practical, hands-on exercises.

•

Interactive eBook, flashcards, and more!

Interactive Quizzes and Study Games drill key chapter concepts, while openended Assignments develop critical thinking skills.

Instructors may add CourseMate to the textbook package, or students may purchase
CourseMate directly through www.cengagebrain.com.

Source Code
The source code, in ANSI/ISO Standard C++, is available for students to download at
www.cengagebrain.com and through the CourseMate available for this text. These files are also
available to instructors at sso.cengage.com. The input files needed to run some of the programs
are also included with the source code.

Instructor Resources
The following supplemental materials are available when this book is used in a classroom
setting. All teaching tools are available with this book at sso.cengage.com. An instructor account
is required.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Supplemental Resources

| xlvii

Electronic Instructor’s Manual
The Instructor’s Manual follows the text chapter-by-chapter and includes material to assist in
planning and organizing an effective, engaging course.
The Manual includes Overviews, Chapter Objectives, Teaching Tips, Quick Quizzes, Class
Discussion Topics, Additional Projects, Additional Resources, and Key Terms. A Sample
Syllabus is also available.

Test Bank
Cengage Learning Testing Powered by Cognero is a flexible, online system that
allows you to:
• author, edit, and manage test bank content from multiple Cengage Learning solutions

•
•

create multiple test versions in an instant
deliver tests from your LMS, your classroom, or wherever you want

PowerPoint Presentations
This book comes with PowerPoint slides to accompany each chapter. Slides may be used to
guide classroom presentation, to make available to students for chapter review, or to print as
classroom handouts. Instructors can add their own slides for additional topics that they
introduce to the class, as well as customize the slides with the complete Figure Files from
the text.

Solution Files
The solution files for all Programming Exercises, in ANSI/ISO C++, are available for
instructor download at sso.cengage.com. The input files needed to run some of the Programming
Exercises are also included with the solution files.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

A CKNOWLEDGEMENTS

ª HunThomas/Shutterstock.com

There are many people that I must thank who, one way or another, contributed to the success
of this book. First, I would like to thank all the students who, during the preparation, were
spontaneous in telling me if certain portions needed to be reworded for better understanding
and clearer reading. Next, I would like to thank those who e-mailed numerous comments
to improve upon the sixth edition. I am also very grateful to the reviewers who reviewed
earlier versions of this book and offered many critical suggestions on how to improve it.
I owe a great deal to the following reviewers who made helpful, critical suggestions for
improving this edition of the text: Terry Hoffer: City College Montana State University;
Douglas Kranch: North Central State College; Xiangdong Li: New York City College of
Technology; and Jeffrey Miller: Occidental College.
Next, I express thanks to Jim Gish, Senior Product Manager, for recognizing the importance
and uniqueness of this project. All this would not have been possible without the careful
planning of Senior Content Developer, Alyssa Pratt, and Product Development Manager,
Leigh Hefferon. I extend my sincere thanks to Alyssa, as well as to Content Project Manager,
Jennifer Feltri-George. I also thank Shanthi Guruswamy of Integra Software Services for
assisting us in keeping the project on schedule. I would like to thank Chris Scriver and Serge
Palladino of Cengage Learning for patiently and carefully testing the code and discovering
typos and errors.
This book is dedicated to my parents, who I thank for their blessings.
Finally, I am thankful for the support of my wife Sadhana and especially my daughter Shelly.
They cheered me up whenever I was overwhelmed during the writing of this book.
I welcome any comments concerning the text. Comments may be forwarded to the following
e-mail address: malik@creighton.edu.
D. S. Malik

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

CHAPTER

ª HunThomas/Shutterstock.com

A N O VERVIEW OF
COMPUTERS AND
P ROGRAMMING
L ANGUAGES
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about different types of computers

2.

Explore the hardware and software components of a computer system

3.

Learn about the language of a computer

4.

Learn about the evolution of programming languages

5.

Examine high-level programming languages

6.

Discover what a compiler is and what it does

7.

Examine a C++ program

8.

Explore how a C++ program is processed

9.

Learn what an algorithm is and explore problem-solving techniques

10.

Become aware of structured design and object-oriented design programming methodologies

11.

Become aware of Standard C++, ANSI/ISO Standard C++, and C++11

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2 |

Chapter 1: An Overview of Computers and Programming Languages

Introduction
Terms such as ‘‘the Internet,’’ which were unfamiliar just 20 years ago are now common.
Students in elementary school regularly ‘‘surf ’’ the Internet and use computers to design and
implement their classroom projects. Many people use the Internet to look for information and
to communicate with others. This is all made possible by the use of various software, also
known as computer programs. Without software, a computer cannot work. Software is
developed by using programming languages. C++ is one of the programming languages,
which is well suited for developing software to accomplish specific tasks. The main objective
of this book is to help you learn C++ programming language to write programs. Before you
begin programming, it is useful to understand some of the basic terminology and different
components of a computer. We begin with an overview of the history of computers.

A Brief Overview of the History of Computers
The first device known to carry out calculations was the abacus. The abacus was invented in
Asia but was used in ancient Babylon, China, and throughout Europe until the late middle
ages. The abacus uses a system of sliding beads in a rack for addition and subtraction. In 1642,
the French philosopher and mathematician Blaise Pascal invented the calculating device
called the Pascaline. It had eight movable dials on wheels and could calculate sums up to
eight figures long. Both the abacus and Pascaline could perform only addition and subtraction operations. Later in the 17th century, Gottfried von Leibniz invented a device that was
able to add, subtract, multiply, and divide. In 1819, Joseph Jacquard, a French weaver,
discovered that the weaving instructions for his looms could be stored on cards with holes
punched in them. While the cards moved through the loom in sequence, needles passed
through the holes and picked up threads of the correct color and texture. A weaver could
rearrange the cards and change the pattern being woven. In essence, the cards programmed a
loom to produce patterns in cloth. The weaving industry may seem to have little in common
with the computer industry. However, the idea of storing information by punching holes on
a card proved to be of great importance in the later development of computers.
In the early and mid-1800s, Charles Babbage, an English mathematician and physical
scientist, designed two calculating machines: the difference engine and the analytical
engine. The difference engine could perform complex operations such as squaring numbers
automatically. Babbage built a prototype of the difference engine, but did not build the
actual device. The first complete difference engine was completed in London in 2002,
153 years after it was designed. It consists of 8,000 parts, weighs five tons, and measures 11
feet long. A replica of the difference engine was completed in 2008 and is on display at the
Computer History Museum in Mountain View, California (http://www.computerhistory.org/
babbage/). Most of Babbage’s work is known through the writings of his colleague Ada
Augusta, Countess of Lovelace. Augusta is considered the first computer programmer.
At the end of the 19th century, U.S. Census officials needed help in accurately tabulating
the census data. Herman Hollerith invented a calculating machine that ran on electricity
and used punched cards to store data. Hollerith’s machine was immensely successful.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Elements of a Computer System

| 3

Hollerith founded the Tabulating Machine Company, which later became the computer
and technology corporation known as IBM.
The first computer-like machine was the Mark I. It was built, in 1944, jointly by IBM and
Harvard University under the leadership of Howard Aiken. Punched cards were used to feed
data into the machine. The Mark I was 52 feet long, weighed 50 tons, and had 750,000 parts.
In 1946, the Electronic Numerical Integrator and Calculator (ENIAC) was built at the
University of Pennsylvania. It contained 18,000 vacuum tubes and weighed some 30 tons.
The computers that we know today use the design rules given by John von Neumann in
the late 1940s. His design included components such as an arithmetic logic unit, a control
unit, memory, and input/output devices. These components are described in the next
section. Von Neumann’s computer design makes it possible to store the programming
instructions and the data in the same memory space. In 1951, the Universal Automatic
Computer (UNIVAC) was built and sold to the U.S. Census Bureau.
In 1956, the invention of transistors resulted in smaller, faster, more reliable, and more
energy-efficient computers. This era also saw the emergence of the software development
industry, with the introduction of FORTRAN and COBOL, two early programming
languages. In the next major technological advancement, transistors were replaced by
small-sized integrated circuits, or ‘‘chips.’’ Chips are much smaller and more efficient than
transistors, and with today’s new technology it can be made to contain thousands of
circuits on a single chip. They give computers tremendous processing speed.
In 1970, the microprocessor, an entire central processing unit (CPU) on a single chip,
was invented. In 1977, Stephen Wozniak and Steven Jobs designed and built the first
Apple computer in their garage. In 1981, IBM introduced its personal computer (PC). In
the 1980s, clones of the IBM PC made the personal computer even more affordable. By
the mid-1990s, people from many walks of life were able to afford them. Computers
continue to become faster and less expensive as technology advances.
Modern-day computers are powerful, reliable, and easy to use. They can accept spoken-word
instructions and imitate human reasoning through artificial intelligence. Expert systems assist
doctors in making diagnoses. Mobile computing applications are growing significantly. Using
hand-held devices, delivery drivers can access global positioning satellites (GPS) to verify
customer locations for pickups and deliveries. Cell phones permit you to check your e-mail,
make airline reservations, see how stocks are performing, access your bank accounts, and
communicate with family and friends via social media.
Although there are several categories of computers, such as mainframe, midsize, and
micro, all computers share some basic elements, described in the next section.

Elements of a Computer System
A computer is an electronic device capable of performing commands. The basic commands
that a computer performs are input (get data), output (display result), storage, and performance of arithmetic and logical operations. There are two main components of a computer

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

4 |

Chapter 1: An Overview of Computers and Programming Languages

system: hardware and software. In the next few sections, you will learn a brief overview of
these components. Let’s look at hardware first.

Hardware
Major hardware components include the central processing unit (CPU); main memory
(MM), also called random access memory (RAM); input/output devices; and secondary
storage. Some examples of input devices are the keyboard, mouse, and secondary storage.
Examples of output devices are the screen, printer, and secondary storage. Let’s look at
each of these components in greater detail.

Central Processing Unit and Main Memory
The central processing unit is the ‘‘brain’’ of a computer and the most expensive piece
of hardware in a computer. The more powerful the CPU, the faster the computer.
Arithmetic and logical operations are carried out inside the CPU. Figure 1-1(a) shows
some hardware components.

Central
Processing
Unit (CPU)

Main Memory

Secondary Storage

Input
Device
Output
Device

.
.
.
1000
1001
.
.
.
2000
2001
.
.
.
Main

(a)

FIGURE 1-1

.
.
.
54
A
.
.
.

.
.
.
Memory
(b)

Hardware components of a computer and main memory

Main memory, or random access memory, is connected directly to the CPU. All
programs must be loaded into main memory before they can be executed. Similarly, all
data must be brought into main memory before a program can manipulate it. When the
computer is turned off, everything in main memory is lost.
Main memory is an ordered sequence of cells, called memory cells. Each cell has a
unique location in main memory, called the address of the cell. These addresses help
you access the information stored in the cell. Figure 1-1(b) shows main memory with
some data.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

The Language of a Computer

| 5

Today’s computers come with main memory consisting of millions to billions of cells.
Although Figure 1-1(b) shows data stored in cells, the content of a cell can be either a
programming instruction or data. Moreover, this figure shows the data as numbers and
letters. However, as explained later in this chapter, main memory stores everything as
sequences of 0s and 1s. The memory addresses are also expressed as sequences of 0s and 1s.
SECONDARY STORAGE
Because programs and data must be loaded into the main memory before processing and
because everything in main memory is lost when the computer is turned off, information
stored in main memory must be saved in some other device for permanent storage. The device
that stores information permanently (unless the device becomes unusable or you change the
information by rewriting it) is called secondary storage. To be able to transfer information
from main memory to secondary storage, these components must be directly connected to
each other. Examples of secondary storage are hard disks, flash drives, and CD-ROMs.

Input /Output Devices
For a computer to perform a useful task, it must be able to take in data and programs and
display the results of calculations. The devices that feed data and programs into computers
are called input devices. The keyboard, mouse, scanner, camera, and secondary storage are
examples of input devices. The devices that the computer uses to display results are called
output devices. A monitor, printer, and secondary storage are examples of output devices.

Software
Software are programs written to perform specific tasks. For example, word processors
are programs that you use to write letters, papers, and even books. All software is written
in programming languages. There are two types of programs: system programs and
application programs.
System programs control the computer. The system program that loads first when you
turn on your computer is called the operating system. Without an operating system, the
computer is useless. The operating system handles the overall activity of the computer
and provides services. Some of these services include memory management, input/output
activities, and storage management. The operating system has a special program that
organizes secondary storage so that you can conveniently access information. Some
well-known operating systems are Windows 8, Mac OS X, Linux, and Android.
Application programs perform a specific task. Word processors, spreadsheets, and
games are examples of application programs. The operating system is the program that
runs application programs.

The Language of a Computer
When you press A on your keyboard, the computer displays A on the screen. But what is
actually stored inside the computer’s main memory? What is the language of the computer?
How does it store whatever you type on the keyboard?
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

6 |

Chapter 1: An Overview of Computers and Programming Languages

Remember that a computer is an electronic device. Electrical signals are used inside the
computer to process information. There are two types of electrical signals: analog and
digital. Analog signals are continuously varying continuous wave forms used to
represent such things as sound. Audio tapes, for example, store data in analog signals.
Digital signals represent information with a sequence of 0s and 1s. A 0 represents a low
voltage, and a 1 represents a high voltage. Digital signals are more reliable carriers of
information than analog signals and can be copied from one device to another with exact
precision. You might have noticed that when you make a copy of an audio tape, the
sound quality of the copy is not as good as the original tape. On the other hand, when
you copy a CD, the copy is the same as the original. Computers use digital signals.
Because digital signals are processed inside a computer, the language of a computer, called
machine language, is a sequence of 0s and 1s. The digit 0 or 1 is called a binary digit,
or bit. Sometimes a sequence of 0s and 1s is referred to as a binary code or a binary
number.
Bit: A binary digit 0 or 1.

A sequence of eight bits is called a byte. Moreover, 210 bytes = 1024 bytes is called
a kilobyte (KB). Table 1-1 summarizes the terms used to describe various numbers
of bytes.

TABLE 1-1

Binary Units

Unit

Symbol

Byte

Bits/Bytes
8 bits

Kilobyte

KB

210 bytes ¼ 1024 bytes

Megabyte

MB

1024 KB ¼ 210 KB ¼ 220 bytes ¼ 1,048,576 bytes

Gigabyte

GB

1024 MB ¼ 210 MB ¼ 230 bytes ¼ 1,073,741,824 bytes

Terabyte

TB

1024 GB ¼ 210 GB ¼ 240 bytes ¼
1,099,511,627,776 bytes

Petabyte

PB

1024 TB ¼ 210 TB ¼ 250 bytes ¼
1,125,899,906,842,624 bytes

Exabyte

EB

1024 PB ¼ 210 PB ¼ 260 bytes ¼
1,152,921,504,606,846,976 bytes

Zettabyte

ZB

1024 EB ¼ 210 EB ¼ 270 bytes ¼
1,180,591,620,717,411,303,424 bytes

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

The Evolution of Programming Languages

| 7

Every letter, number, or special symbol (such as * or {) on your keyboard is encoded as a
sequence of bits, each having a unique representation. The most commonly used
encoding scheme on personal computers is the seven-bit American Standard Code
for Information Interchange (ASCII). The ASCII data set consists of 128 characters
numbered 0 through 127. That is, in the ASCII data set, the position of the first character
is 0, the position of the second character is 1, and so on. In this scheme, A is encoded as
the binary number 1000001. In fact, A is the 66th character in the ASCII character code,
but its position is 65 because the position of the first character is 0. Furthermore, the
binary number 1000001 is the binary representation of 65. The character 3 is encoded as
0110011. Note that in the ASCII character set, the position of the character 3 is 51, so
the character 3 is the 52nd character in the ASCII set. It also follows that 0110011 is the
binary representation of 51. For a complete list of the printable ASCII character set, refer
to Appendix C.
The number system that we use in our daily life is called the decimal system, or base 10.
Because everything inside a computer is represented as a sequence of 0s and 1s, that is,
binary numbers, the number system that a computer uses is called binary, or base 2. We
indicated in the preceding paragraph that the number 1000001 is the binary representation
of 65. Appendix E describes how to convert a number from base 10 to base 2 and vice versa.

Inside the computer, every character is represented as a sequence of eight bits, that is, as a byte.
Now the eight-bit binary representation of 65 is 01000001. Note that we added 0 to the left
of the seven-bit representation of 65 to convert it to an eight-bit representation. Similarly,
we add one 0 to the binary value of 51 to get its eight-bit binary representation 00110011.
ASCII is a seven-bit code. Therefore, to represent each ASCII character inside the
computer, you must convert the seven-bit binary representation of an ASCII character
to an eight-bit binary representation. This is accomplished by adding 0 to the left of the
seven-bit ASCII encoding of a character. Hence, inside the computer, the character
A is represented as 01000001, and the character 3 is represented as 00110011.
There are other encoding schemes, such as EBCDIC (used by IBM) and Unicode, which
is a more recent development. EBCDIC consists of 256 characters; Unicode consists of
65,536 characters. To store a character belonging to Unicode, you need 16 bits or
two bytes. Unicode was created to represent a variety of characters and is continuously
expanding. It consists of characters from languages other than English.

The Evolution of Programming Languages
The most basic language of a computer, the machine language, provides program
instructions in bits. Even though most computers perform the same kinds of operations,
the designers of the computer may have chosen different sets of binary codes to perform
the operations. Therefore, the machine language of one machine is not necessarily the
same as the machine language of another machine. The only consistency among computers is that in any modern computer, all data is stored and manipulated as binary codes.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

8 |

Chapter 1: An Overview of Computers and Programming Languages

Early computers were programmed in machine language. To see how instructions are
written in machine language, suppose you want to use the equation:
wages = rate



hours

to calculate weekly wages. Further, suppose that the binary code 100100 stands for load,
100110 stands for multiplication, and 100010 stands for store. In machine language, you
might need the following sequence of instructions to calculate weekly wages:
100100 010001
100110 010010
100010 010011

To represent the weekly wages equation in machine language, the programmer had to
remember the machine language codes for various operations. Also, to manipulate data, the
programmer had to remember the locations of the data in the main memory. This need to
remember specific codes made programming not only very difficult, but also error prone.
Assembly languages were developed to make the programmer’s job easier. In assembly
language, an instruction is an easy-to-remember form called a mnemonic. For example,
suppose LOAD stands for the machine code 100100, MULT stands for the machine code
100110 (multiplication), and STOR stands for the machine code 100010.
Using assembly language instructions, you can write the equation to calculate the weekly
wages as follows:
LOAD
MULT
STOR

rate
hours
wages

As you can see, it is much easier to write instructions in assembly language. However,
a computer cannot execute assembly language instructions directly. The instructions first
have to be translated into machine language. A program called an assembler translates
the assembly language instructions into machine language.
Assembler: A program that translates a program written in assembly language into an
equivalent program in machine language.

Moving from machine language to assembly language made programming easier, but
a programmer was still forced to think in terms of individual machine instructions. The
next step toward making programming easier was to devise high-level languages that
were closer to natural languages, such as English, French, German, and Spanish. Basic,
FORTRAN, COBOL, C, C++, C#, and Java are all high-level languages. You will
learn the high-level language C++ in this book.
In C++, you write the weekly wages equation as follows:
wages = rate * hours;

The instruction written in C++ is much easier to understand and is self-explanatory
to a novice user who is familiar with basic arithmetic. As in the case of assembly language,

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Processing a C++ Program

| 9

however, the computer cannot directly execute instructions written in a high-level
language. To execute on a computer, these C++ instructions first need to be translated
into machine language. A program called a compiler translates instructions written in
high-level languages into machine code.
Compiler: A program that translates instructions written in a high-level language into the
equivalent machine language.

Processing a C++ Program
In the previous sections, we discussed machine language and high-level languages and
showed a C++ statement. Because a computer can understand only machine language,
you are ready to review the steps required to process a program written in C++.
Consider the following C++ program:
#include <iostream>
using namespace std;
int main()
{
cout << "My first C++ program." << endl;
return 0;
}

At this point, you need not be too concerned with the details of this program. However,
if you run (execute) this program, it will display the following line on the screen:
My first C++ program.

Recall that a computer can understand only machine language. Therefore, in order to run
this program successfully, the code must first be translated into machine language. In this
section, we review the steps required to execute programs written in C++.
The following steps, as shown in Figure 1-2, are necessary to process a C++ program.
1.

2.

You use a text editor to create a C++ program following the rules, or
syntax, of the high-level language. This program is called the source
code, or source program. The program must be saved in a text file
that has the extension .cpp. For example, if you saved the preceding
program in the file named FirstCPPProgram, then its complete name
is FirstCPPProgram.cpp.
Source program: A program written in a high-level language.
The C++ program given in the preceding section contains the statement
#include <iostream>. In a C++ program, statements that begin with
the symbol # are called preprocessor directives. These statements are processed by a program called preprocessor.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

10 |

3.

4.

5.

6.

Chapter 1: An Overview of Computers and Programming Languages

After processing preprocessor directives, the next step is to verify that the
program obeys the rules of the programming language—that is, the program is
syntactically correct—and translate the program into the equivalent machine
language. The compiler checks the source program for syntax errors and, if no
error is found, translates the program into the equivalent machine language.
The equivalent machine language program is called an object program.
Object program: The machine language version of the high-level language
program.
The programs that you write in a high-level language are developed using an
integrated development environment (IDE). The IDE contains many programs that are useful in creating your program. For example, it contains the
necessary code (program) to display the results of the program and several
mathematical functions to make the programmer’s job somewhat easier.
Therefore, if certain code is already available, you can use this code rather
than writing your own code. Once the program is developed and successfully
compiled, you must still bring the code for the resources used from the IDE
into your program to produce a final program that the computer can execute.
This prewritten code (program) resides in a place called the library. A program
called a linker combines the object program with the programs from libraries.
Linker: A program that combines the object program with other programs
in the library and is used in the program to create the executable code.
You must next load the executable program into main memory for execution. A program called a loader accomplishes this task.
Loader: A program that loads an executable program into main memory.
The final step is to execute the program.

Figure 1-2 shows how a typical C++ program is processed.
C++ Program
Editor

Step 1

Preprocessor

Step 2

Compiler

Syntax
Error

Step 3

Library

FIGURE 1-2

Linker

Step 4

Loader

Step 5

Execution

Step 6

Processing a C++ program

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming with the Problem Analysis–Coding–Execution Cycle |

11

As a programmer, you mainly need to be concerned with Step 1. That is, you must learn,
understand, and master the rules of the programming language to create source programs.
As noted earlier, programs are developed using an IDE. Well-known IDEs used to create
programs in the high-level language C++ include Visual C++ 2012 Express and Visual
Studio 2012 (from Microsoft), and C++ Builder (from Borland). You can also use DevC++ IDE from Bloodshed Software to create and test C++ programs. These IDEs
contain a text editor to create the source program, a compiler to check the source
program for syntax errors, a program to link the object code with the IDE resources,
and a program to execute the program.
These IDEs are quite user friendly. When you compile your program, the compiler not
only identifies the syntax errors, but also typically suggests how to correct them. Moreover, with just a simple command, the object code is linked with the resources used from
the IDE. For example, the command that does the linking on Visual C++ 2012 Express
and Visual Studio 2012 is Build or Rebuild. (For further clarification regarding the use
of these commands, check the documentation of these IDEs.) If the program is not yet
compiled, each of these commands first compiles the program and then links and
produces the executable code.
The Web site http://msdn.microsoft.com/en-us/library/vstudio/ms235629.aspx explains how
to use Visual C++ 2012 Express and Visual Studio 2012 to create a C++ program.

Programming with the Problem
Analysis–Coding–Execution Cycle
Programming is a process of problem solving. Different people use different techniques to solve
problems. Some techniques are nicely outlined and easy to follow. They not only solve
the problem, but also give insight into how the solution is reached. These problemsolving techniques can be easily modified if the domain of the problem changes.
To be a good problem solver and a good programmer, you must follow good problem-solving
techniques. One common problem-solving technique includes analyzing a problem, outlining
the problem requirements, and designing steps, called an algorithm, to solve the problem.
Algorithm: A step-by-step problem-solving process in which a solution is arrived at in a
finite amount of time.

In a programming environment, the problem-solving process requires the following three steps:
1.
2.
3.

Analyze and outline the problem and its solution requirements, and design
an algorithm to solve the problem.
Implement the algorithm in a programming language, such as C++, and
verify that the algorithm works.
Maintain the program by using and modifying it if the problem domain changes.

Figure 1-3 summarizes the first two steps of this programming process.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

12 |

Chapter 1: An Overview of Computers and Programming Languages

Problem

Analysis
Algorithm
Design

Coding

Preprocessor

Compiler
Library

Error

No Error
Linker

Loader

Execution

Error

No Error
Results

FIGURE 1-3

Problem analysis–coding–execution cycle

To develop a program to solve a problem, you start by analyzing the problem. You then
design the algorithm; write the program instructions in a high-level language, or code the
program; and enter the program into a computer system.
Analyzing the problem is the first and most important step. This step requires you to do
the following:
1.
2.

Thoroughly understand the problem.
Understand the problem requirements. Requirements can include whether
the program requires interaction with the user, whether it manipulates data,

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming with the Problem Analysis–Coding–Execution Cycle |

3.

13

whether it produces output, and what the output looks like. If the program
manipulates data, the programmer must know what the data is and how it is
represented. That is, you need to look at sample data. If the program produces
output, you should know how the results should be generated and formatted.
If the problem is complex, divide the problem into subproblems and repeat
Steps 1 and 2. That is, for complex problems, you need to analyze each
subproblem and understand each subproblem’s requirements.

After you carefully analyze the problem, the next step is to design an algorithm to solve the
problem. If you break the problem into subproblems, you need to design an algorithm for
each subproblem. Once you design an algorithm, you need to check it for correctness. You
can sometimes test an algorithm’s correctness by using sample data. At other times, you
might need to perform some mathematical analysis to test the algorithm’s correctness.
Once you have designed the algorithm and verified its correctness, the next step is to
convert it into an equivalent programming code. You then use a text editor to enter the
programming code or the program into a computer. Next, you must make sure that the
program follows the language’s syntax. To verify the correctness of the syntax, you run
the code through a compiler. If the compiler generates error messages, you must identify
the errors in the code, remove them, and then run the code through the compiler again.
When all the syntax errors are removed, the compiler generates the equivalent machine
code, the linker links the machine code with the system’s resources, and the loader places
the program into main memory so that it can be executed.
The final step is to execute the program. The compiler guarantees only that the program
follows the language’s syntax. It does not guarantee that the program will run correctly.
During execution, the program might terminate abnormally due to logical errors, such as
division by zero. Even if the program terminates normally, it may still generate erroneous
results. Under these circumstances, you may have to reexamine the code, the algorithm,
or even the problem analysis.
Your overall programming experience will be successful if you spend enough time to
complete the problem analysis before attempting to write the programming instructions.
Usually, you do this work on paper using a pen or pencil. Taking this careful approach to
programming has a number of advantages. It is much easier to find errors in a program that
is well analyzed and well designed. Furthermore, a carefully analyzed and designed program
is much easier to follow and modify. Even the most experienced programmers spend a
considerable amount of time analyzing a problem and designing an algorithm.
Throughout this book, you will not only learn the rules of writing programs in C++, but you
will also learn problem-solving techniques. Most of the chapters contain programming examples that discuss programming problems. These programming examples teach techniques of
how to analyze and solve problems, design algorithms, code the algorithms into C++, and also
help you understand the concepts discussed in the chapter. To gain the full benefit of this book,
we recommend that you work through these programming examples.
Next, we provide examples of various problem-analysis and algorithm-design techniques.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

14 |

Chapter 1: An Overview of Computers and Programming Languages

EXAMPLE 1-1
In this example, we design an algorithm to find the perimeter and area of a rectangle.
To find the perimeter and area of a rectangle, you need to know the rectangle’s length and
width.
The perimeter and area of the rectangle are then given by the following formulas:
perimeter = 2
area = length




(length + width)
width

The algorithm to find the perimeter and area of the rectangle is:
1.
2.
3.

Get the length of the rectangle.
Get the width of the rectangle.
Find the perimeter using the following equation:
perimeter = 2

4.



(length + width)

Find the area using the following equation:
area = length



width

EXAMPLE 1-2
In this example, we design an algorithm that calculates the sales tax and the price of an item
sold in a particular state.
The sales tax is calculated as follows: The state’s portion of the sales tax is 4%, and the city’s
portion of the sales tax is 1.5%. If the item is a luxury item, such as a car more than $50,000,
then there is a 10% luxury tax.
To calculate the price of the item, we need to calculate the state’s portion of the sales
tax, the city’s portion of the sales tax, and, if it is a luxury item, the luxury tax.
Suppose salePrice denotes the selling price of the item, stateSalesTax denotes
the state’s sales tax, citySalesTax denotes the city’s sales tax, luxuryTax denotes
the luxury tax, salesTax denotes the total sales tax, and amountDue denotes the final price
of the item.
To calculate the sales tax, we must know the selling price of the item and whether the item is
a luxury item.
The stateSalesTax and citySalesTax can be calculated using the following formulas:
stateSalesTax = salePrice  0.04
citySalesTax = salePrice  0.015

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming with the Problem Analysis–Coding–Execution Cycle |

15

Next, you can determine luxuryTax as follows:
if (item is a luxury item)
luxuryTax = salePrice  0.1
otherwise
luxuryTax = 0

Next, you can determine salesTax as follows:
salesTax = stateSalesTax + citySalesTax + luxuryTax

Finally, you can calculate amountDue as follows:
amountDue = salePrice + salesTax

The algorithm to determine salesTax and amountDue is, therefore:
1.
2.
3.

Get the selling price of the item.
Determine whether the item is a luxury item.
Find the state’s portion of the sales tax using the formula:
stateSalesTax = salePrice

4.

0.04

Find the city’s portion of the sales tax using the formula:
citySalesTax = salePrice

5.





0.015

Find the luxury tax using the following formula:
if (item is a luxury item)
luxuryTax = salePrice  0.1
otherwise
luxuryTax = 0

6.

Find salesTax using the formula:
salesTax = stateSalesTax + citySalesTax + luxuryTax

7.

Find amountDue using the formula:
amountDue = salePrice + salesTax

EXAMPLE 1-3

Watch
the Video

In this example, we design an algorithm that calculates the monthly paycheck of a salesperson
at a local department store.
Every salesperson has a base salary. The salesperson also receives a bonus at the end of each
month, based on the following criteria: If the salesperson has been with the store for five years
or less, the bonus is $10 for each year that he or she has worked there. If the salesperson has
been with the store for more than five years, the bonus is $20 for each year that he or she has
worked there. The salesperson can earn an additional bonus as follows: If the total sales made

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

16 |

Chapter 1: An Overview of Computers and Programming Languages

by the salesperson for the month are at least $5,000 but less than $10,000, he or she receives a
3% commission on the sale. If the total sales made by the salesperson for the month are at least
$10,000, he or she receives a 6% commission on the sale.
To calculate a salesperson’s monthly paycheck, you need to know the base salary, the number of
years that the salesperson has been with the company, and the total sales made by the salesperson for that month. Suppose baseSalary denotes the base salary, noOfServiceYears
denotes the number of years that the salesperson has been with the store, bonus denotes
the bonus, totalSales denotes the total sales made by the salesperson for the month, and
additionalBonus denotes the additional bonus.
You can determine the bonus as follows:
if (noOfServiceYears is less than or equal to five)
bonus = 10  noOfServiceYears
otherwise
bonus = 20  noOfServiceYears

Next, you can determine the additional bonus of the salesperson as follows:
if (totalSales is less than 5000)
additionalBonus = 0
otherwise
if (totalSales is greater than or equal to 5000 and
totalSales is less than 10000)
additionalBonus = totalSales  (0.03)
otherwise
additionalBonus = totalSales  (0.06)

Following the above discussion, you can now design the algorithm to calculate a salesperson’s
monthly paycheck:
1.
2.
3.

Get baseSalary.
Get noOfServiceYears.
Calculate bonus using the following formula:
if (noOfServiceYears is less than or equal to five)
bonus = 10  noOfServiceYears
otherwise
bonus = 20  noOfServiceYears

4.
5.

Get totalSales.
Calculate additionalBonus using the following formula:
if (totalSales is less than 5000)
additionalBonus = 0
otherwise
if (totalSales is greater than or equal to 5000 and
totalSales is less than 10000)
additionalBonus = totalSales  (0.03)
otherwise
additionalBonus = totalSales  (0.06)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming with the Problem Analysis–Coding–Execution Cycle |

6.

17

Calculate payCheck using the equation:
payCheck = baseSalary + bonus + additionalBonus

EXAMPLE 1-4
In this example, we design an algorithm to play a number-guessing game.
The objective is to randomly generate an integer greater than or equal to 0 and less than 100.
Then prompt the player (user) to guess the number. If the player guesses the number
correctly, output an appropriate message. Otherwise, check whether the guessed number is
less than the random number. If the guessed number is less than the random number
generated, output the message, ‘‘Your guess is lower than the number. Guess again!’’;
otherwise, output the message, ‘‘Your guess is higher than the number. Guess again!’’. Then
prompt the player to enter another number. The player is prompted to guess the random
number until the player enters the correct number.
The first step is to generate a random number, as described above. C++ provides the means to
do so, which is discussed in Chapter 5. Suppose num stands for the random number and
guess stands for the number guessed by the player.
After the player enters the guess, you can compare the guess with the random number as follows:
if (guess is equal to num)
Print "You guessed the correct number."
otherwise
if (guess is less than num)
Print "Your guess is lower than the number. Guess again!"
otherwise
Print "Your guess is higher than the number. Guess again!"

You can now design an algorithm as follows:
1.
2.

Generate a random number and call it num.
Repeat the following steps until the player has guessed the correct number:
a. Prompt the player to enter guess.
b. Check the value of guess.
if (guess is equal to num)
Print "You guessed the correct number."
otherwise
if (guess is less than num)
Print "Your guess is lower than the number. Guess again!"
otherwise
Print "Your guess is higher than the number. Guess again!"

In Chapter 5, we use this algorithm to write a C++ program to play the guessing the number
game.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

18 |

Chapter 1: An Overview of Computers and Programming Languages

EXAMPLE 1-5
There are 10 students in a class. Each student has taken five tests, and each test is worth 100
points. We want to design an algorithm to calculate the grade for each student, as well as the
class average. The grade is assigned as follows: If the average test score is greater than or equal
to 90, the grade is A; if the average test score is greater than or equal to 80 and less than 90,
the grade is B; if the average test score is greater than or equal to 70 and less than 80, the grade
is C; if the average test score is greater than or equal to 60 and less than 70, the grade is D;
otherwise, the grade is F. Note that the data consists of students’ names and their test scores.
This is a problem that can be divided into subproblems as follows: There are five tests, so you
design an algorithm to find the average test score. Next, you design an algorithm to determine
the grade. The two subproblems are to determine the average test score and to determine the
grade.
Let us first design an algorithm to determine the average test score. To find the average test
score, add the five test scores and then divide the sum by 5. Therefore, the algorithm is the
following:
1.
2.
3.

Get the five test scores.
Add the five test scores. Suppose sum stands for the sum of the test scores.
Suppose average stands for the average test score. Then
average = sum / 5;

Next, you design an algorithm to determine the grade. Suppose grade stands for the grade
assigned to a student. The following algorithm determines the grade:
if average is greater than or equal to 90
grade = A
otherwise
if average is greater than or equal to 80
grade = B
otherwise
if average is greater than or equal to 70
grade = C
otherwise
if average is greater than or equal to 60
grade = D
otherwise
grade = F

You can use the solutions to these subproblems to design the main algorithm as follows:
(Suppose totalAverage stands for the sum of the averages of each student’s test average.)
1.
2.

totalAverage = 0;

Repeat the following steps for each student in the class:
a. Get student’s name.
b. Use the algorithm as discussed above to find the average test score.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming with the Problem Analysis–Coding–Execution Cycle |

19

c. Use the algorithm as discussed above to find the grade.
d. Update totalAverage by adding the current student’s average test score.
3.

Determine the class average as follows:
classAverage = totalAverage / 10

A programming exercise in Chapter 8 asks you to write a C++ program to calculate the
average test score and grade for each student in a class.

Earlier in this chapter, we described the problem analysis, coding, and execution cycle.
In this section, we gave various examples to illustrate the problem analysis and coding cycle.
It must be pointed out that problem analysis is the most important part of programming.
Once you have analyzed the problem and written the necessary steps of the solution in your
native language, then, as you will see throughout the text, writing the C++ code to implement
your solution is relatively easy. In addition, soon you will recognize that the steps of your
solutions can be effecively translated into a C++ code. Furthermore, a good problem analysis
will lead to a better and cleaner program. Even though we have not yet introduced the syntax
of C++, to illustrate how to write a C++ code corresponding to the steps of your solution, let
us consider the algorithm designed in Example 1-1. Suppose length, width,
perimeter, and area represents the length, width, perimeter, and area of a rectangle.
Here are the four steps of the algorithm and their corresponding C++ statement:

Algorithm Step

C++ Instruction (Code)

1. Get the length of the rectangle.

cin >> length;

2. Get the width of the rectangle.

cin >> width;

3. Calculate the perimeter.

perimeter = 2 * (length + width);

4. Calculate the area.

area = length * width;

Consider the first statement. In C++, cin stands for common input. During program
execution, the code associated with it instructs the user to input data and if the user enters
a valid datum, then that datum will be stored in the memory, that is, will become the value
of length. The C++ code in Step 3 uses the values of length and width to compute
the perimeter, which then is assigned to perimeter.
In order to write a complete C++ program to compute the area and perimeter, you need to
know the basic structure of a C++ program, which will be introduced in the next chapter.
However, if you are curious to know how the complete C++ program looks, you can visit the
Web site accompanying this book and look at the programming code stored in the file
Ch1_Example_1-1_Code.cpp.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

20 |

Chapter 1: An Overview of Computers and Programming Languages

Programming Methodologies
Two popular approaches to programming design are the structured approach and the
object-oriented approach, which are outlined below.

Structured Programming
Dividing a problem into smaller subproblems is called structured design. Each
subproblem is then analyzed, and a solution is obtained to solve the subproblem.
The solutions to all of the subproblems are then combined to solve the overall problem.
This process of implementing a structured design is called structured programming.
The structured-design approach is also known as top-down design, bottom-up
design, stepwise refinement, and modular programming.

Object-Oriented Programming
Object-oriented design (OOD) is a widely used programming methodology. In OOD,
the first step in the problem-solving process is to identify the components called objects,
which form the basis of the solution, and to determine how these objects interact with one
another. For example, suppose you want to write a program that automates the video
rental process for a local video store. The two main objects in this problem are the video
and the customer.
After identifying the objects, the next step is to specify for each object the relevant data
and possible operations to be performed on that data. For example, for a video object, the
data might include:
•
•
•
•
•

movie name
year released
producer
production company
number of copies in stock

Some of the operations on a video object might include:
• checking the name of the movie
• reducing the number of copies in stock by one after a copy is rented
• incrementing the number of copies in stock by one after a customer returns a
particular video

This illustrates that each object consists of data and operations on that data. An object
combines data and operations on the data into a single unit. In OOD, the final program is
a collection of interacting objects. A programming language that implements OOD is
called an object-oriented programming (OOP) language. You will learn about the
many advantages of OOD in later chapters.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Methodologies |

21

Because an object consists of data and operations on that data, before you can design and
use objects, you need to learn how to represent data in computer memory, how to
manipulate data, and how to implement operations. In Chapter 2, you will learn the basic
data types of C++ and discover how to represent and manipulate data in computer
memory. Chapter 3 discusses how to input data into a C++ program and output the
results generated by a C++ program.
To create operations, you write algorithms and implement them in a programming
language. Because a data element in a complex program usually has many operations, to
separate operations from each other and to use them effectively and in a convenient
manner, you use functions to implement algorithms. After a brief introduction in
Chapters 2 and 3, you will learn the details of functions in Chapter 6. Certain algorithms
require that a program make decisions, a process called selection. Other algorithms might
require certain statements to be repeated until certain conditions are met, a process called
repetition. Still other algorithms might require both selection and repetition. You will learn
about selection and repetition mechanisms, called control structures, in Chapters 4 and 5.
Also, in Chapter 8, using a mechanism called an array, you will learn how to manipulate
data when data items are of the same type, such as items in a list of sales figures.
Finally, to work with objects, you need to know how to combine data and operations on
the data into a single unit. In C++, the mechanism that allows you to combine data and
operations on the data into a single unit is called a class. You will learn how classes work,
how to work with classes, and how to create classes in the chapter Classes and Data
Abstraction (later in this book).
As you can see, you need to learn quite a few things before working with the OOD
methodology. To make this learning easier and more effective, this book
purposely divides control structures into two chapters (Chapter 4—selection; Chapter 5—
repetition).
For some problems, the structured approach to program design will be very effective.
Other problems will be better addressed by OOD. For example, if a problem requires
manipulating sets of numbers with mathematical functions, you might use the structured
design approach and outline the steps required to obtain the solution. The C++ library
supplies a wealth of functions that you can use effectively to manipulate numbers. On the
other hand, if you want to write a program that would make a candy machine operational, the OOD approach is more effective. C++ was designed especially to implement
OOD. Furthermore, OOD works well with structured design.
Both the structured design and OOD approaches require that you master the basic
components of a programming language to be an effective programmer. In Chapters 2
to 8, you will learn the basic components of C++, such as data types, input/output,
control structures, user-defined functions, and arrays, required by either type of programming. We develop and illustrate how these concepts work using the structured
programming approach. Starting with the chapter Classes and Data Abstraction, we
develop and use the OOD approach.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

22 |

Chapter 1: An Overview of Computers and Programming Languages

ANSI/ISO Standard C++
The programming language C++ evolved from C and was designed by Bjarne Stroustrup
at Bell Laboratories in the early 1980s. From the early 1980s through the early 1990s,
several C++ compilers were available. Even though the fundamental features of C++ in
all compilers were mostly the same, the C++ language, referred to in this book as
Standard C++, was evolving in slightly different ways in different compilers. As a
consequence, C++ programs were not always portable from one compiler to another.
To address this problem, in the early 1990s, a joint committee of the American National
Standards Institute (ANSI) and International Organization for Standardization (ISO) was
established to standardize the syntax of C++. In mid-1998, ANSI/ISO C++ language
standards were approved. Most of today’s compilers comply with these new standards.
Over the last several years, the C++ committee met several times to further standardize
the syntax of C++. In 2011, the second standard of C++ was approved. The main
objective of this standard, referred to as C++11, is to make the C++ code cleaner and
more effective. For example, the new standard introduces the data type long long to deal
with large integers, auto declaration of variables using initialization statements, enhancing
the functionality of for loops to effectively work with arrays and containers, and new
algorithms. Some of these new C++ features are introduced in this book.
This book focuses on the syntax of C++ as approved by ANSI/ISO, referred to as ANSI/
ISO Standard C++.

QUICK REVIEW
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

A computer is an electronic device capable of performing arithmetic and
logical operations.
A computer system has two components: hardware and software.
The central processing unit (CPU) and the main memory are examples of
hardware components.
All programs must be brought into main memory before they can be executed.
When the power is switched off, everything in main memory is lost.
Secondary storage provides permanent storage for information. Hard disks,
flash drives, and CD-ROMs are examples of secondary storage.
Input to the computer is done via an input device. Two common input devices
are the keyboard and the mouse.
The computer sends its output to an output device, such as the computer screen
or a printer.
Software are programs run by the computer.
The operating system handles the overall activity of the computer and provides
services.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

11.
12.
13.
14.
15.

16.
17.
18.
19.

20.
21.
22.
23.

24.

25.
26.
27.
28.

23

The most basic language of a computer is a sequence of 0s and 1s called machine
language. Every computer directly understands its own machine language.
A bit is a binary digit, 0 or 1.
A byte is a sequence of eight bits.
A sequence of 0s and 1s is referred to as a binary code or a binary number.
One kilobyte (KB) is 210 ¼ 1024 bytes; one megabyte (MB) is 220 ¼ 1,048,576
bytes; one gigabyte (GB) is 230 ¼ 1,073,741,824 bytes; one terabyte (TB) is
240 ¼ 1,099,511,627,776 bytes; one petabyte (PB) is 250 ¼ 1,125,899,906,842,624
bytes; one exabyte (EB) is 260 ¼ 1,152,921,504,606,846,976 bytes; and one
zettabyte (ZB) is 270 ¼ 1,180,591,620,717,411,303,424 bytes.
Assembly language uses easy-to-remember instructions called mnemonics.
Assemblers are programs that translate a program written in assembly language
into machine language.
Compilers are programs that translate a program written in a high-level
language into machine code, called object code.
A linker links the object code with other programs provided by the integrated
development environment (IDE) and used in the program to produce executable code.
Typically, six steps are needed to execute a C++ program: edit, preprocess,
compile, link, load, and execute.
A loader transfers executable code into main memory.
An algorithm is a step-by-step problem-solving process in which a solution is
arrived at in a finite amount of time.
The problem-solving process has three steps: analyze the problem and design
an algorithm, implement the algorithm in a programming language, and
maintain the program.
In structured design, a problem is divided into smaller subproblems. Each
subproblem is solved, and the solutions to all of the subproblems are then
combined to solve the problem.
In object-oriented design (OOD), a program is a collection of interacting objects.
An object consists of data and operations on that data.
The ANSI/ISO Standard C++ syntax was approved in mid-1998.
The second standard of C++, C++11, was approved in 2011.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

24 |

Chapter 1: An Overview of Computers and Programming Languages

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.
b.

c.
d.
e.
f.
g.
h.

i.
j.

k.
l.
m.
n.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.

14.

The first device known to carry out calculations was the abacus. (1)
The calculating device Pascaline could perform only addition and
subtraction. (1)
The CPU functions under the control of main memory. (2)
Information stored in secondary storage is permanent. (2)
The language of a computer is a sequence of 0s and 1s. (3)
In Unicode every character is coded as a sequence of 16 bits. (3)
ZB stands for zero byte. (3)
A program written in a high-level programming language is called a source
program. (4)
A compiler translates the source program into an object program. (6)
A linker links and loads the object code from main memory into the CPU
for execution. (8)
Processing of a C++ program includes six steps. (9)
The first step in the problem-solving process is to analyze the problem. (10)
The term OOD stands for object-oriented development. (10)
In object-oriented design, a program is a collection of interacting functions. (10)

What are the two main components of a computer? (2)
What is the purpose of main memory? (2)
Why is secondary storage needed? (2)
What is the function of an operating system? (2)
What are the two types of programs? (2)
What are the differences between machine languages and high-level languages? (3)
What is an object program? (5)
What is the function of a loader? (8)
What is linking? (8)
What kind of errors are reported by a compiler? (8)
What is an algorithm? (9)
Describe the three steps of the problem-solving process in a programming
environment. (9)
What are the advantages of problem analysis and algorithm design over directly writing a
program in a high-level language? (9)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

15.

|

25

Design an algorithm to find the weighted average of four test scores. The
four test scores and their respective weights are given in the following
format: (9)
testScore1 weightTestScore1
...

For example, sample data is as follows:
75
95
85
65
16.

17.

18.

19.

20.

21.

22.

0.20
0.35
0.15
0.30

Design an algorithm to convert the change given in quarters, dimes, nickels,
and pennies into pennies. (9)
Given the radius, in inches, and price of a pizza, design an algorithm to find the
price of the pizza per square inch. (9)
To make a profit, the prices of the items sold in a furniture store are marked up
by 80%. After marking up the prices, each item is put on sale at a discount of
10%. Design an algorithm to find the selling price of an item sold at the
furniture store. What information do you need to find the selling price? (9)
The volume of a sphere is (4.0/3.0)pr3 and the surface is 4.0pr2, where r is the
radius of the sphere. Given the radius, design an algorithm that computes the
volume and surface area of the sphere. Also using the C++ statements provided
for Example 1-1, write the C++ statement corresponding to each statement in
the algorithm. (You may assume that p = 3.141592.) (9)
Tom and Jerry opened a new lawn service. They provide three types of
services: mowing, fertilizing, and planting trees. The cost of mowing is
$35.00 per 5000 square yards, fertilizing is $30.00 per application, and planting
a tree is $50.00. Write an algorithm that prompts the user to enter the area of
the lawn, the number of fertilizing applications, and the number of trees to be
planted. The algorithm then determines the billing amount. (Assume that the
user orders all three services.) (9)
Jason typically uses the Internet to buy various items. If the total cost of the items
ordered, at one time, is $200 or more, then the shipping and handling is free;
otherwise, the shipping and handling is $10 per item. Design an algorithm that
prompts Jason to enter the number of items ordered and the price of each item.
The algorithm then outputs the total billing amount. Your algorithm must use a
loop (repetition structure) to get the price of each item. (For simplicity, you may
assume that Jason orders no more than five items at a time.) (9)
An ATM allows a customer to withdraw a maximum of $500 per day. If a
customer withdraws more than $300, the service charge is 4% of the amount
over $300. If the customer does not have sufficient money in the account, the
ATM informs the customer about the insufficient funds and gives the customer
the option to withdraw the money for a service charge of $25.00. If there is no

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1

26 |

23.

24.

25.

Chapter 1: An Overview of Computers and Programming Languages

money in the account or if the account balance is negative, the ATM does not
allow the customer to withdraw any money. If the amount to be withdrawn is
greater than $500, the ATM informs the customer about the maximum amount
that can be withdrawn. Write an algorithm that allows the customer to enter
the amount to be withdrawn. The algorithm then checks the total amount
in the account, dispenses the money to the customer, and debits the
account by the amount withdrawn and the service charges, if any. (9)
Design an algorithm to find the real roots of a quadratic equation of the form
ax2 + bx + c = 0, where a, b, and c are real numbers, and a is nonzero. (9)
A student spends a majority of his weekend playing and watching sports,
thereby tiring him out and leading him to oversleep and often miss his Monday
8 AM math class. Suppose that the tuition per semester is $25,000 and the
average semester consists of 15 units. If the math class meets three days a week,
one hour each day for 15 weeks, and is a four unit course, how much does each
hour of math class cost the student? Design an algorithm that computes the cost
of each math class. (9)
You are given a list of students names and their test scores. Design an algorithm
that does the following:
a.
b.

c.
d.

Calculates the average test scores.
Determines and prints the names of all the students whose test scores are
below the average test score.
Determines the highest test score.
Prints the names of all the students whose test scores are the same as the
highest test score.

(You must divide this problem into subproblems as follows: The first subproblem
determines the average test score. The second subproblem determines and prints the
names of all the students whose test scores are below the average test score. The third
subproblem determines the highest test score. The fourth subproblem prints the names of
all the students whose test scores are the same as the highest test score. The main
algorithm combines the solutions of the subproblems.) (9)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

CHAPTER

ª HunThomas/Shutterstock.com

B ASIC E LEMENTS

OF

C++

I N T H I S C H A P T E R , YO U W I L L :

1.

Become familiar with the basic components of a C++ program, including functions,
special symbols, and identifiers

2.

Explore simple data types

3.

Discover how to use arithmetic operators

4.

Examine how a program evaluates arithmetic expressions

5.

Become familiar with the string data type

6.

Learn what an assignment statement is and what it does

7.

Learn about variable declaration

8.

Discover how to input data into memory using input statements

9.

Become familiar with the use of increment and decrement operators

10.

Examine ways to output results using output statements

11.

Learn how to use preprocessor directives and why they are necessary

12.

Learn how to debug syntax errors

13.

Explore how to properly structure a program, including using comments to
document a program

14.

Become familiar with compound statements

15.

Learn how to write a C++ program

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

28 |

Chapter 2: Basic Elements of C++

In this chapter, you will learn the basics of C++. As your objective is to learn the C++
programming language, two questions naturally arise. First, what is a computer program?
Second, what is programming? A computer program, or a program, is a sequence of
statements whose objective is to accomplish a task. Programming is a process of
planning and creating a program. These two definitions tell the truth, but not the whole
truth, about programming. It may very well take an entire book to give a good and
satisfactory definition of programming. You might gain a better grasp of the nature of
programming from an analogy, so let us turn to a topic about which almost everyone has
some knowledge—cooking. A recipe is also a program, and everyone with some cooking
experience can agree on the following:
1.
2.
3.
4.
5.

It is usually easier to follow a recipe than to create one.
There are good recipes and there are bad recipes.
Some recipes are easy to follow and some are not easy to follow.
Some recipes produce reliable results and some do not.
You must have some knowledge of how to use cooking tools to follow
a recipe to completion.
6. To create good new recipes, you must have a lot of knowledge and a
good understanding of cooking.
These same six points are also true about programming. Let us take the cooking analogy
one step further. Suppose you need to teach someone how to become a chef. How
would you go about it? Would you first introduce the person to good food, hoping that a
taste for good food develops? Would you have the person follow recipe after recipe in the
hope that some of it rubs off? Or would you first teach the use of tools and the nature of
ingredients, the foods and spices, and explain how they fit together? Just as there is
disagreement about how to teach cooking, there is disagreement about how to teach
programming.
Learning a programming language is like learning to become a chef or learning to
play a musical instrument. All three require direct interaction with the tools.
You cannot become a good chef just by reading recipes. Similarly, you cannot become
a musician by reading books about musical instruments. The same is true of
programming. You must have a fundamental knowledge of the language, and you must
test your programs on the computer to make sure that each program does what it is
supposed to do.

A Quick Look at a C++ Program
In this chapter, you will learn the basic elements and concepts of the C++ programming
language to create C++ programs. In addition to giving examples to illustrate various
concepts, we will also show C++ programs to clarify these concepts. In this section, we
provide an example of a C++ program that computes the perimeter and area of a

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

A Quick Look at a C++ Program |

29

rectangle. At this point you need not be too concerned with the details of this program.
You only need to know the effect of an output statement, which is introduced in this
program.
In Example 1-1 (Chapter 1), we designed an algorithm to find the perimeter and area of a
rectangle. Given the length and width of a rectangle, the C++ program, in Example 2-1,
computes and displays the perimeter and area.

EXAMPLE 2-1
//**************************************************************
// Given the length and width of a rectangle, this C++ program
// computes and outputs the perimeter and area of the rectangle.
//**************************************************************
#include <iostream>
using namespace std;
int main()
{
double
double
double
double

length;
width;
area;
perimeter;

cout << "Program to compute and output the perimeter and "
<< "area of a rectangle." << endl;
length = 6.0;
width = 4.0;
perimeter = 2 * (length + width);
area = length * width;
cout
cout
cout
cout

<<
<<
<<
<<

"Length = " << length << endl;
"Width = " << width << endl;
"Perimeter = " << perimeter << endl;
"Area = " << area << endl;

return 0;
}

Sample Run: (When you compile and execute this program, the following five lines are
displayed on the screen.)
Program to compute and output the perimeter and area of a rectangle.
Length = 6
Width = 4
Perimeter = 20
Area = 24

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

30 |

Chapter 2: Basic Elements of C++

These lines are displayed by the execution of the following statements:
cout << "Program to compute and output the perimeter and "
<< "area of a rectangle." << endl;
cout
cout
cout
cout

<<
<<
<<
<<

"Length = " << length << endl;
"Width = " << width << endl;
"Perimeter = " << perimeter << endl;
"Area = " << area << endl;

Next we explain how this happens. Let us first consider the following statement:
cout << "Program to compute and output the perimeter and "
<< "area of a rectangle." << endl;

This is an example of a C++ output statement. It causes the computer to evaluate the
expression after the pair of symbols << and display the result on the screen.
A C++ program can contain various types of expressions such as arithmetic and strings.
For example, length + width is an arithmetic expression. Anything in double quotes is a
string. For example, "Program to compute and output the perimeter and " is a string.
Similarly, "area of a rectangle." is also a string. Typically, a string evaluates to itself.
Arithmetic expressions are evaluated according to rules of arithmetic operations, which
you typically learn in an arithmetic course. Later in this chapter, we will explain how
arithmetic expressions and strings are formed and evaluated.
Also note that in an output statement, endl causes the insertion point to move to the beginning
of the next line. (Note that in endl, the last letter is lowercase el. Also, on the screen, the
insertion point is where the cursor is.) Therefore, the preceding statement causes the
system to display the following line on the screen.
Program to compute and output the area and perimeter of a rectangle.

Let us now consider the following statement:
cout << "Length = " << length << endl;

This output statement consists of two expressions. The first expression, (after the first <<),
is "Length = " and the second expression, (after the second <<), consists of the identifier
length. The expression "Length = " is a string and evaluates to itself. (Notice the space
after =.) The second expression, which consists of the identifier length, evaluates to
whatever the value of length is. Because the value assigned to length in the program is
6.0, length evaluates to 6.0. Therefore, the output of the preceding statement is:
Length = 6

Note that the value of length is output as 6 not as 6.0. We will explain in the next
chapter how to force the program to output the value of length as 6.0. The meaning of
the remaining output statements is similar.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

A Quick Look at a C++ Program |

31

The last statement, that is,
return 0;

returns the value 0 to the operating system when the program terminates. We will
elaborate on this statement later in this chapter.
Before we identify various parts of a C++ program, let’s look at one more output
statement. Consider the following statement:
cout << "7 + 8 = " << 7 + 8 << endl;

In this output statement, the expression "7 + 8 = ", which is a string, evaluates to itself.
Let us consider the second expression, 7 + 8. This expression consists of the numbers
7 and 8, and the C++ arithmetic operator +. Therefore, the result of the expression 7 + 8
is the sum of 7 and 8, which is 15. Thus, the output of the preceding statement is:
7 + 8 = 15

In this chapter, until we explain how to properly construct a C++ program, we will be
using output statements such as the preceding ones to explain various concepts. After
finishing Chapter 2, you should be able to write C++ programs well enough to do some
computations and show results.
Next, let us note the following about the previous C++ program. A C++ program is a
collection of functions, one of which is the function main. Roughly speaking, a function is
a set of statements whose objective is to accomplish something. The preceding program
consists of only the function main; all C++ programs require a function main.
The first four lines of the program begins with the pair of symbols // (shown in
green), which are comments. Comments are for the user; they typically explain the
purpose of the programs, that is, the meaning of the statements. (We will elaborate
on how to include comments in a program later in this chapter.) The next line of the
program, that is,
#include <iostream>

allows us to use the (predefined object) cout to generate output and the (manipulator)
endl. The statement
using namespace std;

allows you to use cout and endl without the prefix std::. It means that if you do not
include this statement, then cout should be used as std::cout and endl should be used
as std::endl. We will elaborate on this later in this chapter.
Next consider the following line:
int main()

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

32 |

Chapter 2: Basic Elements of C++

This is the heading of the function main. The next line consists of a left brace. This
marks the beginning of the (body) of the function main. The right brace (at the last
line of the program) matches this left brace and marks the end of the body of the
function main. We will explain the meaning of the other terms, such as the ones shown
in blue, later in this book. Note that in C++, << is an operator, called the stream
insertion operator.
Before ending this section, let us identify certain parts of the C++ program in Figure 2-1.

//**************************************************************
// Given the length and width of a rectangle, this C++ program
// computes and outputs the perimeter and area of the rectangle.
//**************************************************************

Comments

#include <iostream>
using namespace std;
int main()
{
double
double
double
double

length;
width;
area;
perimeter;

Variable declarations. A statement such as
double length;
instructs the system to allocate memory
space and name it length.

cout << "Program to compute and output the perimeter and "
<< "area of a rectangle." << endl;
length = 6.0;

Assignment statement. This statement instructs the system
to store 6.0 in the memory space length.

width = 4.0;
perimeter = 2 * (length + width);
Assignment statement.
area = length * width;
This statement instructs the system to evaluate
the expression length * width and store
the result in the memory space area.
cout
cout
cout
cout

<<
<<
<<
<<

"Length = " << length << endl;
"Width = " << width << endl;
"Perimeter = " << perimeter << endl;
"Area = " << area << endl;

Output statements. An
output statement
instructs the system to
display results.

return 0;
}

FIGURE 2-1

Various parts of a C++ program

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

A Quick Look at a C++ Program |

33

One of the terms that you will encounter throughout the text and that is also identified in
Figure 2-1 is variable. Therefore, we introduce this term in this section. Recall from
Chapter 1 that all data must be loaded into main memory before it can be manipulated.
For example, given the length and width, the program in Figure 2-1 computes and
outputs the area and perimeter of a rectangle. This means that the values of length and
width must be stored in main memory. Also, recall from Chapter 1 that main memory is
an ordered sequence of cells and every cell has an address. Inside the computer, the
address of a memory cell is in binary. Once we store the values of length and width, and
because these values might be needed in more than one place in a program, we would
like to know the locations where these values are stored and how to access those memory
locations. C++ makes it easy for a programmer to specify the locations because the
programmer can supply an alphabetic name for each of those locations. Of course, we
must follow the rules to specify the names. For example, in the program in Figure 2-1,
we are telling the system to allocate four memory spaces and name them length, width,
area, and perimeter, respectively. (We will explain the meaning of the word double,
shown in blue later in this chapter.) Essentially, a variable is a memory location whose
contents can be changed. So length, width, area, and perimeter are variables. Also
during program execution, the system will allocate four memory locations large enough
to store decimal numbers and those memory locations will be named length, width,
area, and perimeter, respectively, see Figure 2-2.

length

FIGURE 2-2

width

area

perimeter

Memory allocation

The statement length = 6.0; will cause the system to store 6.0 in the memory
location associated with the name (or identified by the name) length, see Figure 23. Examples 2-14 and 2-19 further illustrate how data is manipulated in variables.

6.0
length

FIGURE 2-3

width

area

perimeter

Memory spaces after the statement length = 6.0; executes

As we proceed through this chapter, we will explain the meaning of the remaining parts
identified in Figure 2-1.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

34 |

Chapter 2: Basic Elements of C++

The Basics of a C++ Program
In the previous section, we gave an example of a C++ program and also identified certain
parts of the program. In general, a C++ program is a collection of one or more
subprograms, called functions. Roughly speaking, a subprogram or a function is a
collection of statements, and when it is activated, or executed, it accomplishes something.
Some functions, called predefined or standard functions, are already written and are
provided as part of the system. But to accomplish most tasks, programmers must learn to
write their own functions.
Every C++ program has a function called main. Thus, if a C++ program has only
one function, it must be the function main. Until Chapter 6, other than using some
of the predefined functions, you will mainly deal with the function main. By the end
of this chapter, you will have learned how to write programs consisting only of the
function main.
If you have never seen a program written in a programming language, the C++ program in
Example 2-1 may look like a foreign language. To make meaningful sentences in a foreign
language, you must learn its alphabet, words, and grammar. The same is true of a programming language. To write meaningful programs, you must learn the programming language’s
special symbols, words, and syntax rules. The syntax rules tell you which statements
(instructions) are legal or valid, that is, which are accepted by the programming language
and which are not. You must also learn semantic rules, which determine the meaning of
the instructions. The programming language’s rules, symbols, and special words enable you
to write programs to solve problems.
Programming language: A set of rules, symbols, and special words.

In the remainder of this section, you will learn about some of the special symbols of a
C++ program. Additional special symbols are introduced as other concepts are encountered in later chapters. Similarly, syntax and semantic rules are introduced and discussed
throughout the book.

Comments
The program that you write should be clear not only to you, but also to the reader of
your program. Part of good programming is the inclusion of comments in the program.
Typically, comments can be used to identify the authors of the program, give the date
when the program is written or modified, give a brief explanation of the program, and
explain the meaning of key statements in a program. In the programming examples, for
the programs that we write, we will not include the date when the program is written,
consistent with the standard convention for writing such books.
Comments are for the reader, not for the compiler. So when a compiler compiles a
program to check for the syntax errors, it completely ignores comments. Throughout this
book, comments are shown in green.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

The Basics of a C++ Program |

35

The program in Example 2-1 contains the following comments:
//**************************************************************
// Given the length and width of a rectangle, this C++ program
// computes and outputs the perimeter and area of the rectangle.
//**************************************************************

There are two common types of comments in a C++ program—single-line comments
and multiple-line comments.
Single-line comments begin with // and can be placed anywhere in the line. Everything
encountered in that line after // is ignored by the compiler. For example, consider the
following statement:
cout << "7 + 8 = " << 7 + 8 << endl;

You can put comments at the end of this line as follows:
cout << "7 + 8 = " << 7 + 8 << endl; //prints: 7 + 8 = 15

This comment could be meaningful for a beginning programmer.
Multiple-line comments are enclosed between /* and */. The compiler ignores anything
that appears between /* and */. For example, the following is an example of a multiple-line
comment:
/*
You can include comments that can
occupy several lines.
*/

In multiple-line comments, many programmers use single-line comments on every line
to make the comments stand out more to the reader (as was done in the program in
Example 2-1.)

Special Symbols
The smallest individual unit of a program written in any language is called a token.
C++’s tokens are divided into special symbols, word symbols, and identifiers.
Following are some of the special symbols:
+
.
<=

;
!=

*
?
==

/
,
>=

The first row includes mathematical symbols for addition, subtraction, multiplication, and
division. The second row consists of punctuation marks taken from English grammar.
Note that the comma is also a special symbol. In C++, commas are used to separate items
in a list. Semicolons are also special symbols and are used to end a C++ statement. Note
that a blank, which is not shown above, is also a special symbol. You create a blank
symbol by pressing the space bar (only once) on the keyboard. The third row consists of

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

36 |

Chapter 2: Basic Elements of C++

tokens made up of two characters that are regarded as a single symbol. No character can
come between the two characters in the token, not even a blank.

Reserved Words (Keywords)
A second category of tokens is reserved word symbols. Some of the reserved word symbols
include the following:
int, float, double, char, const, void, return

Reserved words are also called keywords. The letters that make up a reserved word are
always lowercase. Like the special symbols, each is considered to be a single symbol.
Furthermore, reserved words cannot be redefined within any program; that is, they
cannot be used for anything other than their intended use. For a complete list of reserved
words, see Appendix A.
Throughout this book, reserved words are shown in blue.

Identifiers
A third category of tokens is identifiers. Identifiers are names of things that appear in
programs, such as variables, constants, and functions. All identifiers must obey C++’s
rules for identifiers.
Identifier: A C++ identifier consists of letters, digits, and the underscore character ( _ )
and must begin with a letter or underscore.

Some identifiers are predefined; others are defined by the user. In the C++ program in
Example 2-1, cout is a predefined identifier and length is a user-defined identifier. Two
predefined identifiers that you will encounter frequently are cout and cin. You have
already seen the effect of cout. Later in this chapter, you will learn how cin, which is
used to input data, works. Unlike reserved words, predefined identifiers can be redefined,
but it would not be wise to do so.
Identifiers can be made of only letters, digits, and the underscore character; no other
symbols are permitted to form an identifier.
C++ is case sensitive—uppercase and lowercase letters are considered different. Thus,
the identifier NUMBER is not the same as the identifier number. Similarly, the identifiers
X and x are different.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

The Basics of a C++ Program |

37

In C++, identifiers can be of any length.
EXAMPLE 2-2

2

The following are legal identifiers in C++:
first
conversion
payRate
counter1

Table 2-1 shows some illegal identifiers and explains why they are illegal and also gives
a correct identifier.
TABLE 2-1

Examples of Illegal Identifiers

Illegal Identifier

Reason

A Correct Identifier

employee Salary

There can be no space between
employee and Salary.

employeeSalary

Hello!

The exclamation mark cannot
be used in an identifier.

Hello

one + two

The symbol + cannot be used in
an identifier.

onePlusTwo

2nd

An identifier cannot begin with
a digit.

second

Compiler vendors usually begin certain identifiers with an underscore ( _ ).
When the linker links the object program with the system resources provided by
the integrated development environment (IDE), certain errors could occur. Therefore, it
is advisable that you should not begin identifiers in your program with an underscore ( _ ).

Whitespaces
Every C++ program contains whitespaces. Whitespaces include blanks, tabs, and newline
characters. In a C++ program, whitespaces are used to separate special symbols, reserved
words, and identifiers. Whitespaces are nonprintable in the sense that when they are
printed on a white sheet of paper, the space between special symbols, reserved words, and
identifiers is white. Proper utilization of whitespaces in a program is important. They can
be used to make the program more readable.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

38 |

Chapter 2: Basic Elements of C++

Data Types
The objective of a C++ program is to manipulate data. Different programs manipulate
different data. A program designed to calculate an employee’s paycheck will add, subtract,
multiply, and divide numbers, and some of the numbers might represent hours worked and
pay rate. Similarly, a program designed to alphabetize a class list will manipulate names. You
wouldn’t use a cherry pie recipe to help you bake cookies. Similarly, you wouldn’t use a
program designed to perform arithmetic calculations to manipulate alphabetic characters.
Furthermore, you wouldn’t multiply or subtract names. Reflecting these kinds of underlying
differences, C++ categorizes data into different types, and only certain operations can be
performed on particular types of data. Although at first it may seem confusing, by being so
type conscious, C++ has built-in checks to guard against errors.
Data type: A set of values together with a set of allowed operations.

C++ data types fall into the following three categories:
•
•
•

Simple data type
Structured data type
Pointers

For the next few chapters, you will be concerned only with simple data types.

Simple Data Types
The simple data type is the fundamental data type in C++ because it becomes a building
block for the structured data type, which you will start learning about in Chapter 8.
There are three categories of simple data:
•

Integral, which is a data type that deals with integers, or numbers
without a decimal part
• Floating-point, which is a data type that deals with decimal numbers
• Enumeration, which is a user-defined data type
The enumeration type is C++’s method for allowing programmers to create their own
simple data types. This data type will be discussed in Chapter 7.

Integral data types are further classified into the following categories: char, short, int,
long, bool, unsigned char, unsigned short, unsigned int, unsigned long,
long long, and unsigned long long.
Why are there so many categories of the same data type? Every data type has a different set of
values associated with it. For example, the char data type is used to represent integers between –
128 and 127. The int data type is used to represent integers between –2147483648 and
2147483647, and the data type short is used to represent integers between –32768 and 32767.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Data Types |

39

Which data type you use depends on how big a number your program needs to deal with.
In the early days of programming, computers and main memory were very expensive.
Only a small amount of memory was available to execute programs and manipulate the
data. As a result, programmers had to optimize the use of memory. Because writing a
program and making it work is already a complicated process, not having to worry about
the size of memory makes for one less thing to think about. To effectively use memory, a
programmer can look at the type of data to be used by a program and thereby figure out
which data type to use. (Memory constraints may still be a concern for programs written
for applications such as a wristwatch.)
Table 2-2 gives the range of possible values associated with some integral data types and
the size of memory allocated to manipulate these values.

TABLE 2-2

Values and Memory Allocation for Simple Data Types

Data Type

Values

Storage (in bytes)

int

–2147483648 (= –231) to 2147483647
(= 231 – 1 )

4

bool

true and false

1

char

–128 (= –27) to 127 (= 27 – 1 )

1

long long

–9223372036854775808 (–263) to
9223372036854775807 (263 – 1)

64

Use this table only as a guide. Different compilers may allow different ranges
of values. Check your compiler’s documentation. To find the exact size of the
integral data types on a particular system, you can run a program given in
Appendix G (Memory Size of a System). Furthermore, to find the maximum
and minimum values of these data types, you can run another program given
in Appendix F (Header File climits). Also, the data type long long is
available in C++11.

int DATA TYPE
This section describes the int data type. This discussion also applies to other integral data
types.

Integers in C++, as in mathematics, are numbers such as the following:
-6728, -67, 0, 78, 36782, +763

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

40 |

Chapter 2: Basic Elements of C++

Note the following two rules from these examples:
1. Positive integers do not need a + sign in front of them.
2. No commas are used within an integer. Recall that in C++, commas
are used to separate items in a list. So 36,782 would be interpreted as
two integers: 36 and 782.
bool DATA TYPE
The data type bool has only two values: true and false. Also, true and false are called
the logical (Boolean) values. The central purpose of this data type is to manipulate logical
(Boolean) expressions. Logical (Boolean) expressions will be formally defined and discussed
in detail in Chapter 4. In C++, bool, true, and false are reserved words.
char DATA TYPE
The data type char is mainly used to represent single characters—that is, letters, digits,
and special symbols. Thus, the char data type can represent every key on your keyboard.
When using the char data type, you enclose each character represented within single
quotation marks. Examples of values belonging to the char data type include the
following:
'A', 'a', '0', '*', '+', '$', '&', ' '

Note that a blank space is a character and is written as ' ', with a space between the single
quotation marks.
The data type char allows only one symbol to be placed between the single quotation
marks. Thus, the value 'abc' is not of the type char. Furthermore, even though '!='and
similar special symbols are considered to be one symbol, they are not regarded as possible
values of the data type char. All the individual symbols located on the keyboard that are
printable may be considered as possible values of the char data type.
Several different character data sets are currently in use. The most common are the
American Standard Code for Information Interchange (ASCII) and Extended BinaryCoded Decimal Interchange Code (EBCDIC). The ASCII character set has 128 values.
The EBCDIC character set has 256 values and was created by IBM. Both character sets
are described in Appendix C.
Each of the 128 values of the ASCII character set represents a different character. For
example, the value 65 represents 'A', and the value 43 represents '+'. Thus, each
character has a predefined ordering represented by the numeric value associated with
the character. This ordering is called a collating sequence, in the set. The collating
sequence is used when you compare characters. For example, the value representing 'B'
is 66, so 'A' is smaller than 'B'. Similarly, '+' is smaller than 'A' because 43 is smaller
than 65.
The 14th character in the ASCII character set is called the newline character and is
represented as '\n'. (Note that the position of the newline character in the ASCII

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Data Types |

41

character set is 13 because the position of the first character is 0.) Even though the newline
character is a combination of two characters, it is treated as one character. Similarly, the
horizontal tab character is represented in C++ as '\t' and the null character is represented as '\0' (backslash followed by zero). Furthermore, the first 32 characters in the
ASCII character set are nonprintable. (See Appendix C for a description of these
characters.)

Floating-Point Data Types
To deal with decimal numbers, C++ provides the floating-point data type, which we
discuss in this section. To facilitate the discussion, let us review a concept from a high
school or college algebra course.
You may be familiar with scientific notation. For example:
43872918 = 4.3872918 * 107
.0000265 = 2.65 * 10-5
47.9832 = 4.79832 * 101

{ 10 to the power of seven}
{ 10 to the power of minus five}
{ 10 to the power of one}

To represent decimal numbers, C++ uses a form of scientific notation called floatingpoint notation. Table 2-3 shows how C++ might print a set of decimal numbers using
one machine’s interpretation of floating-point notation. In the C++ floating-point
notation, the letter E stands for the exponent.
TABLE 2-3

Examples of Decimal Numbers in Scientific and C++ Floating-Point Notations

Decimal Number

Scientific Notation

C++ Floating-Point Notation

75.924

7.5924 * 101

7.592400E1

0.18

1.8 * 10-1

1.800000E-1

0.0000453

4.53 * 10

-5

-1.482

-1.482 * 10

7800.0

7.8 * 103

4.530000E-5
0

-1.482000E0
7.800000E3

C++ provides three data types to manipulate decimal numbers: float, double, and
long double. As in the case of integral data types, the data types float, double, and
long double differ in the set of values it can represent.
On most newer compilers, the data types double and long double are the same.
Therefore, only the data types float and double are described here.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

42 |

Chapter 2: Basic Elements of C++

float: The data type float is used in C++ to represent any decimal number between
-3.4 *1038 and 3.4 *1038. The memory allocated for a value of the float data type is

four bytes.
double: The data type double is used in C++ to represent any decimal number
between -1.7 *10308 and 1.7 *10308. The memory allocated for a value of the double

data type is eight bytes.
The maximum and minimum values of the data types float and double are system
dependent. To find these values on a particular system, you can check your compiler’s
documentation or, alternatively, you can run a program given in Appendix F (Header
File cfloat).
Other than the set of values, there is one more difference between the data types float
and double. The maximum number of significant digits—that is, the number of decimal
places—in float values is six or seven. The maximum number of significant digits in
values belonging to the double type is 15.
For values of the double type, for better precision, some compilers might give more
than 15 significant digits. Check your compiler’s documentation.

The maximum number of significant digits is called the precision. Sometimes float values
are called single precision, and values of type double are called double precision. If you
are dealing with decimal numbers, for the most part you need only the float type; if you
need accuracy to more than six or seven decimal places, you can use the double type.
In C++, by default, floating-point numbers are considered type double. Therefore, if
you use the data type float to manipulate floating-point numbers in a program,
certain compilers might give you a warning message, such as ‘‘truncation from double
to float.’’ To avoid such warning messages, you should use the double data type.
For illustration purposes and to avoid such warning messages in programming
examples, this book mostly uses the data type double to manipulate floating-point
numbers.

Data Types, Variables, and Assignment
Statements
Now that we know how to define an identifier, what a data type is, and the term variable,
we can show how to declare a variable. When we declare a variable, not only do we
specify the name of the variable, we also specify what type of data a variable can store. A
syntax rule to declare a variable is:
dataType identifier;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arithmetic Operators, Operator Precedence, and Expressions

|

43

For example, consider the following statements:
int counter;
double interestRate;
char grade;

In the first statement, we are telling the system to allocate four bytes of memory space to
store an int value and name that memory space counter. That is, counter is a variable
that can store an int value. Similarly, interestRate is a variable that can store a value
of type double; and grade is a variable that can store a value of type char.
One way to store a value in a variable is by using an assignment statement, which takes
the following form:
variable = expression;

where expression is evaluated and its value is assigned to variable. In C++, = is called
the assignment operator.
For example, consider the following statements:
counter = 5;
interestRate = 0.05;
grade = 'A';

The first statement stores 5 in the variable counter, the second statement stores 0.05 in
interestRate, and the third statement stores the character 'A' in grade.
We will discuss assignment statements in detail later in this chapter.

Arithmetic Operators, Operator Precedence,
and Expressions
One of the most important uses of a computer is its ability to calculate. You can use the
standard arithmetic operators to manipulate integral and floating-point data types. There
are five arithmetic operators:
Arithmetic Operators: + (addition),  (subtraction or negation), * (multiplication), /
(division), % (mod, (modulus or remainder))
These operators work as follows:
•

You can use the operators +, -, *, and / with both integral and floatingpoint data types. These operators work with integral and floating-point
data the same way as you learned in a college algebra course.

•

When you use / with the integral data type, it gives the quotient in
ordinary division. That is, integral division truncates any fractional part;
there is no rounding.

•

You use % with only the integral data type, to find the remainder in
ordinary division.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

44 |

Chapter 2: Basic Elements of C++

Example 2-3 shows how the operators / and % work with the integral data types.
EXAMPLE 2-3
Arithmetic
Expression

Result

Description

5 / 2

2

In the division 5 / 2, the quotient is 2 and the remainder
is 1. Therefore, 5 / 2 with the integral operands evaluates to
the quotient, which is 2.

14 / 7

2

In the division 14 / 7, the quotient is 2.

34 % 5

4

In the division 34 / 5, the quotient is 6 and the remainder
is 4. Therefore, 34 % 5 evaluates to the remainder,
which is 4.

4 % 6

4

In the division 4 / 6, the quotient is 0 and the remainder is
4. Therefore, 4 % 6 evaluates to the remainder, which is 4.

In the following example, we illustrate how to use the operators / and % with integral
data types.
EXAMPLE 2-4
Given length in inches, we write a program that determines and outputs the equivalent
length in feet and (remaining) inches. Now there are 12 inches in a foot. Therefore, 100
inches equals 8 feet and 4 inches; similarly, 55 inches equals 4 feet and 7 inches. Note
that 100 / 12 = 8 and 100 % 12 = 4; similarly, 55 / 12 = 4 and 55 % 12 = 7. From these
examples, it follows that we can effectively use the operators / and % to accomplish our
task. The desired program is as follows:
// Given length in inches, this program outputs the equivalent
// length in feet and remaining inch(es).
#include <iostream>
using namespace std;
int main()
{
int inches; //variable to store total inches
inches = 100;

//store 100 in the variable inches

cout << inches << " inch(es) = "; //output the value of
//inches and the equal sign
cout << inches / 12 << " feet (foot) and "; //output maximum
//number of feet (foot)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arithmetic Operators, Operator Precedence, and Expressions

|

45

cout << inches % 12 << " inch(es)" << endl; //output
//remaining inches
return 0;
}

2

Sample run:
100 inch(es) = 8 feet (foot) and 4 inch(es)

Note that each time you run this program, it will output the value of 100 inches. To convert
some other value of inches, you need to edit this program and store a different value in the
variable inches, which is not very convenient. Later in this chapter we will illustrate how to
include statements in a program that will instruct the user to enter different values. However,
if you are curious to know at this point, then replace the statement
inches = 100;

//store 100 in the variable inches

with the following statements and rerun the program:
cout << "Enter total inches and press Enter: "; //prompt
//the user to enter total inches
cin >> inches; //store the value entered by the user
//into the variable inches
cout << endl;

The modified program is available at the Web site accompanying this book and is named
Example2_4_Modified.cpp.
Consider the following expressions, which you have been accustomed to working with
since high school: -5, 8 – 7, 3 + 4, 2 + 3 * 5, 5.6 + 6.2 * 3, and x + 2 * 5 + 6 / y, where x
and y are unknown numbers. These are examples of arithmetic expressions. The
numbers appearing in the expressions are called operands. The numbers that are used
to evaluate an operator are called the operands for that operator.
In expression -5, the symbol – specifies that the number 5 is negative. In this expression,
– has only one operand. Operators that have only one operand are called unary operators.
In expression 8 – 7, the symbol – is used to subtract 7 from 8. In this expression, – has
two operands, 8 and 7. Operators that have two operands are called binary operators.
Unary operator: An operator that has only one operand.
Binary operator: An operator that has two operands.

In expression 3 + 4, 3 and 4 are the operands for the operator +. In this expression, the
operator + has two operands and is a binary operator. Moreover, in the expression +27,
the operator + indicates that the number 27 is positive. Here, + has only one operand and
so acts as a unary operator.
From the preceding discussion, it follows that – and + are both unary and binary
arithmetic operators. However, as arithmetic operators, *, /, and % are binary and so
must have two operands.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

46 |

Chapter 2: Basic Elements of C++

Order of Precedence
When more than one arithmetic operator is used in an expression, C++ uses the operator
precedence rules to evaluate the expression. According to the order of precedence rules
for arithmetic operators,
*, / , %
are at a higher level of precedence than
+, Note that the operators *, /, and % have the same level of precedence. Similarly, the
operators + and - have the same level of precedence.
When operators have the same level of precedence, the operations are performed from
left to right. To avoid confusion, you can use parentheses to group arithmetic expressions.
For example, using the order of precedence rules,
3 *7 - 6 + 2 *5 / 4 + 6

means the following:
=
=
=
=
=

(((3 * 7) - 6) + ((2 * 5) / 4 )) + 6
((21 - 6) + (10 / 4)) + 6
(Evaluate
((21 - 6) + 2) + 6
(Evaluate
(15 + 2) + 6
(Evaluate
17 + 6
(Evaluate
23
(Evaluate

*)
/.
-)

Note that this is an integer division.)

first +)
+)

Note that the use of parentheses in the second example clarifies the order of precedence.
You can also use parentheses to override the order of precedence rules.
Because arithmetic operators, using the precedence rules, are evaluated from left to right,
unless parentheses are present, the associativity of the arithmetic operators is said to be
from left to right.
(Character Arithmetic) Because the char data type is also an integral data type, C++
allows you to perform arithmetic operations on char data. However, you should use this
ability carefully. There is a difference between the character '8' and the integer 8. The
integer value of 8 is 8. The integer value of '8' is 56, which is the ASCII collating
sequence of the character '8'.
When evaluating arithmetic expressions, 8 + 7 = 15; '8' + '7' = 56 + 55, which yields
111; and '8' + 7 = 56 + 7, which yields 63. Furthermore, because '8' * '7' = 56 *
55 = 3080 and the ASCII character set has only 128 values, '8' * '7' is undefined in
the ASCII character data set.
These examples illustrate that many things can go wrong when you are performing
character arithmetic. If you must employ them, use arithmetic operations on the char data
type with caution.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arithmetic Operators, Operator Precedence, and Expressions

|

47

The following example shows how arithmetic operators work.
EXAMPLE 2-5
// This program illustrates how arithmetic operators work.
#include <iostream>
using namespace std;
int main()
{
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout
cout
cout
cout
cout
cout
cout

<<
<<
<<
<<
<<
<<
<<

"2 + 5 = " << 2 + 5 << endl;
"13 + 89 = " << 13 + 89 << endl;
"34 - 20 = " << 34 - 20 << endl;
"45 - 90 = " << 45 - 90 << endl;
"2 * 7 = " << 2 * 7 << endl;
"5 / 2 = " << 5 / 2 << endl;
"14 / 7 = " << 14 / 7 << endl;
"34 % 5 = " << 34 % 5 << endl;
"4 % 6 = " << 4 % 6 << endl << endl;
"5.0 + 3.5 = " << 5.0 +
"3.0 + 9.4 = " << 3.0 +
"16.3 - 5.2 = " << 16.3
"4.2 * 2.5 = " << 4.2 *
"5.0 / 2.0 = " << 5.0 /
"34.5 / 6.0 = " << 34.5
"34.5 / 6.5 = " << 34.5

3.5 << endl;
9.4 << endl;
- 5.2 << endl;
2.5 << endl;
2.0 << endl;
/ 6.0 << endl;
/ 6.5 << endl;

return 0;
}

Sample Run:
2 + 5 = 7
13 + 89 = 102
34 - 20 = 14
45 - 90 = -45
2 * 7 = 14
5 / 2 = 2
14 / 7 = 2
34 % 5 = 4
4 % 6 = 4
5.0 + 3.5 = 8.5
3.0 + 9.4 = 12.4
16.3 - 5.2 = 11.1
4.2 * 2.5 = 10.5
5.0 / 2.0 = 2.5
34.5 / 6.0 = 5.75
34.5 / 6.5 = 5.30769

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

48 |

Chapter 2: Basic Elements of C++

You should be careful when evaluating the mod operator with negative integer operands.
You might not get the answer you expect. For example, -34 % 5 = -4, because in the
division –34 / 5, the quotient is –6 and the remainder is -4. Similarly, 34 % -5 = 4,
because in the division 34 / –5, the quotient is –6 and the remainder is 4. Also -34 % -5
= -4, because in the division –34 / –5, the quotient is 6 and the remainder is –4.

Expressions
There are three types of arithmetic expressions in C++:
•

Integral expressions—all operands in the expression are integers. An
integral expression yields an integral result.
• Floating-point (decimal) expressions—all operands in the expression
are floating-points (decimal numbers). A floating-point expression yields
a floating-point result.
• Mixed expressions—the expression contains both integers and decimal
numbers.
Looking at some examples will help clarify these definitions.
EXAMPLE 2-6
Consider the following C++ integral expressions:
2 + 3 * 5
3 + x - y / 7
x + 2 * (y - z) + 18

In these expressions, x, y, and z are variables of type int.

EXAMPLE 2-7
Consider the following C++ floating-point expressions:
12.8 * 17.5 - 34.50
x * 10.5 + y - 16.2

Here, x and y are variables of type double.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arithmetic Operators, Operator Precedence, and Expressions

|

49

Evaluating an integral or a floating-point expression is straightforward. As before, when
operators have the same precedence, the expression is evaluated from left to right. You
can always use parentheses to group operands and operators to avoid confusion.
Next, we discuss mixed expressions.

Mixed Expressions
An expression that has operands of different data types is called a mixed expression. A
mixed expression contains both integers and floating-point numbers. The following
expressions are examples of mixed expressions:
2 + 3.5
6 / 4 + 3.9
5.4 * 2 - 13.6 + 18 / 2

In the first expression, the operand + has one integer operand and one floating-point
operand. In the second expression, both operands for the operator / are integers, the first
operand of + is the result of 6 / 4, and the second operand of + is a floating-point
number. The third example is an even more complicated mix of integers and floatingpoint numbers. The obvious question is: How does C++ evaluate mixed expressions?
Two rules apply when evaluating a mixed expression:
1. When evaluating an operator in a mixed expression:
a.

If the operator has the same types of operands (that is, either both
integers or both floating-point numbers), the operator is evaluated
according to the type of the operands. Integer operands thus yield an
integer result; floating-point numbers yield a floating-point number.
b. If the operator has both types of operands (that is, one is an integer and
the other is a floating-point number), then during calculation, the
integer is changed to a floating-point number with the decimal part of
zero and the operator is evaluated. The result is a floating-point number.
2. The entire expression is evaluated according to the precedence rules;
the multiplication, division, and modulus operators are evaluated
before the addition and subtraction operators. Operators having the
same level of precedence are evaluated from left to right. Grouping
using parentheses is allowed for clarity.
From these rules, it follows that when evaluating a mixed expression, you concentrate on
one operator at a time, using the rules of precedence. If the operator to be evaluated has
operands of the same data type, evaluate the operator using Rule 1(a). That is, an operator
with integer operands will yield an integer result, and an operator with floating-point
operands will yield a floating-point result. If the operator to be evaluated has one integer
operand and one floating-point operand, before evaluating this operator, convert the
integer operand to a floating-point number with the decimal part of 0. The following
examples show how to evaluate mixed expressions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

50 |

Chapter 2: Basic Elements of C++

EXAMPLE 2-8
Mixed Expression

Evaluation

Rule Applied

3 / 2 + 5.5

= 1 + 5.5
= 6.5

15.6 / 2 + 5

= 7.8 + 5

3/2 = 1 (integer division; Rule 1(a))
(1 + 5.5
= 1.0 + 5.5 (Rule 1(b))
= 6.5)
15.6 / 2
= 15.6 / 2.0 (Rule 1(b))
= 7.8
7.8 + 5
= 7.8 + 5.0 (Rule1(b))
= 12.8
5 / 2.0 = 5.0 / 2.0 (Rule1(b))
= 2.5
4 + 2.5 = 4.0 + 2.5 (Rule1(b))
= 6.5
4 *3 = 12 (Rule 1(a))
7 / 5 = 1 (integer division; Rule 1(a))
12 + 1 = 13 (Rule 1(a))
13 – 25.5 = 13.0 – 25.5 (Rule 1(b))
= -12.5

= 12.8

4 + 5 / 2.0

= 4 + 2.5
= 6.5

4 *3 + 7 / 5 – 25.5

= 12+7/5 – 25.5
= 12 + 1 – 25.5
= 13 – 25.5
= -12.5

The following C++ program evaluates the preceding expressions:
// This program illustrates how mixed expressions are evaluated.
#include <iostream>
using namespace std;
int main()
{
cout <<
cout <<
cout <<
cout <<
<<
<<

"3 / 2 + 5.5 = " << 3 / 2 + 5.5 << endl;
"15.6 / 2 + 5 = " << 15.6 / 2 + 5 << endl;
"4 + 5 / 2.0 = " << 4 + 5 / 2.0 << endl;
"4 * 3 + 7 / 5 - 25.5 = "
4 * 3 + 7 / 5 - 25.5
endl;

return 0;
}

Sample Run:
3 / 2 + 5.5 = 6.5
15.6 / 2 + 5 = 12.8
4 + 5 / 2.0 = 6.5
4 * 3 + 7 / 5 - 25.5 = -12.5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Type Conversion (Casting)

|

51

These examples illustrate that an integer is not converted to a floating-point number
unless the operator to be evaluated has one integer and one floating-point operand.

Type Conversion (Casting)
In the previous section, you learned that when evaluating an arithmetic expression, if the
operator has mixed operands, the integer value is changed to a floating-point value with
the zero decimal part. When a value of one data type is automatically changed to another
data type, an implicit type coercion is said to have occurred. As the examples in the
preceding section illustrate, if you are not careful about data types, implicit type coercion
can generate unexpected results.
To avoid implicit type coercion, C++ provides for explicit type conversion through the
use of a cast operator. The cast operator, also called type conversion or type casting,
takes the following form:
static_cast<dataTypeName>(expression)

First, the expression is evaluated. Its value is then converted to a value of the type
specified by dataTypeName. In C++, static_cast is a reserved word.
When converting a floating-point (decimal) number to an integer using the cast operator,
you simply drop the decimal part of the floating-point number. That is, the floating-point
number is truncated. Example 2-9 shows how cast operators work. Be sure you understand why the last two expressions evaluate as they do.

EXAMPLE 2-9
Expression

Evaluates to

static_cast<int>(7.9)
static_cast<int>(3.3)
static_cast<double>(25)
static_cast<double>(5 + 3)
static_cast<double>(15) / 2

7
3
25.0
= static_cast<double>(8) = 8.0
= 15.0 / 2
(because static_cast<double> (15) = 15.0)
= 15.0 / 2.0 = 7.5
= static_cast<double>(7) (because 15 / 2 = 7)
= 7.0

static_cast<double>(15 / 2)
static_cast<int>(7.8 +
static_cast<double>(15) / 2)
static_cast<int>(7.8 +
static_cast<double>(15 / 2))

= static_cast<int>(7.8 + 7.5)
= static_cast<int>(15.3)
= 15
= static_cast<int>(7.8 + 7.0)
= static_cast<int>(14.8)
= 14

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

52 |

Chapter 2: Basic Elements of C++

The following C++ program evaluates the preceding expressions:
// This program illustrates how explicit type conversion works.
#include <iostream>
using namespace std;
int main()
{
cout <<
<<
<<
cout <<
<<
<<
cout <<
<<
<<
cout <<
<<
<<
cout <<
<<
<<
cout <<
<<
<<
cout <<
<<
<<
cout <<
<<
<<

"static_cast<int>(7.9) = "
static_cast<int>(7.9)
endl;
"static_cast<int>(3.3) = "
static_cast<int>(3.3)
endl;
"static_cast<double>(25) = "
static_cast<double>(25)
endl;
"static_cast<double>(5 + 3) = "
static_cast<double>(5 + 3)
endl;
"static_cast<double>(15) / 2 = "
static_cast<double>(15) / 2
endl;
"static_cast<double>(15 / 2) = "
static_cast<double>(15 / 2)
endl;
"static_cast<int>(7.8 + static_cast<double>(15) / 2) = "
static_cast<int>(7.8 + static_cast<double>(15) / 2)
endl;
"static_cast<int>(7.8 + static_cast<double>(15 / 2)) = "
static_cast<int>(7.8 + static_cast<double>(15 / 2))
endl;

return 0;
}

Sample Run:
static_cast<int>(7.9) = 7
static_cast<int>(3.3) = 3
static_cast<double>(25) = 25
static_cast<double>(5 + 3) = 8
static_cast<double>(15) / 2 = 7.5
static_cast<double>(15 / 2) = 7
static_cast<int>(7.8 + static_cast<double>(15) / 2) = 15
static_cast<int>(7.8 + static_cast<double>(15 / 2)) = 14

Note that the value of the expression static_cast<double>(25) is 25.0. However, it
is output as 25 rather than 25.0. This is because we have not yet discussed how to output
decimal numbers with 0 decimal parts to show the decimal point and the trailing zeros.
Chapter 3 explains how to output decimal numbers in a desired format. Similarly, the
output of other decimal numbers with zero decimal parts is without the decimal point
and the 0 decimal part.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

string Type | 53

In C++, the cast operator can also take the form dataType(expression). This form
is called C-like casting. For example, double(5) = 5.0 and int(17.6) = 17.
However, static_cast is more stable than C-like casting.

You can also use cast operators to explicitly convert char data values into int data values
and int data values into char data values. To convert char data values into int data
values, you use a collating sequence. For example, in the ASCII character
set, static_cast<int>('A') is 65 and static_cast<int>('8') is 56.
Similarly, static_cast<char>(65) is 'A' and static_cast<char>(56) is '8'.
Earlier in this chapter, you learned how arithmetic expressions are formed and evaluated in
C++. If you want to use the value of one expression in another expression, first you must save
the value of the expression. There are many reasons to save the value of an expression. Some
expressions are complex and may require a considerable amount of computer time to evaluate.
By calculating the values once and saving them for further use, you not only save computer
time and create a program that executes more quickly, you also avoid possible typographical
errors. In C++, expressions are evaluated, and if the value is not saved, it is lost. That is, unless
it is saved, the value of an expression cannot be used in later calculations. Later in this chapter,
you will learn how to save the value of an expression and use it in subsequent calculations.
Before leaving the discussion of data types, let us discuss one more data type—string.

string Type
The data type string is a programmer-defined data type. It is not directly available for
use in a program like the simple data types discussed earlier. To use this data type, you
need to access program components from the library, which will be discussed later in this
chapter. The data type string is a feature of ANSI/ISO Standard C++.
Prior to the ANSI/ISO C++ language standard, the standard C++ library did not provide a
string data type. Compiler vendors often supplied their own programmer-defined string
type, and the syntax and semantics of string operations often varied from vendor to vendor.

A string is a sequence of zero or more characters. Strings in C++ are enclosed in double
quotation marks. A string containing no characters is called a null or empty string. The
following are examples of strings. Note that "" is the empty string.
"William Jacob"
"Mickey"
""

Every character in a string has a relative position in the string. The position of the first
character is 0, the position of the second character is 1, and so on. The length of a string is
the number of characters in it. When determining the length of a string, you must also
count any spaces in the string.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

54 |

Chapter 2: Basic Elements of C++

EXAMPLE 2-10
String

Position of a Character in the String

Length of the String

"William Jacob"

Position
Position
Position
Position
Position

of
of
of
of
of

'W' is 0.
the first 'i' is 1.
' ' (the space) is 7.
'J' is 8.
'b' is 12.

13

"Mickey"

Position
Position
Position
Position
Position
Position

of
of
of
of
of
of

'M'
'i'
'c'
'k'
'e'
'y'

is
is
is
is
is
is

0.
1.
2.
3.
4.
5.

6

The length of the following string is 22.
"It is a beautiful day."

The string type is very powerful and more complex than simple data types. It provides
not only the physical space required to store the string, but many operations to
manipulate strings. For example, it provides operations to find the length of a string,
extract part of a string, and compare strings. You will learn about this data type over the
next few chapters.

Variables, Assignment Statements,
and Input Statements
As noted earlier, the main objective of a C++ program is to perform calculations and
manipulate data. Recall that data must be loaded into main memory before it can be
manipulated. In this section, you will learn how to put data into the computer’s memory.
Storing data in the computer’s memory is a two-step process:
1. Instruct the computer to allocate memory.
2. Include statements in the program to put data into the allocated memory.

Allocating Memory with Constants and Variables
When you instruct the computer to allocate memory, you tell it not only what names to
use for each memory location, but also what type of data to store in those memory
locations. Knowing the location of data is essential, because data stored in one memory
location might be needed at several places in the program. As you saw earlier, knowing
what data type you have is crucial for performing accurate calculations. It is also critical to

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Variables, Assignment Statements, and Input Statements |

55

know whether your data needs to remain fixed throughout program execution or
whether it should change.
NAMED CONSTANTS
Some data must stay the same throughout a program. For example, the conversion
formula that converts inches into centimeters is fixed, because 1 inch is always equal to
2.54 centimeters. When stored in memory, this type of data needs to be protected from
accidental changes during program execution. In C++, you can use a named constant
to instruct a program to mark those memory locations in which data is fixed throughout
program execution.
Named constant: A memory location whose content is not allowed to change during
program execution.

To allocate memory, we use C++’s declaration statements. The syntax to declare a
named constant is:
const dataType identifier = value;

In C++, const is a reserved word. It should be noted that a named constant is initialized
and declared all in one statement and that it must be initialized when it is declared because
from this statement on the compiler will reject any attempt to change the value.
EXAMPLE 2-11
Consider the following C++ statements:
const double CONVERSION = 2.54;
const int NO_OF_STUDENTS = 20;
const char BLANK = ' ';

The first statement tells the compiler to allocate memory (eight bytes) to store a value
of type double, call this memory space CONVERSION, and store the value 2.54 in it.
Throughout a program that uses this statement, whenever the conversion formula is
needed, the memory space CONVERSION can be accessed. The meaning of the other
statements is similar.
Note that the identifier for a named constant is in uppercase letters. Even though
there are no written rules, C++ programmers typically prefer to use uppercase letters
to name a named constant. Moreover, if the name of a named constant is a combination of more than one word, called a run-together word, then the words are typically
separated using an underscore. For example, in the preceding example,
NO_OF_STUDENTS is a run-together word. (Also see the section Program Style and
Form, later in this chapter, to properly structure a program.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

56 |

Chapter 2: Basic Elements of C++

As noted earlier, the default type of floating-point numbers is double. Therefore, if
you declare a named constant of type float, then you must specify that the value is
of type float as follows:

const float CONVERSION = 2.54f;
Otherwise, the compiler will generate a warning message. Notice that 2.54f says that it is
a float value. Recall that the memory size for float values is four bytes; for double
values, eight bytes. Because memory size is of little concern these days, as indicated earlier,
we will mostly use the type double to work with floating-point values.

Using a named constant to store fixed data, rather than using the data value itself, has
one major advantage. If the fixed data changes, you do not need to edit the entire
program and change the old value to the new value wherever the old value is used.
(For example, in the program that computes the sales tax, the sales tax rate may
change.) Instead, you can make the change at just one place, recompile the program,
and execute it using the new value throughout. In addition, by storing a value and
referring to that memory location whenever the value is needed, you avoid typing
the same value again and again and prevent accidental typos. If you misspell the name
of the constant value’s location, the computer will warn you through an error
message, but it will not warn you if the value is mistyped.
VARIABLES
Earlier in this chapter, we introduced the term variable and how to declare it. We now
review this concept and also give the general syntax to declare variables.

In some programs, data needs to be modified during program execution. For example, after
each test, the average test score and the number of tests taken changes. Similarly, after each
pay increase, the employee’s salary changes. This type of data must be stored in those memory
cells whose contents can be modified during program execution. In C++, memory cells
whose contents can be modified during program execution are called variables.
Variable: A memory location whose content may change during program execution.

The syntax for declaring one variable or multiple variables is:
dataType identifier, identifier, . . .;

EXAMPLE 2-12
Consider the following statements:
double amountDue;
int counter;
char ch;
int x, y;
string name;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Variables, Assignment Statements, and Input Statements |

57

The first statement tells the compiler to allocate eight bytes of memory space to store
a value of the type double and call it amountDue. The second and third statements
have similar conventions. The fourth statement tells the compiler to allocate two
different memory spaces, each four bytes, to store a value of the type int; name the
first memory space x; and name the second memory space y. The fifth statement tells
the compiler to allocate memory space and call it name.

As in the case of naming named constants, there are no written rules for naming variables.
However, C++ programmers typically use lowercase letters to declare variables. If a
variable name is a combination of more than one word, then the first letter of each word,
except the first word, is uppercase. (For example, see the variable amountDue in the
preceding example.)
From now on, when we say ‘‘variable,’’ we mean a variable memory location.
In C++, you must declare all identifiers before you can use them. If you refer to an
identifier without declaring it, the compiler will generate an error message (syntax error),
indicating that the identifier is not declared. Therefore, to use either a named constant or
a variable, you must first declare it.

Now that data types, variables, and constants have been defined and discussed, it is
possible to offer a formal definition of simple data types. A data type is called simple if
the variable or named constant of that type can store only one value at a time. For
example, if x is an int variable, at a given time, only one value can be stored in x.

Putting Data into Variables
Now that you know how to declare variables, the next question is: How do you put data
into those variables? In C++, you can place data into a variable in two ways:
1. Use C++’s assignment statement.
2. Use input (read) statements.

Assignment Statement
The assignment statement takes the following form:
variable = expression;

In an assignment statement, the value of the expression should match the data type of
the variable. The expression on the right side is evaluated, and its value is assigned to
the variable (and thus to a memory location) on the left side.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

58 |

Chapter 2: Basic Elements of C++

A variable is said to be initialized the first time a value is placed in the variable.
Recall that in C++, = is called the assignment operator.
EXAMPLE 2-13
Suppose you have the following variable declarations:
int num1, num2;
double sale;
char first;
string str;

Now consider the following assignment statements:
num1 = 4;
num2 = 4 * 5 - 11;
sale = 0.02 * 1000;
first = 'D';
str = "It is a sunny day.";

For each of these statements, the computer first evaluates the expression on the right and
then stores that value in a memory location named by the identifier on the left. The first
statement stores the value 4 in num1, the second statement stores 9 in num2, the third
statement stores 20.00 in sale, and the fourth statement stores the character D in first.
The fifth statement assigns the string "It is a sunny day." to the variable str.
The following C++ program shows the effect of the preceding statements:
// This program illustrates how data in the variables are
// manipulated.
#include <iostream>
#include <string>
using namespace std;
int main()
{
int num1, num2;
double sale;
char first;
string str;
num1 = 4;
cout << "num1 = " << num1 << endl;
num2 = 4 * 5 - 11;
cout << "num2 = " << num2 << endl;
sale = 0.02 * 1000;
cout << "sale = " << sale << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Variables, Assignment Statements, and Input Statements |

59

first = 'D';
cout << "first = " << first << endl;
str = "It is a sunny day.";
cout << "str = " << str << endl;
return 0;
}

Sample Run:
num1 = 4
num2 = 9
sale = 20
first = D
str = It is a sunny day.

For the most part, the preceding program is straightforward. Let us take a look at the
output statement:
cout << " num1 = " << num1 << endl;

This output statement consists of the string " num1 = ", the operator <<, and the variable
num1. Here, first the value of the string " num1 = " is output, and then the value of the
variable num1 is output. The meaning of the other output statements is similar.
A C++ statement such as
num ¼ num + 2;

means ‘‘evaluate whatever is in num, add 2 to it, and assign the new value to the memory
location num.’’ The expression on the right side must be evaluated first; that value is then
assigned to the memory location specified by the variable on the left side. Thus, the
sequence of C++ statements:
num = 6;
num = num + 2;

and the statement:
num = 8;

both assign 8 to num. Note that if num has not been initialized, the statement num = num + 2
might give unexpected results and/or the complier might generate a warning message
indicating that the variable has not been initialized. In general, referencing or using the
contents of a variable before it is initialized should be avoided.
The statement num = 5; is read as ‘‘num becomes 5’’ or ‘‘num is assigned the value 5.’’
Reading the statement as ‘‘num equals 5’’ is incorrect, especially for statements such as num =
num + 2;. Each time a new value is assigned to num, the old value is overwritten. (Recall that
the equal sign in these statements is the assignment operator, not an indication of equality.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

60 |

Chapter 2: Basic Elements of C++

EXAMPLE 2-14
Suppose that num1, num2, and num3 are int variables and the following statements are
executed in sequence.
1.
2.
3.
4.
5.

num1 = 18;
num1 = num1 + 27;
num2 = num1;
num3 = num2 / 5;
num3 = num3 / 4;

The following table shows the values of the variables after the execution of each
statement. (A ? indicates that the value is unknown. The orange color in a box shows
that the value of that variable is changed.)
Values of the Variables/
Statement
Before Statement 1

After Statement 1

Explanation

?

?

?

num1

num2

num3

18

?

?

num1

num2

num3

45

?

?

num1

num2

num3

num1 = 18;

After Statement 2

num1 = num1 + 27;

After Statement 3

45

45

?

num1

num2

num3

num1 + 27 = 18 + 27 =
45. This value is assigned to
num1, which replaces the old
value of num1.
Copy the value of num1 into
num2.

num2 = num1;

After Statement 4

45

45

9

num1

num2

num3

num2 / 5 = 45 / 5 = 9.
This value is assigned to num3.
So num3 = 9.

num3 = num2 / 5;

After Statement 5

45

45

2

num1

num2

num3

num3 = num3 / 4;

num3 / 4 = 9 / 4 = 2.
This value is assigned to num3,
which replaces the old value of
num3.

Thus, after the execution of the statement in Line 5, num1 = 45, num2 = 45, and num3 = 2.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Variables, Assignment Statements, and Input Statements |

61

Tracing values through a sequence, called a walk-through, is a valuable tool to learn and
practice. Try it in the sequence above. You will learn more about how to walk through a
sequence of C++ statements later in this chapter.

2
Suppose that x, y, and z are int variables. The following is a legal statement in C++:

x = y = z;
In this statement, first the value of z is assigned to y, and then the new value of y is
assigned to x. Because the assignment operator, =, is evaluated from right to left, the
associativity of the assignment operator is said to be from right to left.

Saving and Using the Value of an Expression
Now that you know how to declare variables and put data into them, you can learn
how to save the value of an expression. You can then use this value in a later
expression without using the expression itself, thereby answering the question raised
earlier in this chapter. To save the value of an expression and use it in a later
expression, do the following:
1. Declare a variable of the appropriate data type. For example, if the
result of the expression is an integer, declare an int variable.
2. Assign the value of the expression to the variable that was declared,
using the assignment statement. This action saves the value of the
expression into the variable.
3. Wherever the value of the expression is needed, use the variable holding
the value. The following example further illustrates this concept.
EXAMPLE 2-15
Suppose that you have the following declaration:
int a, b, c, d;
int x, y;

Further suppose that you want to evaluate the expressions –b + (b2 – 4ac) and
–b –(b2 – 4ac) and assign the values of these expressions to x and y, respectively.
Because the expression b2 – 4ac appears in both expressions, you can first calculate
the value of this expression and save its value in d. You can then use the value of d
to evaluate the expressions, as shown by the following statements:
d = b * b - 4 * a * c;
x = -b + d;
y = -b - d;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

62 |

Chapter 2: Basic Elements of C++

Earlier, you learned that if a variable is used in an expression, the expression would
yield a meaningful value only if the variable has first been initialized. You also learned
that after declaring a variable, you can use an assignment statement to initialize it. It is
possible to initialize and declare variables at the same time. Before we discuss how to
use an input (read) statement, we address this important issue.

Declaring and Initializing Variables
When a variable is declared, C++ may not automatically put a meaningful value in it. In
other words, C++ may not automatically initialize variables. For example, the int and
double variables may not be initialized to 0, as happens in some programming languages.
This does not mean, however, that there is no value in a variable after its declaration.
When a variable is declared, memory is allocated for it.
Recall from Chapter 1 that main memory is an ordered sequence of cells, and each cell is
capable of storing a value. Also, recall that the machine language is a sequence of 0s and
1s, or bits. Therefore, data in a memory cell is a sequence of bits. These bits are nothing
but electrical signals, so when the computer is turned on, some of the bits are 1 and some
are 0. The state of these bits depends on how the system functions. However, when you
instruct the computer to store a particular value in a memory cell, the bits are set
according to the data being stored.
During data manipulation, the computer takes the value stored in particular cells and
performs a calculation. If you declare a variable and do not store a value in it, the memory
cell still has a value—usually the value of the setting of the bits from their last use—and
you have no way to know what this value is.
If you only declare a variable and do not instruct the computer to put data into the variable,
the value of that variable is garbage. However, the computer does not warn us, regards
whatever values are in memory as legitimate, and performs calculations using those values
in memory. Using a variable in an expression without initializing it produces erroneous
results. To avoid these pitfalls, C++ allows you to initialize variables while they are being
declared. For example, consider the following C++ statements in which variables are first
declared and then initialized:
int first, second;
char ch;
double x;
first = 13;
second = 10;
ch = ' ';
x = 12.6;

You can declare and initialize these variables at the same time using the following C++
statements:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Variables, Assignment Statements, and Input Statements |

63

int first = 13, second = 10;
char ch = ' ';
double x = 12.6;

The first C++ statement declares two int variables, first and second, and stores 13 in
first and 10 in second. The meaning of the other statements is similar.
In reality, not all variables are initialized during declaration. It is the nature of the program
or the programmer’s choice that dictates which variables should be initialized during
declaration. The key point is that all variables must be initialized before they are used.

Input (Read) Statement
Previously, you learned how to put data into variables using the assignment statement. In
this section, you will learn how to put data into variables from the standard input device,
using C++’s input (or read) statements.
In most cases, the standard input device is the keyboard.

When the computer gets the data from the keyboard, the user is said to be acting interactively.
Putting data into variables from the standard input device is accomplished via the use of
cin and the operator >>. The syntax of cin together with >> is:
cin >> variable >> variable ...;

This is called an input (read) statement. In C++, >> is called the stream extraction
operator.
In a syntax, the shading indicates the part of the definition that is optional. Furthermore,
throughout this book, the syntax is enclosed in yellow boxes.

EXAMPLE 2-16
Suppose that miles is a variable of type double. Further suppose that the input is
73.65. Consider the following statement:
cin >> miles;

This statement causes the computer to get the input, which is 73.65, from the standard
input device and stores it in the variable miles. That is, after this statement executes, the
value of the variable miles is 73.65.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

64 |

Chapter 2: Basic Elements of C++

Example 2-17 further explains how to input numeric data into a program.
EXAMPLE 2-17
Suppose we have the following statements:
int feet;
int inches;

Suppose the input is:
23 7

Next, consider the following statement:
cin >> feet >> inches;

This statement first stores the number 23 into the variable feet and then the number 7
into the variable inches. Notice that when these numbers are entered via the keyboard,
they are separated with a blank. In fact, they can be separated with one or more blanks or
lines or even the tab character.
The following C++ program shows the effect of the preceding input statements:
// This program illustrates how input statements work.
#include <iostream>
using namespace std;
int main()
{
int feet;
int inches;
cout << "Enter two integers separated by one or more spaces: ";
cin >> feet >> inches;
cout << endl;
cout << "Feet = " << feet << endl;
cout << "Inches = " << inches << endl;
return 0;
}

Sample Run: In this sample run, the user input is shaded.
Enter two integers separated by one or more spaces: 23 7
Feet = 23
Inches = 7

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Variables, Assignment Statements, and Input Statements |

65

The C++ program in Example 2-18 illustrates how to read strings and numeric data.
EXAMPLE 2-18
// This program illustrates how to read strings and numeric data.
#include <iostream>
#include <string>
using namespace std;
int main()
{
string firstName;
string lastName;
int age;
double weight;

//Line
//Line
//Line
//Line

1
2
3
4

cout << "Enter first name, last name, age, "
<< "and weight, separated by spaces."
<< endl;

//Line 5

cin >> firstName >> lastName;
cin >> age >> weight;

//Line 6
//Line 7

cout << "Name: " << firstName << " "
<< lastName << endl;

//Line 8

cout << "Age: " << age << endl;
cout << "Weight: " << weight << endl;

//Line 9
//Line 10

return 0;

//Line 11

}

Sample Run: In this sample run, the user input is shaded.
Enter first name, last name, age, and weight, separated by spaces.
Sheila Mann 23 120.5
Name: Sheila Mann
Age: 23
Weight: 120.5

The preceding program works as follows: The statements in Lines 1 to 4 declare the
variables firstName and lastName of type string, age of type int, and weight of
type double. The statement in Line 5 is an output statement and tells the user what to
do. (Such output statements are called prompt lines.) As shown in the sample run, the
input to the program is:
Sheila Mann 23 120.5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

66 |

Chapter 2: Basic Elements of C++

The statement in Line 6 first reads and stores the string Sheila into the variable
firstName and then skips the space after Sheila and reads and stores the string Mann
into the variable lastName. Next, the statement in Line 7 first skips the blank after
Mann and reads and stores 23 into the variable age and then skips the blank after 23
and reads and stores 120.5 into the variable weight.
The statements in Lines 8, 9, and 10 produce the third, fourth, and fifth lines of the
sample run.
During programming execution, if more than one value is entered in a line, these values must
be separated by at least one blank or tab. Alternately, one value per line can be entered.

Variable Initialization
Remember, there are two ways to initialize a variable: by using the assignment statement
and by using a read statement. Consider the following declaration:
int feet;
int inches;

Consider the following two sets of code:

(a)

feet = 35;
inches = 6;
cout << "Total inches = "
<< 12 * feet + inches;

(b)

cout << "Enter feet: ";
cin >> feet;
cout << endl;
cout << "Enter inches: ";
cin >> inches;
cout << endl;
cout << "Total inches = "
<< 12 * feet + inches;

In (a), feet and inches are initialized using assignment statements, and in (b), these
variables are initialized using input statements. However, each time the code in (a)
executes, feet and inches are initialized to the same value unless you edit the source
code, change the value, recompile, and run. On the other hand, in (b), each time the
program runs, you are prompted to enter values for feet and inches. Therefore, a read
statement is much more versatile than an assignment statement.
Sometimes it is necessary to initialize a variable by using an assignment statement. This is
especially true if the variable is used only for internal calculation and not for reading and
storing data.
Recall that C++ does not automatically initialize variables when they are declared. Some
variables can be initialized when they are declared, whereas others must be initialized
using either an assignment statement or a read statement.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Variables, Assignment Statements, and Input Statements |

67

When the program is compiled, some of the newer IDEs might give warning messages
if the program uses the value of a variable without first properly initializing that variable.
In this case, if you ignore the warning and execute the program, the program might
terminate abnormally with an error message.

Suppose you want to store a character into a char variable using an input statement.
During program execution, when you enter the character, you do not include the single
quotes. For example, suppose that ch is a char variable. Consider the following input
statement:

cin >> ch;
If you want to store K into ch using this statement, during program execution, you
only enter K. Similarly, if you want to store a string into a string variable using an
input statement, during program execution, you enter only the string without the
double quotes.

EXAMPLE 2-19
This example further illustrates how assignment statements and input statements manipulate variables. Consider the following declarations:
int count, temp;
double length, width, area;
char ch;
string name;

Also, suppose that the following statements execute in the order given.
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

count = 1;
count = count + 1;
cin >> length >> width;
area = length * width;
cin >> name;
length = length + 2;
width = 2 * length - 5 * width;
area = length * width;
cin >> ch;
temp = count + static_cast<int>(
(ch);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

68 |

Chapter 2: Basic Elements of C++

In addition, suppose the input is:
10.5 4.0 Amy A

This line has four values, 10.5, 4.0, Amy, and A, and each value is separated from the
others by a blank.
Let’s now determine the values of the declared variables after the last statement executes.
To explicitly show how a particular statement changes the value of a variable, the values
of the variables after each statement executes are shown. (In Figure 2-4, a question mark
[?] in a box indicates that the value in the box is unknown.)
Before statement 1 executes, all variables are uninitialized, as shown in Figure 2-4.

?
?
?
?
count temp length width

FIGURE 2-4

?
area

?
ch

?
name

Variables before statement 1 executes

Next, we show the values of the variables after the execution of each statement.
After
St.

1

Values of the Variables/Statement

1

?

?

?

count temp length width

Explanation

?

?

?

area

ch

name

?

?

?

area

ch

name

?

?

?

area

ch

name

42.0

?

?

area

ch

name

42.0

?

Amy

area

ch

name

Store 1 into count.

count = 1;

2

2

?

?

?

count temp length width

count = count + 1;

3

2

?

10.5

4.0

count temp length width

cin >> length >> width;

4

2

?

10.5

4.0

count temp length width

count + 1 = 1 + 1 = 2. Store
2 into count. This statement
replaces the old value of count
with this new value.
Read two numbers, which are
10.5 and 4.0, and store the
first number into length, and
the second into width.
length * width = 10.5 *
4.0 = 42.0. Store 42.0 into
area.

area = length * width;

5

2

?

10.5

4.0

count temp length width

cin >> name;

Read the next input, Amy, from
the keyboard and store it into
name.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Variables, Assignment Statements, and Input Statements |

After
St.

Values of the Variables/Statement
2

6

?

12.5

4.0

count temp length width

Explanation

42.0

?

Amy

area

ch

name

length = length + 2;

7

2

?

12.5

5.0

count temp length width

42.0

?

Amy

area

ch

name

width = 2 * length – 5 * width;

8

2

?

12.5

5.0

count temp length width

62.5

?

Amy

area

ch

name

area = length * width;

9

2

?

12.5

5.0

count temp length width

69

62.5

A

Amy

area

ch

name

62.5

A

Amy

area

ch

name

length + 2 = 10.5 + 2 =
12.5. Store 12.5 into length.
This statement replaces the old
value of length with this new
value.
2 * length - 5 * width
= 2 * 12.5 - 5 * 4.0 =
5.0. Store 5.0 into width.
This statement replaces the old
value of width with this new
value.
length * width = 12.5 *
5.0 = 62.5. Store 62.5 into
area. This statement replaces the
old value of area with this new
value.
Read the next input, A, from the
keyboard and store it into ch.

cin >> ch;
2

10

67

12.5

5.0

count temp length width

temp = count
+ static_cast<int>(ch);

count +
static_cast<int>(ch) =
2 + static_cast<int>
('A') = 2 + 65 = 67. Store
67 into temp.

When something goes wrong in a program and the results it generates are not
what you expected, you should do a walk-through of the statements that assign
values to your variables. Example 2-19 illustrates how to do a walk-through
of your program. This is a very effective debugging technique. The Web site
accompanying this book contains a C++ program that shows the effect of the
10 statements listed at the beginning of Example 2-19. The program is named
Example 2_19.cpp.

If you assign the value of an expression that evaluates to a floating-point value—without using
the cast operator—to a variable of type int, the fractional part is dropped. In this case, the
compiler most likely will issue a warning message about the implicit type conversion.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

70 |

Chapter 2: Basic Elements of C++

Increment and Decrement Operators
Now that you know how to declare a variable and enter data into a variable, in this section,
you will learn about two more operators: the increment and decrement operators. These
operators are used frequently by C++ programmers and are useful programming tools.
Suppose count is an int variable. The statement:
count = count + 1;

increments the value of count by 1. To execute this assignment statement, the computer
first evaluates the expression on the right, which is count + 1. It then assigns this value to
the variable on the left, which is count.
As you will see in later chapters, such statements are frequently used to count how many
times certain things have happened. To expedite the execution of such statements, C++
provides the increment operator, ++ (two plus signs), which increases the value of a
variable by 1, and the decrement operator, –– (two minus signs), which decreases the
value of a variable by 1. Increment and decrement operators each have two forms, pre
and post. The syntax of the increment operator is:
Pre-increment: ++variable
Post-increment: variable++
The syntax of the decrement operator is:
Pre-decrement: ––variable
Post-decrement: variable––
Let’s look at some examples. The statement:
++count;

or:
count++;

increments the value of count by 1. Similarly, the statement:
––count;

or:
count––;

decrements the value of count by 1.
Because both the increment and decrement operators are built into C++, the value of the
variable is quickly incremented or decremented without having to use the form of an
assignment statement.
Now, both the pre- and post-increment operators increment the value of the variable by 1.
Similarly, the pre- and post-decrement operators decrement the value of the variable by 1.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Increment and Decrement Operators

|

71

What is the difference between the pre and post forms of these operators? The difference
becomes apparent when the variable using these operators is employed in an expression.
Suppose that x is an int variable. If ++x is used in an expression, first the value of x is
incremented by 1, and then the new value of x is used to evaluate the expression. On the
other hand, if x++ is used in an expression, first the current value of x is used in the
expression, and then the value of x is incremented by 1. The following example clarifies
the difference between the pre- and post-increment operators.
Suppose that x and y are int variables. Consider the following statements:
x = 5;
y = ++x;

The first statement assigns the value 5 to x. To evaluate the second statement, which uses
the pre-increment operator, first the value of x is incremented to 6, and then this value, 6,
is assigned to y. After the second statement executes, both x and y have the value 6. The
equivalent results would occur with this set of statements:
x = 5;
x = x + 1;
y = x;

Now, consider the following statements:
x = 5;
y = x++;

As before, the first statement assigns 5 to x. In the second statement, the post-increment
operator is applied to x. To execute the second statement, first the value of x, which is 5,
is used to evaluate the expression, and then the value of x is incremented to 6. Finally, the
value of the expression, which is 5, is stored in y. After the second statement executes,
the value of x is 6, and the value of y is 5. The equivalent results would occur with this
set of statements:
x = 5;
y = x;
x = x + 1;

As you see, the only difference between the pre- and post-increment statements is when
the incrementing takes place: before the assignment or after.
The following example further illustrates how the pre and post forms of the increment
operator work.
EXAMPLE 2-20
Suppose a and b are int variables and
a = 5;
b = 2 + (++a);
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

72 |

Chapter 2: Basic Elements of C++

The first statement assigns 5 to a. To execute the second statement, first the expression
2 +(++a) is evaluated. Because the pre-increment operator is applied to a, first the value
of a is incremented to 6. Then 2 is added to 6 to get 8, which is then assigned to b.
Therefore, after the second statement executes, a is 6 and b is 8.
On the other hand, after the execution of the following statements:
a = 5;
b = 2 + (a++);

the value of a is 6 while the value of b is 7.

Output
In the preceding sections, you have seen how to put data into the computer’s memory
and how to manipulate that data. We also used certain output statements to show the
results on the standard output device. This section explains in some detail how to further use
output statements to generate the desired results.
The standard output device is usually the screen.

In C++, output on the standard output device is accomplished via the use of cout and
the operator <<. The general syntax of cout together with << is:
cout << expression or manipulator << expression or manipulator...;

This is called an output statement. In C++, << is called the stream insertion
operator. Generating output with cout follows two rules:
1. The expression is evaluated, and its value is printed at the current
insertion point on the output device.
2. A manipulator is used to format the output. The simplest manipulator is
endl (the last character is the letter el), which causes the insertion point
to move to the beginning of the next line.
On the screen, the insertion point is where the cursor is.

The next example illustrates how an output statement works. In an output statement, a
string or an expression involving only one variable or a single value evaluates to itself.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Output |

73

When an output statement outputs char values, it outputs only the character without the
single quotes (unless the single quotes are part of the output statement).
For example, suppose ch is a char variable and ch = 'A';. The statement:

cout << ch;

or:
cout << 'A';

outputs:
A
Similarly, when an output statement outputs the value of a string, it outputs only the
string without the double quotes (unless you include double quotes as part of the output).

EXAMPLE 2-21
Consider the following statements. The output is shown to the right of each statement.
Statement
1
2
3
4
5
6
7
8
9

cout
cout
cout
cout
cout
cout
cout
cout
cout

<<
<<
<<
<<
<<
<<
<<
<<
<<

Output
29 / 4 << endl;
"Hello there." << endl;
12 << endl;
"4 + 7" << endl;
4 + 7 << endl;
'A' << endl;
"4 + 7 = " << 4 + 7 << endl;
2 + 3 * 5 << endl;
"Hello \nthere." << endl;

7
Hello there.
12
4 + 7
11
A
4 + 7 = 11
17
Hello
there.

Look at the output of statement 9. Recall that in C++, the newline character is '\n'; it
causes the insertion point to move to the beginning of the next line before printing there.
Therefore, when \n appears in a string in an output statement, it causes the insertion
point to move to the beginning of the next line on the output device. This fact explains
why Hello and there. are printed on separate lines.

In C++, \ is called the escape character and \n is called the newline escape sequence.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

74 |

Chapter 2: Basic Elements of C++

Recall that all variables must be properly initialized; otherwise, the value stored in them
may not make much sense. Also recall that C++ does not automatically initialize variables.
If num is an int variable, then the output of the C++ statement:
cout << num << endl;

is meaningful provided that num has been given a value. For example, the sequence of
C++ statements:
num = 45;
cout << num << endl;

will produce the output 45.
EXAMPLE 2-22
Consider the following C++ program:
// This program illustrates how output statements work.
#include <iostream>
using namespace std;
int main()
{
int a, b;
a = 65;
b = 78;
cout
cout
cout
cout
cout
cout
cout
cout
cout
cout
cout
cout

<<
<<
<<
<<
<<
<<
<<
<<
<<
<<
<<
<<

29 / 4 << endl;
3.0 / 2 << endl;
"Hello there.\n";
7 << endl;
3 + 5 << endl;
"3 + 5";
" **";
endl;
2 + 3 * 6 << endl;
"a" << endl;
a << endl;
b << endl;

//Line
//Line

1
2

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

3
4
5
6
7
8
9
10
11
12
13
14

return 0;
}

In the following output, the column marked ‘‘Output of Statement at’’ and the line
numbers are not part of the output. The line numbers are shown in this column to make
it easy to see which output corresponds to which statement.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Output |

75

Output of Statement at
7
1.5
Hello there.
7
8
3 + 5 **
20
a
65
78

Line 3
Line 4
Line 5
Line 6
Line 7
Lines 8 and 9
Line 11
Line 12
Line 13
Line 14

For the most part, the output is straightforward. Look at the output of the statements in
Lines 7, 8, 9, and 10. The statement in Line 7 outputs the result of 3 + 5, which is 8, and
moves the insertion point to the beginning of the next line. The statement in Line 8
outputs the string 3 + 5. Note that the statement in Line 8 consists only of the string 3 + 5.
Therefore, after printing 3 + 5, the insertion point stays positioned after 5; it does not
move to the beginning of the next line. Next the output of the statement in Line 9
outputs a space and ** at the insertion point, which was positioned after 5.
The output statement in Line 10 contains only the manipulator endl, which moves
the insertion point to the beginning of the next line. Therefore, when the statement
in Line 11 executes, the output starts at the beginning of the line. Note that in
this output, the column ‘‘Output of Statement at’’ does not contain Line 10. This
is due to the fact that the statement in Line 10 does not produce any printable output.
It simply moves the insertion point to the beginning of the next line. Next, the statement
in Line 11 outputs the value of 2 + 3 * 6, which is 20. The manipulator endl then moves
the insertion point to the beginning of the next line.

Outputting or accessing the value of a variable in an expression does not destroy or modify
the contents of the variable.

Let us now take a close look at the newline character, '\n'. Consider the following C++
statements:
cout << "Hello there.";
cout << "My name is James.";

If these statements are executed in sequence, the output is:
Hello there.My name is James.

Now consider the following C++ statements:
cout << "Hello there.\n";
cout << "My name is James.";
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

76 |

Chapter 2: Basic Elements of C++

The output of these C++ statements is:
Hello there.
My name is James.

When \n is encountered in the string, the insertion point is positioned at the beginning
of the next line. Note also that \n may appear anywhere in the string. For example, the
output of the statement:
cout << "Hello \nthere. \nMy name is James.";

is:
Hello
there.
My name is James.

Also, note that the output of the statement:
cout << '\n';

is the same as the output of the statement:
cout << "\n";

which is the same as the output of the statement:
cout << endl;

Thus, the output of the sequence of statements:
cout << "Hello there.\n";
cout << "My name is James.";

is the same as the output of the sequence of statements:
cout << "Hello there." << endl;
cout << "My name is James.";

EXAMPLE 2-23
Consider the following C++ statements:
cout << "Hello there.\nMy name is James.";

or:
cout << "Hello there.";
cout << "\nMy name is James.";

or:
cout << "Hello there.";
cout << endl << "My name is James.";

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Output |

77

In each case, the output of the statements is:
Hello there.
My name is James.

2
EXAMPLE 2-24
The output of the C++ statements:
cout << "Count...\n....1\n.....2\n......3";

or:
cout << "Count..." << endl << "....1" << endl
<< ".....2" << endl << "......3";

is:
Count...
....1
.....2
......3

EXAMPLE 2-25
Suppose that you want to output the following sentence in one line as part of a message:
It is sunny, warm, and not a windy day. We can go golfing.

Obviously, you will use an output statement to produce this output. However, in the
programming code, this statement may not fit in one line as part of the output statement.
Of course, you can use multiple output statements as follows:
cout << "It is sunny, warm, and not a windy day. ";
cout << "We can go golfing." << endl;

Note the semicolon at the end of the first statement and the identifier cout at the beginning
of the second statement. Also, note that there is no manipulator endl at the end of the first
statement. Here, two output statements are used to output the sentence in one line.
Equivalently, you can use the following output statement to output this sentence:
cout << "It is sunny, warm, and not a windy day. "
<< "We can go golfing." << endl;

In this statement, note that there is no semicolon at the end of the first line, and the identifier
cout does not appear at the beginning of the second line. Because there is no semicolon at
the end of the first line, this output statement continues at the second line. Also, note the
double quotation marks at the beginning and end of the sentences on each line. The string is
broken into two strings, but both strings are part of the same output statement.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

78 |

Chapter 2: Basic Elements of C++

If a string appearing in an output statement is long and you want to output the string in
one line, you can break the string by using either of the previous two methods. However,
the following statement would be incorrect:
cout << "It is sunny, warm, and not a windy day.
We can go golfing." << endl;

//illegal

In other words, the Return (or Enter) key on your keyboard cannot be part of the string.
That is, in programming code, a string cannot be broken into more than one line by using
the return (Enter) key on your keyboard.

Recall that the newline character is \n, which causes the insertion point to move to the
beginning of the next line. There are many escape sequences in C++, which allow you
to control the output. Table 2-4 lists some of the commonly used escape sequences.
TABLE 2-4 Commonly Used Escape Sequences

Escape
Sequence

Description

\n

Newline

Cursor moves to the beginning of the next line

\t

Tab

Cursor moves to the next tab stop

\b

Backspace

Cursor moves one space to the left

\r

Return

Cursor moves to the beginning of the current line (not
the next line)

\\

Backslash

Backslash is printed

\'

Single quotation

Single quotation mark is printed

\"

Double quotation

Double quotation mark is printed

The following example shows the effect of some of these escape sequences.
EXAMPLE 2-26
The output of the statement:
cout << "The newline escape sequence is \\n" << endl;

is:
The newline escape sequence is \n

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Preprocessor Directives |

79

The output of the statement:
cout << "The tab character is represented as \'\\t\'" << endl;

2

is:
The tab character is represented as '\t'

Note that the single quote can also be printed without using the escape sequence.
Therefore, the preceding statement is equivalent to the following output statement:
cout << "The tab character is represented as '\\t'" << endl;

The output of the statement:
cout << "The string \"Sunny\" contains five characters." << endl;

is:
The string "Sunny" contains five characters.

The Web site accompanying this text contains the C++ program that shows
the effect of the statements in Example 2-26. The program is named
Example2_26.cpp.

To use cin and cout in a program, you must include a certain header file. The next section
explains what this header file is, how to include a header file in a program, and why you need
header files in a program. Chapter 3 will provide a detailed explanation of cin and cout.

Preprocessor Directives
Only a small number of operations, such as arithmetic and assignment operations, are
explicitly defined in C++. Many of the functions and symbols needed to run a C++
program are provided as a collection of libraries. Every library has a name and is referred
to by a header file. For example, the descriptions of the functions needed to perform
input/output (I/O) are contained in the header file iostream. Similarly, the descriptions
of some very useful mathematical functions, such as power, absolute, and sine, are
contained in the header file cmath. If you want to use I/O or math functions, you need
to tell the computer where to find the necessary code. You use preprocessor directives
and the names of header files to tell the computer the locations of the code provided in
libraries. Preprocessor directives are processed by a program called a preprocessor.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

80 |

Chapter 2: Basic Elements of C++

Preprocessor directives are commands supplied to the preprocessor that cause the preprocessor to modify the text of a C++ program before it is compiled. All preprocessor
commands begin with #. There are no semicolons at the end of preprocessor commands
because they are not C++ statements. To use a header file in a C++ program, use the
preprocessor directive include.
The general syntax to include a header file (provided by the IDE) in a C++ program is:
#include <headerFileName>

For example, the following statement includes the header file iostream in a C++ program:
#include <iostream>

Preprocessor directives to include header files are placed as the first line of a program so
that the identifiers declared in those header files can be used throughout the program.
(Recall that in C++, identifiers must be declared before they can be used.)
Certain header files are provided as part of C++. Appendix F describes some of the
commonly used header files. Individual programmers can also create their own header
files, which is discussed in the chapter Classes and Data Abstraction, later in this book.
Note that the preprocessor commands are processed by the preprocessor before the
program goes through the compiler.
From Figure 1-2 (Chapter 1), we can conclude that a C++ system has three basic
components: the program development environment, the C++ language, and the C++
library. All three components are integral parts of the C++ system. The program
development environment consists of the six steps shown in Figure 1-2. As you learn
the C++ language throughout the book, we will discuss components of the C++ library
as we need them.

namespace and Using cin and cout in a Program
Earlier, you learned that both cin and cout are predefined identifiers. In ANSI/ISO
Standard C++, these identifiers are declared in the header file iostream, but within
a namespace. The name of this namespace is std. (The namespace mechanism will
be formally defined and discussed in detail in Chapter 7. For now, you need to know
only how to use cin and cout and, in fact, any other identifier from the header file
iostream.)
There are several ways you can use an identifier declared in the namespace std. One way to use
cin and cout is to refer to them as std::cin and std::cout throughout the program.
Another option is to include the following statement in your program:
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Creating a C++ Program |

81

This statement should appear after the statement #include <iostream>. You can then
refer to cin and cout without using the prefix std::. To simplify the use of cin and
cout, this book uses the second form. That is, to use cin and cout in a program, the
programs will contain the following two statements:
#include <iostream>
using namespace std;

In C++, namespace and using are reserved words.
The namespace mechanism is a feature of ANSI/ISO Standard C++. As you learn more
C++ programming, you will become aware of other header files. For example, the
header file cmath contains the specifications of many useful mathematical functions.
Similarly, the header file iomanip contains the specifications of many useful functions
and manipulators that help you format your output in a specific manner. However, just
like the identifiers in the header file iostream, the identifiers in ANSI/ISO Standard
C++ header files are declared within a namespace.
The name of the namespace in each of these header files is std. Therefore, whenever
certain features of a header file in ANSI/ISO Standard C++ are discussed, this book will
refer to the identifiers without the prefix std::. Moreover, to simplify the accessing of
identifiers in programs, the statement using namespace std; will be included. Also, if
a program uses multiple header files, only one using statement is needed. This using
statement typically appears after all the header files.

Using the string Data Type in a Program
Recall that the string data type is a programmer-defined data type and is not directly
available for use in a program. To use the string data type, you need to access its
definition from the header file string. Therefore, to use the string data type in a
program, you must include the following preprocessor directive:
#include <string>

Creating a C++ Program
In previous sections, you learned enough C++ concepts to write meaningful programs.
You are now ready to create a complete C++ program.
A C++ program is a collection of functions, one of which is the function main.
Therefore, if a C++ program consists of only one function, then it must be the function
main. Moreover, a function is a set of instructions designed to accomplish a specific task.
Until Chapter 6, you will deal mainly with the function main.
The statements to declare variables, the statements to manipulate data (such as assignments),
and the statements to input and output data are placed within the function main. The
statements to declare named constants are usually placed outside of the function main.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

82 |

Chapter 2: Basic Elements of C++

The syntax of the function main used throughout this book has the following form:
int main()
{
statement_1
.
.
.
statement_n
return 0;
}

In the syntax of the function main, each statement (statement_1, . . . , statement_n) is
usually either a declarative statement or an executable statement. The statement return 0;
must be included in the function main and must be the last statement. If the statement
return 0; is misplaced in the body of the function main, the results generated by the
program may not be to your liking. The full meaning of the statement return 0; will be
discussed in Chapter 6. For now, think of this statement as the end-of-program statement.
In C++, return is a reserved word.
A C++ program might use the resources provided by the IDE, such as the necessary code
to input the data, which would require your program to include certain header files. You
can, therefore, divide a C++ program into two parts: preprocessor directives and the
program. The preprocessor directives tell the compiler which header files to include in
the program. The program contains statements that accomplish meaningful results. Taken
together, the preprocessor directives and the program statements constitute the C++
source code. Recall that to be useful, source code must be saved in a file with the file
extension .cpp. For example, if the source code is saved in the file firstProgram, then
the complete name of this file is firstProgram.cpp. The file containing the source
code is called the source code file or source file.
When the program is compiled, the compiler generates the object code, which is saved in
a file with the file extension .obj. When the object code is linked with the system
resources, the executable code is produced and saved in a file with the file extension
.exe. Typically, the name of the file containing the object code and the name of the file
containing the executable code are the same as the name of the file containing the source
code. For example, if the source code is located in a file named firstProg.cpp, the
name of the file containing the object code is firstProg.obj, and the name of the file
containing the executable code is firstProg.exe.
The extensions as given in the preceding paragraph—that is, .cpp, .obj, and .exe—are
system dependent. Moreover, some IDEs maintain programs in the form of projects. The
name of the project and the name of the source file need not be the same. It is possible
that the name of the executable file is the name of the project, with the extension .exe.
To be certain, check your system or IDE documentation.
Because the programming instructions are placed in the function main, let us elaborate on
this function.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Creating a C++ Program |

83

The basic parts of the function main are the heading and the body. The first line of the
function main, that is:
int main()

2

is called the heading of the function main.
The statements enclosed between the curly braces ( {and }) form the body of the
function main. The body of the function main contains two types of statements:
•
•

Declaration statements
Executable statements

Declaration statements are used to declare things, such as variables.
In C++, identifiers, such as variables, can be declared anywhere in the program, but they
must be declared before they can be used.
EXAMPLE 2-27
The following statements are examples of variable declarations:
int a, b, c;
double x, y;

Executable statements perform calculations, manipulate data, create output, accept
input, and so on.
Some executable statements that you have encountered so far are the assignment, input,
and output statements.
EXAMPLE 2-28
The following statements are examples of executable statements:
a = 4;
cin >> b;
cout << a << " " << b << endl;

//assignment statement
//input statement
//output statement

In skeleton form, a C++ program looks like the following:
//comments, if needed
preprocessor directives to include header files
using statement
named constants, if needed

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

84 |

Chapter 2: Basic Elements of C++

int main()
{
statement_1
.
.
.
statement_n
return 0;
}

The C++ program in Example 2-29 shows where include statements, declaration statements, executable statements, and so on typically appear in the program.
EXAMPLE 2-29
//***************************************************************
// Author: D.S. Malik
//
// This program shows where the include statements, using
// statement, named constants, variable declarations, assignment
// statements, and input and output statements typically appear.
//***************************************************************
#include <iostream>

//Line 1

using namespace std;

//Line 2

const int NUMBER = 12;

//Line 3

int main()
{
int firstNum;
int secondNum;

//Line
//Line
//Line
//Line

firstNum = 18;
cout << "Line 9: firstNum = " << firstNum
<< endl;

//Line 8

cout << "Line 10: Enter an integer: ";
cin >> secondNum;
cout << endl;

//Line 10
//Line 11
//Line 12

cout << "Line 13: secondNum = " << secondNum
<< endl;

//Line 13

firstNum = firstNum + NUMBER + 2 * secondNum;

//Line 14

cout << "Line 15: The new value of "
<< "firstNum = " << firstNum << endl;

//Line 15

return 0;
}

4
5
6
7

//Line 9

//Line 16
//Line 17

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Debugging: Understanding and Fixing Syntax Errors

|

85

Sample Run: In this sample run, the user input is shaded.
Line 9: firstNum = 18
Line 10: Enter an integer:

15

Line 13: secondNum = 15
Line 15: The new value of firstNum = 60

The preceding program works as follows: The statement in Line 1 includes the
header file iostream so that program can perform input/output. The statement in
Line 2 uses the using namespace statement so that identifiers declared in the
header file iostream, such as cin, cout, and endl, can be used without using
the prefix std::. The statement in Line 3 declares the named constant NUMBER and
sets its value to 12. The statement in Line 4 contains the heading of the function
main, and the left brace in Line 5 marks the beginning of the function main. The
statements in Lines 6 and 7 declare the variables firstNum and secondNum.
The statement in Line 8 sets the value of firstNum to 18, and the statement in Line 9
outputs the value of firstNum. Next, the statement in Line 10 prompts the user to
enter an integer. The statement in Line 11 reads and stores the integer into the variable
secondNum, which is 15 in the sample run. The statement in Line 12 positions the
cursor on the screen at the beginning of the next line. The statement in Line 13
outputs the value of secondNum. The statement in Line 14 evaluates the expression:
firstNum + NUMBER + 2 * secondNum

and assigns the value of this expression to the variable firstNum, which is 60 in the
sample run. The statement in Line 15 outputs the new value of firstNum. The statement
in Line 16 contains the return statement, which is the last executable statement. The
right brace in Line 17 marks the end of the function main.

Debugging: Understanding and Fixing
Syntax Errors
The previous sections of this chapter described the basic components of a C++ program.
When you type a program, typos and unintentional syntax errors are likely to occur.
Therefore, when you compile a program, the compiler will identify the syntax error. In
this section, we show how to identify and fix syntax errors.
Consider the following C++ program:
1. #include <iostream>
2.
3. using namespace std;
4.
5. int main()

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

86 |

Chapter 2: Basic Elements of C++

6.
7.
8.
9.
10.
11.
12.
13.
14.
15.
16.

{

int num
num = 18;
tempNum = 2 * num;
cout << "Num = " << num << ", tempNum = " < tempNum << endl;

return ;
}

(Note that the numbers 1 to 16 on the left side are not part of the program. We have
numbered the statements for easy reference.) This program contains syntax errors. When
you compile this program, the compiler produces the following errors. (This program is
compiled using Microsoft Visual Studio 2012.)
ExampleCh2_Syntax_Errors.cpp
c:\examplech2_syntax_errors.cpp(9):
before identifier 'num'
c:\examplech2_syntax_errors.cpp(11):
c:\examplech2_syntax_errors.cpp(13):
c:\examplech2_syntax_errors.cpp(13):
c:\examplech2_syntax_errors.cpp(13):
function overload

error

C2146:

syntax

error

:

missing

';'

error C2065: 'tempNum' : undeclared identifier
error C2065: 'tempNum' : undeclared identifier
error C2563: mismatch in formal parameter list
error C2568: '<<' : unable to resolve

c:\program files (x86)\microsoft visual studio
11.0\vc\include\ostream(1037): could be 'std::basic_ostream<_Elem,_Traits>
&std::endl(std::basic_ostream<_Elem,_Traits> &)'
with
[
_Elem=unsigned short,
_Traits=std::char_traits<unsigned short>
]
c:\program files (x86)\microsoft visual studio
11.0\vc\include\ostream(1027): or
'std::basic_ostream<_Elem,_Traits>
&std::endl(std::basic_ostream<_Elem,_Traits> &)'
with
[
_Elem=wchar_t,
_Traits=std::char_traits<wchar_t>
]
c:\program files (x86)\microsoft visual studio
11.0\vc\include\ostream(1019): or
'std::basic_ostream<_Elem,_Traits>
&std::endl(std::basic_ostream<_Elem,_Traits> &)'
with
[
_Elem=char,
_Traits=std::char_traits<char>
]

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Debugging: Understanding and Fixing Syntax Errors

|

87

c:\program files (x86)\microsoft visual studio
11.0\vc\include\ ostream(993): or
'std::basic_ostream<_Elem,_Traits>
&std::endl(std::basic_ostream<_Elem,_Traits> &)'
c: \examplech2_syntax_errors.cpp(15): error C2561: 'main' : function must
return a value
c:\examplech2_syntax_errors.cpp(5) : see declaration of 'main'

It is best to try to correct the errors in top-down fashion because the first error may
confuse the compiler and cause it to flag multiple subsequent errors when actually there
was only one error on an earlier line. So, let’s first consider the following error:
c:\examplech2_syntax_errors.cpp(9): error C2146: syntax error : missing ';'
before identifier 'num'

The expression examplech2_syntax_errors.cpp(9) indicates that there is an error in
Line 9. The remaining part of this error specifies that there is a missing ; before the
identifier num. If we look at Line 7, we find that there is a missing semicolon at the end of
the statement int num. Therefore, we must insert ; at the end of the statement in Line 7.
Next, consider the second error:
c:\examplech2_syntax_errors.cpp(11): error C2065: 'tempNum' : undeclared identifier

This error occurs in Line 11, and it specifies that the identifier tempNum is undeclared.
When we look at the code, we find that this identifier has not been declared. So we must
declare tempNum as an int variable.
The error:
c:\examplech2_syntax_errors.cpp(11): error C2065: 'tempNum' : undeclared identifier

occurs in Line 13, and it specifies that the identifier tempNum is undeclared. As in the
previous error, we must declare tempNum. Note that once we declare tempNum and
recompile, this and the previous error will disappear.
The next error is:
c:\examplech2_syntax_errors.cpp(13): error C2563: mismatch in formal parameter list

This error occurs in Line 13, and it indicates that some formal parameter list is mismatched. For a beginner, this error is somewhat hard to understand. (In Chapter 13, we
will explain the formal parameter list of the operator <<.) However, as you practice, you
will learn how to interpret and correct syntax errors. This error becomes clear if you look
at the next error, part of which is:
c:\examplech2_syntax_errors.cpp(13):
function overload

error

C2568:

'<<'

:

unable

to

resolve

It tells us that this error has something to do with the operator <<. When we carefully
look at the statement in Line 13, which is:
cout << "Num = " << num << ", tempNum = " < tempNum << endl;

we find that in the expression < tempNum, we have unintentionally used < in place of <<.
So we must correct this error.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

88 |

Chapter 2: Basic Elements of C++

Let us look at the last error, which is:
c\examplech2_syntax_errors.cpp(15): error C2561: 'main' : function must return a value
c:\examplech2_syntax_errors.cpp(5) : see declaration of 'main'

This error occurs in Line 15. However, at this point, the explanation given,
especially for a beginner, is somewhat unclear. However, if you look at the statement
return ; in Line 15 and remember the syntax of the function main as well as all the
programs given in this book, we find that the number 0 is missing, that is, this statement
must be return 0;
From the errors reported by the compiler, we see that the compiler not only identifies the
errors, but it also specifies the line numbers where the errors occur and the types of the
errors. We can effectively use this information to fix syntax errors.
After correcting all of the syntax errors, a correct program is:
#include <iostream>
using namespace std;
int main()
{
int num;
int tempNum;
num = 18;
tempNum = 2 * num;
cout << "Num = " << num << ", tempNum = " << tempNum << endl;
return 0;
}

The output is:
Num = 18, tempNum = 36

As you learn C++ and practice writing and executing programs, you will learn how to
spot and fix syntax errors. It is possible that the list of errors reported by the compiler is
longer than the program itself. This is because, as indicated above, a syntax error in one
line can cause syntax errors in subsequent lines. In situations like this, correct the syntax
errors in the order they are listed and compile your program, if necessary, after each
correction. You will see how quickly the syntax errors list shrinks. The important thing is
not to panic.
In the next section, we describe some simple rules that you can follow so that your
program is properly structured.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Program Style and Form

|

89

Program Style and Form
In previous sections, you learned enough C++ concepts to write meaningful programs.
Before beginning to write programs, however, you need to learn their proper structure,
among other things. Using the proper structure for a C++ program makes it easier
to understand and subsequently modify the program. There is nothing more frustrating
than trying to follow and perhaps modify a program that is syntactically correct but has
no structure.
In addition, every C++ program must satisfy certain rules of the language. A C++
program must contain the function main. It must also follow the syntax rules, which, like
grammar rules, tell what is right and what is wrong and what is legal and what is illegal in
the language. Other rules serve the purpose of giving precise meaning to the language;
that is, they support the language’s semantics.
The following sections are designed to help you learn how to use the C++ programming
elements you have learned so far to create a functioning program. These sections
cover the syntax; the use of blanks; the use of semicolons, brackets, and commas;
semantics; naming identifiers; prompt lines; documentation, including comments; and
form and style.

Syntax
The syntax rules of a language tell what is legal and what is not legal. Errors in syntax are
detected during compilation. For example, consider the following C++ statements:
int x;
int y
double z;

//Line 1
//Line 2
//Line 3

y = w + x;

//Line 4

When these statements are compiled, a compilation error will occur at Line 2 because the
semicolon is missing after the declaration of the variable y. A second compilation error
will occur at Line 4 because the identifier w is used but has not been declared.
As discussed in Chapter 1, you enter a program into the computer by using a text editor.
When the program is typed, errors are almost unavoidable. Therefore, when the program is
compiled, you are most likely to see syntax errors. It is quite possible that a syntax error at a
particular place might lead to syntax errors in several subsequent statements. It is very
common for the omission of a single character to cause four or five error messages.
However, when the first syntax error is removed and the program is recompiled, subsequent syntax errors caused by this syntax error may disappear. Therefore, you should
correct syntax errors in the order in which the compiler lists them. As you become more
familiar and experienced with C++, you will learn how to quickly spot and fix syntax
errors. Also, compilers not only discover syntax errors, but also hint and sometimes tell the
user where the syntax errors are and how to fix them.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

90 |

Chapter 2: Basic Elements of C++

Use of Blanks
In C++, you use one or more blanks to separate numbers when data is input. Blanks are
also used to separate reserved words and identifiers from each other and from other
symbols. Blanks must never appear within a reserved word or identifier.

Use of Semicolons, Brackets, and Commas
All C++ statements must end with a semicolon. The semicolon is also called a statement
terminator.
Note that curly braces, { and }, are not C++ statements in and of themselves, even
though they often appear on a line with no other code. You might regard brackets as
delimiters, because they enclose the body of a function and set it off from other parts of
the program. Brackets have other uses, which will be explained in Chapter 4.
Recall that commas are used to separate items in a list. For example, you use commas
when you declare more than one variable following a data type.

Semantics
The set of rules that gives meaning to a language is called semantics. For example, the
order-of-precedence rules for arithmetic operators are semantic rules.
If a program contains syntax errors, the compiler will warn you. What happens when a
program contains semantic errors? It is quite possible to eradicate all syntax errors in a
program and still not have it run. And if it runs, it may not do what you meant it to do.
For example, the following two lines of code are both syntactically correct expressions,
but they have different meanings:
2 + 3 *5

and:
(2 + 3) * 5

If you substitute one of these lines of code for the other in a program, you will not get the
same results—even though the numbers are the same, the semantics are different. You
will learn about semantics throughout this book.

Naming Identifiers
Consider the following two sets of statements:
const double A = 2.54;
double x;
double y;

//conversion constant
//variable to hold centimeters
//variable to hold inches

x = y * A;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Program Style and Form

|

91

and
const double CENTIMETERS_PER_INCH = 2.54;
double centimeters;
double inches;
centimeters = inches * CENTIMETERS_PER_INCH;

The identifiers in the second set of statements, such as CENTIMETERS_PER_INCH, are
usually called self-documenting identifiers. As you can see, self-documenting identifiers
can make comments less necessary.
Consider the self-documenting identifier annualsale. This identifier is called a
run-together word. In using self-documenting identifiers, you may inadvertently include
run-together words, which may lessen the clarity of your documentation. You can make
run-together words easier to understand by either capitalizing the beginning of each new
word or by inserting an underscore just before a new word. For example, you could use
either annualSale or annual_sale to create an identifier that is more clear.
Recall that earlier in this chapter, we specified the general rules for naming named
constants and variables. For example, an identifier used to name a named constant is
all uppercase. If this identifier is a run-together word, then the words are separated
with the underscore character, such as CENTIMETERS_PER_INCH.

Prompt Lines
Part of good documentation is the use of clearly written prompts so that users will
know what to do when they interact with a program. There is nothing more
frustrating than sitting in front of a running program and not having the foggiest
notion of whether to enter something or what to enter. Prompt lines are executable
statements that inform the user what to do. For example, consider the following
C++ statements, in which num is an int variable:
cout << "Please enter an integer between 1 and 10 and "
<< "press the return key" << endl;
cin >> num;

When these two statements execute in the order given, first the output statement causes
the following line of text to appear on the screen:
Please enter an integer between 1 and 10 and press the return key

After seeing this line, users know that they must enter an integer and press the return key.
If the program contained only the second statement, users would have no idea that they
must enter an integer, and the computer would wait forever for the input. The preceding
output statement is an example of a prompt line.
In a program, whenever input is needed from users, you must include the necessary
prompt lines. Furthermore, these prompt lines should include as much information as

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

92 |

Chapter 2: Basic Elements of C++

possible about what input is acceptable. For example, the preceding prompt line not
only tells the user to input a number, but also informs the user that the number
should be between 1 and 10.

Documentation
The programs that you write should be clear not only to you, but also to anyone
else. Therefore, you must properly document your programs. A well-documented
program is easier to understand and modify, even a long time after you originally
wrote it. You use comments to document programs. Comments should appear in a
program to explain the purpose of the program, identify who wrote it, and explain
the purpose of particular statements or groups of statements.

Form and Style
You might be thinking that C++ has too many rules. However, in practice, the rules give
C++ a great degree of freedom. For example, consider the following two ways of
declaring variables:
int feet, inches;
double x, y;

and
int feet,inches;double x,y;

The computer would have no difficulty understanding either of these formats,
but the first form is easier to read and follow. Of course, the omission of a single
comma or semicolon in either format may lead to all sorts of strange error messages.
What about blank spaces? Where are they significant and where are they meaningless?
Consider the following two statements:
int a,b,c;

and
int

a,

b,

c;

Both of these declarations mean the same thing. Here, the blanks between the identifiers
in the second statement are meaningless. On the other hand, consider the following
statement:
inta,b,c;

This statement contains a syntax error. The lack of a blank between int and the identifier
a changes the reserved word int and the identifier a into a new identifier, inta.
The clarity of the rules of syntax and semantics frees you to adopt formats that are pleasing
to you and easier to understand.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Program Style and Form

|

93

The following example further elaborates on this.
EXAMPLE 2-30
Consider the following C++ program:
//An improperly formatted C++ program.
#include <iostream>
#include <string>
using namespace std;
int main()
{
int num; double height;
string name;
cout << "Enter an integer: "; cin >> num; cout << endl;
cout<<"num: "<<num<<endl;
cout<<"Enter the first name: "; cin>>name;
cout<<endl; cout <<"Enter the height: ";
cin>>height; cout<<endl;
cout<<"Name: "<<name<<endl;cout<<"Height: "
<<height; cout <<endl;return 0;
}

This program is syntactically correct; the C++ compiler would have no difficulty reading
and compiling this program. However, this program is very hard to read. The program
that you write should be properly indented and formatted. Note the difference when the
program is reformatted:
//A properly formatted C++ program.
#include <iostream>
#include <string>
using namespace std;
int main()
{
int num;
double height;
string name;
cout << "Enter an integer: ";
cin >> num;
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

94 |

Chapter 2: Basic Elements of C++

cout << "num: " << num << endl;
cout << "Enter the first name: ";
cin >> name;
cout << endl;
cout << "Enter the height: ";
cin >> height;
cout << endl;
cout << "Name: " << name << endl;
cout << "Height: " << height << endl;
return 0;
}

As you can see, this program is easier to read. Your programs should be properly
indented and formatted. To document the variables, programmers typically declare
one variable per line. Also, always put a space before and after an operator. When
you type your program using an IDE, typically, your program is automatically
indented.

More on Assignment Statements
The assignment statements you have seen so far are called simple assignment
statements. In certain cases, you can use special assignment statements called
compound assignment statements to write simple assignment statements in a
more concise notation.
Corresponding to the five arithmetic operators +, -, *, /, and %, C++ provides five
compound operators: +=, -=, *=, /=, and %=, respectively. Consider the following simple
assignment statement, in which x and y are int variables:
x = x * y;

Using the compound operator *=, this statement can be written as:
x *= y;

In general, using the compound operator *=, you can rewrite the simple assignment
statement:
variable = variable * (expression);

as:
variable *= expression;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More on Assignment Statements |

95

The other arithmetic compound operators have similar conventions. For example, using
the compound operator +=, you can rewrite the simple assignment statement:
variable = variable + (expression);

2

as:
variable += expression;

The compound assignment statement allows you to write simple assignment statements in a concise fashion by combining an arithmetic operator with the assignment
operator.
EXAMPLE 2-31
This example shows several compound assignment statements that are equivalent to
simple assignment statements.
Simple Assignment Statement

Compound Assignment Statement

i = i + 5;
counter = counter + 1;
sum = sum + number;
amount = amount * (interest + 1);
x = x / ( y + 5);

i += 5;
counter += 1;
sum += number;
amount *= interest + 1;
x /= y + 5;

Any compound assignment statement can be converted into a simple assignment statement. However, a simple assignment statement may not be (easily) converted to a
compound assignment statement. For example, consider the following simple assignment statement:

x = x * y + z – 5;
To write this statement as a compound assignment statement, the variable x must be a
common factor in the right side, which is not the case. Therefore, you cannot immediately
convert this statement into a compound assignment statement. In fact, the equivalent
compound assignment statement is:

x *=

y + (z – 5)/x;

which is more complicated than the simple assignment statement. Furthermore, in the
preceding compound statement, x cannot be 0. We recommend avoiding such compound
expressions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

96 |

Chapter 2: Basic Elements of C++

PROGRAMMING EXAMPLE:

Convert Length

Write a program that takes as input given lengths expressed in feet and inches. The
program should then convert and output the lengths in centimeters. Assume that the
given lengths in feet and inches are integers.
Watch
the Video

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Input

Length in feet and inches.

Output

Equivalent length in centimeters.

The lengths are given in feet and inches, and you need to find the equivalent length
in centimeters. One inch is equal to 2.54 centimeters. The first thing the program
needs to do is convert the length given in feet and inches to all inches. Then, you can
use the conversion formula, 1 inch = 2.54 centimeters, to find the equivalent length
in centimeters. To convert the length from feet and inches to inches, you multiply
the number of feet by 12, as 1 foot is equal to 12 inches, and add the given inches.
For example, suppose the input is 5 feet and 7 inches. You then find the total inches
as follows:
totalInches = (12 * feet) + inches
= 12 * 5 + 7
= 67

You can then apply the conversion formula, 1 inch = 2.54 centimeters, to find the
length in centimeters.
centimeters = totalInches * 2.54
= 67 * 2.54
= 170.18

Based on this analysis of the problem, you can design an algorithm as follows:
1.
2.
3.
4.

Get the length in feet and inches.
Convert the length into total inches.
Convert total inches into centimeters.
Output centimeters.

Variables The input for the program is two numbers: one for feet and one for inches. Thus,

you need two variables: one to store feet and the other to store inches. Because the
program will first convert the given length into inches, you need another variable to
store the total inches. You also need a variable to store the equivalent length in
centimeters. In summary, you need the following variables:
int feet;
int inches;
int totalInches;
double centimeters;

//variable
//variable
//variable
//variable

to
to
to
to

hold
hold
hold
hold

given feet
given inches
total inches
length in centimeters

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Convert Length |

97

Named To calculate the equivalent length in centimeters, you need to multiply the total
Constants inches by 2.54. Instead of using the value 2.54 directly in the program, you will

declare this value as a named constant. Similarly, to find the total inches, you need to
multiply the feet by 12 and add the inches. Instead of using 12 directly in the
program, you will also declare this value as a named constant. Using a named
constant makes it easier to modify the program later.
const double CENTIMETERS_PER_INCH = 2.54;
const int INCHES_PER_FOOT = 12;
MAIN
ALGORITHM

In the preceding sections, we analyzed the problem and determined the formulas to do
the calculations. We also determined the necessary variables and named constants. We
can now expand the algorithm given in the section Problem Analysis and Algorithm
Design to solve the problem given at the beginning of this programming example.
1. Prompt the user for the input. (Without a prompt line, the user
will be staring at a blank screen and will not know what to do.)
2. Get the data.
3. Echo the input—that is, output what the program read as input.
(Without this step, after the program has executed, you will not
know what the input was. This is also a good way to ensure that
your input was correctly received by the program.)
4. Find the length in inches.
5. Output the length in inches.
6. Convert the length to centimeters.
7. Output the length in centimeters.

Putting It Now that the problem has been analyzed and the algorithm has been designed, the
Together next step is to translate the algorithm into C++ code. Because this is the first

complete C++ program you are writing, let’s review the necessary steps in sequence.
The program will begin with comments that document its purpose and functionality.
As there is both input to this program (the length in feet and inches) and output (the
equivalent length in centimeters), you will be using system resources for input/output.
In other words, the program will use input statements to get data into the program and
output statements to print the results. Because the data will be entered from the
keyboard and the output will be displayed on the screen, the program must include the
header file iostream. Thus, the first statement of the program, after the comments as
described above, will be the preprocessor directive to include this header file.
This program requires two types of memory locations for data manipulation: named
constants and variables. Typically, named constants hold special data, such as
CENTIMETERS_PER_INCH. Depending on the nature of a named constant, it can be

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

98 |

Chapter 2: Basic Elements of C++

placed before the function main or within the function main. If a named constant is to be
used throughout the program, then it is typically placed before the function main. We will
comment further on where to put named constants within a program in Chapter 6, when
we discuss user-defined functions in general. Until then, usually, we will place named
constants before the function main so that they can be used throughout the program.
This program has only one function, the function main, which will contain all of the
programming instructions in its body. In addition, the program needs variables to
manipulate data, and these variables will be declared in the body of the function
main. The reasons for declaring variables in the body of the function main are
explained in Chapter 6. The body of the function main will also contain the C++
statements that implement the algorithm. Therefore, the body of the function main
has the following form:
int main()
{
declare variables
statements
return 0;
}

To write the complete length conversion program, follow these steps:
1.
2.
3.
4.

Begin the program with comments for documentation.
Include header files, if any are used in the program.
Declare named constants.
Write the definition of the function main.

COMPLETE PROGRAM LISTING
//********************************************************
// Author: D. S. Malik
//
// Program Convert Measurements: This program converts
// measurements in feet and inches into centimeters using
// the formula that 1 inch is equal to 2.54 centimeters.
//********************************************************
//Header file
#include <iostream>
using namespace std;
//Named constants
const double CENTIMETERS_PER_INCH = 2.54;
const int INCHES_PER_FOOT = 12;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Make Change |

99

int main ()
{
//Declare variables
int feet, inches;
int totalInches;
double centimeters;
//Statements: Step 1 - Step 7
cout << "Enter two integers, one for feet and "
<< "one for inches: ";
cin >> feet >> inches;
cout << endl;
cout << "The numbers you entered are " << feet
<< " for feet and " << inches
<< " for inches. " << endl;

2

//Step 1
//Step 2

//Step 3

totalInches = INCHES_PER_FOOT * feet + inches;

//Step 4

cout << "The total number of inches = "
<< totalInches << endl;

//Step 5

centimeters = CENTIMETERS_PER_INCH * totalInches; //Step 6
cout << "The number of centimeters = "
<< centimeters << endl;

//Step 7

return 0;
}

Sample Run: In this sample run, the user input is shaded.
Enter two integers, one for feet, one for inches: 15 7
The numbers you entered are 15 for feet and 7 for inches.
The total number of inches = 187
The number of centimeters = 474.98

PROGRAMMING EXAMPLE:

Make Change

Write a program that takes as input any change expressed in cents. It should then
compute the number of half-dollars, quarters, dimes, nickels, and pennies to be
returned, returning as many half-dollars as possible, then quarters, dimes, nickels,
and pennies, in that order. For example, 483 cents should be returned as 9 halfdollars, 1 quarter, 1 nickel, and 3 pennies.
Input

Change in cents.

Output

Equivalent change in half-dollars, quarters, dimes, nickels, and pennies.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

100 |

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Chapter 2: Basic Elements of C++

Suppose the given change is 646 cents. To find the number of half-dollars, you divide
646 by 50, the value of a half-dollar, and find the quotient, which is 12, and the
remainder, which is 46. The quotient, 12, is the number of half-dollars, and the
remainder, 46, is the remaining change.
Next, divide the remaining change by 25 to find the number of quarters. Since the
remaining change is 46, division by 25 gives the quotient 1, which is the number of
quarters, and a remainder of 21, which is the remaining change. This process continues
for dimes and nickels. To calculate the remainder in an integer division, you use the mod
operator, %.
Applying this discussion to 646 cents yields the following calculations:
1.
2.
3.
4.
5.
6.
7.
8.
9.

Change = 646
Number of half-dollars = 646 / 50 = 12
Remaining change = 646 % 50 = 46
Number of quarters = 46 / 25 = 1
Remaining change = 46 % 25 = 21
Number of dimes = 21 / 10 = 2
Remaining change = 21 % 10 = 1
Number of nickels = 1 / 5 = 0
Number of pennies = remaining change = 1 % 5 = 1

This discussion translates into the following algorithm:
1.
2.
3.
4.
5.
6.
7.
8.
9.
VARIABLES

Get the change in cents.
Find the number of half-dollars.
Calculate the remaining change.
Find the number of quarters.
Calculate the remaining change.
Find the number of dimes.
Calculate the remaining change.
Find the number of nickels.
Calculate the remaining change, which is the number of pennies.

From the previous discussion and algorithm, it appears that the program will need variables to
hold the number of half-dollars, quarters, and so on. However, the numbers of half-dollars,
quarters, and so on are not used in later calculations, so the program can simply output these
values without saving each of them in a variable. The only thing that keeps changing is the
change, so the program actually needs only one variable:
int change;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Make Change |

NAMED
CONSTANTS

To calculate the equivalent change, the program performs calculations using the
values of a half-dollar, which is 50; a quarter, which is 25; a dime, which is 10;
and a nickel, which is 5. Because these data are special and the program uses
these values more than once, it makes sense to declare them as named
constants. Using named constants also simplifies later modification of the
program:
const
const
const
const

MAIN
ALGORITHM

101

int
int
int
int

HALF_DOLLAR = 50;
QUARTER = 25;
DIME = 10;
NICKEL = 5;

Following the previous discussion, we can design the main algorithm as follows.
Using the variables and named constants specified earlier, while writing the steps
of the main algorithm, we also give the corresponding C++ statements.

Algorithm

Corresponding C++ Statement

1. Prompt the user for input.

cout << "Enter change in cents: ";

2. Get input.

cin >> change;

3. Echo the input by
displaying the entered
change on the screen.

cout << "The change you entered is " << change
<< endl;

4. Compute and print the
number of half-dollars.

cout << "The number of half-dollars to be returned "
<< "is " << change / HALF_DOLLAR
<< endl;

5. Calculate the remaining
change.

change = change % HALF_DOLLAR;

6. Compute and print the
number of quarters.

cout << "The number of quarters to be returned is "
<< change / QUARTER << endl;

7. Calculate the remaining
change.

change = change % QUARTER;

8. Compute and print the
number of dimes.

cout << "The number of dimes to be returned is "
<< change / DIME << endl;

9. Calculate the remaining
change.

change = change % DIME;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

102 |

Chapter 2: Basic Elements of C++

Algorithm

Corresponding C++ Statement

10. Compute and print the
number of nickels.

cout << "The number of nickels to be returned is "
<< change / NICKEL << endl;

11. Calculate the remaining
change.

change = change % NICKEL;

12. Print the remaining
change.

cout << "The number of pennies to be returned is "
<< change << endl;

COMPLETE PROGRAM LISTING
//************************************************************
// Author: D. S. Malik
//
// Program Make Change: Given any amount of change expressed
// in cents, this program computes the number of half-dollars,
// quarters, dimes, nickels, and pennies to be returned,
// returning as many half-dollars as possible, then quarters,
// dimes, nickels, and pennies in that order.
//************************************************************
//Header file
#include <iostream>
using namespace std;
//Named constants
const int HALF_DOLLAR = 50;
const int QUARTER = 25;
const int DIME = 10;
const int NICKEL = 5;
int main()
{
//Declare variable
int change;
//Statements: Step 1 – Step 12
cout << "Enter change in cents: ";
cin >> change;
cout << endl;
cout << "The change you entered is " << change
<< endl;

//Step 1
//Step 2

//Step 3

cout << "The number of half-dollars to be returned "
<< "is " << change / HALF_DOLLAR
<< endl;
//Step 4

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

change = change % HALF_DOLLAR;

103

//Step 5

cout << "The number of quarters to be returned is "
<< change / QUARTER << endl;
//Step 6
change = change % QUARTER;

//Step 7

cout << "The number of dimes to be returned is "
<< change / DIME << endl;
//Step 8
change = change % DIME;

//Step 9

cout << "The number of nickels to be returned is "
<< change / NICKEL << endl;
//Step 10
change = change % NICKEL;

//Step 11

cout << "The number of pennies to be returned is "
<< change << endl;
//Step 12
return 0;
}

Sample Run: In this sample run, the user input is shaded.
Enter change in cents: 583
The
The
The
The
The
The

change
number
number
number
number
number

you entered is 583
of half-dollars to be returned is 11
of quarters to be returned is 1
of dimes to be returned is 0
of nickels to be returned is 1
of pennies to be returned is 3

QUICK REVIEW
1.
2.
3.
4.
5.
6.
7.

A C++ program is a collection of functions.
Every C++ program has a function called main.
A single-line comment starts with the pair of symbols // anywhere in the
line.
Multiline comments are enclosed between /* and */.
The compiler ignores comments.
Reserved words cannot be used as identifiers in a program.
All reserved words in C++ consist of lowercase letters (see Appendix A).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

104 |

8.
9.
10.
11.
12.
13.
14.

15.
16.
17.
18.
19.
20.

21.

22.
23.
24.
25.
26.
27.

Chapter 2: Basic Elements of C++

In C++, identifiers are names of things.
A C++ identifier consists of letters, digits, and underscores and must begin
with a letter or underscore.
Whitespaces include blanks, tabs, and newline characters.
A data type is a set of values together with a set of allowed operations.
C++ data types fall into the following three categories: simple, structured,
and pointers.
There are three categories of simple data: integral, floating-point, and
enumeration.
Integral data types are classified into the following categories: char,
short, int, long, bool, unsigned char, unsigned short,
unsigned int, unsigned long, long long, and unsigned long
long.
The values belonging to int data type are 2147483648 (¼ 231) to
2147483647 (¼ 231  1).
The data type bool has only two values: true and false.
The most common character sets are ASCII, which has 128 values, and
EBCDIC, which has 256 values.
The collating sequence of a character is its preset number in the character
data set.
C++ provides three data types to manipulate decimal numbers: float,
double, and long double.
The data type float is used in C++ to represent any real number between
-3.4 * 1038 and 3.4 * 1038. The memory allocated for a value of the
float data type is four bytes.
The data type double is used in C++ to represent any real number
between -1.7 * 10308 and 1.7 * 10308. The memory allocated for a value
of the double data type is eight bytes.
The arithmetic operators in C++ are addition (+), subtraction (-), multiplication (*), division (/), and modulus (%).
The modulus operator, %, takes only integer operands.
Arithmetic expressions are evaluated using the precedence rules and the
associativity of the arithmetic operators.
All operands in an integral expression, or integer expression, are integers,
and all operands in a floating-point expression are decimal numbers.
A mixed expression is an expression that consists of both integers and
decimal numbers.
When evaluating an operator in an expression, an integer is converted to a
floating-point number, with a decimal part of 0, only if the operator has
mixed operands.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

28.
29.
30.
31.
32.

33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.

105

You can use the cast operator to explicitly convert values from one data
type to another.
A string is a sequence of zero or more characters.
Strings in C++ are enclosed in double quotation marks.
A string containing no characters is called a null or empty string.
Every character in a string has a relative position in the string. The
position of the first character is 0, the position of the second character
is 1, and so on.
The length of a string is the number of characters in it.
During program execution, the contents of a named constant cannot be
changed.
A named constant is declared by using the reserved word const.
A named constant must be initialized when it is declared.
All variables must be declared before they can be used.
C++ does not automatically initialize variables.
Every variable has a name, a value, a data type, and a size.
When a new value is assigned to a variable, the old value is lost.
Only an assignment statement or an input (read) statement can change the
value of a variable.
In C++, >> is called the stream extraction operator.
Input from the standard input device is accomplished by using cin and the
stream extraction operator >>.
When data is input in a program, the data items, such as numbers, are
usually separated by blanks, lines, or tabs.
In C++, << is called the stream insertion operator.
Output of the program to the standard output device is accomplished by
using cout and the stream insertion operator <<.
The manipulator endl positions the insertion point at the beginning of the
next line on an output device.
Outputting or accessing the value of a variable in an expression does not
destroy or modify the contents of the variable.
The character \ is called the escape character.
The sequence \n is called the newline escape sequence.
All preprocessor commands start with the symbol #.
The preprocessor commands are processed by the preprocessor before the
program goes through the compiler.
The preprocessor command #include <iostream> instructs the preprocessor to include the header file iostream in the program.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

106 |

54.

55.
56.
57.
58.
59.
60.

Chapter 2: Basic Elements of C++

To use cin and cout, the program must include the header file iostream
and either include the statement using namespace std; or refer to these
identifiers as std::cin and std::cout.
All C++ statements end with a semicolon. The semicolon in C++ is called
the statement terminator.
A C++ system has three components: environment, language, and the
standard libraries.
Standard libraries are not part of the C++ language. They contain functions
to perform operations, such as mathematical operations.
A file containing a C++ program usually ends with the extension .cpp.
Prompt lines are executable statements that tell the user what to do.
Corresponding to the five arithmetic operators +, -, *, /, and %,
C++ provides five compound operators: +=, -=, *=, /=, and %=, respectively.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.
b.

c.
d.
e.
f.
g.
h.

An identifier can be any sequence of digits and letters. (1)
In C++, there is no difference between a reserved word and a predefined identifier. (1)
A C++ identifier can start with a digit. (1)
The operands of the modulus operator must be integers. (3)
If a = 4; and b = 3;, then after the statement a = b; the value of b is still 3. (6)
In the statement cin >> y;, y can only be an int or a double variable. (8)
In an output statement, the newline character may be a part of the string. (10)
The following is a legal C++ program: (1, 13)
int main()
{
return 0;
}

i.

j.

k.

In a mixed expression, all the operands are converted to floating-point
numbers. (4)
Suppose x = 5. After the statement y = x++; executes, y is 5 and
x is 6. (9)
Suppose a = 5. After the statement ++a; executes, the value of a is still 5
because the value of the expression is not saved in another variable. (9)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

2.

d.
g.
j.

e.

5.
6.

b. _nextQuiz
c. 3rdProject
CPP_Project
f. OneInchIs2.2Centimeters
Jack'sHomework
i. first#

main b. #include
cin f. bool

c.

double

d.

Const

What is the difference between a reserved word and a user-defined identifier? (1)
Are the identifiers quizNo1 and quizno1 the same? (1)
Evaluate the following expressions. (3, 4)
a.
e.
h.

7.

new-Assignment
$twoHundred e.
Weekly Quiz
h.
overPayment

Which of the following is a reserved word in C++? (1)
a.

4.

107

Which of the following are valid C++ identifiers? (1)
a.

3.

|

28 - 3 + 6
b. 6 / 5
c. 3 * 6 / 2 - 15
d. 4 - 6 % 11
37 / 4.0
f. 15 + 18 % 2 - 20 / 6
g. 32 % 12 + 6 - 36 / 5 * 8
5 / 9 * (32.6 - 4.5)
i. 18.0 + 5.0 * 3.0 /4.0

If int x = 3;, int y = 18;, double z = 9.5;, and double w = 3.5;,
evaluate each of the following statements, if possible. If it is not possible,
state the reason. (3, 4)
(x + y) % y
b. x % y - w
c. (y + z) / w
d. x * z % y + w
(x % y) * z
f. (x * y % z) - w
g. x % (y + z)
h. (x % y + z) / w
a.
e.

8.

Given:
int num1, num2, newNum;
double x, y;

Which of the following assignments are valid? If an assignment is not valid, state the
reason. (3, 6)
a.

num1 = 35;

b.

newNum = num1 – num2;

c.

num1 = 5; num2 = 2 + num1; num1 = num2 / 3;

d.

num1 * num2 = newNum;

e.

x = 12 * num1 - 15.3;

f.

num1 * 2 = newNum + num2;

g.

x / y = x * y;

h.

num2 = num1 % 2.0;

i.

newNum = static_cast<int> (x) % 5;

j.

x = x + y - 5;

k.

newNum = num1 + static_cast<int> (4.6 / 2);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

108 |

9.

Suppose that x, y, z, w, and t are int variables. What is stored in x, y, z, w,
and t after the following statements execute? (3, 6)
x
y
z
w
t

10.

Chapter 2: Basic Elements of C++

=
=
=
=
=

5;
x + 2;
x % (y - 2) + 4;
(x * y) / z - 5;
z + (x + y + 2) % w;

Which of the following variable declarations are correct? If a variable
declaration is not correct, give the reason(s) and provide the correct
variable declaration. (1, 7)
double conversion = 2.5;
char grade = 'B+';
double 28.5 = num
string message = ''First C++ course';
int age = 18 years
int perfectSquare;
float x, y, decimal;

11.

c.

i - 5 = x; b. i = i++;
x = x * percent / 100; d.

percent = 0.05%;

Write C++ statement(s) that accomplish the following: (6, 7)
a.
b.

c.
d.
e.

f.

g.

h.
i.
j.

13.

1
2
3
4
5
6
7

Which of the following are valid C++ assignment statements? Assume that i
is an int variable, and x and percent are double variables. (6)
a.

12.

//Line
//Line
//Line
//Line
//Line
//Line
//Line

Declare int variables x and y. Initialize x to 25 and y to 18.
Declare and initialize an int variable temp to 10 and a char variable
ch to 'A'.
Update the value of an int variable x by adding 5 to it.
Declare and initialize a double variable payRate to 12.50.
Copy the value of an int variable firstNum into an int variable
tempNum.
Swap the contents of the int variables x and y. (Declare additional
variables, if necessary.)
Suppose x and y are double variables. Output the contents of x, y,
and the expression x + 12 / y - 18.
Declare a char variable grade and set the value of grade to 'A'.
Declare int variables to store four integers.
Copy the value of a double variable z to the nearest integer into an
int variable x.

Write each of the following as a C++ expression. (3, 4, 6)
a.

5.0 divided by 9 times (F minus 32).

b.

The character that represents 65.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

f.

Assign the value B+ to the variable grade.
Assign the string seventh edition to the variable str.
totalInches is equal to 12 times feet plus inches.
Increment the value of the int variable i by 1.

g.

v = 4/3(3.1416r3).

h.

s = 2(3.1416r2) + 2(3.1416r)h.

i.

(a + b)/c(ef)-gh.

j.

(-b + (b2 - 4ac)) / 2a.

c.
d.
e.

14.

17.

12;
x z x +
x ;
2 *

y =
5 /
y;
3 *
y +

18;
x;
z;
2 * z;

y + w - x;

Suppose x, y, and z are int variables and w and t are double variables.
What value is assigned to each of these variables after the last statement
executes? (4, 6)
x
y
x
z
w
t

16.

109

Suppose x, y, z, and w are int variables. What value is assigned to each of
these variables after the last statement executes? (4,6)
x =
z =
x =
y =
w =
w++
z =

15.

|

=
=
=
=
=
=

38;
x 2 *
y %
3.0
x /

10;
x + y - 3;
(x + 2);
* y + z + 6.5 - 7 % 3;
4.0 + 17 / 4 - y % 4;

Suppose x, y, and z are int variables and x = 8, y = 3, and z = 5. What is
the output of each of the following statements? (3, 4, 10)
a.

cout << "x = " << x << ", y = " << y << ", z = " << z << endl;

b.

cout << "x + 3 * y = " << x + 3 * y << endl;

c.

cout << "Product of " << x << " and " << z << " is " << x * z << endl;

d.

cout << "x + y / z = " << x + y / z << endl;

e.

cout << "2 times " << x << " = " << 2 * x << endl;

Suppose a and b are int variables, c is a double variable, and a = 32,
b = 16, and c = 4.5. What is the output of the following statements?
(3, 4, 10)
a.
b.
c.
d.

cout
cout
cout
cout

<<
<<
<<
<<

a - b * c << endl;
a / 2 - c << endl;
a / static_cast<double>(b) + 3.5 * c << endl;
62 % 28 + 6.3 + a / (c + 0.5) << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

110 |

Chapter 2: Basic Elements of C++

cout << 5 - static_cast<int>(
(c) % 3 + a - b << endl;
cout << 22.5 / 2 + 14.0 * 3.5 + 28 << endl;
(c)) << endl;
g. cout << 2 / (c - static_cast<int>(

e.

f.

18.

Write C++ statements that accomplish the following: (10)
a.
b.
c.

19.

20.

Which of the following are correct C++ statements? (10)
a.

cout << "Hello There!" << endl;

b.

cout << "Hello";
<< " There!" << endl;

c.

cout << "Hello"
<< " There!" << endl;

d.

cout << 'Hello There!' << endl;

Give meaningful identifiers for the following variables and write a proper
C++ declaration and initialization to a reasonable value. (1, 6, 7)
a.
b.
c.
d.
e.

21.

A
A
A
A
A

variable
variable
variable
variable
variable

to
to
to
to
to

store
store
store
store
store

the
the
the
the
the

first name of a student.
discounted price of an item.
number of juice bottles.
number of miles traveled.
highest test score.

Write C++ statements to do the following: (7, 8, 10)
a.
b.
c.
d.

22.

Output the newline character.
Output the tab character.
Output double quotation mark.

Declare int variables num1 and num2.
Prompt the user to input two integers.
Input the first number in num1 and the second number in num2.
Output num1, num2, and 2 times num1 minus num2. Your output must
identify each number and the expression.

The following program has syntax errors. Correct them. On each successive
line, assume that any preceding error has been corrected. (12)
#include <ioStream>
using

std;

const double DECIMAL# = 5.50;
const string blanks = "
"

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

111

int ()main
{
int height, weight;
double 10%discount
double billingAmount$;
double bonus;
int hoursWorked = 45;
height = 6.2;
weight = 156;
cout << height << " " << weight << end;
discount = (2 * height + weight) % 10.0
price = 49.99;
billingAmount = price * (1 - discount) - DECIMAL;
DECIMAL = 7.55;
cout << price << blanks << $ billingAmount << endl;
bouns = hoursWorked * PAY_RATE / 50;
cout << "Bonus = " << bonus << endl;
return 0;
}
23.

The following program has syntax errors. Correct them. On each successive
line, assume that any preceding error has been corrected. (12)
const char = STAR = '*'
const int PRIME = 71;
int main
{
int count, sum;
double x;
count = 1;
sum = count + PRIME;
x = 25.67
newNum = count * ONE + 2;
sum + count = sum;
(x + sum)++;
x = x + sum * COUNT;
sum += 3––;
cout << " count = " << count << ", sum = " << sum
<< ", PRIME = " << Prime << endl;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

112 |

24.

Chapter 2: Basic Elements of C++

The following program has syntax errors and/or the statements are in the
incorrect order. Correct them. On each successive line, assume that any
preceding error has been corrected. (12)
using namespace std;
include <#iostream>
int main()
{
int num1; num2;
string str1;
cout << "Enter a string without any blanks in it ": ;
cin >> string
cout << endl;
cout << "Enter two integers: ";
cin << num1, num2;
cout << endl;
return 0;
cout << str1 << " "
<< "num1 * num2 = " << num1 * num2 << endl
}

26.

What actions must be taken before a variable can be used in a program? (7)
Preprocessor directives begin with which of the following symbols: (12)
a. *
b. #
c. $
d. !
e. None of these.

27.

Write equivalent compound statements if possible. (14)

25.

a.
d.
28.

Write the following compound statements as equivalent simple statements. (14)
a.
d.

29.

x = 2 *x
b. x = x + y - 2;
c. sum = sum + num;
z = z * x + 2 * z;
e. y = y / (x + 5);

x += 5 - z;
b.
x -= z + y - t;

y *= 2 * x + 5 - z;
sum += num;

w += 2 * z + 4;

Suppose a, b, and c are int variables and a = 5 and b = 6. What value is
assigned to each variable after each statement executes? If a variable is
undefined at a particular statement, report UND (undefined). (6, 9)
a = (b++) + 3;
c = 2 * a + (++b);
b = 2 * (++c) - (a++);

30.

c.

e.

a
__
__
__

b
__
__
__

c
__
__
__

Suppose a, b, and sum are int variables and c is a double variable. What
value is assigned to each variable after each statement executes? Suppose a = 3,
b = 5, and c = 14.1. (14)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

sum = a + b + c;
c /= a;
b += c - a;
a *= 2 * b + c;
31.

a
___
___
___
___

b
___
___
___
___

c
___
___
___
___

|

113

sum
___
___
___
___

What is printed by the following program? Suppose the input is: (8, 10, 11)
35 10.5 27 B
#include <iostream>
using namespace std;
const int NUM = 10;
const double X = 20.5;
int main()
{
int firstNum, secondNum;
double z;
char grade;
firstNum = 62;
cout << "firstNum = " << firstNum << endl;
cout << "Enter three numbers: ";
cin >> firstNum >> z >> secondNum;
cout << endl;
cout << "The numbers you entered are "
<< firstNum << ", " << z << ", and "
<< secondNum << endl;
z = z - X + 2 * firstNum - secondNum;
cout << "z = " << z << endl;
cout << "Enter grade: ";
cin >> grade;
cout << endl;
cout << "The letter that follows your grade is: "
<< static_cast<char>(static_cast<int>(grade) + 1)
<< endl;
return 0;
}

32.

What is printed by the following program? Suppose the input is: (8, 10, 11)
Miller
34
62.5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

114 |

Chapter 2: Basic Elements of C++

#include <iostream>
#include <string>
using namespace std;
const double CONVERSION = 3.5;
int main()
{
const int TEMP = 23;
string name;
int id;
int num;
double decNum;
double mysteryNum;
cout << "Enter last name: ";
cin >> name;
cout << endl;
cout << "Enter a two digit integer: ";
cin >> id;
cout << endl;
num = (id * TEMP) % (static_cast<int>(CONVERSION));
cout << "Enter a decimal number: ";
cin >> decNum;
cout << endl;
mysteryNum = decNum / CONVERSION - TEMP;
cout << "Name: " << name << endl;
cout << "Id: " << id << endl;
cout << "Mystery number: " << mysteryNum << endl;
return 0;
}
33.

Rewrite the following program so that it is properly formatted: (13)
#include <iostream>
#include <string>
using namespace std;
const double X = 13.45; const int Y=34;
const char BLANK= ' ';
int main()
{ string firstName,lastName;int num;
double salary;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

115

cout<<"Enter first name: "; cin>> firstName; cout<<endl;
cout<<"Enter last name: "; cin
>>lastName;cout<<endl;
cout<<"Enter a positive integer less than 70:";
cin>>num;cout<<endl; salary=num*X;
cout<<"Name: "<<firstName<<BLANK<<lastName<<endl;cout
<<"Wages: $"<<salary<<endl; cout<<"X = "<<X<<endl;
cout<<"X+Y = " << X+Y << endl; return 0;
}
34.

What type of input does the following program require, and in what order
does the input need to be provided? (8, 10, 11)
#include <iostream>
using namespace std;
int main()
{
int invoiceNumber;
double salesTaxRate;
double productPrice;
string productName;
cin >> productName;
cin >> salesTaxRate >> productPrice;
cin >> invoiceNumber;
return 0;
}

PROGRAMMING EXERCISES
1.

Write a program that produces the following output:
**********************************
*
Programming Assignment 1
*
*
Computer Programming I
*
*
Author: ???
*
*
Due Date: Thursday, Jan. 24 *
**********************************

In your program, substitute ??? with your own name. If necessary, adjust the
positions and the number of the stars to produce a rectangle.
2.
Write a program that produces the following output:
CCCCCCCCC
++
CC
++
CC
++++++++++++++
CC
++++++++++++++
CC
++
CCCCCCCCC
++

++
++
+++++++++++++++
+++++++++++++++
++
++

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

116 |

3.

Chapter 2: Basic Elements of C++

Consider the following program segment
//include statement(s)
//using namespace statement
int main()
{
//variable declaration
//executable statements
//return statement
}
a.
b.

c.

d.

e.

f.

g.
4.

5.

Write a C++ statement that includes the header file iostream.
Write a C++ statement that allows you to use cin, cout, and endl
without the prefix std::.
Write C++ statement(s) that declare the following variables: num1,
num2, num3, and average of type int.
Write C++ statements that store 125 into num1, 28 into num2, and
-25 into num3.
Write a C++ statement that stores the average of num1, num2, and
num3, into average.
Write C++ statement(s) that output the values of num1, num2, num3,
and average.
Compile and run your program.

Repeat Exercise 3 by declaring num1, num2, and num3, and average of
type double. Store 75.35 into num1, -35.56 into num2, and 15.76
into num3.
Consider the following C++ program in which the statements are in the
incorrect order. Rearrange the statements so that it prompts the user to
input the radius of a circle and outputs the area and circumference of
the circle.
#include <iostream>
{
int main()
cout << "Enter the radius: ";
cin >> radius;
cout << endl;
double radius;
double area;
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

117

return 0;
cout << "Area = " << area << endl;
area = PI * radius * radius;
circumference = 2 * PI * radius;
cout << "Circumference = " << circumference << endl;
const double PI = 3.14;
double circumference;
}
6.

Consider the following program segment:
//include statement(s)
//using namespace statement
int main()
{
//variable declaration
//executable statements
//return statement
}
a.

b.

c.

d.

e.

Write C++ statements that include the header files iostream and
string.
Write a C++ statement that allows you to use cin, cout, and endl
without the prefix std::.
Write C++ statements that declare the following variables: name of type
string and studyHours of type double.
Write C++ statements that prompt and input a string into name and a
double value into studyHours.
Write a C++ statement that outputs the values of name and studyHours
with the appropriate text. For example, if the value of name is "Donald"
and the value of studyHours is 4.5, the output is:

Hello, Donald! on Saturday, you need to study 4.5 hours for the exam.
f.
7.

Compile and run your program.

Write a program that prompts the user to input a decimal number and
outputs the number rounded to the nearest integer.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

118 |

8.

Chapter 2: Basic Elements of C++

Consider the following program segment:
//include statement(s)
//using namespace statement
int main()
{
//variable declaration
//executable statements
//return statement
}
a.

b.

c.

d.

e.

f.

Write C++ statements that include the header files iostream and
string.
Write a C++ statement that allows you to use cin, cout, and endl
without the prefix std::.
Write C++ statements that declare and initialize the following named
constants: SECRET of type int initialized to 11 and RATE of type
double initialized to 12.50.
Write C++ statements that declare the following variables: num1, num2,
and newNum of type int; name of type string; and hoursWorked and
wages of type double.
Write C++ statements that prompt the user to input two integers and
store the first number in num1 and the second number in num2.
Write a C++ statement(s) that outputs the values of num1 and num2,
indicating which is num1 and which is num2. For example, if num1 is 8
and num2 is 5, then the output is:
The value of num1 = 8 and the value of num2 = 5.

g.

h.

i.

j.

Write a C++ statement that multiplies the value of num1 by 2, adds the
value of num2 to it, and then stores the result in newNum. Then, write a
C++ statement that outputs the value of newNum.
Write a C++ statement that updates the value of newNum by adding
the value of the named constant SECRET to it. Then, write a C++
statement that outputs the value of newNum with an appropriate
message.
Write C++ statements that prompt the user to enter a person’s last name
and then store the last name into the variable name.
Write C++ statements that prompt the user to enter a decimal number
between 0 and 70 and then store the number entered into hoursWorked.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

k.

l.

|

119

Write a C++ statement that multiplies the value of the named constant
RATE with the value of hoursWorked and then stores the result into the
variable wages.
Write C++ statements that produce the following output:
Name:
Pay Rate: $
Hours Worked:
Salary: $

//output the value
//output the value
//output the value
//hoursWorked
//output the value

of the variable name
of RATE
of the variable
of the variable wages

For example, if the value of name is "Rainbow" and hoursWorked is
45.50, then the output is:
Name: Rainbow
Pay Rate: $12.50
Hours Worked: 45.50
Salary: $568.75
m.

9.

10.

11.

12.

13.

Write a C++ program that tests each of the C++ statements that you
wrote in parts a through l. Place the statements at the appropriate place
in the C++ program segment given at the beginning of this problem.
Test run your program (twice) on the following input data:
a.

num1 = 13, num2 = 28; name = "Jacobson"; hoursWorked =
48.30.

b.

num1 = 32, num2 = 15; name = "Crawford"; hoursWorked =
58.45.

Write a program that prompts the user to enter five test scores and then prints
the average test score. (Assume that the test scores are decimal numbers.)
Write a program that prompts the user to input five decimal numbers. The
program should then add the five decimal numbers, convert the sum to the
nearest integer, and print the result.
Write a program that prompts the capacity, in gallons, of an automobile
fuel tank and the miles per gallon the automobile can be driven. The
program outputs the number of miles the automobile can be driven
without refueling.
Write a C++ program that prompts the user to input the elapsed time for
an event in seconds. The program then outputs the elapsed time in hours,
minutes, and seconds. (For example, if the elapsed time is 9630 seconds,
then the output is 2:40:30.), and seconds. The program then outputs the
elapsed time in seconds.)
To make a profit, a local store marks up the prices of its items by a certain
percentage. Write a C++ program that reads the original price of the item
sold, the percentage of the marked-up price, and the sales tax rate. The
program then outputs the original price of the item, the percentage of the

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

120 |

14.

15.

16.

mark-up, the store’s selling price of the item, the sales tax rate, the sales tax,
and the final price of the item. (The final price of the item is the selling
price plus the sales tax.)
(Hard drive storage capacity) If you buy a 40GB hard drive, then chances
are that the actual storage on the hard drive is not 40GB. This is due to the
fact that, typically, a manufacturer uses 1000 bytes as the value of 1K bytes,
1000K bytes as the value of 1MB, 1000MB as the value of 1GB. Therefore,
a 40GB byte hard drive contains 40,000,000,000 bytes. However, in
computer memory, as given in Table 1-1 (Chapter 1), 1KB is equal to
1024 bytes, and so on. So the actual storage on a 40GB hard drive is
approximately 37.25GB. (You might like to read the fine print next time
you buy a hard drive.) Write a program that prompts the user to enter the
size of the hard drive specified by the manufacturer, on the hard drive box,
and outputs the actual storage capacity of the hard drive.
Write a program to implement and test the algorithm that you designed for
Exercise 17 of Chapter 1. (You may assume that the value of p = 3.141593.
In your program, declare a named constant PI to store this value.)
A milk carton can hold 3.78 liters of milk. Each morning, a dairy farm ships
cartons of milk to a local grocery store. The cost of producing one liter of
milk is $0.38, and the profit of each carton of milk is $0.27. Write a
program that does the following:
a.

b.

c.
d.
17.

18.

Chapter 2: Basic Elements of C++

Prompts the user to enter the total amount of milk produced in the
morning.
Outputs the number of milk cartons needed to hold milk. (Round your
answer to the nearest integer.)
Outputs the cost of producing milk.
Outputs the profit for producing milk.

Redo Programming Exercise 16 so that the user can also input the cost of
producing one liter of milk and the profit on each carton of milk.
You found an exciting summer job for five weeks. It pays, say, $15.50
per hour. Suppose that the total tax you pay on your summer job
income is 14%. After paying the taxes, you spend 10% of your net
income to buy new clothes and other accessories for the next school
year and 1% to buy school supplies. After buying clothes and school
supplies, you use 25% of the remaining money to buy savings bonds.
For each dollar you spend to buy savings bonds, your parents spend
$0.50 to buy additional savings bonds for you. Write a program that
prompts the user to enter the pay rate for an hour and the number
of hours you worked each week. The program then outputs the
following:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

a.
b.
c.
d.
e.

19.

20.

21.

22.

23.

24.

|

121

Your income before and after taxes from your summer job.
The money you spend on clothes and other accessories.
The money you spend on school supplies.
The money you spend to buy savings bonds.
The money your parents spend to buy additional savings bonds for
you.

Write a program that prompts the user to input a number of quarters,
dimes, and nickels. The program then outputs the total value of the coins in
pennies.
Newton’s law states that the force, F, between two bodies of masses M1 and
M2 is given by:


M M
F ¼ k d1 2 2 ;
in which k is the gravitational constant and d is the distance between the
bodies. The value of k is approximately 6.6710-8 dyn. cm2/g2. Write a
program that prompts the user to input the masses of the bodies and the
distance between the bodies. The program then outputs the force between
the bodies.
One metric ton is approximately 2205 pounds. Write a program that
prompts the user to input the amount of rice, in pounds, a bag can hold.
The program outputs the number of bags needed to store one metric ton
of rice.
Cindy uses the services of a brokerage firm to buy and sell stocks. The firm
charges 1.5% service charges on the total amount for each transaction, buy
or sell. When Cindy sells stocks, she would like to know if she gained or
lost on a particular investment. Write a program that allows Cindy to input
the number of shares sold, the purchase price of each share, and the selling
price of each share. The program outputs the amount invested, the total
service charges, amount gained or lost, and the amount received after
selling the stock.
A piece of wire is to be bent in the form of a rectangle to put around a
picture frame. The length of the picture frame is 1.5 times the width. Write
a program that prompts the user to input the length of the wire and outputs
the length and width of the picture frame.
Repeat Exercise 23, but the wire is to be bent in the form of a circle. In this
case, the user specifies the length of the wire and the program outputs the
radius and area of the circle. (You may assume that p = 3.1416. Also declare
it as a named constant.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2

122 |

25.

26.

27.

Chapter 2: Basic Elements of C++

A room has one door, two windows, and a built-in bookshelf and it needs
to be painted. Suppose that one gallon of paint can paint 120 square feet.
Write the program that prompts the user to input the lengths and widths of
the door, each window, the bookshelf; and the length, width, and height of
the room (in feet). The program outputs the amount of paint needed to
paint the walls of the room.
Modify Exercise 25 so that the user can also specify the area that can be
painted with one gallon of paint.
In an elementary school, a mixture of equal amounts of nuts and dried fruit is
provided during lunch. Suppose that the number of calories in each pound of
nuts is 0.70 times the number of calories in each pound of dried fruit. Write a
program that prompts the user to input the number of students in the
elementary school, the number of calories required for each student from
the mixture, and the number of calories in each pound of nuts. The program
outputs the amount of nuts and dried fruit needed for the students. (For
simplicity, assume that each student requires the same amount of calories.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

CHAPTER

ª HunThomas/Shutterstock.com

I NPUT /O UTPUT
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn what a stream is and examine input and output streams

2.

Explore how to read data from the standard input device

3.

Learn how to use predefined functions in a program

4.

Explore how to use the input stream functions get, ignore, putback, and peek

5.

Become familiar with input failure

6.

Learn how to write data to the standard output device

7.

Discover how to use manipulators in a program to format output

8.

Learn how to perform input and output operations with the string data type

9.

Learn how to debug logic errors

10.

Become familiar with file input and output

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

124 |

Chapter 3: Input/Output

In Chapter 2, you were introduced to some of C++’s input/output (I/O) instructions,
which get data into a program and print the results on the screen. You used cin and
the extraction operator >> to get data from the keyboard, and cout and the insertion
operator << to send output to the screen. Because I/O operations are fundamental to
any programming language, in this chapter, you will learn about C++’s I/O operations
in more detail. First, you will learn about statements that extract input from the
standard input device and send output to the standard output device. You will then
learn how to format output using manipulators. In addition, you will learn about the
limitations of the I/O operations associated with the standard input/output devices and
learn how to extend these operations to other devices.

I/O Streams and Standard I/O Devices
A program performs three basic operations: it gets data, it manipulates the data, and it
outputs the results. In Chapter 2, you learned how to manipulate numeric data using
arithmetic operations. In later chapters, you will learn how to manipulate nonnumeric
data. Because writing programs for I/O is quite complex, C++ offers extensive support
for I/O operations by providing substantial prewritten I/O operations, some of which
you encountered in Chapter 2. In this chapter, you will learn about various I/O
operations that can greatly enhance the flexibility of your programs.
In C++, I/O is a sequence of bytes, called a stream, from the source to the
destination. The bytes are usually characters, unless the program requires other
types of information, such as a graphic image or digital speech. Therefore, a
stream is a sequence of characters from the source to the destination. There are
two types of streams:
Input stream: A sequence of characters from an input device to the computer.
Output stream: A sequence of characters from the computer to an output device.

Recall
output
output
header

that the standard input device is usually the keyboard, and the standard
device is usually the screen. To receive data from the keyboard and send
to the screen, every C++ program must use the header file iostream. This
file contains, among other things, the definitions of two data types,
istream (input stream) and ostream (output stream). The header file also contains
two variable declarations, one for cin (pronounced ‘‘see-in’’), which stands for
common input, and one for cout (pronounced ‘‘see-out’’), which stands for
common output.
These variable declarations are similar to the following C++ statements:
istream cin;
ostream cout;

To use cin and cout, every C++ program must use the preprocessor directive:
#include <iostream>

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

I/O Streams and Standard I/O Devices

|

125

From Chapter 2, recall that you have been using the statement using namespace
std; in addition to including the header file iostream to use cin and cout. Without
the statement using namespace std;, you refer to these identifiers as std::cin
and std::cout. In Chapter 7, you will learn about the meaning of the statement
using namespace std; in detail.

Variables of type istream are called input stream variables; variables of type ostream
are called output stream variables. A stream variable is either an input stream
variable or an output stream variable.
Because cin and cout are already defined and have specific meanings, to avoid confusion, you should never redefine them in programs.
The variable cin has access to operators and functions that can be used to extract data
from the standard input device. You have briefly used the extraction operator >> to input
data from the standard input device. The next section describes in detail how the
extraction operator >> works. In the following sections, you will learn how to use the
functions get, ignore, peek, and putback to input data in a specific manner.

cin and the Extraction Operator >>
In Chapter 2, you saw how to input data from the standard input device by using cin and
the extraction operator >>. Suppose payRate is a double variable. Consider the
following C++ statement:
cin >> payRate;

When the computer executes this statement, it inputs the next number typed on
the keyboard and stores this number in payRate. Therefore, if the user types 15.50, the
value stored in payRate is 15.50.
The extraction operator >> is binary and thus takes two operands. The left-side operand
must be an input stream variable, such as cin. Because the purpose of an input statement
is to read and store values in a memory location and because only variables refer to
memory locations, the right-side operand is a variable.
The extraction operator >> is defined only for putting data into variables of simple
data types. Therefore, the right-side operand of the extraction operator >> is a variable
of the simple data type. However, C++ allows the programmer to extend the definition
of the extraction operator >> so that data can also be put into other types of variables
by using an input statement. You will learn this mechanism in Chapter 13 later in
this book.

The syntax of an input statement using cin and the extraction operator >> is:
cin >> variable >> variable...;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

126 |

Chapter 3: Input/Output

As you can see in the preceding syntax, a single input statement can read more than one
data item by using the operator >> several times. Every occurrence of >> extracts the
next data item from the input stream. For example, you can read both payRate and
hoursWorked via a single input statement by using the following code:
cin >> payRate >> hoursWorked;

There is no difference between the preceding input statement and the following two
input statements. Which form you use is a matter of convenience and style.
cin >> payRate;
cin >> hoursWorked;

How does the extraction operator >> work? When scanning for the next input, >> skips
all whitespace characters. Recall that whitespace characters consist of blanks and certain
nonprintable characters, such as tabs and the newline character. Thus, whether you
separate the input data by lines or blanks, the extraction operator >> simply finds the
next input data in the input stream. For example, suppose that payRate and
hoursWorked are double variables. Consider the following input statement:
cin >> payRate >> hoursWorked;

Whether the input is:
15.50 48.30

or:
15.50

48.30

or:
15.50
48.30

the preceding input statement would store 15.50 in payRate and 48.30 in
hoursWorked. Note that the first input is separated by a blank, the second input is
separated by a tab, and the third input is separated by a line.
Now suppose that the input is 2. How does the extraction operator >> distinguish
between the character 2 and the number 2? The right-side operand of the extraction
operator >> makes this distinction. If the right-side operand is a variable of the data type
char, the input 2 is treated as the character 2 and, in this case, the ASCII value of 2 is
stored. If the right-side operand is a variable of the data type int or double, the input
2 is treated as the number 2.
Next, consider the input 25 and the statement:
cin >> a;

where a is a variable of some simple data type. If a is of the data type char, only the single
character 2 is stored in a. If a is of the data type int, 25 is stored in a. If a is of the data type

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

I/O Streams and Standard I/O Devices

|

127

double, the input 25 is converted to the decimal number 25.0. Table 3-1 summarizes this

discussion by showing the valid input for a variable of the simple data type.
TABLE 3-1

Valid Input for a Variable of the Simple Data Type

Data Type of a

Valid Input for a

char

One printable character except the blank

int

An integer, possibly preceded by a + or - sign

double

A decimal number, possibly preceded by a + or - sign. If the actual
data input is an integer, the input is converted to a decimal number
with the zero decimal part.

When reading data into a char variable, after skipping any leading whitespace characters,
the extraction operator >> finds and stores only the next character; reading stops after a
single character. To read data into an int or double variable, after skipping all leading
whitespace characters and reading the plus or minus sign (if any), the extraction operator
>> reads the digits of the number, including the decimal point for floating-point variables,
and stops when it finds a whitespace character or a character other than a digit.

EXAMPLE 3-1
Suppose you have the following variable declarations:
int a, b;
double z;
char ch;

The following statements show how the extraction operator >> works.
Statement
1
2

cin >> ch;
cin >> ch;

Input
A
AB

Value Stored in Memory
ch = 'A'
ch = 'A', 'B' is held for
later input

3
4

cin >> a;
cin >> a;

48
46.35

a = 48
a = 46, .35 is held for
later input

5
6
7

cin >> z;
cin >> z;
cin >> z >> a;

74.35
39
65.78 38

z = 74.35
z = 39.0
z = 65.78, a = 38

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

128 |

8
9

Chapter 3: Input/Output

Statement

Input

Value Stored in Memory

cin >> a >> b;
cin >> a >> z;

4 60
46 32.4 68

a = 4, b = 60
a = 46, z = 32.4, 68 is
held for later input

EXAMPLE 3-2
Suppose you have the following variable declarations:
int a;
double z;
char ch;

The following statements show how the extraction operator >> works.
Statement

Input

Value Stored in Memory

1

cin >> a >> ch >> z;

57 A 26.9

2

cin >> a >> ch >> z;

3

cin >> a >> ch >> z;

4

cin >> a >> ch >> z;

57 A
26.9
57
A
26.9
57A26.9

a
z
a
z
a
z

=
=
=
=
=
=

57, ch = 'A',
26.9
57, ch = 'A',
26.9
57, ch = 'A',
26.9

a = 57, ch = 'A',
z = 26.9

Note that for statements 1 through 4, the input statement is the same; however, the data
is entered differently. For statement 1, data is entered on the same line separated by
blanks. For statement 2, data is entered on two lines; the first two input values are
separated by two blank spaces, and the third input is on the next line. For statement 3, all
three input values are separated by lines, and for statement 4, all three input values are on
the same line, but there is no space between them. Note that the second input is a nonnumeric character. These statements work as follows.
Statements 1, 2, and 3 are easy to follow. Let us look at statement 4.
In statement 4, first the extraction operator >> extracts 57 from the input stream and
stores it in a. Then, the extraction operator >> extracts the character 'A' from the input
stream and stores it in ch. Next, 26.9 is extracted and stored in z.
Note that statements 1, 2, and 3 illustrate that regardless of whether the input is
separated by blanks or by lines, the extraction operator >> always finds the next
input.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

I/O Streams and Standard I/O Devices

|

129

EXAMPLE 3-3
Suppose you have the following variable declarations:
int a, b;
double z;
char ch, ch1, ch2;

The following statements show how the extraction operator >> works.
Statement

Input

Value Stored in Memory

1

cin >> z >> ch >> a;

36.78B34

2

cin >> z >> ch >> a;

36.78
B34
11 34

z
a
z
a
a

3

cin >> a >> b >> z;

6

78.49
256
256

7

cin >> ch1 >> ch2;

A B

5

36.78, ch = 'B',
34
36.78, ch = 'B',
34
11, b = 34,

computer waits for the next
number

cin >> a >> z;
cin >> ch >> a;
cin >> a >> ch;

4

=
=
=
=
=

a = 78, z = 0.49
ch = '2', a = 56
a = 256, computer waits for
the input value for ch
ch1 = 'A', ch2 = 'B'

In statement 1, because the first right-side operand of >> is z, which is a double
variable, 36.78 is extracted from the input stream, and the value 36.78 is stored in z.
Next, 'B' is extracted and stored in ch. Finally, 34 is extracted and stored in a.
Statement 2 works similarly.
In statement 3, 11 is stored in a, and 34 is stored in b, but the input stream does not have
enough input data to fill each variable. In this case, the computer waits (and waits, and
waits . . .) for the next input to be entered. The computer does not continue to execute
until the next value is entered.
In statement 4, the first right-side operand of the extraction operator >> is a variable of
the type int, and the input is 78.49. Now for int variables, after inputting the digits of
the number, the reading stops at the first whitespace character or a character other than a
digit. Therefore, the operator >> stores 78 into a. The next right-side operand of >> is
the variable z, which is of the type double. Therefore, the operator >> stores the value
.49 as 0.49 into z.
In statement 5, the first right-side operand of the extraction operator >> is a char
variable, so the first nonwhitespace character, '2', is extracted from the input stream.
The character '2' is stored in the variable ch. The next right-side operand of the
extraction operator >> is an int variable, so the next input value, 56, is extracted and
stored in a.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

130 |

Chapter 3: Input/Output

In statement 6, the first right-side operator of the extraction operator >> is an int
variable, so the first data item, 256, is extracted from the input stream and stored in a.
Now the computer waits for the next data item for the variable ch.
In statement 7, 'A' is stored into ch1. The extraction operator >> then skips the blank,
and 'B' is stored in ch2.

Recall that during program execution, when entering character data such as letters, you
do not enter the single quotes around the character.

What happens if the input stream has more data items than required by the program?
After the program terminates, any values left in the input stream are discarded. When you
enter data for processing, the data values should correspond to the data types of the
variables in the input statement. Recall that when entering a number for a double
variable, it is not necessary for the input number to have a decimal part. If the input
number is an integer and has no decimal part, it is converted to a decimal value. The
computer, however, does not tolerate any other kind of mismatch. For example, entering
a char value into an int or double variable causes serious errors, called input failure.
Input failure is discussed later in this chapter.
The extraction operator, when scanning for the next input in the input stream, skips
whitespace such as blanks and the newline character. However, there are situations when
these characters must also be stored and processed. For example, if you are processing
text in a line-by-line fashion, you must know where in the input stream the newline
character is located. Without identifying the position of the newline character, the
program would not know where one line ends and another begins. The next few sections
teach you how to input data into a program using the input functions, such as get,
ignore, putback, and peek. These functions are associated with the data type istream
and are called istream member functions. I/O functions, such as get, are typically
called stream member functions or stream functions.
Before you can learn about the input functions get, ignore, putback, peek, and other
I/O functions that are used in this chapter, you need to first understand what a function is
and how it works. You will study functions in detail and learn how to write your own
in Chapter 6.

Using Predefined Functions in a Program
As noted in Chapter 2, a function, also called a subprogram, is a set of instructions. When
a function executes, it accomplishes something. The function main, as you saw in
Chapter 2, executes automatically when you run a program. Other functions execute

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Using Predefined Functions in a Program |

131

only when they are activated—that is, called. C++ comes with a wealth of functions,
called predefined functions, that are already written. In this section, you will learn how
to use some predefined functions that are provided as part of the C++ system. Later in this
chapter, you will learn how to use stream functions to perform a specific I/O operation.
Recall from Chapter 2 that predefined functions are organized as a collection of libraries,
called header files. A particular header file may contain several functions. Therefore, to
use a particular function, you need to know the name of the function and a few other
things, which are described shortly.
A very useful function, pow, called the power function, can be used to calculate xy in a
program. That is, pow(x, y) p=ﬃﬃﬃﬃﬃﬃﬃ
xy. For example, pow(2.0, 3.0) = 2.03.0 = 8.0 and
ﬃ
0.5
pow(4.0, 0.5) = 4.0
= 4:0 = 2.0. The numbers x and y that you use in the
function pow are called the arguments or parameters of the function pow. For
example, in pow(2.0, 3.0), the parameters are 2.0 and 3.0.
An expression such as pow(2.0, 3.0) is called a function call, which causes the code
attached to the predefined function pow to execute and, in this case, computes 2.03.0.
The header file cmath contains the specification of the function pow.
To use a predefined function in a program, you need to know the name of the header
file containing the specification of the function and include that header file in the
program. In addition, you need to know the name of the function, the number of
parameters the function takes, and the type of each parameter. You must also be aware
of what the function is going to do. For example, to use the function pow, you must
include the header file cmath. The function pow has two parameters, which are decimal
numbers. The function calculates the first parameter to the power of the second
parameter. (Appendix F describes some commonly used header files and predefined
functions.)
The program in the following example illustrates how to use predefined functions in a
program. More specifically, we use some math functions, from the header file cmath, and
the string function length, from the header file string. Note that the function
length determines the length of a string.
EXAMPLE 3-4
//How to use predefined functions.
//This program uses the math functions pow and sqrt to determine
//and output the volume of a sphere, the distance between two
//points, respectively, and the string function length to find
//the number of characters in a string.
//If the radius of the sphere is r, then the volume of the sphere
//is (4/3)*PI*r^3. If (x1,y1) and (x2,y2) are the coordinates of two
//points in the X-Y plane, then the distance between these points is
//sqrt((x2-x1)^2 + (y2-y1)^2).
#include <iostream>
#include <cmath>
#include <string>
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

132 |

Chapter 3: Input/Output

using namespace std;
const double PI = 3.1416;
int main()
{

double
double
double
double
double

sphereRadius;
sphereVolume;
point1X, point1Y;
point2X, point2Y;
distance;

//Line
//Line
//Line
//Line
//Line

1
2
3
4
5

string str;

//Line 6

cout << "Line 7: Enter the radius of the sphere: ";
cin >> sphereRadius;
cout << endl;

//Line 7
//Line 8
//Line 9

sphereVolume = (4.0 / 3) * PI * pow(sphereRadius, 3);

//Line 10

cout << "Line 11: The volume of the sphere is: "
<< sphereVolume << endl << endl;

//Line 11

cout << "Line 12: Enter the coordinates of two "
<< "points in the X-Y plane: ";
cin >> point1X >> point1Y >> point2X >> point2Y;
cout << endl;

//Line 12
//Line 13
//Line 14

distance = sqrt(pow(point2X - point1X, 2)
+ pow(point2Y - point1Y, 2));

//Line 15

cout <<
<<
<<
<<

//Line 16

"Line 16: The distance between the points "
"(" << point1X << ", " << point1Y << ") and "
"(" << point2X << ", " << point2Y << ") is: "
distance << endl << endl;

str = "Programming with C++";

//Line 17

cout << "Line 18: The number of characters, "
<< "including blanks, in \"" << str << "\" is: "
<< str.length() << endl;

//Line 18

return 0;

//Line 19

}

Sample Run: In this sample run, the user input is shaded.
Line 7: Enter the radius of the sphere: 3
Line 11: The volume of the sphere is: 113.098
Line 12: Enter the coordinates of two points in the X-Y plane: 4 7 9 -5
Line 16: The distance between the points (4, 7) and (9, -5) is: 13
Line 18: The number of characters, including blanks, in "Programming
with C++" is: 20

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Using Predefined Functions in a Program |

133

The preceding program works as follows. The statements in Lines 1 to 6 declare the
variables used in the program. The statement in Line 7 prompts the user to enter the
radius of the sphere, and the statement in Line 8 stores the radius in the variable
sphereRadius. The statement in Line 10 uses the function pow to compute and store
the volume of the sphere in the variable sphereVolume. The statement in Line 11
outputs the volume. The statement in Line 12 prompts the user to enter the coordinates
of two points in the X-Y plane, and the statement in Line 13 stores the coordinates in the
variables point1X, point1Y, point2X, and point2Y, respectively. The statement in
Line 15 uses the functions sqrt and pow to determine the distance between the points.
The statement in Line 16 outputs the distance between the points. The statement in Line
17 stores the string "Programming with C++" in str. The statement in Line 18 uses the
string function length to determine and output the length of str. Note how the
function length is used. Later in this chapter we will explain the meaning of expressions
such as str.length().

Because I/O is fundamental to any programming language and because writing instructions to perform a specific I/O operation is not a job for everyone, every programming
language provides a set of useful functions to perform specific I/O operations. In the
remainder of this chapter, you will learn how to use some of these functions in a
program. As a programmer, you must pay close attention to how these functions are
used so that you can get the most out of them. The first function you will learn about
here is the function get.

cin and the get Function
As you have seen, the extraction operator skips all leading whitespace characters when
scanning for the next input value. Consider the variable declarations:
char ch1, ch2;
int num;

and the input:
A 25

Now consider the following statement:
cin >> ch1 >> ch2 >> num;

When the computer executes this statement, 'A' is stored in ch1, the blank is skipped by
the extraction operator >>, the character '2' is stored in ch2, and 5 is stored in num.
However, what if you intended to store 'A' in ch1, the blank in ch2, and 25 in num? It is
clear that you cannot use the extraction operator >> to input this data.
As stated earlier, sometimes you need to process the entire input, including whitespace
characters, such as blanks and the newline character. For example, suppose you want to

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

134 |

Chapter 3: Input/Output

process the entered data on a line-by-line basis. Because the extraction operator >> skips
the newline character and unless the program captures the newline character, the
computer does not know where one line ends and the next begins.
The variable cin can access the stream function get, which is used to read character
data. The get function inputs the very next character, including whitespace characters,
from the input stream and stores it in the memory location indicated by its argument.
The function get comes in many forms. Next, we discuss the one that is used to read a
character.
The syntax of cin, together with the get function to read a character, follows:
cin.get(varChar);

In the cin.get statement, varChar is a char variable. varChar, which appears in
parentheses following the function name, is called the argument or parameter of the
function. The effect of the preceding statement would be to store the next input character
in the variable varChar.
Now consider the following input again:
A 25

To store 'A' in ch1, the blank in ch2, and 25 in num, you can effectively use the get
function as follows:
cin.get(ch1);
cin.get(ch2);
cin >> num;

Because this form of the get function has only one argument and reads only one
character and you need to read two characters from the input stream, you need to call
this function twice. Notice that you cannot use the get function to read data into the
variable num because num is an int variable. The preceding form of the get function
reads values of only the char data type.
The preceding set of cin.get statements is equivalent to the following
statements:
cin >> ch1;
cin.get(ch2);
cin >> num;

The function get has other forms, one of which you will study in Chapter 8.
For the next few chapters, you need only the form of the function get introduced
here.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Using Predefined Functions in a Program |

135

cin and the ignore Function
When you want to process only partial data (say, within a line), you can use the stream
function ignore to discard a portion of the input. The syntax to use the function ignore is:
cin.ignore(intExp, chExp);

Here, intExp is an integer expression yielding an integer value, and chExp is a char
expression yielding a char value. In fact, the value of the expression intExp specifies the
maximum number of characters to be ignored in a line.
Suppose intExp yields a value of, say 100. This statement says to ignore the next 100
characters or ignore the input until it encounters the character specified by chExp,
whichever comes first. To be specific, consider the following statement:
cin.ignore(100, '\n');

When this statement executes, it ignores either the next 100 characters or all characters
until the newline character is found, whichever comes first. For example, if the next 120
characters do not contain the newline character, then only the first 100 characters are
discarded and the next input data is the character 101. However, if the 75th character is
the newline character, then the first 75 characters are discarded and the next input data is
the 76th character. Similarly, the execution of the statement:
cin.ignore(100, 'A');

results in ignoring the first 100 characters or all characters until the character 'A' is
found, whichever comes first.
EXAMPLE 3-5
Consider the declaration:
int a, b;

and the input:
25 67 89 43 72
12 78 34

Now consider the following statements:
cin >> a;
cin.ignore(100, '\n');
cin >> b;

The first statement, cin >> a;, stores 25 in a. The second statement,
cin.ignore(100, '\n');, discards all of the remaining numbers in the first line. The
third statement, cin >> b;, stores 12 (from the next line) in b.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

136 |

Chapter 3: Input/Output

EXAMPLE 3-6
Consider the declaration:
char ch1, ch2;

and the input:
Hello there. My name is Mickey.

a.

Consider the following statements:
cin >> ch1;
cin.ignore(100, '.');
cin >> ch2;

The first statement, cin >> ch1;, stores 'H' in ch1. The second statement,
cin.ignore(100, '.');, results in discarding all characters until . (period).
The third statement, cin >> ch2;, stores the character 'M' (from the same line)
in ch2. (Remember that the extraction operator >> skips all leading whitespace
characters. Thus, the extraction operator skips the space after . [period] and
stores 'M' in ch2.)
b. Suppose that we have the following statement:
cin >> ch1;
cin.ignore(5, '.');
cin >> ch2;

The first statement, cin >> ch1;, stores 'H' in ch1. The second statement,
cin.ignore(5, '.');, results in discarding the next five characters, that is, until t.
The third statement, cin >> ch2;, stores the character 't' (from the same line) in ch2.
When the function ignore is used without any arguments, then it only skips the very
next character. For example, the following statement will skip the very next character:
cin.ignore();

This statement is typically used to skip the newline character.

The putback and peek Functions
Suppose you are processing data that is a mixture of numbers and characters. Moreover, the
numbers must be read and processed as numbers. You have also looked at many sets of
sample data and cannot determine whether the next input is a character or a number. You
could read the entire data set character by character and check whether a certain character is
a digit. If a digit is found, you could then read the remaining digits of the number and
somehow convert these characters into numbers. This programming code would be
somewhat complex. Fortunately, C++ provides two very useful stream functions that
can be used effectively in these types of situations.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Using Predefined Functions in a Program |

137

The stream function putback lets you put the last character extracted from the input
stream by the get function back into the input stream. The stream function peek looks
into the input stream and tells you what the next character is without removing it from
the input stream. By using these functions, after determining that the next input is a
number, you can read it as a number. You do not have to read the digits of the number as
characters and then convert these characters to that number.

3

The syntax to use the function putback is:
istreamVar.putback(ch);

Here, istreamVar is an input stream variable, such as cin, and ch is a char variable.
The peek function returns the next character from the input stream but does not remove the
character from that stream. In other words, the function peek looks into the input stream
and checks the identity of the next input character. Moreover, after checking the next input
character in the input stream, it can store this character in a designated memory location
without removing it from the input stream. That is, when you use the peek function, the
next input character stays the same, even though you now know what it is.
The syntax to use the function peek is:
ch = istreamVar.peek();

Here, istreamVar is an input stream variable, such as cin, and ch is a char variable.
Notice how the function peek is used. First, the function peek is used in an assignment
statement. It is not a stand-alone statement like get, ignore, and putback. Second, the
function peek has empty parentheses. Until you become comfortable with using a function
and learn how to write one, pay close attention to how to use a predefined function.
The following example illustrates how to use the peek and putback functions.
EXAMPLE 3-7
//Functions peek and putback
#include <iostream>
using namespace std;
int main()
{
char ch;
cout << "Line 1: Enter a string: ";
cin.get(ch);
cout << endl;

//Line 1
//Line 2
//Line 3

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

138 |

Chapter 3: Input/Output

cout << "Line 4: After first cin.get(ch); "
<< "ch = " << ch << endl;
cin.get(ch);
cout << "Line 6: After second cin.get(ch); "
<< "ch = " << ch << endl;
cin.putback(ch);
cin.get(ch);
cout << "Line 9: After putback and then "
<< "cin.get(ch); ch = " << ch << endl;

//Line 4
//Line 5
//Line 6
//Line 7
//Line 8
//Line 9

ch = cin.peek();
cout << "Line 11: After cin.peek(); ch = "
<< ch << endl;

//Line 10

cin.get(ch);
cout << "Line 13: After cin.get(ch); ch = "
<< ch << endl;

//Line 12

//Line 11

//Line 13

return 0;
}

Sample Run: In this sample run, the user input is shaded.
Line 1: Enter a string: abcd
Line
Line
Line
Line
Line

4: After first cin.get(ch); ch = a
6: After second cin.get(ch); ch = b
9: After putback and then cin.get(ch); ch = b
11: After cin.peek(); ch = c
13: After cin.get(ch); ch = c

The user input, abcd, allows you to see the effect of the functions get, putback, and
peek in the preceding program. The statement in Line 1 prompts the user to enter a string.
In Line 2, the statement cin.get(ch); extracts the first character from the input stream
and stores it in the variable ch. So after Line 2 executes, the value of ch is 'a'.
The cout statement in Line 4 outputs the value of ch. The statement cin.get(ch); in
Line 5 extracts the next character from the input stream, which is 'b', and stores it in ch.
At this point, the value of ch is 'b'.
The cout statement in Line 6 outputs the value of ch. The cin.putback(ch); statement
in Line 7 puts the previous character extracted by the get function, which is 'b', back into
the input stream. Therefore, the next character to be extracted from the input stream is 'b'.
The cin.get(ch); statement in Line 8 extracts the next character from the input
stream, which is still 'b', and stores it in ch. Now the value of ch is 'b'. The cout
statement in Line 9 outputs the value of ch as 'b'.
In Line 10, the statement ch = cin.peek(); checks the next character in the input stream,
which is 'c', and stores it in ch. The value of ch is now 'c'. The cout statement in Line

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Using Predefined Functions in a Program |

139

11 outputs the value of ch. The cin.get(ch); statement in Line 12 extracts the next
character from the input stream and stores it in ch. The cout statement in Line 13 outputs
the value of ch, which is still 'c'.
Note that the statement ch = cin.peek(); in Line 10 did not remove the character 'c'
from the input stream; it only peeked into the input stream. The output of Lines 11 and
13 demonstrates this functionality.

The Dot Notation between I/O Stream Variables and I/O Functions:
A Precaution
In the preceding sections, you learned how to manipulate an input stream to get data
into a program. You also learned how to use the functions get, ignore, peek, and
putback. It is important that you use these functions exactly as shown. For example, to
use the get function, you used statements such as the following:
cin.get(ch);

Omitting the dot—that is, the period between the variable cin and the function name
get—results in a syntax error. For example, in the statement:
cin.get(ch);
cin and get are two separate identifiers separated by a dot. In the statement:
cinget(ch);
cinget becomes a new identifier. If you used cinget(ch); in a program, the compiler

would try to resolve an undeclared identifier, which would generate an error. Similarly,
missing parentheses, as in cin.getch;, result in a syntax error. Also, remember that you
must use the input functions together with an input stream variable. If you try to use any
of the input functions alone—that is, without the input stream variable—the compiler
might generate an error message such as ‘‘undeclared identifier.’’ For example, the
statement get(ch); could result in a syntax error.
As you can see, several functions are associated with an istream variable, each doing a
specific job. Recall that the functions get, ignore, and so on are members of the data type
istream. Called the dot notation, the dot separates the input stream variable name
from the member, or function, name. In fact, in C++, the dot is an operator called the
member access operator.
C++ has a special name for the data types istream and ostream. The data types
istream and ostream are called classes. The variables cin and cout also have special
names, called objects. Therefore, cin is called an istream object, and cout is called an
ostream object. In fact, stream variables are called stream objects. You will learn these
concepts in Chapter 11 later in this book.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

140 |

Chapter 3: Input/Output

Input Failure
Many things can go wrong during program execution. A program that is syntactically
correct might produce incorrect results. For example, suppose that a part-time employee’s
paycheck is calculated by using the following formula:
wages = payRate * hoursWorked;

If you accidentally type + in place of *, the calculated wages would be incorrect, even
though the statement containing a + is syntactically correct.
What about an attempt to read invalid data? For example, what would happen if you tried
to input a letter into an int variable? If the input data did not match the corresponding
variables, the program would run into problems. For example, trying to read a letter into
an int or double variable would result in an input failure. Consider the following
statements:
int a, b, c;
double x;

If the input is:
W 54

then the statement:
cin >> a >> b;

would result in an input failure, because you are trying to input the character 'W' into
the int variable a. If the input were:
35 67.93 48

then the input statement:
cin >> a >> x > >b;

would result in storing 35 in a, 67.93 in x, and 48 in b.
Now consider the following read statement with the previous input (the input with three
values):
cin >> a >> b >> c;

This statement stores 35 in a and 67 in b. The reading stops at . (the decimal point).
Because the next variable c is of the data type int, the computer tries to read . into c,
which is an error. The input stream then enters a state called the fail state.
What actually happens when the input stream enters the fail state? Once an input stream
enters the fail state, all further I/O statements using that stream are ignored. Unfortunately, the program quietly continues to execute with whatever values are stored in
variables and produces incorrect results. The program in Example 3-8 illustrates an input
failure. This program on your system may produce different results.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Input Failure |

141

EXAMPLE 3-8
//Input Failure program
#include <iostream>
#include <string>
using namespace std;

3

int main()
{
string name;
int age = 0;
int weight = 0;
double height = 0.0;

//Line
//Line
//Line
//Line

cout << "Line 5: Enter name, age, weight, and "
<< "height: ";
cin >> name >> age >> weight >> height;
cout << endl;

//Line 5
//Line 6
//Line 7

cout
cout
cout
cout

//Line
//Line
//Line
//Line

<<
<<
<<
<<

"Line
"Line
"Line
"Line

8: Name: " << name << endl;
9: Age: " << age << endl;
10: Weight: " << weight << endl;
11: Height: " << height << endl;

return 0;

1
2
3
4

8
9
10
11

//Line 12

}

Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1
Line 5: Enter name, age, weight, and height: Sam 35 q56 6.2
Line
Line
Line
Line

8: Name: Sam
9: Age: 35
10: Weight: 0
11: Height: 0

The statements in Lines 1, 2, 3, and 4 declare the variables name, age, weight, and
height, and also initialize the variable age, weight, and height. The statement in Line 5
prompts the user to enter a person’s name, age, weight, and height; the statement in Line 6
inputs these values into variables name, age, weight, and height, respectively.
In this sample run, the third input is q56 and the cin statement tries to input this into the
variable weight. However, the input q56 begins with the character 'q' and weight is a
variable of type int, so cin enters the fail state. Note that the printed values of the
variables weight and height are unchanged, as shown by the output of the statements in
Lines 10 and 11.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

142 |

Chapter 3: Input/Output

Sample Run 2
Line 5: Enter name, age, weight, and height: Sam 35.0 156 6.2
Line
Line
Line
Line

8: Name: Sam
9: Age: 35
10: Weight: 0
11: Height: 0

In this sample run, after inputting Sam into name and 35 into age, the reading stops at the
decimal point for the cin statement in Line 6. Next the cin statement tries to input the
decimal point into weight, which is an int variable. So the input stream enters the fail
state and the values of weight and height are unchanged, as shown by the output of the
statements in Lines 10 and 11.

The clear Function
When an input stream enters the fail state, the system ignores all further I/O using that
stream. You can use the stream function clear to restore the input stream to a working
state.
The syntax to use the function clear is:
istreamVar.clear();

Here, istreamVar is an input stream variable, such as cin.
After using the function clear to return the input stream to a working state, you still
need to clear the rest of the garbage from the input stream. This can be accomplished by
using the function ignore. Example 3-9 illustrates this situation.
EXAMPLE 3-9
//Input failure and the clear function
#include <iostream>
#include <string>
using namespace std;
int main()
{
string name;
int age = 0;
int weight = 0;
double height = 0.0;

//Line
//Line
//Line
//Line

1
2
3
4

cout << "Line 5: Enter name, age, weight, and "
<< "height: ";

//Line 5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Input Failure |

cin >> name >> age >> weight >> height;
cout << endl;

//Line 6
//Line 7

cout
cout
cout
cout

//Line
//Line
//Line
//Line

<<
<<
<<
<<

"Line
"Line
"Line
"Line

8: Name: " << name << endl;
9: Age: " << age << endl;
10: Weight: " << weight << endl;
11: Height: " << height << endl;

8
9
10
11

//Restore input stream; Line 12

cin.clear();
cin.ignore(200,'\n');

//Clear the buffer; Line 13

cout << "\nLine 14: Enter name, age, weight, "
<< "and height: ";
cin >> name >> age >> weight >> height;
cout << endl;

//Line 14
//Line 15
//Line 16

cout
cout
cout
cout

//Line
//Line
//Line
//Line

<<
<<
<<
<<

"Line
"Line
"Line
"Line

143

17:
18:
19:
20:

Name: " << name << endl;
Age: " << age << endl;
Weight: " << weight << endl;
Height: " << height << endl;

return 0;

17
18
19
20

//Line 21

}

Sample Run: In this sample run, the user input is shaded.
Line 5: Enter name, age, weight, and height: Sam 35 q56 6.2
Line
Line
Line
Line

8: Name: Sam
9: Age: 35
10: Weight: 0
11: Height: 0

Line 14: Enter name, age, weight, and height: Sam 35 156 6.2
Line
Line
Line
Line

17:
18:
19:
20:

Name: Sam
Age: 35
Weight: 156
Height: 6.2

The statements in Lines 1, 2, 3, and 4 declare the variables name, age, weight, and
height, and also initialize the variable age, weight, and height. The statement in Line 5
prompts the user to enter a person’s name, age, weight, and height; the statement in Line 6
inputs these values into variables name, age, weight, and height, respectively.
As in Example 3-8, when the cin statement tries to input q56 into weight, it enters the
fail statement. The statement in Line 12 restores the input stream by using the function
clear, and the statement in Line 13 ignores the rest of the input. The statement in Line 14
again prompts the user to input a person’s name, age, weight, and height; the statement in
Line 15 stores these values in name, age, weight, and height, respectively. Next, the
statements in Lines 17 to 20 output the values of name, age, weight, and height.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

144 |

Chapter 3: Input/Output

Output and Formatting Output
Other than writing efficient programs, generating the desired output is one of a programmer’s highest priorities. Chapter 2 briefly introduced the process involved in
generating output on the standard output device. More precisely, you learned how to
use the insertion operator << and the manipulator endl to display results on the standard
output device.
However, there is a lot more to output than just displaying results. Sometimes, floatingpoint numbers must be output in a specific way. For example, a paycheck must be
printed to two decimal places, whereas the results of a scientific experiment might
require the output of floating-point numbers to six, seven, or perhaps even ten decimal
places. Also, you might like to align the numbers in specific columns or fill the empty
space between strings and numbers with a character other than the blank. For example,
in preparing the table of contents, the space between the section heading and the page
number might need to be filled with dots or dashes. In this section, you will learn about
various output functions and manipulators that allow you to format your output in a
desired way.
Recall that the syntax of cout when used together with the insertion operator
<< is:
cout << expression or manipulator << expression or manipulator...;

Here, expression is evaluated, its value is printed, and manipulator is used to format
the output. The simplest manipulator that you have used so far is endl, which is used to
move the insertion point to the beginning of the next line.
Other output manipulators that are of interest include setprecision, fixed, showpoint,
and setw. The next few sections describe these manipulators.

setprecision Manipulator
You use the manipulator setprecision to control the output of floating-point numbers. Usually, the default output of floating-point numbers is scientific notation. Some
integrated development environments (IDEs) might use a maximum of six decimal
places for the default output of floating-point numbers. However, when an employee’s
paycheck is printed, the desired output is a maximum of two decimal places. To print
floating-point output to two decimal places, you use the setprecision manipulator to
set the precision to 2.
The general syntax of the setprecision manipulator is:
setprecision(n)

where n is the number of decimal places.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Output and Formatting Output

|

145

You use the setprecision manipulator with cout and the insertion operator. For
example, the statement:
cout << setprecision(2);

formats the output of decimal numbers to two decimal places until a similar subsequent
statement changes the precision. Notice that the number of decimal places, or the
precision value, is passed as an argument to setprecision.
To use the manipulator setprecision, the program must include the header file
iomanip. Thus, the following include statement is required:
#include <iomanip>

fixed Manipulator
To further control the output of floating-point numbers, you can use other manipulators.
To output floating-point numbers in a fixed decimal format, you use the manipulator
fixed. The following statement sets the output of floating-point numbers in a fixed
decimal format on the standard output device:
cout << fixed;

After the preceding statement executes, all floating-point numbers are displayed in the fixed
decimal format until the manipulator fixed is disabled. You can disable the manipulator
fixed by using the stream member function unsetf. For example, to disable the manipulator fixed on the standard output device, you use the following statement:
cout.unsetf(ios::fixed);

After the manipulator fixed is disabled, the output of the floating-point numbers returns
to their default settings. The manipulator scientific is used to output floating-point
numbers in scientific format.
On some compilers, the statements cout << fixed; and cout << scientific;
might not work. In this case, you can use cout.setf(ios::fixed); in place of
cout << fixed; and cout.setf(ios::scientific); in place of
cout << scientific;.

The following example shows how the manipulators scientific and fixed work
without using the manipulator setprecision.
EXAMPLE 3-10
//Example: scientific and fixed
#include <iostream>
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

146 |

Chapter 3: Input/Output

int main()
{
double hours = 35.45;
double rate = 15.00;
double tolerance = 0.01000;
cout << "hours = " << hours << ", rate = " << rate
<< ", pay = " << hours * rate
<< ", tolerance = " << tolerance << endl << endl;
cout << scientific;
cout << "Scientific notation: " << endl;
cout << "hours = " << hours << ", rate = " << rate
<< ", pay = " << hours * rate
<< ", tolerance = " << tolerance << endl << endl;
cout << fixed;
cout << "Fixed decimal notation: " << endl;
cout << "hours = " << hours << ", rate = " << rate
<< ", pay = " << hours * rate
<< ", tolerance = " << tolerance << endl << endl;
return 0;
}

Sample Run:
hours = 35.45, rate = 15, pay = 531.75, tolerance = 0.01
Scientific notation:
hours = 3.545000e+001, rate = 1.500000e+001, pay = 5.317500e+002, tolerance = 1
.000000e-002
Fixed decimal notation:
hours = 35.450000, rate = 15.000000, pay = 531.750000, tolerance = 0.010000

The sample run shows that when the value of rate and tolerance are printed without setting
the scientific or fixed manipulators, the trailing zeros are not shown and, in the case of
rate, the decimal point is also not shown. After setting the manipulators, the values are printed
to six decimal places. In the next section, we describe the manipulator showpoint to force the
system to show the decimal point and trailing zeros. We will then give an example to show how
to use the manipulators setprecision, fixed, and showpoint to get the desired output.

showpoint Manipulator
Suppose that the decimal part of a decimal number is zero. In this case, when you instruct the
computer to output the decimal number in a fixed decimal format, the output may not show
the decimal point and the decimal part. To force the output to show the decimal point and

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Output and Formatting Output

|

147

trailing zeros, you use the manipulator showpoint. The following statement sets the output
of decimal numbers with a decimal point and trailing zeros on the standard input device:
cout << showpoint;

Of course, the following statement sets the output of a floating-point number in a fixed
decimal format with the decimal point and trailing zeros on the standard output device:

3

cout << fixed << showpoint;

The program in Example 3-11 illustrates how to use the manipulators setprecision,
fixed, and showpoint.

EXAMPLE 3-11
//Example: setprecision, fixed, showpoint
#include <iostream>
#include <iomanip>

//Line 1
//Line 2

using namespace std;

//Line 3

const double PI = 3.14159265;

//Line 4

int main()
{
double radius = 12.67;
double height = 12.00;

//Line
//Line
//Line
//Line

cout << fixed << showpoint;
cout <<
<<
cout <<
cout <<
cout <<
<<
cout <<

setprecision(2)
"Line 10: setprecision(2)" << endl;
"Line 11: radius = " << radius << endl;
"Line 12: height = " << height << endl;
"Line 13: volume = "
PI * radius * radius * height << endl;
"Line 14: PI = " << PI << endl << endl;

cout <<
<<
cout <<
cout <<
cout <<
<<
cout <<

setprecision(3)
"Line 15: setprecision(3)" << endl;
"Line 16: radius = " << radius << endl;
"Line 17: height = " << height << endl;
"Line 18: volume = "
PI * radius * radius * height << endl;
"Line 19: PI = " << PI << endl << endl;

cout <<
<<
cout <<
cout <<

setprecision(4)
"Line 20: setprecision(4)" << endl;
"Line 21: radius = " << radius << endl;
"Line 22: height = " << height << endl;

5
6
7
8

//Line 9
//Line 10
//Line 11
//Line 12
//Line 13
//Line 14
//Line 15
//Line 16
//Line 17
//Line 18
//Line 19
//Line 20
//Line 21
//Line 22

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

148 |

Chapter 3: Input/Output

cout << "Line 23: volume = "
<< PI * radius * radius * height << endl;
cout << "Line 24: PI = " << PI << endl << endl;

//Line 23
//Line 24

cout <<
<<
<<
<<

//Line 25

"Line 25: "
setprecision(3) << radius << ", "
setprecision(2) << height << ", "
setprecision(5) << PI << endl;

return 0;
}

//Line 26
//Line 27

Sample Run:
Line
Line
Line
Line
Line

10:
11:
12:
13:
14:

setprecision(2)
radius = 12.67
height = 12.00
volume = 6051.80
PI = 3.14

Line
Line
Line
Line
Line

15:
16:
17:
18:
19:

setprecision(3)
radius = 12.670
height = 12.000
volume = 6051.797
PI = 3.142

Line
Line
Line
Line
Line

20:
21:
22:
23:
24:

setprecision(4)
radius = 12.6700
height = 12.0000
volume = 6051.7969
PI = 3.1416

Line 25: 12.670, 12.00, 3.14159

In this program, the statement in Line 2 includes the header file iomanip, and the
statement in Line 4 declares the named constant PI and sets the value to eight decimal
places. The statements in Lines 7 and 8 declare and initialize the variables radius and
height to store the radius of the base and the height of a cylinder. The statement in Line
10 sets the output of floating-point numbers in a fixed decimal format with a decimal
point and trailing zeros.
The statements in Lines 11, 12, 13, and 14 output the values of radius, height,
volume, and PI to two decimal places.
The statements in Lines 16, 17, 18, and 19 output the values of radius, height,
volume, and PI to three decimal places.

The statements in Lines 21, 22, 23, and 24 output the values of radius, height,
volume, and PI to four decimal places.

The statement in Line 25 outputs the value of radius to three decimal places, the value
of height to two decimal places, and the value of PI to five decimal places.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Output and Formatting Output

|

149

Notice how the values of radius are printed in Lines 11, 16, and 21. The value of
radius printed in Line 16 contains a trailing 0. This is because the stored value of
radius has only two decimal places; a 0 is printed at the third decimal place. In a similar
manner, the value of height is printed in Lines 12, 17, and 22.
Also, notice how the statements in Lines 13, 18, and 23 calculate and output volume to
two, three, and four decimal places.
Note that the value of PI printed in Line 24 is rounded.
The statement in Line 25 first sets the output of floating-point numbers to three decimal
places and then outputs the value of radius to three decimal places. After printing the
value of radius, the statement in Line 25 sets the output of floating-point numbers to
two decimal places and then outputs the value of height to two decimal places. Next, it
sets the output of floating-point numbers to five decimal places and then outputs the
value of PI to five decimal places.
If you omit the statement in Line 9 and recompile and run the program, you will see the
default output of the decimal numbers. More specifically, the value of the expression that
calculates the volume might be printed in the scientific notation.

setw
The manipulator setw is used to output the value of an expression in a specific number of
columns. The value of the expression can be either a string or a number. The expression
setw(n) outputs the value of the next expression in n columns. The output is rightjustified. Thus, if you specify the number of columns to be 8, for example, and the output
requires only four columns, the first four columns are left blank. Furthermore, if the
number of columns specified is less than the number of columns required by the output,
the output automatically expands to the required number of columns; the output is not
truncated. For example, if x is an int variable, the following statement outputs the value
of x in five columns on the standard output device:
cout << setw(5) << x << endl;

To use the manipulator setw, the program must include the header file iomanip. Thus,
the following include statement is required:
#include <iomanip>

Unlike setprecision, which controls the output of all floating-point numbers until it is
reset, setw controls the output of only the next expression.
EXAMPLE 3-12
//Example: This example illustrates how the function
//setw works
#include <iostream>
#include <iomanip>

//Line 1
//Line 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

150 |

Chapter 3: Input/Output

using namespace std;

//Line 3

int main()
{
int miles = 245;
int speed = 55;
double hours = 35.45;
double error = 3.7564;

//Line
//Line
//Line
//Line
//Line
//Line

4
5
6
7
8
9

cout << fixed << showpoint;
cout << "123456789012345678901234567890" << endl;

//Line 10
//Line 11

cout << setw(5) << miles << endl;

//Line 12

cout << setprecision(2);

//Line 13

cout << setw(5) << miles << setw(5) << speed
<< setw(6) << hours
<< setw(7) << error << endl << endl;

//Line 14

cout << setw(5) << speed << setw(5) << miles
<< setw(4) << hours
<< setw(7) << error << endl << endl;

//Line 15

cout << setw(2) << miles << setw(6) << hours
<< setw(7) << error << endl << endl;

//Line 16

cout << setw(2) << miles
<< setw(7) << "error"
<< error << endl;

//Line 17

return 0;

//Line 18
//Line 19

}

Sample Run:
123456789012345678901234567890
245
245
55 35.45
3.76
55

24535.45

245 35.45
245

3.76

3.76

error3.76

The statements in Lines 6, 7, 8, and 9 declare the variables miles, speed, hours, and
error, and initialize these variables to 245, 55, 35.45, and 3.7564, respectively. The
statement in Line 10 sets the output of floating-point numbers in a fixed decimal format
with a decimal point and trailing zeros. The output of the statement in Line 11 shows the
column positions when the specific values are printed; it is the first line of output.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Additional Output Formatting Tools

|

151

The statement in Line 12 outputs the value of miles in five columns. Because miles has
only three digits, only three columns are needed to output its value. Therefore, the first
two columns are left blank in the second line of output.
The statement in Line 13 sets the output of floating-point numbers to two decimal places.
The statement in Line 14 outputs the value of miles in the first five columns, the value of
speed in the next five columns, the value of hours in the next six columns, and the value of
error in the next seven columns. Because hours contains four digits and a decimal point,
five columns are required to output the value of hours. Also, because the setw function sets
the output of hours in six columns, the first column is left blank. Similarly, the value of
error is output in seven columns leaving the first three columns blank. The fourth line of
output is blank because the manipulator endl appears twice in the statement in Line 14.
The statement in Line 15 outputs the values of speed in the first five columns, miles in
the next five columns, the value of hours in the next four columns, and error in the
following seven columns, creating the fifth line of output. Note that to output the value
of hours at least five columns are required, but the program only specifies four columns,
so the output of hours is expanded to the required number of columns. Also note that
after printing the value of miles, the value of hours is printed at the current cursor
position (see the fifth line of output).
The statement in Line 16 sets the output of miles in two columns. However, the value
of miles contains three digits, so the value of miles is expanded to the right number of
columns. After printing the value of miles, the value of hours is printed in the next six
columns followed by the value of error in the next seven columns.
The statement in Line 17 sets the output of miles in two columns. However, the value
of miles contains three digits, so the value of miles is expanded to the right number of
columns. After printing the value of miles, the value of the string "error" is printed in
the next seven columns followed by the value of error. Because to output the value of
error the number of columns is not specified, after printing the string "error" the value
of error is printed (see the last line of the output).

Additional Output Formatting Tools
In the previous section, you learned how to use the manipulators setprecision, fixed, and
showpoint to control the output of floating-point numbers and how to use the manipulator
setw to display the output in specific columns. Even though these manipulators are adequate
to produce an elegant report, in some situations, you may want to do more. In this section, you
will learn additional formatting tools that give you more control over your output.

setfill Manipulator
Recall that in the manipulator setw, if the number of columns specified exceeds the number
of columns required by the expression, the output of the expression is right-justified and the

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

152 |

Chapter 3: Input/Output

unused columns to the left are filled with spaces. The output stream variables can use the
manipulator setfill to fill the unused columns with a character other than a space.
The syntax to use the manipulator setfill is:
ostreamVar << setfill(ch);

where ostreamVar is an output stream variable and ch is a character. For example, the
statement:
cout << setfill('#');

sets the fill character to '#' on the standard output device.
To use the manipulator setfill, the program must include the header file iomanip.
The program in Example 3-13 illustrates the effect of using setfill in a program.
EXAMPLE 3-13
//Example: This program illustrates how the function
//setfill works.
#include <iostream>
#include <string>
#include <iomanip>

//Line 1
//Line 2
//Line 3

using namespace std;

//Line 4

int main()
{
string name = "Jessica";
double gpa = 3.75;
int scholarship = 7850;

//Line
//Line
//Line
//Line
//Line

5
6
7
8
9

cout << "123456789012345678901234567890" << endl;
cout << fixed << showpoint << setprecision(2);

//Line 10
//Line 11

cout << setw(10) << name << setw(7) << gpa
<< setw(8) << scholarship << endl;

//Line 12
//Line 13

cout << setfill('*');
cout << setw(10) << name << setw(7) << gpa
<< setw(8) << scholarship << endl;

//Line 14

cout << setw(10) << name << setfill('#')
<< setw(7) << gpa
<< setw(8) << scholarship << endl;

//Line 15

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Additional Output Formatting Tools

cout <<
<<
<<
<<

setw(10) << setfill('@') << name
setw(7) << setfill('#') << gpa
setw(8) << setfill('^') << scholarship
endl;

cout << setfill(' ');
cout << setw(10) << name << setw(7) << gpa
<< setw(8) << scholarship << endl;
return 0;
}

|

153

//Line 16
//Line 17
//Line 18
//Line 19
//Line 20

Sample Run:
123456789012345678901234567890
Jessica
3.75
7850
***Jessica***3.75****7850
***Jessica###3.75####7850
@@@Jessica###3.75^^^^7850
Jessica
3.75
7850

The statements in Lines 7, 8, and 9 declare and initialize the variables name, gpa, and
scholarship to "Jessica", 3.75, and 7850, respectively. The output of the statement
in Line 10—the first line of output—shows the column position when the subsequent
statements output the values of the variables. The statement in Line 11, sets the output of
decimal numbers in a fixed decimal format with a decimal point with two decimal places.
The statement in Line 12 outputs the value of name in ten columns, the value of gpa in
seven columns, and the value of scholarship in eight columns. In this statement, the
filling character is the blank character, as shown in the second line of output.
The statement in Line 13 sets the filling character to *. The statement in Line 14 outputs
the value of name in ten columns, the value of gpa in seven columns, and the value of
scholarship in eight columns. Because "Jessica" is a string of length 7 and ten
columns are assigned to output its value, the first three columns are unused and are,
therefore, filled by the filling character *. Similarly, the columns unused by the values of
gpa and scholarship are filled by *.
The output of the statement in Line 15—the fourth line of output—is similar to the
output of the statement in Line 14, except that the filling character for gpa and
scholarship is #. In the output of the statement in Line 16 (the fifth line of output),
the filling character for name is @, the filling character for gpa is #, and the filling
character for scholarship is ^. The manipulator setfill sets these filling characters.
The statement in Line 17 sets the filling character to blank. The statement in Line 18
outputs the values of name, gpa, and scholarship using the filling character blank, as
shown in the sixth line of output.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

154 |

Chapter 3: Input/Output

left and right Manipulators
Recall that if the number of columns specified in the setw manipulator exceeds the
number of columns required by the next expression, the default output is right-justified.
Sometimes, you might want the output to be left-justified. To left-justify the output, you
use the manipulator left.
The syntax to set the manipulator left is:
ostreamVar << left;

where ostreamVar is an output stream variable. For example, the following statement
sets the output to be left-justified on the standard output device:
cout << left;

You can disable the manipulator left by using the stream function unsetf. The syntax
to disable the manipulator left is:
ostreamVar.unsetf(ios::left);

where ostreamVar is an output stream variable. Disabling the manipulator left returns
the output to the settings of the default output format. For example, the following
statement disables the manipulator left on the standard output device:
cout.unsetf(ios::left);

The syntax to set the manipulator right is:
ostreamVar << right;

where ostreamVar is an output stream variable. For example, the following statement
sets the output to be right-justified on the standard output device:
cout << right;
On some compilers, the statements cout << left; and cout << right; might not
work. In this case, you can use cout.setf(ios::left); in place of cout << left;
and cout.setf(ios::right); in place of cout << right;.

The program in Example 3-14 illustrates the effect of the manipulators left and right.
EXAMPLE 3-14
//Example: left justification
#include <iostream>
#include <string>
#include <iomanip>

//Line 1
//Line 2
//Line 3

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Additional Output Formatting Tools

|

using namespace std;

//Line 4

int main()
{
string name = "Jessica";
double gpa = 3.75;
int scholarship = 7850;

//Line
//Line
//Line
//Line
//Line

155

5
6
7
8
9

cout << "123456789012345678901234567890" << endl;
cout << fixed << showpoint << setprecision(2);

//Line 10
//Line 11

cout << left;

//Line 12

cout << setw(10) << name << setw(7) << gpa
<< setw(8) << scholarship << endl;

//Line 13
//Line 14

cout << setfill('*');
cout << setw(10) << name << setw(7) << gpa
<< setw(8) << scholarship << endl;

//Line 15

cout << setw(10) << name << setfill('#')
<< setw(7) << gpa
<< setw(8) << scholarship << endl;

//Line 16

cout <<
<<
<<
<<

//Line 17

setw(10) << setfill('@') << name
setw(7) << setfill('#') << gpa
setw(8) << setfill('^') << scholarship
endl;

cout << right;
cout << setfill(' ');
cout << setw(10) << name << setw(7) << gpa
<< setw(8) << scholarship << endl;
return 0;
}

//Line 18
//Line 19
//Line 20
//Line 21
//Line 22

Sample Run:
123456789012345678901234567890
Jessica
3.75
7850
Jessica***3.75***7850****
Jessica***3.75###7850####
Jessica@@@3.75###7850^^^^
Jessica
3.75
7850

The output of this program is the same as the output of Example 3-13. The only
difference here is that for the statements in Lines 13 through 17, the output is leftjustified. You are encouraged to do a walk-through of this program.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

156 |

Chapter 3: Input/Output

This chapter discusses several stream functions and stream manipulators. To use stream
functions such as get, ignore, fill, and clear in a program, the program must
include the header file iostream.
There are two types of manipulators: those with parameters and those without parameters.
Manipulators with parameters are called parameterized stream manipulators. For example,
manipulators such as setprecision, setw, and setfill are parameterized. On the
other hand, manipulators such as endl, fixed, scientific, showpoint, and
left do not have parameters.
To use a parameterized stream manipulator in a program, you must include the header file

iomanip. Manipulators without parameters are part of the iostream header file and,
therefore, do not require inclusion of the header file iomanip.

Input/Output and the string Type
You can use an input stream variable, such as cin, and the extraction operator >> to
read a string into a variable of the data type string. For example, if the input
is the string "Shelly", the following code stores this input into the string
variable name:
string name;
cin >> name;

//variable declaration
//input statement

Recall that the extraction operator skips any leading whitespace characters and that
reading stops at a whitespace character. As a consequence, you cannot use the extraction
operator to read strings that contain blanks. For example, suppose that the variable name
is defined as noted above. If the input is:
Alice Wonderland

then after the statement:
cin >> name;

executes, the value of the variable name is "Alice".
To read a string containing blanks, you can use the function getline.
The syntax to use the function getline is:
getline(istreamVar, strVar);

where istreamVar is an input stream variable and strVar is a string variable. The
reading is delimited by the newline character '\n'.
The function getline reads until it reaches the end of the current line. The newline
character is also read but not stored in the string variable.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Debugging: Understanding Logic Errors and Debugging with cout Statements |

157

Consider the following statement:
string myString;

If the input is 29 characters:
bbbbHello there. How are you?

where b represents a blank, after the statement:

3

getline(cin, myString);

the value of myString is:
myString =

"

Hello there. How are you?"

All 29 characters, including the first four blanks, are stored into myString.
Similarly, you can use an output stream variable, such as cout, and the insertion operator
<< to output the contents of a variable of the data type string.

Debugging: Understanding Logic Errors
and Debugging with cout Statements
In the debugging section of Chapter 2, we illustrated how to understand and correct syntax
errors. As we have seen, syntax errors are reported by the compiler, and the compiler not
only reports syntax errors, but also gives some explanation about the errors. On the other
hand, logic errors are typically not caught by the compiler except for the trivial ones such as
using a variable without properly initializing it. In this section, we illustrate how to spot and
correct logic errors using cout statements. Suppose that we want to write a program that
takes as input the temperature in Fahrenheit and outputs the equivalent temperature in
Celsius. The formula to convert the temperature is: Celsius ¼ 5 / 9 * (Fahrenheit – 32). So
consider the following program:
#include <iostream>

//Line 1

using namespace std;

//Line 2

int main()
{
int fahrenheit;
int celsius;

//Line
//Line
//Line
//Line

3
4
5
6

cout << "Enter temperature in Fahrenheit: ";
cin >> fahrenheit;
cout << endl;

//Line 7
//Line 8
//Line 9

celsius = 5 / 9 * (fahrenheit - 32);

//Line 10

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

158 |

Chapter 3: Input/Output

cout << fahrenheit << " degree F = "
<< celsius << " degree C. " << endl;
return 0;
}

//Line 11
//Line 12
//Line 13

Sample Run 1: In this sample run, the user input is shaded.
Enter temperature in Fahrenheit: 32
32 degree F = 0 degree C.

Sample Run 2: In this sample run, the user input is shaded.
Enter temperature in Fahrenheit: 110
110 degree F = 0 degree C.

The result shown in the first calculation looks correct. However, the result in the second
calculation is clearly not correct even though the same formula is used, because 110 degree
F ¼ 43 degree C. It means the value of celsius calculated in Line 10 is incorrect. Now,
the value of celsius is given by the expression 5 / 9 * (fahrenheit - 32). So we should
look at this expression closely. To see the effect of this expression, we can separately print
the values of the two expression 5 / 9 and fahrenheit - 32. This can be accomplished by
temporarily inserting an output statement as shown in the following program:
#include <iostream>

//Line 1

using namespace std;

//Line 2

int main()
{
int fahrenheit;
int celsius;

//Line
//Line
//Line
//Line

cout << "Enter temperature in Fahrenheit: ";
cin >> fahrenheit;
cout << endl;

//Line 7
//Line 8
//Line 9

cout << "5 / 9 = " << 5 / 9
<< "; fahrenheit - 32 = "
<< fahrenheit - 32 << endl;

//Line 9a

celsius = 5 / 9 * (fahrenheit - 32);

//Line 10

cout << fahrenheit << " degree F = "
<< celsius << " degree C. " << endl;

//Line 11

return 0;
}

3
4
5
6

//Line 12
//Line 13

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Debugging: Understanding Logic Errors and Debugging with cout Statements |

159

Sample Run: In this sample run, the user input is shaded.
Enter temperature in Fahrenheit: 110
5 / 9 = 0; fahrenheit - 32 = 78
110 degree F = 0 degree C.

Let us look at the sample run. We see that the value of 5 / 9 = 0 and the value
of fahrenheit - 32 = 78. Because fahrenheit = 110, the value of the expression
fahrenheit - 32 is correct. Now let us look at the expression 5 / 9. The value of
this expression is 0. Because both of the operands, 5 and 9, of the operator / are integers,
using integer division, the value of the expression is 0. That is, the value of the expression
5 / 9 = 0 is also calculated correctly. So by the precedence of the operators, the value of the
expression 5 / 9 * (fahrenheit - 32) will always be 0 regardless of the value
of fahrenheit. So the problem is in the integer division. We can replace the expression
5 / 9 with 5.0 / 9. In this case, the value of the expression 5.0 / 9 * (fahrenheit - 32)
will be a decimal number. Because fahrenheit and celsius are int variables, we
can use he cast operators to convert this value to an integer, that is, we use the following
expression:
celsius = static_cast<int> (5.0 / 9 * (fahrenheit - 32) + 0.5);

(Note that in the preceding expression, we added 0.5 to round the number to the nearest
integer.)
The revised program is:
#include <iostream>

//Line 1

using namespace std;

//Line 2

int main()
{
int fahrenheit;
int celsius;

//Line
//Line
//Line
//Line

cout << "Enter temperature in Fahrenheit: ";
cin >> fahrenheit;
cout << endl;

//Line 7
//Line 8
//Line 9

celsius = static_cast<int>
(5.0 / 9 * (fahrenheit - 32) + 0.5);

//Line 10

cout << fahrenheit << " degree F = "
<< celsius << " degree C. " << endl;

//Line 11

return 0;
}

3
4
5
6

//Line 12
//Line 13

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

160 |

Chapter 3: Input/Output

Sample Run: In this sample run, the user input is shaded.
Enter temperature in Fahrenheit: 110
110 degree F = 43 degree C.

As we can see, using temporary cout statements, we were able to find the problem. After
correcting the problem, the temporary cout statements are removed.
The temperature conversion program contained logic errors, not syntax errors. Using
cout statements to print the values of expressions and/or variables to see the results of a
calculation is an effective way to find and correct logic errors.

File Input/Output
The previous sections discussed in some detail how to get input from the keyboard (standard
input device) and send output to the screen (standard output device). However, getting input
from the keyboard and sending output to the screen have several limitations. Inputting data in a
program from the keyboard is comfortable as long as the amount of input is very small. Sending
output to the screen works well if the amount of data is small (no larger than the size of the
screen) and you do not want to distribute the output in a printed format to others.
If the amount of input data is large, however, it is inefficient to type it at the keyboard
each time you run a program. In addition to the inconvenience of typing large amounts
of data, typing can generate errors, and unintentional typos cause erroneous results. You
must have some way to get data into the program from other sources. By using alternative
sources of data, you can prepare the data before running a program, and the program can
access the data each time it runs.
Suppose you want to present the output of a program in a meeting. Distributing printed
copies of the program output is a better approach than showing the output on a screen.
For example, you might give a printed report to each member of a committee before an
important meeting. Furthermore, output must sometimes be saved so that the output
produced by one program can be used as an input to other programs.
This section discusses how to obtain data from other input devices, such as a disk (that is,
secondary storage), and how to save the output to a disk. C++ allows a program to get
data directly from and save output directly to secondary storage. A program can use the file
I/O and read data from or write data to a file. Formally, a file is defined as follows:
File: An area in secondary storage used to hold information.

The standard I/O header file, iostream, contains data types and variables that are used
only for input from the standard input device and output to the standard output device.
In addition, C++ provides a header file called fstream, which is used for file I/O.
Among other things, the fstream header file contains the definitions of two data types:
ifstream, which means input file stream and is similar to istream, and ofstream,
which means output file stream and is similar to ostream.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

File Input/Output |

161

The variables cin and cout are already defined and associated with the standard input/
output devices. In addition, >>, get, ignore, putback, peek, and so on can be used with
cin, whereas <<, setfill, and so on can be used with cout. These same operators and
functions are also available for file I/O, but the header file fstream does not declare variables
to use them. You must declare variables called file stream variables, which include
ifstream variables for input and ofstream variables for output. You then use these
variables together with >>, <<, or other functions for I/O. Remember that C++ does not
automatically initialize user-defined variables. Once you declare the fstream variables, you
must associate these file variables with the input/output sources.
File I/O is a five-step process:
1.
2.
3.
4.
5.

Include the header file fstream in the program.
Declare file stream variables.
Associate the file stream variables with the input/output sources.
Use the file stream variables with >>, <<, or other input/output functions.
Close the files.

We will now describe these five steps in detail. A skeleton program then shows how the
steps might appear in a program.
Step 1 requires that the header file fstream be included in the program. The following
statement accomplishes this task:
#include <fstream>

Step 2 requires you to declare file stream variables. Consider the following statements:
ifstream inData;
ofstream outData;

The first statement declares inData to be an input file stream variable. The second
statement declares outData to be an output file stream variable.
Step 3 requires you to associate file stream variables with the input/output sources. This
step is called opening the files. The stream member function open is used to open files.
The syntax for opening a file is:
fileStreamVariable.open(sourceName);

Here, fileStreamVariable is a file stream variable, and sourceName is the name of the
input/output file.
Suppose you include the declaration from Step 2 in a program. Further suppose that the input
data is stored in a file called prog.dat. The following statements associate inData with
prog.dat and outData with prog.out. That is, the file prog.dat is opened for inputting
data, and the file prog.out is opened for outputting data.
inData.open("prog.dat"); //open the input file; Line 1
outData.open("prog.out"); //open the output file; Line 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

162 |

Chapter 3: Input/Output

IDEs such as Visual Studio .Net manage programs in the form of projects. That is, first you
create a project, and then you add source files to the project. The statement in Line 1 assumes
that the file prog.dat is in the same directory (subdirectory) as your project. However, if this
is in a different directory (subdirectory), then you must specify the path where the file is
located, along with the name of the file. For example, suppose that the file prog.dat is on a
flash memory in drive H. Then the statement in Line 1 should be modified as follows:

inData.open("h:\\prog.dat");
Note that there are two \ after h:. Recall from Chapter 2 that in C++, \ is the escape
character. Therefore, to produce a \within a string, you need \\. (To be absolutely sure
about specifying the source where the input file is stored, such as the drive h:\\, check
your system’s documentation.)
Similar conventions for the statement in Line 2.

Suppose that a program reads data from a file. Because different computers have drives
labeled differently, for simplicity, throughout the book, we assume that the file containing
the data and the program reading data from the file are in the same directory (subdirectory).

We typically use .dat, .out, or .txt as an extension for the input and output files
and use Notepad, Wordpad, or TextPad to create and open these files. You can also use
your IDE’s editor, if any, to create .txt (text) files. (To be absolutely sure about it, check
you IDE’s documentation.)

Step 4 typically works as follows. You use the file stream variables with >>, <<, or other
input/output functions. The syntax for using >> or << with file stream variables is exactly
the same as the syntax for using cin and cout. Instead of using cin and cout, however,
you use the file stream variable names that were declared. For example, the statement:
inData >> payRate;

reads the data from the file prog.dat and stores it in the variable payRate. The statement:
outData << "The paycheck is: $" << pay << endl;

stores the output—The paycheck is: $565.78—in the file prog.out. This statement
assumes that the pay was calculated as 565.78.
Once the I/O is complete, Step 5 requires closing the files. Closing a file means that
the file stream variables are disassociated from the storage area and are freed. Once
these variables are freed, they can be reused for other file I/O. Moreover, closing an
output file ensures that the entire output is sent to the file; that is, the buffer is
emptied. You close files by using the stream function close. For example, assuming

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

File Input/Output |

163

the program includes the declarations listed in Steps 2 and 3, the statements for
closing the files are:
inData.close();
outData.close();

On some systems, it is not necessary to close the files. When the program terminates,
the files are closed automatically. Nevertheless, it is a good practice to close the files
yourself. Also, if you want to use the same file stream variable to open another file,
you must close the first file opened with that file stream variable.

In skeleton form, a program that uses file I/O usually takes the following form:
#include <fstream>
//Add additional header files you use
using namespace std;
int main()
{
//Declare file stream variables such as the following
ifstream inData;
ofstream outData;
.
.
.
//Open the files
inData.open("prog.dat"); //open the input file
outData.open("prog.out"); //open the output file
//Code for data manipulation
//Close files
inData.close();
outData.close();
return 0;
}

Recall that Step 3 requires the file to be opened for file I/O. Opening a file associates a
file stream variable declared in the program with a physical file at the source, such as a
disk. In the case of an input file, the file must exist before the open statement executes.
If the file does not exist, the open statement fails and the input stream enters the fail
state. An output file does not have to exist before it is opened; if the output file does not
exist, the computer prepares an empty file for output. If the designated output file
already exists, by default, the old contents are erased when the file is opened.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

164 |

Chapter 3: Input/Output

To add the output at the end of an existing file, you can use the option ios::app as follows.
Suppose that outData is declared as before and you want to add the output at the end
of the existing file, say, firstProg.out. The statement to open this file is:

outData.open("firstProg.out", ios::app);
If the file firstProg.out does not exist, then the system creates an empty file.

Appendix E discusses binary and random access files.

PROGRAMMING EXAMPLE:

Movie Tickets Sale and Donation to Charity

Watch
the Video

A movie in a local theater is in great demand. To help a local charity, the theater
owner has decided to donate to the charity a portion of the gross amount generated
from the movie. This example designs and implements a program that prompts the
user to input the movie name, adult ticket price, child ticket price, number of adult
tickets sold, number of child tickets sold, and percentage of the gross amount to be
donated to the charity. The output of the program is as follows.
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Movie Name: ....................... Journey to Mars
Number of Tickets Sold: ...........
2650
Gross Amount: ..................... $ 9150.00
Percentage of Gross Amount Donated:
10.00%
Amount Donated: ................... $ 915.00
Net Sale: ......................... $ 8235.00

Note that the strings, such as "Movie Name:" , in the first column are left-justified,
the numbers in the right column are right-justified, and the decimal numbers are
output with two decimal places.
Input

The input to the program consists of the movie name, adult ticket price, child
ticket price, number of adult tickets sold, number of child tickets sold, and
percentage of the gross amount to be donated to the charity.

Output

The output is as shown above.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Movie Tickets Sale and Donation to Charity |

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

165

To calculate the amount donated to the local charity and the net sale, you first need to
determine the gross amount. To calculate the gross amount, you multiply the number
of adult tickets sold by the price of an adult ticket, multiply the number of child tickets
sold by the price of a child ticket, and then add these two numbers. That is:
grossAmount = adultTicketPrice * noOfAdultTicketsSold
+ childTicketPrice * noOfChildTicketsSold;

Next, you determine the percentage of the amount donated to the charity and then
calculate the net sale amount by subtracting the amount donated from the gross
amount. The formulas to calculate the amount donated and the net sale amount are
given below. This analysis leads to the following algorithm:
1.
2.
3.
4.
5.
6.
7.

Get the movie name.
Get the price of an adult ticket.
Get the price of a child ticket.
Get the number of adult tickets sold.
Get the number of child tickets sold.
Get the percentage of the gross amount donated to the charity.
Calculate the gross amount using the following formula:
grossAmount = adultTicketPrice * noOfAdultTicketsSold
+ childTicketPrice * noOfChildTicketsSold;

8. Calculate the amount donated to the charity using the following formula:
amountDonated = grossAmount * percentDonation / 100;

9. Calculate the net sale amount using the following formula:
netSaleAmount = grossAmount – amountDonated;

Variables From the preceding discussion, it follows that you need variables to store the

movie name, adult ticket price, child ticket price, number of adult tickets sold,
number of child tickets sold, percentage of the gross amount donated to the
charity, gross amount, amount donated, and net sale amount. Therefore, the
following variables are needed:
string movieName;
double adultTicketPrice;
double childTicketPrice;
int noOfAdultTicketsSold;
int noOfChildTicketsSold;
double percentDonation;
double grossAmount;
double amountDonated;
double netSaleAmount;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

166 |

Chapter 3: Input/Output

Because movieName is declared as a string variable, you need to include the header
file string. Therefore, the program needs, among others, the following include
statement:
#include <string>

Formatting In the output, the first column is left-justified and the numbers in the second
Output column are right-justified. Therefore, when printing a value in the first column,
the manipulator left is used; before printing a value in the second column, the
manipulator right is used. The empty space between the first and second
columns is filled with dots; the program uses the manipulator setfill to

accomplish this goal. In the lines showing the gross amount, amount donated,
and net sale amount, the space between the $ sign and the number is filled with
blank spaces. Therefore, before printing the dollar sign, the program uses the
manipulator setfill to set the filling character to blank. The following statements accomplish the desired output:
cout <<
<<
cout <<
<<
cout <<
<<
<<
<<
cout <<
<<
<<
cout <<
<<
<<
<<
cout <<
<<
<<
cout <<
<<
<<
MAIN
ALGORITHM

"-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*"
"-*-*-*-*-*-*-*-*-*-*-*-*-*" << endl;
setfill('.') << left << setw(35) << "Movie Name: "
right << " " << movieName << endl;
left << setw(35) << "Number of Tickets Sold: "
setfill(' ') << right << setw(10)
noOfAdultTicketsSold + noOfChildTicketsSold
endl;
setfill('.') << left << setw(35) << "Gross Amount: "
setfill(' ') << right << " $"
setw(8) << grossAmount << endl;
setfill('.') << left << setw(35)
"Percentage of Gross Amount Donated: "
setfill(' ') << right
setw(9) << percentDonation << '%' << endl;
setfill('.') << left << setw(35) << "Amount Donated: "
setfill(' ') << right << " $"
setw(8) << amountDonated << endl;
setfill('.') << left << setw(35) << "Net Sale: "
setfill(' ') << right << " $"
setw(8) << netSaleAmount << endl;

In the preceding sections, we analyzed the problem and determined the formulas to
do the calculations. We also determined the necessary variables and named constants.
We can now expand the previous algorithm to solve the problem given at the
beginning of this programming example.
1. Declare the variables.
2. Set the output of the floating-point numbers to two decimal places
in a fixed decimal format with a decimal point and trailing zeros.
Include the header file iomanip.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Movie Tickets Sale and Donation to Charity |

167

3. Prompt the user to enter a movie name.
4. Input (read) the movie name. Because the name of a movie might
contain more than one word (and, therefore, might contain blanks), the
program uses the function getline to input the movie name.
5. Prompt the user to enter the price of an adult ticket.
6. Input (read) the price of an adult ticket.
7. Prompt the user to enter the price of a child ticket.
8. Input (read) the price of a child ticket.
9. Prompt the user to enter the number of adult tickets sold.
10. Input (read) the number of adult tickets sold.
11. Prompt the user to enter the number of child tickets sold.
12. Input (read) the number of child tickets sold.
13. Prompt the user to enter the percentage of the gross amount donated.
14. Input (read) the percentage of the gross amount donated.
15. Calculate the gross amount.
16. Calculate the amount donated.
17. Calculate the net sale amount.
18. Output the results.
COMPLETE PROGRAM LISTING
//************************************************************
// Author: D.S. Malik
//
// Program: Movie Tickets Sale
// This program determines the money to be donated to a
// charity. It prompts the user to input the movie name, adult
// ticket price, child ticket price, number of adult tickets
// sold, number of child tickets sold, and percentage of the
// gross amount to be donated to the charity.
//************************************************************
#include <iostream>
#include <iomanip>
#include <string>
using namespace std;
int main()
{
//Step 1
string movieName;
double adultTicketPrice;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

168 |

Chapter 3: Input/Output

double childTicketPrice;
int noOfAdultTicketsSold;
int noOfChildTicketsSold;
double percentDonation;
double grossAmount;
double amountDonated;
double netSaleAmount;
cout << fixed << showpoint << setprecision(2);

//Step 2

cout << "Enter the movie name: ";
getline(cin, movieName);
cout << endl;

//Step 3
//Step 4

cout << "Enter the price of an adult ticket: "; //Step 5
cin >> adultTicketPrice;
//Step 6
cout << endl;
cout << "Enter the price of a child ticket: ";
cin >> childTicketPrice;
cout << endl;
cout << "Enter the number of adult tickets "
<< "sold: ";
cin >> noOfAdultTicketsSold;
cout << endl;
cout << "Enter the number of child tickets "
<< "sold: ";
cin >> noOfChildTicketsSold;
cout << endl;
cout << "Enter the percentage of donation: ";
cin >> percentDonation;
cout << endl << endl;

//Step 7
//Step 8
//Step 9
//Step 10

//Step 11
//Step 12
//Step 13
//Step 14

//Step 15
grossAmount = adultTicketPrice * noOfAdultTicketsSold +
childTicketPrice * noOfChildTicketsSold;
//Step 16
amountDonated = grossAmount * percentDonation / 100;
netSaleAmount = grossAmount - amountDonated;

//Step 17

//Step 18: Output results
cout << "-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*"
<< "-*-*-*-*-*-*-*-*-*-*-*-*-*" << endl;
cout << setfill('.') << left << setw(35) << "Movie Name: "
<< right << " " << movieName << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Movie Tickets Sale and Donation to Charity |

cout <<
<<
<<
<<
cout <<
<<
<<
<<
cout <<
<<
<<
<<
cout <<
<<
<<
<<
cout <<
<<
<<

169

left << setw(35) << "Number of Tickets Sold: "
setfill(' ') << right << setw(10)
noOfAdultTicketsSold + noOfChildTicketsSold
endl;
setfill('.') << left << setw(35)
"Gross Amount: "
setfill(' ') << right << " $"
setw(8) << grossAmount << endl;
setfill('.') << left << setw(35)
"Percentage of Gross Amount Donated: "
setfill(' ') << right
setw(9) << percentDonation << '%' << endl;
setfill('.') << left << setw(35)
"Amount Donated: "
setfill(' ') << right << " $"
setw(8) << amountDonated << endl;
setfill('.') << left << setw(35) << "Net Sale: "
setfill(' ') << right << " $"
setw(8) << netSaleAmount << endl;

return 0;
}

Sample Run: In this sample run, the user input is shaded.
Enter movie name: Journey to Mars
Enter the price of an adult ticket: 4.50
Enter the price of a child ticket: 3.00
Enter number of adult tickets sold: 800
Enter number of child tickets sold: 1850
Enter the percentage of donation: 10
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
Movie Name: ....................... Journey to Mars
Number of Tickets Sold: ...........
2650
Gross Amount: ..................... $ 9150.00
Percentage of Gross Amount Donated:
10.00%
Amount Donated: ................... $ 915.00
Net Sale: ......................... $ 8235.00

Note that the first six lines of output get the necessary data to generate the last six
lines of the output as required.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

170 |

Chapter 3: Input/Output

PROGRAMMING EXAMPLE:

Student Grade

Write a program that reads a student name followed by five test scores. The program
should output the student name, the five test scores, and the average test score.
Output the average test score with two decimal places.
The data to be read is stored in a file called test.txt. The output should be stored
in a file called testavg.out.
Input

A file containing the student name and the five test scores. A sample input is:
Andrew Miller 87.50 89 65.75 37 98.50

Output

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

The student name, the five test scores, and the average of the five test
scores, saved to a file.

To find the average of the five test scores, you add the five test scores and divide the
sum by 5. The input data is in the following form: the student name followed by the
five test scores. Therefore, you must read the student name first and then read the five
test scores. This problem analysis translates into the following algorithm:
1.
2.
3.
4.

Read the student name and the five test scores.
Output the student name and the five test scores.
Calculate the average.
Output the average.

You output the average test score in the fixed decimal format with two decimal places.
Variables The program needs to read a student’s first and last name and five test scores. Therefore, you

need two variables to store the student name and five variables to store the five test scores.
To find the average, you must add the five test scores and then divide the sum by 5.
Thus, you need a variable to store the average test score. Furthermore, because the
input data is in a file, you need an ifstream variable to open the input file. Because
the program output will be stored in a file, you need an ofstream variable to open
the output file. The program, therefore, needs at least the following variables:
ifstream inFile;
ofstream outFile;

//input file stream variable
//output file stream variable

double test1, test2, test3, test4, test5; //variables to
//read the five test scores
double average;
//variable to store the average test score
string firstName; //variable to store the first name
string lastName;
//variable to store the last name
MAIN
ALGORITHM

In the preceding sections, we analyzed the problem and determined the formulas to
perform the calculations. We also determined the necessary variables and named

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Student Grade |

171

constants. We can now expand the previous algorithm to solve the problem given at
the beginning of this programming example:
1.
2.
3.
4.

5.
6.
7.
8.
9.
10.
11.

Declare the variables.
Open the input file.
Open the output file.
To output the floating-point numbers in a fixed decimal format with
a decimal point and trailing zeros, set the manipulators fixed and
showpoint. Also, to output the floating-point numbers with two
decimal places, set the precision to two decimal places.
Read the student name.
Output the student name.
Read the five test scores.
Output the five test scores.
Find the average test score.
Output the average test score.
Close the input and output files.

Because this program reads data from a file and outputs data to a file, it must include
the header file fstream. Because the program outputs the average test score to two decimal
places, you need to set the precision to two decimal places. Therefore, the program uses the
manipulator setprecision, which requires you to include the header file iomanip.
Because firstName and lastName are string variables, we must include the header file
string. The program also includes the header file iostream to print a message on the
screen so that you will not stare at a blank screen while the program executes.
COMPLETE PROGRAM LISTING
//************************************************************
// Author: D.S. Malik
//
// Program to calculate the average test score.
// Given a student's name and five test scores, this program
// calculates the average test score. The student's name, the
// five test scores, and the average test score are stored in
// the file testavg.out. The data is input from the file
// test.txt.
//************************************************************
#include
#include
#include
#include

<iostream>
<fstream>
<iomanip>
<string>

using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

172 |

Chapter 3: Input/Output

int main()
{
//Declare variables;
ifstream inFile;
ofstream outFile;

Step 1

double test1, test2, test3, test4, test5;
double average;
string firstName;
string lastName;
inFile.open("test.txt");
outFile.open("testavg.out");

//Step 2
//Step 3

outFile << fixed << showpoint;
outFile << setprecision(2);

//Step 4
//Step 4

cout << "Processing data" << endl;
inFile >> firstName >> lastName;
outFile << "Student name: " << firstName
<< " " << lastName << endl;

//Step 5
//Step 6

inFile >> test1 >> test2 >> test3
>> test4 >> test5;
//Step 7
outFile << "Test scores: " << setw(6) << test1
<< setw(6) << test2 << setw(6) << test3
<< setw(6) << test4 << setw(6) << test5
<< endl;
//Step 8
average = (test1 + test2 + test3 + test4
+ test5) / 5.0;

//Step 9

outFile << "Average test score: " << setw(6)
<< average << endl;

//Step 10

inFile.close();
outFile.close();

//Step 11
//Step 11

return 0;
}

Sample Run:
Input File (contents of the file test.txt):
Andrew Miller 87.50 89 65.75 37 98.50

Output File (contents of the file testavg.out):
Student name: Andrew Miller
Test scores: 87.50 89.00 65.75 37.00 98.50
Average test score: 75.55
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

173

The preceding program uses five variables—test1, test2, test3, test4,
and test5—to read the five test scores and then find the average test score.
The Web site accompanying this book contains a modified version of this program
that uses only one variable, testScore, to read the test scores and another
variable, sum, to find the sum of the test scores. The program is named
Ch3_AverageTestScoreVersion2.cpp.

QUICK REVIEW
1.
2.
3.
4.
5.
6.

7.

8.
9.
10.
11.
12.
13.
14.
15.

A stream in C++ is an infinite sequence of characters from a source to a
destination.
An input stream is a stream from a source to a computer.
An output stream is a stream from a computer to a destination.
cin, which stands for common input, is an input stream object, typically
initialized to the standard input device, which is the keyboard.
cout, which stands for common output, is an output stream object,
typically initialized to the standard output device, which is the screen.
When the binary operator >> is used with an input stream object, such as cin, it
is called the stream extraction operator. The left-side operand of >> must be an
input stream variable, such as cin; the right-side operand must be a variable.
When the binary operator << is used with an output stream object, such as
cout, it is called the stream insertion operator. The left-side operand of <<
must be an output stream variable, such as cout; the right-side operand of
<< must be an expression or a manipulator.
When inputting data into a variable, the operator >> skips all leading
whitespace characters.
To use cin and cout, the program must include the header file iostream.
The function get is used to read data on a character-by-character basis and
does not skip any whitespace characters.
The function ignore is used to skip data in a line.
The function putback puts the last character retrieved by the function get
back into the input stream.
The function peek returns the next character from the input stream but
does not remove the character from the input stream.
Attempting to read invalid data into a variable causes the input stream to
enter the fail state.
Once an input failure has occurred, you use the function clear to restore
the input stream to a working state.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

174 |

16.
17.
18.
19.
20.

21.
22.

23.
24.
25.
26.

27.

Chapter 3: Input/Output

The manipulator setprecision formats the output of floating-point
numbers to a specified number of decimal places.
The manipulator fixed outputs floating-point numbers in the fixed
decimal format.
The manipulator showpoint outputs floating-point numbers with a
decimal point and trailing zeros.
The manipulator setw formats the output of an expression in a specific
number of columns; the default output is right-justified.
If the number of columns specified in the argument of setw is less than the
number of columns needed to print the value of the expression, the output
is not truncated and the output of the expression expands to the required
number of columns.
The manipulator setfill is used to fill the unused columns on an output
device with a character other than a space.
If the number of columns specified in the setw manipulator exceeds the
number of columns required by the next expression, the output is rightjustified. To left-justify the output, you use the manipulator left.
To use the stream functions get, ignore, putback, peek, clear, and unsetf
for standard I/O, the program must include the header file iostream.
To use the manipulators setprecision, setw, and setfill, the program
must include the header file iomanip.
The header file fstream contains the definitions of ifstream and ofstream.
For file I/O, you must use the statement #include <fstream> to include the
header file fstream in the program. You must also do the following: declare
variables of type ifstream for file input and of type ofstream for file output
and use open statements to open input and output files. You can use <<, >>,
get, ignore, peek, putback, or clear with file stream variables.
To close a file as indicated by the ifstream variable inFile, you use the
statement inFile.close();. To close a file as indicated by the ofstream
variable outFile, you use the statement outFile.close();.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.

b.

An input stream is a sequence of characters from a computer to an input
device. (1)
To use cin and cout in a program, the program must include the
header file iostream. (1, 2)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

c.

d.
e.

f.

g.

h.

i.

j.

k.

2.

|

175

Suppose pay is a variable of type double. The statement cin >> pay;
requires the input of a decimal number. (2)
The statement cin >> length; and length >> cin; are equivalent. (2)
When the statement cin >> num1 >> num2; executes, then after
inputting a number into the variable num1 the program skips all trailing
whitespace characters. (2)
To use the predefined function pow in a program, the program must include
the header file cppmath. (3)
The statement cin.get(ch); inputs the next character into the variable
ch. (4)
When the input stream enters the fail state, the program terminates with
an error message. (5)
To use the manipulators fixed and showpoint, the program does not
require the inclusion of the header file iomanip. (6)
The statement cin >> right; sets the input of only the next variable
right-justified. (7)
To input data from a file, the program must include the header file
fstream. (10)

Suppose num1 and num2 are int variables and symbol is a char variable.
Consider the following input: (2)
47 18 * 28 $

What value (if any) is assigned to num1, num2, and symbol after each of the
following statements executes? (Use the same input for each statement.)

3.

a.

cin >> num1 >> symbol >> num2;

b.

cin >> symbol >> num1 >> num2;

c.

cin >> num1;
cin.get (symbol);
cin >> num2;

d.

cin >> num1 >> num2;
cin.get (symbol);

e.

cin.get (symbol);
cin >> num1 >> num2;

Suppose num1 and num2 are int variables and x and y are double variables.
Assume the following input data: (2)
35 28.30 67 12.50

What value (if any) is assigned to num1, num2, x, y after each of the following
statements executes? (Use the same input for each statement.)
a.

cin >> x >> num1 >> y >> num2;

b.

cin >> num1 >> x >> num2 >> y;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

176 |

4.

Chapter 3: Input/Output

c.

cin >> x >> y >> num1 >> num2;

d.

cin >> num1 >> num2 >> x >> y;

e.

cin >> num1 >> x >> y >> num2;

f.

cin >> x >> num1 >> num2 >> y;

Suppose x and y are int variables and symbol is a char variable. Assume
the following input data:
38 26 * 67 33
24 $ 55 # 34
# & 63 85

What value (if any) is assigned to x, y, and symbol after each of the following
statements executes? (Use the same input for each statement.) (2, 3, 4)

5.

a.

cin >> x >> y;
cin.ignore(100, '\n');
cin >> symbol;

b.

cin >> x;
cin.ignore(100, '*');
cin >> y;
cin.get(symbol);

c.

cin >> y;
cin.ignore(100, '\n');
cin >> x >> symbol;

d.

cin.get(symbol);
cin.ignore(100, '*');
cin >> x;
cin.ignore(100, '\n');
cin >> y;

e.

cin.ignore(100, '\n');
cin >> x >> symbol;
cin.ignore(100, '\n');
cin.ignore(100, '&');
cin >> y;

Given the input:
12.8 Bill 15

and the variable declaration: (2, 8)
double x = 3.5;
int y = 18;
string name = "Lisa";

What is the output, if any? Use the same input for each part.
a.

cin >> x >> name >> y;
cout << x << " " << y << " " << name << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

b.
c.

6.

cin >> y >> x >>
cout << x << " "
cin >> x >> y >>
cout << x << " "

|

177

name;
<< y << " " << name << endl;
name;
<< y << " " << name << endl;

Suppose that x and y are int variables, z is a double variable, and ch is a
char variable. Suppose the input statement is:
cin >> x >> y >> ch >> z;

What values, if any, are stored in x, y, z, and ch if the input is: (2)

7.
8.
9.
10.

11.
12.

a.

35 62.78

b.

86 32A 92.6

c.

12 .45A 32

Which header file must be included to use the function pow? (3)
Which header file must be included to use the function sqrt? (3)
Which header file must be included to use the function setprecision? (7)
Which header file must be included to use the manipulators fixed and
showpoint? (7)
Which header file must be included to use the function setw? (7)
What is the output of the following program? (2, 3, 6, 8)
#include
#include
#include
#include

<iostream>
<cmath>
<string>
<iomanip>

using namespace std;
int main()
{
double first, second;
int temp;
string message;
first = 2.5;
second = 4.0;
cout << fixed << showpoint << setprecision(2);
cout << (pow(first, second)) << endl;
cout << (pow(second, first)) << endl;
temp = static_cast<int>(pow(second, 1.5));
cout << temp << endl;
cout << sqrt(56.25) << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

178 |

Chapter 3: Input/Output

cout << static_cast<int>(sqrt(pow(first, temp))) << endl;
message = "Predefined functions simplify programming code!";
cout << "Length of message = "
<< message.length() << endl;
return 0;
}
13.

14.

To use the functions peek and putback in a program, which header file(s)
must be included in the program? (4)
Suppose that num is an int variable and discard is a char variable. Assume
the following input data:
#34

What value (if any) is assigned to num and discard after each of the
following statements executes? (Use the same input for each statement.)
(2, 4)

15.

a.

cin.get(discard);
cin >> num;

b.

discard = cin.peek();
cin >> num;

c.

cin.get(discard);
cin.putback(discard);
cin >> discard;
cin >> num;

Suppose that name is variable of type string. What is the effect of the
following statement? (8)
getline(cin, name);

16.

Write a C++ statement that uses the manipulator setfill to output a line
containing 35 stars, as in the following line: (7)
***********************************

17.

Suppose that age is an int variable and name is a string variable. What are
the values of age and name after the following input statements execute: (8)
cin >> age;
getline(cin, name);

if the input is:
a.

23 Lance Grant

b.

23
Lance Grant

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

18.

|

179

Suppose that age is an int variable, ch is a char variable, and name is a
string variable. What are the values of age and name after the following
input statements execute: (8)
cin >> age;
cin.get(ch);
getline(cin, name);

if the input is:

19.

a.

23 Lance Grant

b.

23
Lance Grant

The following program is supposed to read two numbers from a file named
input.dat and write the sum of the numbers to a file named output.dat.
However, it fails to do so. Rewrite the program so that it accomplishes what
it is intended to do. (Also, include statements to close the files.) (10)
#include <iostream>
#include <fstream>
using namespace std;
int main()
{
int num1, num2;
ifstream infile;
outfile.open("output.dat");
infile >> num1 >> num2;
outfile << "Sum = " << num1 + num2 << endl;
return 0;
}

20.

21.

22.

23.

What may cause an input stream to enter the fail state? What happens when
an input stream enters the fail state? (5)
Which header file needs to be included in a program that uses the data types
ifstream and ofstream? (10)
Suppose that infile is an ifstream variable and employee.dat is a file
that contains employees’ information. Write the C++ statement that opens
this file using the variable infile. (10)
A program reads data from a file called inputFile.dat and, after doing
some calculations, writes the results to a file called outFile.dat. Answer
the following questions: (10)
a.

b.

After the program executes, what are the contents of the file
inputFile.dat?
After the program executes, what are the contents of the file outFile.dat if
this file was empty before the program executed?

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

180 |

c.

d.

24.

25.

Chapter 3: Input/Output

After the program executes, what are the contents of the file outFile.dat
if this file contained 100 numbers before the program executed?
What would happen if the file outFile.dat did not exist before the
program executed?

Suppose that infile is an ifstream variable and it is associated with the
file that contains the following data: 27306 savings 7503.35. Write the
C++ statement(s) that reads and stores the first input in the int variable
acctNumber, the second input in the string variable accountType, and
the third input in the double variable balance. (10)
Suppose that you have the following statements: (10)
ofstream outfile;
double distance = 375;
double speed = 58;
double travelTime;

Write C++ statements to do the following:
a.
b.

c.

d.
e.

Open the file travel.dat using the variable outfile.
Write the statement to format your output to two decimal places in
fixed form.
Write the values of the variables day, distance, and speed in the file
travel.dat.
Calculate and write the travelTime in the file travel.dat.
Which header files are needed to process the information in (a) to (d)?

PROGRAMMING EXERCISES
1.

Consider the following incomplete C++ program:
#include <iostream>
int main()
{
...
}
a.

b.

c.

Write a statement that includes the header files fstream, string, and
iomanip in this program.
Write statements that declare inFile to be an ifstream variable and
outFile to be an ofstream variable.
The program will read data from the file inData.txt and write output to
the file outData.txt. Write statements to open both of these files, associate
inFile with inData.txt, and associate outFile with outData.txt.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

d.

|

181

Suppose that the file inData.txt contains the following data:
Giselle Robinson Accounting
5600 5 30
450 9
75 1.5

The first line contains a person’s first name, last name, and the department
the person works in. In the second line, the first number represents the
monthly gross salary, the bonus (as a percent), and the taxes (as a percent).
The third line contains the distance traveled and the traveling time. The
fourth line contains the number of coffee cups sold and the cost of each
coffee cup. Write statements so that after the program executes, the contents
of the file outData.txt are as shown below. If necessary, declare additional
variables. Your statements should be general enough so that if the content of
the input file changes and the program is run again (without editing and
recompiling), it outputs the appropriate results.
Name: Giselle Robinson, Department: Accounting
Monthly Gross Salary: $5600.00, Monthly Bonus: 5.00%, Taxes: 30.00%
Paycheck: $4116.00
Distance Traveled: 450.00 miles, Traveling Time: 9.00 hours
Average Speed: 50.00 miles per hour
Number of Coffee Cups Sold: 75, Cost: $1.50 per cup
Sales Amount = $112.50
e.
f.
2.

Write statements that close the input and output files.
Write a C++ program that tests the statements in parts a through e.

Consider the following program in which the statements are in the incorrect
order. Rearrange the statements so that the program prompts the user to input
the height and the radius of the base of a cylinder and outputs the volume and
surface area of the cylinder. Format the output to two decimal places.
#include <iomanip>
#include <cmath>
int main()
{}
double height;
cout << "Volume of the cylinder = "
<< PI * pow(radius, 2.0)* height << endl;
cout << "Enter the height of the cylinder: ";
cin >> radius;
cout << endl;
return 0;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

182 |

Chapter 3: Input/Output

double radius;
cout <<
<<
<<
cout <<

"Surface area: "
2 * PI * radius * height + 2 * PI * pow(radius, 2.0)
endl;
fixed << showpoint << setprecision(2);

cout << "Enter the radius of the base of the cylinder: ";
cin >> height;
cout << endl;
#include <iostream>
const double PI = 3.14159;
using namespace std;
3.

4.

Write a program that prompts the user to enter the weight of a person in
kilograms and outputs the equivalent weight in pounds. Output both the
weights rounded to two decimal places. (Note that 1 kilogram ¼ 2.2
pounds.) Format your output with two decimal places.
During each summer, John and Jessica grow vegetables in their backyard and
buy seeds and fertilizer from a local nursery. The nursery carries different
types of vegetable fertilizers in various bag sizes. When buying a particular
fertilizer, they want to know the price of the fertilizer per pound and the cost
of fertilizing per square foot. The following program prompts the user to
enter the size of the fertilizer bag, in pounds, the cost of the bag, and the
area, in square feet, that can be covered by the bag. The program should
output the desired result. However, the program contains logic errors. Find
and correct the logic errors so that the program works properly.
//Logic errors.
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
double cost;
double area;
double bagSize;
cout << fixed << showpoint << setprecision(2);
cout << "Enter the amount of fertilizer, in pounds, "
<< "in one bag: ";
cin >> bagSize;
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

183

cout << "Enter the cost of the " << bagSize
<< " pound fertilizer bag: ";
cin >> cost;
cout << endl;
cout << "Enter the area, in square feet, that can be "
<< "fertilized by one bag: ";
cin >> area;
cout << endl;
cout <<
<<
cout <<
<<

"The cost of the fertilizer per pound is: $"
bagSize / cost << endl;
"The cost of fertilizing per square foot is: $"
area / cost << endl;

return 0;
}
5.

The manager of a football stadium wants you to write a program that
calculates the total ticket sales after each game. There are four types of
tickets—box, sideline, premium, and general admission. After each game,
data is stored in a file in the following form:
ticketPrice
...

numberOfTicketsSold

Sample data are shown below:
250
100
50
25

6.

5750
28000
35750
18750

The first line indicates that the ticket price is $250 and that 5750 tickets were
sold at that price. Output the number of tickets sold and the total sale amount.
Format your output with two decimal places.
Three employees in a company are up for a special pay increase. You are
given a file, say Ch3_Ex6Data.txt, with the following data:
Miller Andrew 65789.87 5
Green Sheila 75892.56 6
Sethi Amit 74900.50 6.1

Each input line consists of an employee’s last name, first name, current salary, and
percent pay increase. For example, in the first input line, the last name of the
employee is Miller, the first name is Andrew, the current salary is 65789.87, and
the pay increase is 5%. Write a program that reads data from the specified file
and stores the output in the file Ch3_Ex6Output.dat. For each employee, the
data must be output in the following form: firstName lastName
updatedSalary. Format the output of decimal numbers to two decimal places.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

3

184 |

7.

8.

Chapter 3: Input/Output

Write a program that accepts as input the mass, in grams, and density, in
grams per cubic centimeters, and outputs the volume of the object using the
formula: volume ¼ mass / density. Format your output to two decimal places.
Interest on a credit card’s unpaid balance is calculated using the average daily
balance. Suppose that netBalance is the balance shown in the bill, payment is the
payment made, d1 is the number of days in the billing cycle, and d2 is the number
of days payment is made before billing cycle. Then, the average daily balance is:
averageDailyBalance ¼ ðnetBalance  d1  payment  d2Þ=d1
If the interest rate per month is, say, 0.0152, then the interest on the unpaid
balance is:
interest ¼ averageDailyBalance  0:0152

9.

10.

11.

Write a program that accepts as input netBalance, payment, d1, d2, and interest
rate per month. The program outputs the interest. Format your output to two
decimal places.
Linda is starting a new cosmetic and clothing business and would like to
make a net profit of approximately 10% after paying all the expenses, which
include merchandise cost, store rent, employees’ salary, and electricity cost
for the store. She would like to know how much the merchandise should be
marked up so that after paying all the expenses at the end of the year she gets
approximately 10% net profit on the merchandise cost. Note that after
marking up the price of an item she would like to put the item on 15% sale.
Write a program that prompts Linda to enter the total cost of the merchandise, the salary of the employees (including her own salary), the yearly rent,
and the estimated electricity cost. The program then outputs how much the
merchandise should be marked up so that Linda gets the desired profit.
Dairy Farm decided to ship milk in containers in the form of cubes rather
than cylinders. Write a program that prompts the user to input the radius of
the base and the height of a cylindrical container and outputs the side of the
cube with the same volume as the cylindrical container.
Paula and Danny want to plant evergreen trees along the back side of their
yard. They do not want to have an excessive number of trees. Write a
program that prompts the user to input the following:
a.
b.
c.

The length of the yard.
The radius of a fully grown tree.
The required space between fully grown trees.

The program outputs the number of trees that can be planted in the yard and
the total space that will be occupied by the fully grown trees.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

CHAPTER

ª HunThomas/Shutterstock.com

CONTROL S TRUCTURES I
(S ELECTION )
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about control structures

2.

Examine relational operators

3.

Discover how to use the selection control structures if and if ... else

4.

Examine int and bool data types and logical (Boolean) expressions

5.

Examine logical operators

6.

Explore how to form and evaluate logical (Boolean) expressions

7.

Learn how relational operators work with the string type

8.

Become aware of short-circuit evaluation

9.

Learn how the conditional operator, ?:, works

10.

Learn how to use pseudocode to develop, test, and debug a program

11.

Discover how to use a switch statement in a program

12.

Learn how to avoid bugs by avoiding partially understood concepts

13.

Learn to use the assert function to terminate a program

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

186 |

Chapter 4: Control Structures I (Selection)

Chapter 2 defined a program as a sequence of statements whose objective is to
accomplish some task. The programs you have examined so far were simple
and straightforward. To process a program, the computer begins at the first executable statement and executes the statements in order until it comes to the end.
In this chapter and Chapter 5, you will learn how to tell a computer that it does
not have to follow a simple sequential order of statements; it can also make
decisions and repeat certain statements over and over until certain conditions
are met.

Control Structures
A computer can process a program in one of the following ways: in sequence; selectively,
by making a choice, which is also called a branch; repetitively, by executing a statement
over and over, using a structure called a loop; or by calling a function. Figure 4-1
illustrates the first three types of program flow. (In Chapter 6, we will show how function
calls work.) The programming examples in Chapters 2 and 3 included simple sequential
programs. With such a program, the computer starts at the beginning and follows the
statements in order to the end. No choices are made; there is no repetition. Control
structures provide alternatives to sequential program execution and are used to alter the
sequential flow of execution. The two most common control structures are selection and
repetition. In selection, the program executes particular statements depending on some
condition(s). In repetition, the program repeats particular statements a certain number of
times based on some condition(s).

statement1
false

expression

true

statement2
statement2

statement1

expression

true

statement

false

statementN

a. Sequence

FIGURE 4-1

b. Selection

c. Repetition

Flow of execution

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

187

SELECTION: if AND if...else
Figures 4-1(b) and 4-1(c) show that the execution of a selection or a repetition
statement requires the execution of a logical expression. Therefore, first we need to
learn about logical expressions and how to evaluate them.
Logical expression: An expression that evaluates to true or false is called a logical

expression.
For example, because ‘‘8 is greater than 3’’ is true, the expression 8 > 3 is a logical
expression. Note that > is an operator in C++, called the ‘‘greater than’’ and is an
example of a relational operator. Table 4-1 lists the C++ relational operators.

TABLE 4-1

Relational Operators in C++

Operator

Description

==

equal to

!=

not equal to

<

less than

<=

less than or equal to

>

greater than

>=

greater than or equal to

In C++, the symbol ==, which consists of two equal signs, is called the equality operator.
Recall that the symbol = is called the assignment operator. Remember that the equality
operator, ==, determines whether two expressions are equal, whereas the assignment
operator, =, assigns the value of an expression to a variable.

Each of the relational operators is a binary operator; that is, it requires two operands.
Because the result of a comparison is true or false, expressions using these operators
always evaluate to true or false.

Relational Operators and Simple Data Types
You can use the relational operators with all three simple data types. In the following
example, the expressions use both integers and real numbers:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

188 |

Chapter 4: Control Structures I (Selection)

EXAMPLE 4-1
Expression

Meaning

Value

8 < 15
6 != 6
2.5 > 5.8
5.9 <= 7.5
7 <= 10.4

8 is less than 15
6 is not equal to 6
2.5 is greater than 5.8
5.9 is less than or equal to 7.5
7 is less than or equal to 10.4

true
false
false
true
true

Comparing Characters
For char values, whether an expression using relational operators evaluates to true or false
depends on a machine’s collating sequence. The collating sequence of some of the characters is:
ASCII
Value

Char

ASCII
Value

32

''

61

33

!
"
*
+
/
0
1
2
3
4
5
6
7
8
9
<

62

34
42
43
45
47
48
49
50
51
52
53
54
55
56
57
60

65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80

Char
=
>
A
B
C
D
E
F
G
H
I
J
K
L
M
N
O
P

ASCII
Value

Char

ASCII
Value

Char

81

Q

105

i

82

R

106

j

83

S

107

k

84

T
U
V
W
X
Y
Z
a
b
c
d
e
f
g
h

108

l
m
n
o
p
q
r
s
t
u
v
w
x
y
z

85
86
87
88
89
90
97
98
99
100
101
102
103
104

109
110
111
112
113
114
115
116
117
118
119
120
121
122

The ASCII character set is described in Appendix C.
Now, because 32 < 97, and the ASCII value of ' ' is 32 and the ASCII value of 'a' is
97, it follows that ' ' < 'a' is true. Similarly, using the previous ASCII values:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

189

'R' > 'T' is false
'+' < '*' is false
'A' <= 'a' is true

Note that comparing values of different data types may produce unpredictable results. For
example, the following expression compares an integer and a character:
8 < '5'

In this expression, on a particular machine, 8 would be compared with the collating
sequence of '5', which is 53. That is, 8 is compared with 53, which makes this particular
expression evaluate to true.
Expressions 4 < 6 and 'R' > 'T' are logical (Boolean) expressions. When C++ evaluates
a logical expression, it returns an integer value of 1 if the logical expression evaluates to
true; it returns an integer value of 0 otherwise. In C++, any nonzero value is treated as
true.
Chapter 2 introduced the data type bool. Recall that the data type bool has two values:
true and false. In C++, true and false are reserved words. The identifier
true is set to 1, and the identifier false is set to 0. For readability, whenever
logical expressions are used, the identifiers true and false will be used here as the
value of the logical expression.

Now that we know how relational operators work, we can start learning how to
implement decisions in a C++ program. Although there are only two logical values,
true and false, they turn out to be extremely useful because they permit programs to
incorporate decision making that alters the processing flow. The remainder of this chapter
discusses ways to incorporate decisions into a program. In C++, there are two selections,
or branch control structures: if statements and the switch structure. This section
discusses how if and if. . .else statements can be used to create one-way
selection, two-way selection, and multiple selections. The switch structure is
discussed later in this chapter.

One-Way Selection
A bank would like to send a notice to a customer if her or his checking account balance
falls below the required minimum balance. That is, if the account balance is below the
required minimum balance, it should send a notice to the customer; otherwise, it should
do nothing. Similarly, if the policyholder of an insurance policy is a nonsmoker, the
company would like to apply a 10% discount to the policy premium. Both of these

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

190 |

Chapter 4: Control Structures I (Selection)

examples involve one-way selection. In C++, one-way selections are incorporated using
the if statement. The syntax of one-way selection is:
if (expression)
statement

Note the elements of this syntax. It begins with the reserved word if, followed by
an expression contained within parentheses, followed by a statement. Note that
the parentheses around the expression are part of the syntax. The expression is
sometimes called a decision maker because it decides whether to execute the
statement that follows it. The expression is usually a logical expression. If the
value of the expression is true, the statement executes. If the value is false,
the statement does not execute. The statement following the expression is
sometimes called the action statement. Figure 4-2 shows the flow of execution of
the if statement (one-way selection).

expression

true

statement

false

FIGURE 4-2

One-way selection

EXAMPLE 4-2
if (score >= 60)
grade = 'P';

In this code, if the expression (score >= 60) evaluates to true, the assignment statement,
grade = 'P';, executes. If the expression evaluates to false, the assignment statement
does not execute. For example, if the value of score is 65, the value assigned to the
variable grade is 'P'.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

191

EXAMPLE 4-3
//Program to compute and output the penalty on an unpaid
//credit card balance. The program assumes that the interest
//rate on the unpaid balance is 1.5% per month.
#include <iostream>
#include <iomanip>

//Line 1
//Line 2

using namespace std;

//Line 3

const double INTEREST_RATE = 0.015;

//Line 4

int main ()
{
double creditCardBalance;
double payment;
double balance;
double penalty = 0.0;

//Line
//Line
//Line
//Line
//Line
//Line

5
6
7
8
9
10

cout << fixed << showpoint << setprecision(2);

//Line 11

cout << "Line 12: Enter credit card balance: ";
cin >> creditCardBalance;
cout << endl;

//Line 12
//Line 13
//Line 14

cout << "Line 15: Enter the payment: ";
cin >> payment;
cout << endl;

//Line 15
//Line 16
//Line 17

balance = creditCardBalance - payment;

//Line 18

if (balance > 0)
penalty = balance * INTEREST_RATE;

//Line 19
//Line 20

cout <<
<<
cout <<
<<

//Line 21

"Line 21: The balance is: $" << balance
endl;
"Line 22: The penalty to be added to your "
"next month bill is: $" << penalty << endl;

return 0;
}

//Line 22
//Line 23
//Line 24

Sample Run: In this sample run, the user input is shaded.
Line 12: Enter credit card balance: 2500.00
Line 15: Enter the payment: 275.00
Line 21: The balance is: $2225.00
Line 22: The penalty to be added to your next month bill is: $33.38

The statements in Lines 7 to 10 declare the variables used in the program. The statement in
Line 12 prompts the user to enter the credit card billing amount. The statement in Line 13
inputs the amount into the variable creditCardBalance. The statement in Line 15

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

192 |

Chapter 4: Control Structures I (Selection)

prompts the user to enter the payment. The statement in Line 16 inputs the payment into
the variable payment. The statement in Line 18 computes the unpaid balance. The if
statement in Line 19 determines if the unpaid balance is positive. If the unpaid balance is
positive, the statement in Line 20 computes the penalty. The statements in Lines 21 and 22
output the results. This program assumes that the interest rate on the unpaid balance is 18%
per year (that is, 1.5% per month). As you can see the interest rate on the unpaid balance
can quickly add up and ruin your credit ratings as well as put you in financial trouble.

EXAMPLE 4-4
Consider the following statement:
if score >= 60
grade = 'P';

//syntax error

This statement illustrates an incorrect version of an if statement. The parentheses around
the logical expression are missing, which is a syntax error.

Putting a semicolon after the parentheses following the expression in an if statement
(that is, before the statement) is a semantic error. If the semicolon immediately follows
the closing parenthesis, the if statement will operate on the empty statement.
EXAMPLE 4-5
Consider the following C++ statements:
if (score >= 60);
grade = 'P';

//Line 1
//Line 2

Because there is a semicolon at the end of the expression (see Line 1), the if statement in
Line 1 terminates. The action of this if statement is null, and the statement in Line 2 is
not part of the if statement in Line 1. Hence, the statement in Line 2 executes regardless
of how the if statement evaluates.

Two-Way Selection
There are many programming situations in which you must choose between two
alternatives. For example, if a part-time employee works overtime, the paycheck is
calculated using the overtime payment formula; otherwise, the paycheck is calculated
using the regular formula. This is an example of two-way selection. To choose between
two alternatives—that is, to implement two-way selections—C++ provides the if. . .
else statement. Two-way selection uses the following syntax:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

193

if (expression)
statement1
else
statement2

Take a moment to examine this syntax. It begins with the reserved word if, followed by a
logical expression contained within parentheses, followed by a statement, followed by the
reserved word else, followed by a second statement. Statements 1 and 2 are any valid
C++ statements. In a two-way selection, if the value of the expression is true,
statement1 executes. If the value of the expression is false, statement2 executes.
Figure 4-3 shows the flow of execution of the if. . .else statement (two-way selection).

false

expression

statement2

FIGURE 4-3

true
statement1

Two-way selection

EXAMPLE 4-6
Consider the following statements:
if (hours > 40.0)
wages = 40.0 * rate +
1.5 * rate * (hours - 40.0);
else
wages = hours * rate;

//Line 1
//Line 2
//Line 3
//Line 4

If the value of the variable hours is greater than 40.0, the wages include overtime
payment. Suppose that hours is 50. The expression in the if statement, in Line 1,
evaluates to true, so the statement in Line 2 executes. On the other hand, if hours is
30 or any number less than or equal to 40, the expression in the if statement, in Line 1,
evaluates to false. In this case, the program skips the statement in Line 2 and executes the
statement in Line 4—that is, the statement following the reserved word else executes.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

194 |

Chapter 4: Control Structures I (Selection)

EXAMPLE 4-7
The following program determines an employee’s weekly wages. If the hours worked
exceed 40, the wages include overtime payment.
//Program: Weekly wages
#include <iostream>
#include <iomanip>

//Line 1
//Line 2

using namespace std;

//Line 3

int main()
{
double wages, rate, hours;

//Line 4
//Line 5
//Line 6

cout << fixed << showpoint << setprecision(2);
cout << "Line 8: Enter working hours and rate: ";
cin >> hours >> rate;

//Line 7
//Line 8
//Line 9

if (hours > 40.0)
wages = 40.0 * rate +
1.5 * rate * (hours - 40.0);
else
wages = hours * rate;

//Line 10
//Line 11
//Line 12
//Line 13

cout << endl;
//Line 14
cout << "Line 15: The wages are $" << wages << endl; //Line 15
return 0;
}

//Line 16
//Line 17

Sample Run: In this sample run, the user input is shaded.
Line 8: Enter working hours and rate: 50.00 12.50
Line 15: The wages are $687.50

The statement in Line 6 declares the variables used in the program. The
statement in Line 7 sets the output of the floating-point numbers in a fixed
decimal format, with a decimal point, trailing zeros, and two decimal places. The
statement in Line 8 prompts the user to input the number of hours worked and
the pay rate. The statement in Line 9 inputs these values into the variables
hours and rate, respectively. The statement in Line 10 checks whether the
value of the variable hours is greater than 40.0. If hours is greater than 40.0,
then the wages are calculated by the statement in Line 11, which includes
overtime payment. Otherwise, the wages are calculated by the statement in Line
13. The statement in Line 15 outputs the wages.
In a two-way selection statement, putting a semicolon after the expression and
before statement1 creates a syntax error. If the if statement ends with a semicolon,
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

195

statement1 is no longer part of the if statement, and the else part of the
if. . .else statement stands all by itself. There is no stand-alone else statement in C++.
That is, it cannot be separated from the if statement.

EXAMPLE 4-8
The following statements show an example of a syntax error:
if (hours > 40.0);
//Line 1
wages = 40.0 * rate +
1.5 * rate * (hours - 40.0); //Line 2
else
//Line 3
wages = hours * rate;
//Line 4

The semicolon at the end of the if statement (see Line 1) ends the if statement, so the
statement in Line 2 separates the else clause from the if statement. That is, else is all
by itself. Because there is no stand-alone else statement in C++, this code generates a
syntax error. As shown in Example 4-5, in a one-way selection, the semicolon at the end
of an if statement is a logical error, whereas as shown in this example, in a two-way
selection, it is a syntax error.
Let us now consider another example of an if statement and examine some of the
semantic errors that can occur.
EXAMPLE 4-9
Consider the following statements:
if (score >= 60)
cout << "Passing" << endl;
cout << "Failing" << endl;

//Line 1
//Line 2
//Line 3

If the expression (score >= 60) evaluates to false, the output statement in Line 2 does
not execute. So the output would be Failing. That is, this set of statements performs the
same action as an if. . .else statement. It will execute the output statement in Line 3
rather than the output statement in Line 2. For example, if the value of score is 50, these
statements will output the following line:
Failing

However, if the expression (score >= 60) evaluates to true, the program will execute
both of the output statements, giving a very unsatisfactory result. For example, if the
value of score is 70, these statements will output the following lines:
Passing
Failing

The if statement controls the execution of only the statement in Line 2. The statement
in Line 3 always executes.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

196 |

Chapter 4: Control Structures I (Selection)

Now the logical (Boolean) expression (score >= 60) evaluates to true or false. So we
used two different values of score—one for which the logical (Boolean) expression
evaluated to true and the other for which it evaluated to false. This is an example of
thoroughly testing your code.
The correct code to print Passing or Failing, depending on the value of score, is:
if (score >= 60)
cout << "Passing" << endl;
else
cout << "Failing" << endl;

int Data Type and Logical (Boolean) Expressions
Earlier versions of C++ did not provide built-in data types that had logical (or Boolean)
values true and false. Because logical expressions evaluate to either 1 or 0, the value of
a logical expression was stored in a variable of the data type int. Therefore, you can use
the int data type to manipulate logical (Boolean) expressions.
Recall that nonzero values are treated as true. Now, consider the declarations:
int legalAge;
int age;

and the assignment statement:
legalAge = 21;

If you regard legalAge as a logical variable, the value of legalAge assigned by this
statement is true.
The assignment statement:
legalAge = (age >= 21);

assigns the value 1 to legalAge if the value of age is greater than or equal to 21. The
statement assigns the value 0 if the value of age is less than 21.
It is interesting to note that !(!true) evaluates to true. However, !(!36) evaluates to 0
because as a logical expression 36 evaluates to 1, so !(36) evaluates to 0 and !(!36) = !(0) = 1.

bool Data Type and Logical (Boolean) Expressions
More recent versions of C++ contain a built-in data type, bool, that has the logical
(Boolean) values true and false. Therefore, you can manipulate logical (Boolean)
expressions using the bool data type. Recall that in C++, bool, true, and false are
reserved words. In addition, the identifier true has the value 1, and the identifier false
has the value 0. Now, consider the following declaration:
bool legalAge;
int age;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

197

The statement:
legalAge = true;

sets the value of the variable legalAge to true. The statement:
legalAge = (age >= 21);

assigns the value true to legalAge if the value of age is greater than or equal to 21. This
statement assigns the value false to legalAge if the value of age is less than 21. For
example, if the value of age is 25, the value assigned to legalAge is true—that is, 1.
Similarly, if the value of age is 16, the value assigned to legalAge is false—that is, 0.
You can use either an int variable or a bool variable to store the value of a logical
expression. For the purpose of clarity, this book uses bool variables to store the values of
logical expressions.

Logical (Boolean) Operators and Logical Expressions
Examples 4-3 and 4-7 show how to incorporate selection statements in a program.
However, the logical expressions used in these examples involve the evaluation of a
single relational operator. There are situations when the logical expression is a combination of two or more logical expressions. For example, suppose weight and height are
double variables. Consider the following logical expression:
weight > 180 and height < 6.0

This logical expression is a combination of the logical expressions weight > 180 and
height < 6.0, and these logical expressions are combined using the word ‘‘and.’’ So how
do we evaluate and implement such expressions in C++?
This section describes how to form and evaluate logical expressions that are combinations
of other logical expressions. Logical (Boolean) operators enable you to combine
logical expressions. C++ has three logical (Boolean) operators, as shown in Table 4-2.
TABLE 4-2

Logical (Boolean) Operators in C++

Operator

Description

!

not

&&

and

||

or

Logical operators take only logical values as operands and yield only logical values as
results. The operator ! is unary, so it has only one operand. The operators && and || are
binary operators and there is no space within these operators. Tables 4-3, 4-4, and 4-5
define these operators.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

198 |

Chapter 4: Control Structures I (Selection)

Table 4-3 defines the operator ! (not). When you use the ! operator, !true is false
and !false is true. Putting ! in front of a logical expression reverses the value of that
logical expression.
TABLE 4-3

The ! (Not) Operator

Expression

!(Expression)

true (nonzero)

false (0)

false (0)

true (1)

EXAMPLE 4-10
Expression

Value

Explanation

!('A' > 'B')
!(6 <= 7)

true
false

Because 'A' > 'B' is false, !('A' > 'B') is true.
Because 6 <= 7 is true, !(6 <= 7) is false.

Table 4-4 defines the operator && (and). From this table, it follows that Expression1 &&
Expression2 is true if and only if both Expression1 and Expression2 are true;
otherwise, Expression1 && Expression2 evaluates to false.
TABLE 4-4

The && (And) Operator

Expression1

Expression2

Expression1 && Expression2

true (nonzero)

true (nonzero)

true (1)

true (nonzero)

false (0)

false (0)

false (0)

true (nonzero)

false (0)

false (0)

false (0)

false (0)

EXAMPLE 4-11
Expression

Value

Explanation

(14 >= 5) && ('A' < 'B')

true

(24 >= 35) && ('A' < 'B')

false

Because (14 >= 5) is true, ('A' <
'B') is true, and true && true is
true, the expression evaluates to true.
Because (24 >= 35) is false, ('A'
<'B') is true, and false && true is
false, the expression evaluates to false.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

199

Table 4-5 defines the operator || (or). From this table, it follows that Expression1 ||
Expression2 is true if and only if at least one of the expressions, Expression1 or
Expression2, is true; otherwise, Expression1 || Expression2 evaluates to false.
TABLE 4-5

The || (Or) Operator

Expression1

Expression2

Expression1 || Expression2

true (nonzero)

true (nonzero)

true (1)

true (nonzero)

false (0)

true (1)

false (0)

true (nonzero)

true (1)

false (0)

false (0)

false (0)

EXAMPLE 4-12
Expression

Value

Explanation

(14 >= 5) || ('A' > 'B')

true

(24 >= 35) || ('A' > 'B')

false

('A' <= 'a') || (7 != 7)

true

Because (14 >= 5) is true, ('A' >
'B') is false, and true || false is
true, the expression evaluates to true.
Because (24 >= 35) is false, ('A' >
'B') is false, and false || false is
false, the expression evaluates to false.
Because ('A' <= 'a') is true,
(7 != 7) is false, and true || false
is true, the expression evaluates to true.

Order of Precedence
Complex logical expressions can be difficult to evaluate. Consider the following logical expression:
11 > 5 || 6 < 15 && 7 >= 8

This logical expression yields different results, depending on whether || or && is
evaluated first. If || is evaluated first, the expression evaluates to false. If && is evaluated
first, the expression evaluates to true.
An expression might contain arithmetic, relational, and logical operators, as in the expression:
5 + 3 <= 9 && 2 > 3

To work with complex logical expressions, there must be some priority scheme for
evaluating operators. Table 4-6 shows the order of precedence of some C++ operators,
including the arithmetic, relational, and logical operators. (See Appendix B for the
precedence of all C++ operators.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

200 |

Chapter 4: Control Structures I (Selection)

TABLE 4-6

Precedence of Operators

Operators

Precedence

!, +, - (unary operators)

first

*, /, %

second

+, -

third

<, <=, >=, >

fourth

==, !=

fifth

&&

sixth

||

seventh

=

(assignment operator)

last

In C++, & and | are also operators. The meaning of these operators is different from the
meaning of && and ||. Using & in place of && or | in place of ||—as might result from a
typographical error—would produce very strange results.

Using the precedence rules in an expression, relational and logical operators are evaluated
from left to right. Because relational and logical operators are evaluated from left to right, the
associativity of these operators is said to be from left to right.
Example 4-13 illustrates how logical expressions consisting of variables are evaluated.
EXAMPLE 4-13
Suppose you have the following declarations:
bool found = true;
int age = 20;
double hours = 45.30;
double overTime = 15.00;
int count = 20;
char ch = 'B';

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

201

Consider the following expressions:
Expression

Value / Explanation

!found

false
Because found is true, !found is false.

hours > 40.00

!age

true
Because hours is 45.30 and 45.30 > 40.00 is
true, the expression hours > 40.00 evaluates to
true.
false
age is 20, which is nonzero, so age evaluates to
true. Therefore, !age is false.

!found && (age >= 18)

false
!found is false; age > 18 is 20 > 18 is true.
Therefore,!found && (age >= 18) is false &&
true, which evaluates to false.

!(found && (age >= 18))

false
Now, found && (age >= 18) is true && true,
which evaluates to true. Therefore, !(found &&
(age >= 18)) is !true, which evaluates to false.

hours + overTime <= 75.00

true
Because hours + overTime is 45.30 + 15.00 =
60.30 and 60.30 <= 75.00 is true, it follows that
hours + overTime <= 75.00 evaluates to true.

(count >= 0) &&
(count <= 100)

true

('A' <= ch && ch <= 'Z')

Now, count is 20. Because 20 >= 0 is true,
count >= 0 is true. Also, 20 <= 100 is true, so
count <= 100 is true. Therefore, (count >=
0) && (count <= 100) is true && true,
which evaluates to true.
true
Here, ch is 'B'. Because 'A' <= 'B' is true,
'A' <= ch evaluates to true. Also, because 'B'
<= 'Z' is true, ch <= 'Z' evaluates to true.
Therefore, ('A' <= ch && ch <= 'Z') is true
&& true, which evaluates to true.

Note that if the value of a logical expression is true, it evaluates to 1, and if the value of the
logical expression is false, it evaluates to 0. The Web site accompanying this book contains
the program Ch4_LogicalOperators.cpp, which evaluates these expressions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

202 |

Chapter 4: Control Structures I (Selection)

You can insert parentheses into an expression to clarify its meaning. You can also use
parentheses to override the precedence of operators. Using the standard order of precedence, the expression:
11 > 5 || 6 < 15 && 7 >= 8

is equivalent to:
11 > 5 || (6 < 15 && 7 >= 8)

In this expression, 11 > 5 is true, 6 < 15 is true, and 7 >= 8 is false. Substitute these values in
the expression 11 > 5 || (6 < 15 && 7 >= 8) to get true || (true && false ) = true ||
false = true. Therefore, the expression 11 > 5 || (6 < 15 && 7 >= 8) evaluates to true.
In C++, logical (Boolean) expressions can be manipulated or processed in either of two ways: by
using int variables or by using bool variables. The following sections describe these methods.
EXAMPLE 4-14
Typically on an economy flight, if either the suitcase dimension (length + width + depth)
is more than 108 inches or the weight is more than 50 pounds, then the airline may apply
additional charges to the passenger. The following program uses the logical operator ||
(or) in an if statement to determine if additional charges may be applied to a suitcase.
//Chapter 4: Example 4-14
//Program to determine if additional charges are applicable on
//a suitcase accompanying a passenger on an economy flight.
#include <iostream>
#include <iomanip>

//Line 1
//Line 2

using namespace std;

//Line 3

int main()
{
double suitcaseDimension;
double suitcaseWeight;
double additionalCharges = 0.0;

//Line
//Line
//Line
//Line
//Line

4
5
6
7
8

cout << fixed << showpoint << setprecision(2);
cout << "Line 10: Enter suitcase dimensions "
<< "(length + width + depth) in inches: ";
cin >> suitcaseDimension;
cout << endl;

//Line
//Line
//Line
//Line
//Line

9
10
11
12
13

cout << "Line 14: Enter suitcase weight in pounds: ";
cin >> suitcaseWeight;
cout << endl;

//Line 14
//Line 15
//Line 16

if (suitcaseDimension > 108 || suitcaseWeight > 50)
additional_charges = 50.00;

//Line 17
//Line 18

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

203

cout << "Line 19: Additional suitcase charges: $"
<< additionalCharges << endl;

//Line 19
//Line 20

return 0;

//Line 21
//Line 22

}

Sample Run:
Line 10: Enter suitcase dimensions (length + width + depth) in inches: 110
Line 14: Enter suitcase weight: 49
Line 19: Additional suitcase charges: $50.00

Relational Operators and the string Type
The relational operators can be applied to variables of type string. Variables of type
string are compared character by character, starting with the first character and using
the ASCII collating sequence. The character-by-character comparison continues until
either a mismatch is found or the last characters have been compared and are equal. The
following example shows how variables of type string are compared.
EXAMPLE 4-15
Suppose that you have the following statements:
string
string
string
string
string

str1
str2
str3
str4
str5

=
=
=
=
=

"Hello";
"Hi";
"Air";
"Bill";
"Big";

The following expressions show how string relational expressions evaluate.
Expression

Value /Explanation

str1 < str2

true
str1 = "Hello" and str2 = "Hi". The first characters
of str1 and str2 are the same, but the second character 'e'
of str1 is less than the second character 'i' of str2.
Therefore, str1 < str2 is true.

str1 > "Hen"

false
str1 = "Hello". The first two characters of str1 and
"Hen" are the same, but the third character 'l' of str1 is
less than the third character 'n' of "Hen". Therefore,
str1 > "Hen" is false.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

204 |

Chapter 4: Control Structures I (Selection)

str3 < "An"

true
str3 = "Air". The first characters of str3 and "An" are
the same, but the second character 'i' of "Air" is less than
the second character 'n' of "An". Therefore, str3 < "An"
is true.

str1 == "hello"

false
str1 = "Hello". The first character 'H' of str1 is less
than the first character 'h' of "hello" because the ASCII
value of 'H' is 72, and the ASCII value of 'h' is 104.
Therefore, str1 == "hello" is false.

str3 <= str4

true
str3 = "Air" and str4 = "Bill". The first character
'A' of str3 is less than the first character 'B' of str4.
Therefore, str3 <= str4 is true.

str2 > str4

true
str2 = "Hi" and str4 = "Bill". The first character
'H' of str2 is greater than the first character 'B' of str4.
Therefore, str2 > str4 is true.

If two strings of different lengths are compared and the character-by-character comparison is equal until it reaches the last character of the shorter string, the shorter string is
evaluated as less than the larger string, as shown next.
Expression

Value/Explanation

str4 >= "Billy"

false
str4 = "Bill". It has four characters, and "Billy" has
five characters. Therefore, str4 is the shorter string. All four
characters of str4 are the same as the corresponding first
four characters of "Billy", and "Billy" is the larger
string. Therefore, str4 >= "Billy" is false.
true

str5 <= "Bigger"

str5 = "Big". It has three characters, and "Bigger"
has six characters. Therefore, str5 is the shorter string.
All three characters of str5 are the same as the
corresponding first three characters of "Bigger",
and "Bigger" is the larger string. Therefore,
str5 <= "Bigger" is true.

The program Ch4_StringComparisons.cpp at the Web site accompanying this book
shows the results of the previous expressions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

205

Compound (Block of) Statements
The if and if. . .else structures control only one statement at a time. Suppose, however, that you want to execute more than one statement if the expression in an if or
if. . .else statement evaluates to true. To permit more complex statements, C++
provides a structure called a compound statement or a block of statements. A
compound statement takes the following form:
{
statement_1
statement_2
.
.
.
statement_n
}

In general, a compound statement consists of one or more statements enclosed in curly
braces, {and }. In an if or if . . .else structure, a compound statement functions as if it
was a single statement. Thus, instead of having a simple two-way selection similar to the
following code:
if (age >= 18)
cout << "Eligible to vote." << endl;
else
cout << "Not eligible to vote." << endl;

you could include compound statements, similar to the following code:
if (age >= 18)
{
cout << "Eligible to vote." << endl;
cout << "No longer a minor." << endl;
}
else
{
cout << "Not eligible to vote." << endl;
cout << "Still a minor." << endl;
}

The compound statement is very useful and will be used in most of the structured
statements in this book.

Multiple Selections: Nested if
In the previous sections, you learned how to implement one-way and two-way selections
in a program. Some problems require the implementation of more than two alternatives.
For example, suppose that if the checking account balance is more than $50,000, the
interest rate is 7%; if the balance is between $25,000 and $49,999.99, the interest rate is
5%; if the balance is between $1,000 and $24,999.99, the interest rate is 3%; otherwise,

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

206 |

Chapter 4: Control Structures I (Selection)

the interest rate is 0%. This particular problem has four alternatives—that is, multiple
selection paths. You can include multiple selection paths in a program by using an
if. . .else structure if the action statement itself is an if or if. . .else statement. When
one control statement is located within another, it is said to be nested.
Example 4-16 illustrates how to incorporate multiple selections using a nested if. . .else
structure.
EXAMPLE 4-16
Suppose that balance and interestRate are variables of type double. The following
statements determine the interestRate depending on the value of the balance:
if (balance > 50000.00)
interestRate = 0.07;
else
if (balance >= 25000.00)
interestRate = 0.05;
else
if (balance >= 1000.00)
interestRate = 0.03;
else
interestRate = 0.00;

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7
8
9
10

A nested if. . .else structure demands the answer to an important question: How do you
know which else is paired with which if? Recall that in C++, there is no stand-alone
else statement. Every else must be paired with an if. The rule to pair an else with an
if is as follows:
Pairing an else with an if: In a nested if statement, C++ associates an else with the most
recent incomplete if—that is, the most recent if that has not been paired with an else.
Using this rule, in Example 4-16, the else in Line 3 is paired with the if in Line 1. The else
in Line 6 is paired with the if in Line 4, and the else in Line 9 is paired with the if in Line 7.
This means that the block for each else extends from the else all the way to line 10.
To avoid excessive indentation, the code in Example 4-16 can be rewritten as follows:
if (balance > 50000.00)
interestRate = 0.07;
else if (balance >= 25000.00)
interestRate = 0.05;
else if (balance >= 1000.00)
interestRate = 0.03;
else
interestRate = 0.00;

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7
8

The following examples will help you to see the various ways in which you can use
nested if structures to implement multiple selection.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

207

EXAMPLE 4-17
Assume that score is a variable of type int. Based on the value of score, the following
code outputs the grade:
if (score >= 90)
cout << "The grade
else if (score >= 80)
cout << "The grade
else if (score >= 70)
cout << "The grade
else if (score >= 60)
cout << "The grade
else
cout << "The grade

is A." << endl;
is B." << endl;

4

is C." << endl;
is D." << endl;
is F." << endl;

EXAMPLE 4-18
Assume that all variables are properly declared, and consider the following statements:
if (temperature >= 50)
if (temperature >= 80)
cout << "Good day for swimming." << endl;
else
cout << "Good day for golfing." << endl;
else
cout << "Good day to play tennis." << endl;

//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7

In this C++ code, the else in Line 4 is paired with the if in Line 2, and the else in Line 6
is paired with the if in Line 1. Note that the else in Line 4 cannot be paired with the if in
Line 1. If you pair the else in Line 4 with the if in Line 1, the if in Line 2 becomes the
action statement part of the if in Line 1, leaving the else in Line 6 dangling. Also, the
statements in Lines 2 though 5 form the statement part of the if in Line 1. The indentation
does not determine the pairing, but should be used to communicate the pairing.

EXAMPLE 4-19
Assume that all variables are properly declared, and consider the following statements:
if (temperature >= 70)
if (temperature >= 80)
cout << "Good day for swimming." << endl;
else
cout << "Good day for golfing." << endl;

//Line
//Line
//Line
//Line
//Line

1
2
3
4
5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

208 |

Chapter 4: Control Structures I (Selection)

In this code, the else in Line 4 is paired with the if in Line 2. Note that for the else in
Line 4, the most recent incomplete if is in Line 2. In this code, the if in Line 1 has no
else and is a one-way selection. Once again, the indentation does not determine the
pairing, but it communicates the pairing. Note that if the value of temperature is less
than 70, this code renders no decision.

EXAMPLE 4-20
Assume that all variables are properly declared, and consider the following statements:
if (gender == 'M')
if (age < 21 )
policyRate
else
policyRate
else if (gender ==
if (age < 21 )
policyRate
else
policyRate

= 0.05;
= 0.035;
'F')
= 0.04;
= 0.03;

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7
8
9
10

In this code, the else in Line 4 is paired with the if in Line 2. Note that for the else in
Line 4, the most recent incomplete if is the if in Line 2. The else in Line 6 is paired
with the if in Line 1. The else in Line 9 is paired with the if in Line 7. Once again,
the indentation does not determine the pairing, but it communicates the pairing.

Comparing if...else Statements with a Series of if Statements
Consider the following C++ program segments, both of which accomplish the same task:
a.

if (month == 1)
cout << "January" << endl;
else if (month == 2)
cout << "February" << endl;
else if (month == 3)
cout << "March" << endl;
else if (month == 4)
cout << "April" << endl;
else if (month == 5)
cout << "May" << endl;
else if (month == 6)
cout << "June" << endl;

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7
8
9
10
11
12

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

209

b. if (month == 1)
cout << "January" << endl;
if (month == 2)
cout << "February" << endl;
if (month == 3)
cout << "March" << endl;
if (month == 4)
cout << "April" << endl;
if (month == 5)
cout << "May" << endl;
if (month == 6)
cout << "June" << endl;

Program segment (a) is written as a sequence of if. . .else statements; program segment
(b) is written as a series of if statements. Both program segments accomplish the same
thing. If month is 3, then both program segments output March. If month is 1, then in
program segment (a), the expression in the if statement in Line 1 evaluates to true. The
statement (in Line 2) associated with this if then executes; the rest of the structure,
which is the else of this if statement, is skipped; and the remaining if statements are
not evaluated. In program segment (b), the computer has to evaluate the expression in
each if statement because there is no else statement. As a consequence, program
segment (b) executes more slowly than does program segment (a).
In a sequence of if...else statements, such as (a), if more than one condition is true,
only the statements associated with the first true condition will be executed. On the
other hand, in a series of if statements, such as (b), if more than one condition evaluates
to true, statements associated with each true condition will execute.

Short-Circuit Evaluation
Logical expressions in C++ are evaluated using a highly efficient algorithm. This algorithm is illustrated with the help of the following statements:
(x > y) || (x == 5)
(a == b) && (x >= 7)

//Line 1
//Line 2

In the statement in Line 1, the two operands of the operator || are the expressions
(x > y) and (x == 5). This expression evaluates to true if either the operand (x > y)
is true or the operand (x == 5) is true. With short-circuit evaluation, the computer
evaluates the logical expression from left to right. As soon as the final value of the
entire logical expression is known, the evaluation stops. For example, in statement 1,
if the operand (x > y) evaluates to true, then the entire expression evaluates to true
because true || true is true and true || false is true. Therefore, the value of
the operand (x == 5) has no bearing on the final outcome.
Similarly, in the statement in Line 2, the two operands of the operator && are (a == b)
and (x >= 7). If the operand (a == b) evaluates to false, then the entire expression
evaluates to false because false && true is false and false && false is false.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

210 |

Chapter 4: Control Structures I (Selection)

Short-circuit evaluation (of a logical expression): A process in which the computer evaluates
a logical expression from left to right and stops as soon as the final value of the expression is
known.
EXAMPLE 4-21
Consider the following expressions:
(age >= 21) || ( x == 5)
(grade == 'A') && (x >= 7)

//Line 1
//Line 2

For the expression in Line 1, suppose that the value of age is 25. Because (25 >= 21) is
true and the logical operator used in the expression is ||, the expression evaluates to true.
Due to short-circuit evaluation, the computer does not evaluate the expression (x == 5).
Similarly, for the expression in Line 2, suppose that the value of grade is 'B'. Because
('B' == 'A') is false and the logical operator used in the expression is &&, the expression
evaluates to false. The computer does not evaluate (x >= 7).

Comparing Floating-Point Numbers for Equality: A Precaution
Comparison of floating-point numbers for equality may not behave as you would expect.
For example, consider the following program:
#include <iostream>
#include <iomanip>
#include <cmath>
using namespace std;
int main()
{
double x = 1.0;
double y = 3.0 / 7.0 + 2.0 / 7.0 + 2.0 / 7.0;
cout << flixed << showpoint << setprecision(17);
cout << "3.0 / 7.0 + 2.0 / 7.0 + 2.0 / 7.0 = "
<< 3.0 / 7.0 + 2.0 / 7.0 + 2.0 / 7.0 << endl;
cout << "x = " << x << endl;
cout << "y = " << y << endl;
if (x == y)
cout << "x and y are the same." << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

211

else
cout << "x and y are not the same." << endl;
if (fabs(x
cout <<
<<
else
cout <<
<<

- y) < 0.000001)
"x and y are the same within the tolerance "
"0.000001." << endl;
" x and y are not the same within the "
"tolerance 0.000001." << endl;

return 0;
}

Sample Run:
3.0 / 7.0 + 2.0 / 7.0 + 2.0 / 7.0 = 0.99999999999999989
x = 1.00000000000000000
y = 0.99999999999999989
x and y are not the same.
x and y are the same within the tolerance 0.000001.

In this program, x is initialized to 1.0 and y is initialized to 3.0 / 7.0 + 2.0 / 7.0 + 2.0 /
7.0. Now, due to rounding, as shown by the output, this expression evaluates to
0.99999999999999989. Therefore, the expression (x == y) evaluates to false. However,
if you evaluate the expression 3.0 / 7.0 + 2.0 / 7.0 + 2.0 / 7.0 by hand using a paper and
a pencil, you will get 3.0 / 7.0 + 2.0 / 7.0 + 2.0 / 7.0 = (3.0 + 2.0 + 2.0) / 7.0 = 7.0 /
7.0 = 1.0. That is, the value of y should be set to 1.0 and x should be equal to y.
The preceding program and its output show that you should be careful when comparing
floating-point numbers for equality. One way to check whether two floating-point
numbers are equal is to check whether the absolute value of their difference is less than a
certain tolerance. For example, suppose the tolerance is 0.000001. Then, x and y are equal
if the absolute value of (x – y) is less than 0.000001. To find the absolute value, you can
use the function fabs (find the absolute value of a floating-point number), of the header
file cmath, as shown in the program. Therefore, the expression fabs(x – y) < 0.000001
determines whether the absolute value of (x – y) is less than 0.000001.

Associativity of Relational Operators: A Precaution
Sometimes logical expressions do not behave as you might expect, as shown by the
following program, which determines if a number is between 0 and 10 (inclusive).
#include <iostream>
using namespace std;
int main()
{
int num;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

212 |

Chapter 4: Control Structures I (Selection)

cout << "Enter an integer: ";
cin >> num;
cout << endl;
if (0 <= num <= 10)
cout << num << " is within 0 and 10." << endl;
else
cout << num << " is not within 0 and 10." << endl;
return 0;
}

Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1:
Enter an integer: 5
5 is within 0 and 10.

Sample Run 2:
Enter an integer: 20
20 is within 0 and 10.

Sample Run 3:
Enter an integer: -10
-10 is within 0 and 10.

Clearly, Sample Run 1 is correct and Sample Runs 2 and 3 are incorrect. Now, the if
statement is supposed to determine whether an integer is between 0 and 10. It appears
that this is not the case. So the problem is in the expression in the if statement. Let us look
at this expression, which is:
0 <= num <= 10

Although this statement is a legal C++ expression, you do not get the desired result. Let us
evaluate this expression for certain values of num. Suppose that the value of num is 5. Then:
0 <= num <= 10

= 0 <= 5 <= 10
= (0 <= 5) <= 10

(Because relational operators
are evaluated from left to right)

= 1 <= 10

(Because 0 <= 5 is true, 0 <= 5
evaluates to 1)

= 1

(true)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

213

Now, suppose that num = 20. Then:
0 <= num <= 10

= 0 <= 20 <= 10
= (0 <= 20) <= 10

(Because relational operators are
evaluated from left to right)

= 1 <= 10

(Because 0 <= 20 is true, 0
<= 20 evaluates to 1)

= 1

(true)

Now, you can see why the expression evaluates to true when num is 20. Similarly, if
num is 10, the expression 0 <= num <= 10 evaluates to true. In fact, this expression will
always evaluate to true, no matter what num is. This is due to the fact that the expression
0 <= num evaluates to either 0 or 1, and 0 <= 10 is true and 1 <= 10 is true. So what is
wrong with the expression 0 <= num <= 10? It is missing the logical operator &&. A correct
way to write this expression in C++ is:
0 <= num && num <= 10

Using the precedence of operators the expression 0 <= num && num <= 10 is the same as
(0 <= num) && (num <= 10).
You must take care when formulating logical expressions. When creating a complex
logical expression, you must use the proper logical operators.

Avoiding Bugs by Avoiding Partially Understood
Concepts and Techniques
The debugging sections in Chapters 2 and 3 illustrated how to understand and fix syntax
and logic errors. In this section, we illustrate how to avoid bugs by avoiding partially
understood concepts and techniques.
The programs that you have written until now should have illustrated that a small error
such as the omission of a semicolon at the end of a variable declaration or using a variable
without properly declaring it can prevent a program from successfully compiling. Similarly, using a variable without properly initializing it can prevent a program from running
correctly. Recall that the condition associated with an if statement must be enclosed in
parentheses. Therefore, the following expression will result in a syntax error:
if score >= 90

Example 4-12 illustrates that an unintended semicolon following the condition of the
following if statement:
if (hours > 40.0);

can prevent successful compilation or correct execution.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

214 |

Chapter 4: Control Structures I (Selection)

The approach that you take to solve a problem must use concepts and techniques correctly;
otherwise, your solution will be either incorrect or deficient. The problem of using partially
understood concepts and techniques can be illustrated by the following program.
Suppose that we want to write a program that analyzes students’ GPAs. If the GPA is
greater than or equal to 3.9, the student makes the dean’s honor list. If the GPA is less
than 2.00, the student is sent a warning letter indicating that the GPA is below the
graduation requirement. So, consider the following program:
//GPA program with bugs.
#include <iostream>

//Line 1

using namespace std;

//Line 2

int main()
{
double gpa;

//Line 3
//Line 4
//Line 5

cout << "Enter the GPA: ";
cin >> gpa;
cout << endl;

//Line 6
//Line 7
//Line 8

if (gpa >= 2.0)
if (gpa >= 3.9)
cout << "Dean\’s Honor List." << endl;
else
cout << "The GPA is below the graduation "
<< "requirement. \nSee your "
<< "academic advisor." << endl;

//Line
//Line
//Line
//Line

return 0;

//Line 14
//Line 15

}

9
10
11
12

//Line 13

Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1:
Enter the GPA: 3.91
Dean's Honor List.

Sample Run 2:
Enter the GPA: 3.8
The GPA is below the graduation requirement.
See your academic advisor.

Sample Run 3:
Enter the GPA: 1.95

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

215

Let us look at these sample runs. Clearly, the output in Sample Run 1 is correct. In
Sample Run 2, the input is 3.8 and the output indicates that this GPA is below the
graduation requirement. However, a student with a GPA of 3.8 would graduate with
some type of honor. So, the output in Sample Run 2 is incorrect. In Sample Run 3, the
input is 1.95, and the output does not show any warning message. Therefore, the output
in Sample Run 3 is also incorrect. It means that the if. . .else statement in Lines 9 to 13
is incorrect. Let us look at these statements, that is:
if (gpa >= 2.0)
if (gpa >= 3.9)
cout << "Dean\'s Honor List." << endl;
else
cout << "The GPA is below the graduation "
<< "requirement. \nSee your "
<< "academic advisor." << endl;

//Line
//Line
//Line
//Line

9
10
11
12

//Line 13

Following the rule of pairing an else with an if, the else in Line 12 is paired with the
if in Line 10. In other words, using the correct indentation, the code is:
if (gpa >= 2.0)
if (gpa >= 3.9)
cout << "Dean\'s Honor List." << endl;
else
cout << "The GPA is below the graduation "
<< "requirement. \nSee your "
<< "academic advisor." << endl;

//Line
//Line
//Line
//Line

9
10
11
12

//Line 13

Now, we can see that the if statement in Line 9 is a one-way selection. Therefore, if the
input number is less than 2.0, no action will take place, that is, no warning message will
be printed. Now, suppose the input is 3.8. Then, the expression in Line 9 evaluates to
true, so the expression in Line 10 is evaluated, which evaluates to false. This means the
output statement in Line 13 executes, resulting in an unsatisfactory result.
In fact, the program should print the warning message only if the GPA is less than 2.0, and
it should print the message:
Dean's Honor List.

if the GPA is greater than or equal to 3.9.
To achieve that result, the else in Line 12 needs to be paired with the if in Line 9. To
pair the else in Line 12 with the if in Line 9, you need to use a compound statement, as
follows:
if (gpa >= 2.0)
{
if (gpa >= 3.9)
cout << "Dean\'s Honor List." << endl;
}
else
cout << "The GPA is below the graduation "
<< "requirement. \nSee your "
<< "academic advisor." << endl;

//Line 9
//Line 10
//Line 11
//Line 12
//Line 13

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

216 |

Chapter 4: Control Structures I (Selection)

The correct program is as follows:
//Correct GPA program.
#include <iostream>

//Line 1

using namespace std;

//Line 2

int main()
{
double gpa;

//Line 3
//Line 4
//Line 5

cout << "Enter the GPA: ";
cin >> gpa;
cout << endl;

//Line 6
//Line 7
//Line 8

if (gpa >= 2.0)
{
if (gpa >= 3.9)
cout << "Dean\’s Honor List." << endl;
}
else
cout << "The GPA is below the graduation "
<< "requirement. \nSee your "
<< "academic advisor." << endl;

//Line
//Line
//Line
//Line
//Line
//Line

return 0;

//Line 16
//Line 17

}

9
10
11
12
13
14

//Line 15

Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1:
Enter the GPA: 3.91
Dean’s Honor List.

Sample Run 2:
Enter the GPA: 3.8

Sample Run 3:
Enter the GPA: 1.95
The GPA is below the graduation requirement.
See your academic advisor.

In cases such as this one, the general rule is that you cannot look inside of a block (that is,
inside the braces) to pair an else with an if. The else in Line 14 cannot be paired with
the if in Line 11 because the if statement in Line 11 is enclosed within braces, and the
else in Line 14 cannot look inside those braces. Therefore, the else in Line 14 is paired
with the if in Line 9.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

217

In this book, the C++ programming concepts and techniques are presented in a logical
order. Understanding a concept or technique completely before using it will save you an
enormous amount of debugging time.

Input Failure and the if Statement
In Chapter 3, you saw that an attempt to read invalid data causes the input stream to enter a
fail state. Once an input stream enters a fail state, all subsequent input statements associated
with that input stream are ignored, and the computer continues to execute the program,
which produces erroneous results. You can use if statements to check the status of an input
stream variable and, if the input stream enters the fail state, include instructions that stop
program execution.
In addition to reading invalid data, other events can cause an input stream to enter the fail
state. Two additional common causes of input failure are the following:
•
•

Attempting to open an input file that does not exist
Attempting to read beyond the end of an input file

One way to address these causes of input failure is to check the status of the
input stream variable. You can check the status by using the input stream variable as the
logical expression in an if statement. If the last input succeeded, the input stream
variable evaluates to true; if the last input failed, it evaluates to false.
The statement:
if (cin)
cout << "Input is OK." << endl;

prints:
Input is OK.

if the last input from the standard input device succeeded. Similarly, if infile is an
ifstream variable, the statement:
if (!infile)
cout << "Input failed." << endl;

prints:
Input failed.

if the last input associated with the stream variable infile failed.
Suppose an input stream variable tries to open a file for inputting data into a program. If
the input file does not exist, you can use the value of the input stream variable, in
conjunction with the return statement, to terminate the program.
Recall that the last statement included in the function main is:
return 0;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

218 |

Chapter 4: Control Structures I (Selection)

This statement returns a value of 0 to the operating system when the program terminates.
A value of 0 indicates that the program terminated normally and that no error occurred
during program execution. Values of type int other than 0 can also be returned to the
operating system via the return statement. The return of any value other than 0,
however, indicates that something went wrong during program execution.
The return statement can appear anywhere in the program. Whenever a return
statement executes, it immediately exits the function in which it appears. In the case of
the function main, the program terminates when the return statement executes. You
can use these properties of the return statement to terminate the function main
whenever the input stream fails. This technique is especially useful when a program tries
to open an input file. Consider the following statements:
ifstream infile;
infile.open("inputdat.dat");

//open file inputdat.dat

if (!infile)
{
cout << "Cannot open the input file. "
<< "The program terminates." << endl;
return 1;
}

Suppose that the file inputdat.dat does not exist. The operation to open this file fails,
causing the input stream to enter the fail state. As a logical expression, the file stream
variable infile then evaluates to false. Because infile evaluates to false, the
expression !infile (in the if statement) evaluates to true, and the body of the if
statement executes. The message:
Cannot open the input file. The program terminates.

is printed on the screen, and the return statement terminates the program by returning a
value of 1 to the operating system.
Let’s now use the code that responds to input failure by including these features in
the Programming Example: Student Grade from Chapter 3. Recall that this program
calculates the average test score based on data from an input file and then outputs the
results to another file. The following programming code is the same as the code from
Chapter 3, except that it includes statements to exit the program if the input file does
not exist.
//Program to calculate the average test score.
#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

int main()
{
ifstream inFile;
ofstream outFile;

219

//input file stream variable
//output file stream variable

double test1, test2, test3, test4, test5;
double average;
string firstName;
string lastName;
inFile.open("test.txt"); //open the input file
if (!inFile)
{
cout << "Cannot open the input file. "
<< "The program terminates." << endl;
return 1;
}
outFile.open("testavg.out");

//open the output file

outFile << fixed << showpoint;
outFile << setprecision(2);
cout << "Processing data" << endl;
inFile >> firstName >> lastName;
outFile << "Student name: " << firstName
<< " " << lastName << endl;
inFile >> test1 >> test2 >> test3
>> test4 >> test5;
outFile << "Test scores: " << setw(4) << test1
<< setw(4) << test2 << setw(4) << test3
<< setw(4) << test4 << setw(4) << test5
<< endl;
average = (test1 + test2 + test3 + test4 + test5) / 5.0;
outFile << "Average test score: " << setw(6)
<< average << endl;
inFile.close();
outFile.close();
return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

220 |

Chapter 4: Control Structures I (Selection)

Confusion between the Equality Operator (==) and the
Assignment Operator (=)
Recall that if the decision-making expression in the if structure evaluates to true, the
statement part of the if structure executes. In addition, the expression is usually a logical
expression. However, C++ allows you to use any expression that can be evaluated to either
true or false as an expression in the if structure. Consider the following statement:
if (x = 5)
cout << "The value is five." << endl;

The expression—that is, the decision maker—in the if statement is x = 5. The
expression x = 5 is called an assignment expression because the operator = appears in
the expression and there is no semicolon at the end.
This expression is evaluated as follows. First, the right side of the operator = is evaluated,
which evaluates to 5. The value 5 is then assigned to x. Moreover, the value 5—that is, the
new value of x—also becomes the value of the expression in the if statement—that is, the
value of the assignment expression. Because 5 is nonzero, the expression in the if statement
evaluates to true, so the statement part of the if statement outputs: The value is five.
In general, the expression x = a, where a is a nonzero integer, will always evaluate to true.
However, the expression x = 0 will evaluate to false.
No matter how experienced a programmer is, almost everyone makes the mistake of
using = in place of == at one time or another. One reason why these two operators are
often confused is that some programming languages use = as an equality operator. Thus,
experience with such programming languages can create confusion. Sometimes the error
is merely typographical, another reason to be careful when typing code.
Despite the fact that an assignment expression can be used as an expression, using the
assignment operator in place of the equality operator can cause serious problems in a
program. For example, suppose that the discount on a car insurance policy is based on the
insured’s driving record. A driving record of 1 means that the driver is accident-free and
receives a 25% discount on the policy. The statement:
if (drivingCode == 1)
cout << "The discount on the policy is 25%." << endl;

outputs:
The discount on the policy is 25%.

only if the value of drivingCode is 1. However, the statement:
if (drivingCode = 1)
cout << "The discount on the policy is 25%." << endl;

always outputs:
The discount on the policy is 25%.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Control Structures |

221

because the right side of the assignment expression evaluates to 1, which is nonzero and so
evaluates to true. Therefore, the expression in the if statement evaluates to true,
outputting the following line of text: The discount on the policy is 25%. Also, the
value 1 is assigned to the variable drivingCode. Suppose that before the if statement
executes, the value of the variable drivingCode is 4. After the if statement executes, not
only is the output wrong, but the new value also replaces the old driving code.
The appearance of = in place of == resembles a silent killer. It is not a syntax error, so the
compiler does not warn you of an error. Rather, it is a logical error.
Using = in place of == can cause serious problems, especially if it happens in a looping
statement. Chapter 5 discusses looping structures.

The appearance of the equality operator in place of the assignment operator can also cause
errors in a program. For example, suppose x, y, and z are int variables. The statement:
x = y + z;

assigns the value of the expression y + z to x. The statement:
x == y + z;

compares the value of the expression y + z with the value of x; the value of x remains the
same, however. If somewhere else in the program you are counting on the value of x
being y + z, a logic error will occur, the program output will be incorrect, and you will
receive no warning of this situation from the compiler. The compiler only provides
feedback about syntax errors, not logic errors. For this reason, you must use extra care
when working with the equality operator and the assignment operator.

Conditional Operator (?:)
The reader can skip this section without any discontinuation.

Certain if. . .else statements can be written in a more concise way by using C++’s
conditional operator. The conditional operator, written as ?:, is a ternary operator,
which means that it takes three arguments. The syntax for using the conditional operator is:
expression1 ? expression2 : expression3

This type of statement is called a conditional expression. The conditional expression is
evaluated as follows: If expression1 evaluates to a nonzero integer (that is, to true), the
result of the conditional expression is expression2. Otherwise, the result of the conditional expression is expression3.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

222 |

Chapter 4: Control Structures I (Selection)

Consider the following statements:
if (a >= b)
max = a;
else
max = b;

You can use the conditional operator to simplify the writing of this if. . .else statement
as follows:
max = (a >= b) ? a : b;

Program Style and Form (Revisited): Indentation
In the section ‘‘Program Style and Form’’ of Chapter 2, we specified some guidelines to
write programs. Now that we have started discussing control structures, in this section,
we give some general guidelines to properly indent your program.
As you write programs, typos and errors are unavoidable. If your program is properly
indented, you can spot and fix errors quickly, as shown by several examples in this
chapter. Typically, the IDE that you use will automatically indent your program. If for
some reason your IDE does not indent your program, you can indent your program
yourself.
Proper indentation can show the natural grouping and subordination of statements. You
should insert a blank line between statements that are naturally separate. In this book, the
statements inside braces, the statements of a selection structure, and an if statement
within an if statement are all indented four spaces to the right. Throughout the book,
we use four spaces to indent statements, especially to show the levels of control structures
within other control structures. Note that for larger more complex programs, there is a
tradeoff with the indentation spacing and readability due to continuation lines. Some
programs indent only two or three spaces if there are several levels of subordination.
There are two commonly used styles for placing braces. In this book, we place braces
on a line by themselves. Also, matching left and right braces are in the same column,
that is, they are the same number of spaces away from the left margin. This style of
placing braces easily shows the grouping of the statements and also matches left and
right braces. You can also follow this style to place and indent braces.
In the second style of placing braces, the left brace need not be on a line by itself.
Typically, for control structures, the left brace is placed after the last right parenthesis of
the (logical) expression, and the right brace is on a line by itself. This style might save
some vertical space. However, sometimes this style might not immediately show the
grouping or the block of the statements and results in slightly poorer readability.
No matter what style of indentation you use, you should be consistent within your
programs, and the indentation should show the structure of the program.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Using Pseudocode to Develop, Test, and Debug a Program |

223

Using Pseudocode to Develop, Test,
and Debug a Program
There are several ways to develop a program. One method involves using an informal
mixture of C++ and ordinary language, called pseudocode or just pseudo. Sometimes
pseudo provides a useful means to outline and refine a program before putting it into
formal C++ code. When you are constructing programs that involve complex nested
control structures, pseudo can help you quickly develop the correct structure of the
program and avoid making common errors.
One useful program segment determines the larger of two integers. If x and y are integers,
using pseudo, you can quickly write the following:
a.

if (x > y) then
x is larger

b.

if (y > x) then
y is larger

If the statement in (a) is true, then x is larger. If the statement in (b) is true, then y is
larger. However, for this code to work in concert to determine the larger of two integers,
the computer needs to evaluate both expressions:
(x > y)

and

(y > x)

even if the first statement is true. Evaluating both expressions when the first one is true
is a waste of computer time.
Let’s rewrite this pseudo as follows:
if (x > y) then
x is larger
else
y is larger

Here, only one condition needs to be evaluated. This code looks okay, so let’s put it
into C++.
#include <iostream>
using namespace std;
int main()
{
if (x > y)

Wait . . . once you begin translating the pseudo into a C++ program, you should immediately notice that there is no place to store the value of x or y. The variables were not
declared, which is a very common oversight, especially for new programmers. If you
examine the pseudo, you will see that the program needs three variables, and you might
as well make them self-documenting. Let’s start the program code again:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

224 |

Chapter 4: Control Structures I (Selection)

#include <iostream>
using namespace std;
int main()
{
int num1, num2, larger;
if

(num1 > num2);
larger = num1;
else
larger = num2;
return

//Line 1
//Line
//Line
//Line
//Line

2; error
3
4
5

0;

}

Compiling this program will result in the identification of a common syntax error
(in Line 2). Recall that a semicolon cannot appear after the expression in the
if. . .else statement. However, even after you correct this syntax error, the program
still would not give satisfactory results because it tries to use identifiers that have no
values. The variables have not been initialized, which is another common error. In
addition, because there are no output statements, you would not be able to see the results
of the program.
Because there are so many mistakes in the program, you should try a walk-through to see
whether it works at all. You should always use a wide range of values in several
walkthroughs to evaluate the program under as many different circumstances as possible. For
example, does this program work if one number is zero, if one number is negative and the other
number is positive, if both numbers are negative, or if both numbers are the same? Examining
the program, you can see that it does not check whether the two numbers are equal. Taking all of
these points into account, you can rewrite the program as follows:
//Program: Compare Numbers
//This program compares two integers and outputs the largest.
#include <iostream>
using namespace std;
int main()
{
int num1, num2;
cout << "Enter any two integers: ";
cin >> num1 >> num2;
cout << endl;
cout << "The two integers entered are " << num1
<< " and " << num2 << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

switch Structures | 225

if (num1 > num2)
cout << "The larger number is " << num1 << endl;
else if (num2 > num1)
cout << "The larger number is " << num2 << endl;
else
cout << "Both numbers are equal." << endl;
return 0;
}

Sample Run: In this sample run, the user input is shaded.
Enter any two integers: 78 90
The two integers entered are 78 and 90
The larger number is 90

One thing you can learn from the preceding program is that you must first develop a
program using paper and pencil. Although a program that is first written on a piece of paper is
not guaranteed to run successfully on the first try, this step is still a good starting point. On
paper, it is easier to spot errors and improve the program, especially with large programs.

switch Structures
Recall that there are two selection, or branch, structures in C++. The first selection structure,
which is implemented with if and if. . .else statements, usually requires the evaluation of a
(logical) expression. The second selection structure, which does not require the evaluation of
a logical expression, is called the switch structure. C++’s switch structure gives the
computer the power to choose from among many alternatives.
A general syntax of the switch statement is:
switch (expression)
{
case value1:
statements1
break;
case value2:
statements2
break;

.
.
.
case valuen:
statementsn
break;
default:
statements

In C++, switch, case, break, and default are reserved words. In a switch structure, first
the expression is evaluated. The value of the expression is then used to choose and
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

226 |

Chapter 4: Control Structures I (Selection)

perform the actions specified in the statements that follow the reserved word case. Recall that
in a syntax, shading indicates an optional part of the definition.
Although it need not be, the expression is usually an identifier. Whether it is an identifier or
an expression, the value can be only integral. The expression is sometimes called the selector.
Its value determines which statement is selected for execution. A particular case value should
appear only once. One or more statements may follow a case label, so you do not need to use
braces to turn multiple statements into a single compound statement. The break statement may
or may not appear after each statement. The general diagram to show the syntax of the switch
statement is not straightforward because following a case label a statement and/or a break
statement may or may not appear. Keeping these in mind, Figure 4-4 shows the flow of
execution of a switch statement. Note that in the figure following a case value, the box
containing statement and/or the box containing break may or may not appear. Following
the figure, we give the general rules that a switch statement follows.

expression
case value1

true

statements1

break

true

statements2

break

true

statementsn

break

false
case value2
false

false
case valuen
false
default

FIGURE 4-4

statements

switch statement

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

switch Structures | 227

The switch statement executes according to the following rules:
1. When the value of the expression is matched against a case
value (also called a label), the statements execute until either a
break statement is found or the end of the switch structure is
reached.
2. If the value of the expression does not match any of the case values,
the statements following the default label execute. If the switch
structure has no default label and if the value of the expression
does not match any of the case values, the action of the switch
statement is null.
3. A break statement causes an immediate exit from the switch structure.
EXAMPLE 4-22
Consider the following statements, in which grade is a variable of type char:
switch (grade)
{
case 'A':
cout << "The
break;
case 'B':
cout << "The
break;
case 'C':
cout << "The
break;
case 'D':
cout << "The
break;
case 'F':
cout << "The
break;
default:
cout << "The
}

grade point is 4.0.";

grade point is 3.0.";

grade point is 2.0.";

grade point is 1.0.";

grade point is 0.0.";

grade is invalid.";

In this switch statement, the expression, grade, is a variable of type char, which is an
integral type. The possible values of grade are 'A', 'B', 'C', 'D', and 'F'. Each case
label specifies a different action to take, depending on the value of grade. If the value of
grade is 'A', the output is:
The grade point is 4.0.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

228 |

Chapter 4: Control Structures I (Selection)

EXAMPLE 4-23
The following program illustrates the effect of the break statement. It asks the user to
input a number between 0 and 7.
//Program: Effect of break statements in a switch structure
#include <iostream>
using namespace std;
int main()
{
int num;
cout << "Enter an integer between 0 and 7: ";
cin >> num;
cout << endl;
cout << "The number you entered is " << num
<< endl;

//Line 1
//Line 2
//Line 3

switch (num)
{
case 0:
case 1:
cout << "Learning to use ";
case 2:
cout << "C++'s ";
case 3:
cout << "switch structure." << endl;
break;
case 4:
break;
case 5:
cout << "This program shows the effect ";
case 6:
case 7:
cout << "of the break statement." << endl;
break;
default:
cout << "The number is out of range." << endl;
}

//Line 5

//Line 4

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23

cout << "Out of the switch structure." << endl;

//Line 24

return 0;

//Line 25

}

Sample Runs: These outputs were obtained by executing the preceding program several
times. In each of these sample runs, the user input is shaded.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

switch Structures | 229

Sample Run 1:
Enter an integer between 0 and 7: 0
The number you entered is 0
Learning to use C++'s switch structure.
Out of the switch structure.

Sample Run 2:
Enter an integer between 0 and 7: 2
The number you entered is 2
C++'s switch structure.
Out of the switch structure.

Sample Run 3:
Enter an integer between 0 and 7: 4
The number you entered is 4
Out of the switch structure.

Sample Run 4:
Enter an integer between 0 and 7: 5
The number you entered is 5
This program shows the effect of the break statement.
Out of the switch structure.

Sample Run 5:
Enter an integer between 0 and 7: 7
The number you entered is 7
of the break statement.
Out of the switch structure.

Sample Run 6:
Enter an integer between 0 and 7: 8
The number you entered is 8
The number is out of range.
Out of the switch structure.

A walk-through of this program, using certain values of the switch expression num,
can help you understand how the break statement functions. If the value of num is 0,
the value of the switch expression matches the case value 0. All statements following
case 0: execute until a break statement appears.
The first break statement appears in Line 13, just before the case value of 4. Even
though the value of the switch expression does not match any of the case values 1, 2,
or 3, the statements following these values execute.
When the value of the switch expression matches a case value, all statements execute
until a break is encountered, and the program skips all case labels in between. Similarly,
if the value of num is 3, it matches the case value of 3, and the statements following this
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

230 |

Chapter 4: Control Structures I (Selection)

label execute until the break statement is encountered in Line 13. If the value of num is
4, it matches the case value of 4. In this situation, the action is empty because only the
break statement, in Line 15, follows the case value of 4.

EXAMPLE 4-24
Although a switch structure’s case values (labels) are limited, the switch statement
expression can be as complex as necessary. For example, consider the following
switch statement:
switch (score / 10)
{
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
grade = 'F';
break;
case 6:
grade = 'D';
break;
case 7:
grade = 'C';
break;
case 8:
grade = 'B';
break;
case 9:
case 10:
grade = 'A';
break;
default:
cout << "Invalid test score." << endl;
}

Assume that score is an int variable with values between 0 and 100. If score is 75,
score / 10 = 75 / 10 = 7, and the grade assigned is 'C'. If the value of score is between
0 and 59, the grade is 'F'. If score is between 0 and 59, then score / 10 is 0, 1, 2, 3, 4,
or 5. Each of these values corresponds to the grade 'F'.
Therefore, in this switch structure, the action statements of case 0, case 1, case 2,
case 3, case 4, and case 5 are all the same. Rather than write the statement grade =
'F'; followed by the break statement for each of the case values of 0, 1, 2, 3, 4, and 5,
you can simplify the programming code by first specifying all of the case values (as shown
in the preceding code) and then specifying the desired action statement. The case values
of 9 and 10 follow similar conventions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

switch Structures | 231

In addition to being a variable identifier or a complex expression, the switch expression
can evaluate to a logical value. Consider the following statements:
switch (age
{
case 1:
cout <<
cout <<
break;
case 0:
cout <<
cout <<
}

>= 18)

"Old enough to be drafted." << endl;
"Old enough to vote." << endl;

"Not old enough to be drafted." << endl;
"Not old enough to vote." << endl;

If the value of age is 25, the expression age >= 18 evaluates to 1—that is, true. If
the expression evaluates to 1, the statements following the case label 1 execute. If the
value of age is 14, the expression age >= 18 evaluates to 0—that is, false—and the
statements following the case label 0 execute.
You can use true and false, instead of 1 and 0, respectively, in the case labels, and
rewrite the preceding switch statement as follows:
switch (age
{
case true:
cout <<
cout <<
break;
case false:
cout <<
cout <<
}

>= 18)

"Old enough to be drafted." << endl;
"Old enough to vote." << endl;

"Not old enough to be drafted." << endl;
"Not old enough to vote." << endl;

You can use a nested switch statement to incorporate multilevel selections such as
the following:
switch (age >= 18)
{
case true:
cout << "Old enough to be drafted." << endl;
cout << "Old enough to vote." << endl;
switch (age >= 21)
{
case true:
cout << "Old enough to drink." << endl;
break;
case false:
cout << "Not old enough to drink." << endl;
}
break;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

232 |

Chapter 4: Control Structures I (Selection)

case false:
cout << "Not old enough to be drafted." << endl;
cout << "Not old enough to vote." << endl;
cout << "Not old enough to drink." << endl;
}

As you can see from the preceding examples, the switch statement is an elegant way to
implement multiple selections. You will see the use of a switch statement in the programming example at the end of this chapter. Even though no fixed rules exist that can be applied
to decide whether to use an if. . .else structure or a switch structure to implement
multiple selections, the following considerations should be remembered. If multiple selections involve a range of values, you can use either a switch structure (wherein you convert
each range to a finite set of values), or an if...else structure.
For instance, in Example 4-24, the value of grade depends on the value of score. If
score is between 0 and 59, grade is 'F'. Because score is an int variable, 60 values
correspond to the grade of 'F'. If you list all 60 values as case values, the switch
statement could be very long. However, dividing by 10 reduces these 60 values to only 6
values: 0, 1, 2, 3, 4, and 5.
If the range of values consists of infinitely many values and you cannot reduce them to a set
containing a finite number of values, you must use the if. . .else structure. For example, if
score happens to be a double variable and fractional scores are possible, the number of values
between 0 and 60 is infinite. However, you can use the expression static_cast<int>
(score) / 10 and still reduce this infinite number of values to just six values.

Avoiding Bugs by Avoiding Partially Understood Concepts
and Techniques (Revisited)
Earlier in this chapter, we discussed how a partial understanding of a concept or technique
can lead to errors in a program. In this section, we give another example to illustrate the
problem of using partially understood concepts and techniques. In Example 4-24, we
illustrate how to assign a grade based on a test score between 0 and 100. Next, consider
the following program that assigns a grade based on a test score:
//Grade program with bugs.
#include <iostream>

//Line 1

using namespace std;

//Line 2

int main()
{
int testScore;

//Line 3
//Line 4
//Line 5

cout << "Enter the test score: ";
cin >> testScore;

//Line 6
//Line 7

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

switch Structures | 233

cout << endl;

//Line 8

switch (testScore / 10)
{
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
cout << "The grade is
case 6:
cout << "The grade is
case 7:
cout << "The grade is
case 8:
cout << "The grade is
case 9:
case 10:
cout << "The grade is
default:
cout << "Invalid test
}

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//LIne
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

F." << endl;
D." << endl;
C." << endl;
B." << endl;

A." << endl;
score." << endl;

return 0;
}

9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29

//Line 30
//Line 31

Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1:
Enter the test score: 110
Invalid test score.

Sample Run 2:
Enter the test score: -70
Invalid test score.

Sample Run 3:
Enter the test score: 75
The grade is
The grade is
The grade is
Invalid test

C.
B.
A.
score.

From these sample runs, it follows that if the value of testScore is less than 0 or greater
than 100, the program produces correct results, but if the value of testScore is between
0 and 100, say 75, the program produces incorrect results. Can you see why?

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

234 |

Chapter 4: Control Structures I (Selection)

As in Sample Run 3, suppose that the value of testScore is 75. Then, testScore % 10 = 7,
and this value matched the case label 7. So, as we indented, it should print The grade is C.
However, the output is:
The grade is C.
The grade is B.
The grade is A.
Invalid test score.

But why? Clearly only at most one cout statement is associated with each case label.
The problem is a result of having only a partial understanding of how the switch
structure works. As we can see, the switch statement does not include any break
statement. Therefore, after executing the statement(s) associated with the matching case
label, execution continues with the statement(s) associated with the next case label,
resulting in the printing of four unintended lines.
To output results correctly, the switch structure must include a break statement after
each cout statement, except the last cout statement. We leave it as an exercise for you to
modify this program so that it outputs correct results.
Once again, we can see that a partially understood concept can lead to serious errors in a
program. Therefore, taking time to understand each concept and technique completely
will save you hours of debugging time.

Terminating a Program with the assert Function
Certain types of errors that are very difficult to catch can occur in a program. For
example, division by zero can be difficult to catch using any of the programming
techniques you have examined so far. C++ includes a predefined function, assert, that
is useful in stopping program execution when certain elusive errors occur. In the case of
division by zero, you can use the assert function to ensure that a program terminates
with an appropriate error message indicating the type of error and the program location
where the error occurred.
Consider the following statements:
int numerator;
int denominator;
int quotient;
double hours;
double rate;
double wages;
char ch;

1. quotient = numerator / denominator;
2. if (hours > 0 && (0 < rate && rate <= 15.50))
wages = rate * hours;

3. if ('A' <= ch && ch <= 'Z')

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Terminating a Program with the assert Function |

235

In the first statement, if the denominator is 0, logically you should not perform the
division. During execution, however, the computer would try to perform the division. If
the denominator is 0, the program would terminate with an error message stating that
an illegal operation has occurred.
The second statement is designed to compute wages only if hours is greater than 0 and
rate is positive and less than or equal to 15.50. The third statement is designed to
execute certain statements only if ch is an uppercase letter.
For all of these statements (for that matter, in any situation), if conditions are not met, it
would be useful to halt program execution with a message indicating where in the program
an error occurred. You could handle these types of situations by including output and return
statements in your program. However, C++ provides an effective method to halt a program
if required conditions are not met through the assert function.
The syntax to use the assert function is:
assert(expression);

Here, expression is any logical expression. If expression evaluates to true, the next
statement executes. If expression evaluates to false, the program terminates and indicates
where in the program the error occurred.
The specification of the assert function is found in the header file cassert. Therefore,
for a program to use the assert function, it must include the following statement:
#include <cassert>

A statement using the assert function is sometimes called an assert statement.
Returning to the preceding statements, you can rewrite statement 1 (quotient =
numerator / denominator;) using the assert function. Because quotient should
be calculated only if denominator is nonzero, you include an assert statement before
the assignment statement as follows:
assert(denominator);
quotient = numerator / denominator;

Now, if denominator is 0, the assert statement halts the execution of the program
with an error message similar to the following:
Assertion failed: denominator, file c:\temp\assert
function\assertfunction.cpp, line 20

This error message indicates that the assertion of denominator failed. The error message
also gives the name of the file containing the source code and the line number where the
assertion failed.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

236 |

Chapter 4: Control Structures I (Selection)

For readability, the previous code using the assert statement can also be written as:
assert(denominator != 0);
quotient = numerator / denominator;

The error message would be slightly different:
Assertion failed: denominator != 0, file c:\temp\assert
function\assertfunction.cpp, line 20

You can also rewrite statement 2 using an assertion statement as follows:
assert(hours > 0 && (0 < rate && rate <= 15.50));
if (hours > 0 && (0 < rate && rate <= 15.50))
wages = rate * hours;

If the expression in the assert statement fails, the program terminates with an error
message similar to the following:
Assertion failed: hours > 0 && (0 < rate && rate <= 15.50), file
c:\temp\assertfunction\assertfunction.cpp, line 26

During program development and testing, the assert statement is very useful for enforcing programming constraints. As you can see, the assert statement not only halts the
program, but also identifies the expression where the assertion failed, the name of the file
containing the source code, and the line number where the assertion failed.
Although assert statements are useful during program development, after a program has been
developed and put into use, if an assert statement fails for some reason, an end user would have
no idea what the error means. Therefore, after you have developed and tested a program, you
might want to remove or disable the assert statements. In a very large program, it could be
tedious, and perhaps impossible, to remove all of the assert statements that you used during
development. In addition, if you plan to modify a program in the future, you might like to keep
the assert statements. Therefore, the logical choice is to keep these statements but to disable
them. You can disable assert statements by using the following preprocessor directive:
#define NDEBUG

This preprocessor directive #define NDEBUG must be placed before the directive
#include <cassert>.

PROGRAMMING EXAMPLE:

Watch
the Video

Cable Company Billing

This programming example demonstrates a program that calculates a customer’s bill
for a local cable company. There are two types of customers: residential and business.
There are two rates for calculating a cable bill: one for residential customers and one
for business customers. For residential customers, the following rates apply:
•
•
•

Bill processing fee: $4.50
Basic service fee: $20.50
Premium channels: $7.50 per channel

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Cable Company Billing

|

237

For business customers, the following rates apply:
•
•
•

Bill processing fee: $15.00
Basic service fee: $75.00 for first 10 connections, $5.00 for each
additional connection
Premium channels: $50.00 per channel for any number of
connections

The program should ask the user for an account number (an integer) and a customer
code. Assume that R or r stands for a residential customer, and B or b stands for a
business customer

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Input

The customer’s account number, customer code, number of premium channels
to which the user subscribes, and, in the case of business customers, number of
basic service connections.

Output

Customer’s account number and the billing amount.

The purpose of this program is to calculate and print the billing amount. To calculate
the billing amount, you need to know the customer for whom the billing amount is
calculated (whether the customer is residential or business) and the number of
premium channels to which the customer subscribes. In the case of a business
customer, you also need to know the number of basic service connections and the
number of premium channels. Other data needed to calculate the bill, such as the bill
processing fees and the cost of a premium channel, are known quantities. The
program should print the billing amount to two decimal places, which is standard
for monetary amounts. This problem analysis translates into the following algorithm:
1. Set the precision to two decimal places.
2. Prompt the user for the account number and customer type.
3. Based on the customer type, determine the number of premium
channels and basic service connections, compute the bill, and print
the bill:
a. If the customer type is R or r,
i. Prompt the user for the number of premium channels.
ii. Compute the bill.
iii. Print the bill.
b. If the customer type is B or b,
i. Prompt the user for the number of basic service connections
and number of premium channels.
ii. Compute the bill.
iii. Print the bill.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

238 |

Chapter 4: Control Structures I (Selection)

Variables Because the program will ask the user to input the customer account number,

customer code, number of premium channels, and number of basic service
connections, you need variables to store all of this information. Also, because the
program will calculate the billing amount, you need a variable to store the billing
amount. Thus, the program needs at least the following variables to compute and
print the bill:
int accountNumber;

//variable to store the customer's
//account number
char customerType;
//variable to store the customer code
int numOfPremChannels; //variable to store the number
//of premium channels to which the
//customer subscribes
int numOfBasicServConn; //variable to store the
//number of basic service connections
//to which the customer subscribes
double amountDue; //variable to store the billing amount

Named As you can see, the bill processing fees, the cost of a basic service connection, and the
Constants cost of a premium channel are fixed, and these values are needed to compute the bill.

Although these values are constants in the program, the cable company can change
them with little warning. To simplify the process of modifying the program later,
instead of using these values directly in the program, you should declare them as
named constants. Based on the problem analysis, you need to declare the following
named constants:
//Named constants – residential customers
const double RES_BILL_PROC_FEES = 4.50;
const double RES_BASIC_SERV_COST = 20.50;
const double RES_COST_PREM_CHANNEL = 7.50;
const
const
const
const

//Named constants – business customers
double BUS_BILL_PROC_FEES = 15.00;
double BUS_BASIC_SERV_COST = 75.00;
double BUS_BASIC_CONN_COST = 5.00;
double BUS_COST_PREM_CHANNEL = 50.00;

Formulas The program uses a number of formulas to compute the billing amount. To compute

the residential bill, you need to know only the number of premium channels to
which the user subscribes. The following statement calculates the billing amount for a
residential customer:
amountDue = RES_BILL_PROC_FEES + RES_BASIC_SERV_COST
+ numOfPremChannels * RES_COST_PREM_CHANNEL;

To compute the business bill, you need to know the number of basic service
connections and the number of premium channels to which the user subscribes. If
the number of basic service connections is less than or equal to 10, the cost of the

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Cable Company Billing

|

239

basic service connections is fixed. If the number of basic service connections
exceeds 10, you must add the cost for each connection over 10. The following
statement calculates the business billing amount:
if (numOfBasicServConn <= 10)
amountDue = BUS_BILL_PROC_FEES + BUS_BASIC_SERV_COST
+ numOfPremChannels * BUS_COST_PREM_CHANNEL;
else
amountDue = BUS_BILL_PROC_FEES + BUS_BASIC_SERV_COST
+ (numOfBasicServConn - 10)
* BUS_BASIC_CONN_COST
+ numOfPremChannels * BUS_COST_PREM_CHANNEL;
MAIN
ALGORITHM

Based on the preceding discussion, you can now write the main algorithm.
1. To output floating-point numbers in a fixed decimal format with
a decimal point and trailing zeros, set the manipulators fixed and
showpoint. Also, to output floating-point numbers with two
decimal places, set the precision to two decimal places. Recall
that to use these manipulators, the program must include the
header file iomanip.
2. Prompt the user to enter the account number.
3. Get the customer account number.
4. Prompt the user to enter the customer code.
5. Get the customer code.
6. If the customer code is r or R,
a. Prompt the user to enter the number of premium channels.
b. Get the number of premium channels.
c. Calculate the billing amount.
d. Print the account number and the billing amount.
7. If the customer code is b or B,
a. Prompt the user to enter the number of basic service connections.
b. Get the number of basic service connections.
c. Prompt the user to enter the number of premium channels.
d. Get the number of premium channels.
e. Calculate the billing amount.
f. Print the account number and the billing amount.
8. If the customer code is something other than r, R, b, or B, output an
error message.
For Steps 6 and 7, the program uses a switch statement to calculate the bill for the
desired customer.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

240 |

Chapter 4: Control Structures I (Selection)

COMPLETE PROGRAM LISTING
//***********************************************************
// Author: D. S. Malik
//
// Program: Cable Company Billing
// This program calculates and prints a customer's bill for
// a local cable company. The program processes two types of
// customers: residential and business.
//***********************************************************
#include <iostream>
#include <iomanip>
using namespace std;
//Named constants – residential customers
const double RES_BILL_PROC_FEES = 4.50;
const double RES_BASIC_SERV_COST = 20.50;
const double RES_COST_PREM_CHANNEL = 7.50;
const
const
const
const

//Named constants – business customers
double BUS_BILL_PROC_FEES = 15.00;
double BUS_BASIC_SERV_COST = 75.00;
double BUS_BASIC_CONN_COST = 5.00;
double BUS_COST_PREM_CHANNEL = 50.00;

int main()
{
//Variable declaration
int accountNumber;
char customerType;
int numOfPremChannels;
int numOfBasicServConn;
double amountDue;
cout << fixed << showpoint;
cout << setprecision(2);
cout << "This program computes a cable "
<< "bill." << endl;
cout << "Enter account number (an integer): ";
cin >> accountNumber;
cout << endl;
cout <<
<<
<<
cin >>
cout <<

"Enter customer type: "
"R or r (Residential), "
"B or b (Business): ";
customerType;
endl;

//Step 1
//Step 1

//Step 2
//Step 3

//Step 4
//Step 5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Cable Company Billing

switch (customerType)
{
case 'r':
case 'R':
cout << "Enter the number"
<< " of premium channels: ";
cin >> numOfPremChannels;
cout << endl;
amountDue = RES_BILL_PROC_FEES
+ RES_BASIC_SERV_COST
+ numOfPremChannels *
RES_COST_PREM_CHANNEL;
cout <<
<<
<<
cout <<
<<
<<
break;

"Account number: "
accountNumber
endl;
"Amount due: $"
amountDue
endl;

case 'b':
case 'B':
cout << "Enter the number of basic "
<< "service connections: ";
cin >> numOfBasicServConn;
cout << endl;
cout << "Enter the number"
<< " of premium channels: ";
cin >> numOfPremChannels;
cout << endl;
if (numOfBasicServConn<= 10)
amountDue = BUS_BILL_PROC_FEES
+ BUS_BASIC_SERV_COST
+ numOfPremChannels *
BUS_COST_PREM_CHANNEL;

|

241

//Step 6
//Step 6a
//Step 6b
//Step 6c

4

//Step 6d
//Step 6d
//Step 7
//Step 7a
//Step 7b

//Step 7c
//Step 7d
//Step 7e

else
amountDue = BUS_BILL_PROC_FEES
+ BUS_BASIC_SERV_COST
+ (numOfBasicServConn - 10) *
BUS_BASIC_CONN_COST
+ numOfPremChannels *
BUS_COST_PREM_CHANNEL;
cout <<
<<
cout <<
<<
break;

"Account number: "
accountNumber << endl;
"Amount due: $" << amountDue
endl;

//Step 7f
//Step 7f

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

242 |

Chapter 4: Control Structures I (Selection)

default:
cout << "Invalid customer type." << endl;
}//end switch

//Step 8

return 0;
}

Sample Run: In this sample run, the user input is shaded.
This program computes a cable bill.
Enter account number (an integer): 12345
Enter customer type: R or r (Residential), B or b (Business): b
Enter the number of basic service connections: 16
Enter the number of premium channels: 8
Account number: 12345
Amount due: $520.00

QUICK REVIEW
1.
2.
3.
4.
5.
6.
7.

8.
9.

Control structures alter the normal flow of control.
The two most common control structures are selection and repetition.
Selection structures incorporate decisions in a program.
The relational operators are == (equality), < (less than), <= (less than or equal
to), > (greater than), >= (greater than or equal to), and != (not equal to).
Including a space within the relational operators ==, <=, >=, and != creates
a syntax error.
Characters are compared using a machine’s collating sequence.
Logical expressions evaluate to 1 (or a nonzero value) or 0. The logical
value 1 (or any nonzero value) is treated as true; the logical value 0 is
treated as false.
There are two selection structures in C++.
One-way selection takes the following form:
if (expression)
statement

10.

If expression is true, the statement executes; otherwise, the
statement does not execute.
Two-way selection takes the following form:
if (expression)
statement1
else
statement2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

11.
12.
13.
14.
15.
16.
17.
18.
19.

20.
21.
22.
23.
24.

|

243

If expression is true, then statement1 executes; otherwise,
statement2 executes.
The expression in an if or if. . .else structure is usually a logical expression.
Including a semicolon before the statement in a one-way selection creates
a semantic error. In this case, the action of the if statement is empty.
Including a semicolon before statement1 in a two-way selection creates a
syntax error.
There is no stand-alone else statement in C++. Every else has a related if.
An else is paired with the most recent if that has not been paired with
any other else.
In C++, int variables can be used to store the value of a logical expression.
In C++, bool variables can be used to store the value of a logical expression.
In C++, the logical operators are ! (not), && (and), and || (or).
A sequence of statements enclosed between curly braces, { and }, is called a
compound statement or block of statements. A compound statement is
treated as a single statement.
You can use the input stream variable in an if statement to determine the
state of the input stream.
Using the assignment operator in place of the equality operator creates a
semantic error. This can cause serious errors in the program.
The switch structure is used to handle multiway selection.
The execution of a break statement in a switch statement immediately
exits the switch structure.
If certain conditions are not met in a program, the program can be
terminated using the assert function.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false:
a.

b.
c.

d.

The order in which statements execute in a program is called the flow
of control. (1)
In C++, =, is the equality operator. (2)
In a one-way selection, if a semicolon is placed after the expression in
an if statement, the expression in the if statement is always true. (3)
Every if statement must have a corresponding else. (3)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

244 |

e.

Chapter 4: Control Structures I (Selection)

The expression in the if statement:
if (score = 30)
grade = 'A';

f.

always evaluates to true. (3)
The expression:
(ch >= 'A' && ch <= 'Z')

g.

evaluates to false if either ch < 'A' or ch >= 'Z'. (2, 5)
Suppose the input is 5. The output of the code: (3)
cin >> num;
if (num > 5)
cout << num;
num = 0;
else
cout << "Num is zero" << endl;
is: Num is zero

h.
i.
j.
k.

2.

3.

The result of a logical expression cannot be assigned to an int variable. (4)
The expression !(x > 0) is true only if x is a negative number. (5)
In C++, both ! and != are logical operators. (5)
The expression in a switch statement should evaluate to a value of the
simple data type. (11)

Evaluate the following expressions. (2)
a.

3 * 4 == 15 - 3

b.

2 - 15 / 3 >= 7 - 4

c.

'd' >= 'F'

d.

'T' <= 's'

e.

'#' <= '*'

f.

8.5 / 2 - 1.3 < 4.0 * 0.7 + 1.2

Suppose that x, y, and z are int variables and x = 12, y = 34, and z = 18.
Determine whether the following expressions evaluate to true or
false. (2, 5)
a.

!(x - y >= 1)

b.

z <= 7 || y < 12

c.

(x + y != 40) && (x != z)

d.

(z - x >= y) || (y - x != z + 4)

e.

(5 - x <= 2 * y) && (y - 15 >= z) || (x - 5 != y - 2 * z)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

4.

|

245

Suppose that str1, str2, and str3 are string variables, and str1 =
"Stop", str2 = "Running", and str3 = "Physics". Evaluate the following expressions. (2, 7)
a.

str1 <= str3

b.

str1 != "Stop"

c.

str2 < str1

d.

str3 >= "chemistry"

e.

str3 >= "Run"

4
5.

6.

Suppose that x, y, z, and w are int variables and x = 25, y = 3, z = 12, and
w = 4. What is the output of the following statements? (2, 5)
a.

cout << "x == z: " << (x == z) << endl;

b.

cout << "y != z - 9: " << (y != z - 9) << endl;

c.

cout << "x - y == z + 10: " << (x - y == z + 10) << endl;

d.

cout << "!(z < w): " << !(z < w) << endl;

e.

cout << "w - y < x - 2 * z: " << (w - y < x - 2 * z) << endl;

Which of the following are relational operators? (2)
a.

7.

>

b.

==

c.

=

d.

!=

e.

<>

What is the output of the following statements? (2, 3)
a.

if ('-' < '/')
cout << "/";
cout << "/-" << endl;

b.

if (5 + 3 <= 12 - 4)
cout << "8 ";
cout << "12 - 4";
cout << endl;

c.

if ('^' < ':')
cout << ":^";
cout << "^:";
cout << endl;

d.

if ("++C" >= "--D")
cout << "--D" << endl;
cout << "++C" << endl;

e.

if ("Bob" <= "Amy")
cout << "Amy" << endl;
cout << "Amy < Bob" << endl;

f.

if (18 / 3 == 2 * 3)
cout << 12 * 4 / 3 - 28 << endl;
cout << "**" << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

246 |

8.

Which of the following are logical (Boolean) operators? (5)
a.

9.

10.

Chapter 4: Control Structures I (Selection)

=!

b.

&&

c.

|

What is the output of the following statements? (3, 5)
a.

if ('K' > '%' || '@' <= '?')
cout << "?%";
cout << "!!";
cout << endl;

b.

if ('8' < 'B' && 15 > -13)
cout << "a b c d" << endl;
cout << "##" << endl;

c.

if ("Fly" >= "Flying" && "Programming" >= "Coding")
cout << "Fly Programming" << endl;
cout << "Flying Coding" << endl;

What is the output of the following code? (2, 4)
int num = 17;
double gpa = 3.85;
bool done;

//Line 1
//Line 2
//Line 3

done = (num == static_cast<int>(2 * gpa + 9.3));
cout << "The value of done is: "<< done << endl;
11.

How does the output in Exercise 10 change if the statement in Line 4 is
replaced by the following statement? (2, 4)
done = (num ==

12.

//Line 4
//Line 5

static_cast<int>(2 * gpa)
+ static_cast<int>(9.3));

//Line 4

What is the output of the following program? (2)
#include <iostream>
using namespace std;
int main()
{
int firstNum = 8;
int secondNum = 39;
cout
cout
cout
cout
cout
cout
cout

<<
<<
<<
<<
<<
<<
<<

firstNum << " " << secondNum << endl;
(firstNum = 35 - 17) << endl;
(firstNum <= 90) << endl;
(firstNum > secondNum - 30) << endl;
(5 * firstNum - 1 <= secondNum) << endl;
(secondNum == 2 * firstNum - 1) << endl;
firstNum << " " << secondNum << endl;

return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

13.

|

247

Correct the following code so that it prints the correct message: (3)
if (score >= 60)
cout << "You pass." << endl;
else;
cout << "You fail." << endl;

14.

15.

a. Write C++ statements that output First Year if the standing is 'F',
Sophomore if the standing is 'S ', and Junior or Senior otherwise. (3)
b. Write C++ statements that output First Year or Sophomore if the
standing is '1' or '2', Junior or Senior if the standing is '3' or
'4', and Graduate Student otherwise. (3)
If the number of items bought is less than 5, then the shipping charges are
$7.00 for each item bought; if the number of items bought is at least 5, but
less than 10, then the shipping charges are $3.00 for each item bought; if the
number of items bought is at least 10, there are no shipping charges. Correct
the following code so that it computes the correct shipping charges. (3, 5, 6)
if (numOfItemsBought > 10)
shippingCharges = 0.0;
else if (5 <= numOfItemsBought || numOfItemsBought <= 10);
shippingCharges = 3.00 * numOfItemsBought;
else if (0 < numOfItemsBought || numOfItemsBought < 5)
shippingCharges = 7.00 * numOfItemsBought;

16.

What is the output of the following C++ code? (2, 5, 6)
int x = 5;
int y = 12;
if (x + y > 20 || y - x < 10)
{
x = y + 6;
y = 2 * (x + y);
cout << x << " " << y << " " << x - y << " " << x + y << endl;
}
else
{
y = (5 * x + 20) % y;
cout << x << " " << y << " " << x * x + y * y << endl;
}

17.

What is the output of the following program? (2, 3, 5)
#include <iostream>
using namespace std;
int main()

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

248 |

Chapter 4: Control Structures I (Selection)

{
int firstNum = 18;
int secondNum = 37;
if ((secondNum % firstNum == 2) || (secondNum % firstNum == 3))
{
secondNum = 3;
firstNum = 2;
}
else if (secondNum % firstNum == 1)
{
secondNum = 18;
firstNum = 1;
}
else
{
secondNum = 1;
firstNum = 37;
}
cout << firstNum << " " << secondNum << endl;
return 0;
}
18.

a.

b.

19.

20.

21.

What is the output of the program in Exercise 17, if firstNum = 10
and secondNum = 5? (2, 3, 5)
What is the output of the program in Exercise 17, if firstNum = 20 and
secondNum = 42? (2, 3, 5)

Suppose that sale and bonus are double variables. Write an if. . .else
statement that assigns a value to bonus as follows: If sale is greater than
$20,000, the value assigned to bonus is 0.10, that is, 10%; if sale is greater
than $10,000 and less than or equal to $20,000, the value assigned to bonus
is 0.05, that is, 5%; otherwise, the value assigned to bonus is 0. (3)
Suppose that overSpeed and fine are double variables. Assign the value
to fine as follows: If 0 < overSpeed <= 5, the value assigned to fine is
$20.00; if 5 < overSpeed <= 10, the value assigned to fine is $75.00; if
10 < overSpeed <= 15, the value assigned to fine is $150.00; if
overSpeed > 15, the value assigned to fine is $150.00 plus $20.00 per
mile over 15. (3)
Suppose that score is an int variable. Consider the following if statements: (3)
if (score >= 90);
cout << "Discount = 10%" << endl;
a.
b.

What is the output if the value of score is 95? Justify your answer.
What is the output if the value of score is 85? Justify your answer.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

22.

|

249

Suppose that score is an int variable. Consider the following if statements: (3)
i.

if (score == 70)
cout << "Grade is C." << endl;

ii.

if (score = 70)
cout << "Grade is C." << endl;

Answer the following questions:
a.

b.

23.

24.

25.

What is the output in (i) and (ii) if the value of score is 70? What is the value
of score after the if statement executes?
What is the output in (i) and (ii) if the value of score is 80? What is the value
of score after the if statement executes?

Rewrite the following expressions using the conditional operator. (Assume
that all variables are declared properly.) (9)
a.

if (x >= y)
z = x - y;
else
z = y - x;

b.

if (hours >= 40.0)
wages = 40 * 7.50 + 1.5 * 7.5 * (hours - 40);
else
wages = hours * 7.50;

c.

if (score >= 60)
str = "Pass";
else
str = "Fail";

Rewrite the following expressions using an if. . .else statement. (Assume
that all variables are declared properly.) (9)
a.

(x < 5) ? y = 10 : y = 20;

b.

(fuel >= 10) ? drive = 150 : drive = 30;

c.

(booksBought >= 3) ? discount = 0.15 : discount = 0.0;

Suppose that you have the following conditional expression. (Assume that
all the variables are properly declared.) (9)
(0 < backyard && backyard <= 5000) ? fertilizingCharges = 40.00
: fertilizingCharges = 40.00 + (backyard - 5000) * 0.01;
a.

b.

c.

What is the value of fertilizingCharges if the value of backyard
is 3000?
What is the value of fertilizingCharges if the value of backyard
is 5000?
What is the value of fertilizingCharges if the value of backyard
is 6500?

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

250 |

26.

Chapter 4: Control Structures I (Selection)

State whether the following are valid switch statements. If not, explain
why. Assume that n and digit are int variables. (11)
a.

switch (n <= 2)
{
case 0:
cout << "Draw." << endl;
break;
case 1:
cout << "Win." << endl;
break;
case 2:
cout << "Lose." << endl;
break;
}

b.

switch (digit / 4)
{
case 0,
case 1:
cout << "low." << endl;
break;
case 1,
case 2:
cout << "middle." << endl;
break;
case 3:
cout << "high." << endl;
}

c.

switch (n % 6)
{
case 1:
case 2:
case 3:
case 4:
case 5:
cout << n;
break;
case 0:
cout << endl;
break;
}

d.

switch (n % 10)
{
case 2:
case 4:
case 6:
case 8:
cout << "Even";
break;
case 1:
case 3:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

251

case 5:
case 7:
cout << "Odd";
break;
}
27.

Suppose that score is an int variable. Consider the following C++ code: (3, 11)
int score;
cin >> score;
switch (score % 7)
{
case 0:
score = score / 2 - 1;
break;
case 1: case 3:
score = 3 * score + 1;
break;
case 2:
++score;
break;
case 4:
break;
case 5: case 6:
score = score % 3;
break;
default:
score = score / 2;
}
cout << score << endl;
a.
b.
c.
d.

28.

What is the output if the input is 12?
What is the output if the input is 4?
What is the output if the input is 3?
What is the output if the input is 25?

Suppose that beta is an int variable. Consider the following C++ code: (11)
cin >> beta;
switch (beta % 8)
{
case 0:
case 1:
beta = beta + beta;
break;
case 2:
beta--;
break;
case 3:
case 7:
beta = static_cast<int>(sqrt(beta * 1.0));
beta = beta / 3;
break;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

252 |

Chapter 4: Control Structures I (Selection)

case 4:
beta = beta * beta;
case 5:
case 6:
beta = 11 - beta;
break;
default:
beta = -5;
}
cout << beta << endl;
a.
b.
c.
d.
29.

What
What
What
What

is
is
is
is

the
the
the
the

output
output
output
output

if
if
if
if

the
the
the
the

input
input
input
input

is
is
is
is

3?
12?
15?
28?

Suppose that num is an int variable. Consider the following C++ code: (3, 11)
cin >> num;
if (num >= 0)
switch (num)
{
case 0:
num = static_cast<int>(pow(num, 3.0));
break;
case 2:
num = ++num;
break;
case 4:
num = num – 4;
break;
case 5:
num = num * 4;
case 6:
num = num / 6;
break;
case 10:
num--;
break;
default:
num = -20;
}
else
num = num + 10;
cout << num << endl;
a.
b.
c.
d.

What
What
What
What

is
is
is
is

the
the
the
the

output
output
output
output

if
if
if
if

the
the
the
the

input
input
input
input

is
is
is
is

5?
26?
2?
-5?

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

30.

|

253

In the following code, correct any errors that would prevent the program
from compiling or running: (3, 11)
include <iostream>
main ()
{
int num1, num2;
bool found;
cout << "Enter two integers: ;
cin >> num1 >> num2;
cout << endl;
if (num1 >= num2) && num2 > 0
switch (num % num2)
{
case 1
found = (num / num2) >= 6;
break;
case 2: case 3
num1 = num2 / 2;
brake;
default:
num2 = num1 * num2;
}
else
{
found = (2 * num2 < num1);
if found
cin >> num2
num 1 = num2 – num1;
temp = (num1 + num2) / 10;
if num2
{
num1 = num2;
num2 = temp;
}
cout << num1 << " " << num2 << endl;
}

After correcting the code, answer the following questions. (If needed, insert prompt
lines to inform the user for the input.)
a.
b.
31.

What is the output if the input is 10 8?
What is the output if the input is 4 9?

The following program contains errors. Correct them so that the program
will run and output w = 21. (3, 11)
#include <iostream>
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

254 |

Chapter 4: Control Structures I (Selection)

const int SECRET = 5
main ()
{
int x, y, w, z;
z = 9;
if z > 10
x = 12; y = 5, w = x + y + SECRET;
else
x = 12; y = 4, w = x + y + SECRET;
cout << "w = " << w << endl;
}
32.

Write the missing statements in the following program so that it prompts the user
to input two numbers. If one of the numbers is 0 or negative, the program
outputs that both numbers must be positive. If both the numbers are equal, it
outputs the sum of the numbers; if the first number is less than or equal to 2 and
both the numbers are not equal, it outputs the second number to the power of
the first number; otherwise, it outputs the product of the numbers. (3)
#include <iostream>
//Include additional header files, if necessary
using namespace std;
int main()
{
double firstNum, secondNum;
cout << "Enter two nonzero numbers: ";
cin >> firstNum >> secondNum;
cout << endl;
//Missing statements
return 0;
}

33.

Suppose that classStanding is a char variable, and gpa and dues are
double variables. Write a switch expression that assigns the dues as
follows: If classStanding is 'f', the dues are $150.00; if
classStanding is 's' (if gpa is at least 3.75, the dues are $75.00;
otherwise, dues are 120.00); if classStanding is 'j' (if gpa is at least
3.75, the dues are $50.00; otherwise, dues are $100.00); if
classStanding is 'n' (if gpa is at least 3.75, the dues are $25.00;
otherwise, dues are $75.00). (Note that the code 'f' stands for first-year
students, the code 's' stands for second-year students, the code 'j' stands
for juniors, and the code 'n' stands for seniors.) (3)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

34.

|

255

Suppose that billingAmount is a double variable, which denotes the
amount you need to pay to the department store. If you pay the full
amount, you get $10.00 or 1% of the billingAmount, whichever is
smaller, as a credit on your next bill; if you pay at least 50% of the
billingAmount, the penalty is 5% of the balance; if you pay at least 20%
of the billingAmount and less than 50% of the billingAmount, the
penalty is 10% of the balance; otherwise, the penalty is 20% of the balance.
Design an algorithm that prompts the user to enter the billing amount and
the desired payment. The algorithm then calculates and outputs the credit
or the remaining balance. If the amount is not paid in full, the algorithm
should also output the penalty amount. (3)

PROGRAMMING EXERCISES
1.

2.

3.

4.

Write a program that prompts the user to input a number. The program
should then output the number and a message saying whether the number is
positive, negative, or zero.
Write a program that prompts the user to input three numbers. The program
should then output the numbers in ascending order.
Write a program that prompts the user to input an integer between 0 and 35. If
the number is less than or equal to 9, the program should output the number;
otherwise, it should output A for 10, B for 11, C for 12 . . . and Z for 35. (Hint:
Use the cast operator, static_cast<char>( ), for numbers >= 10.)
The statements in the following program are in incorrect order. Rearrange
the statements so that they prompt the user to input the shape type
(rectangle, circle, or cylinder) and the appropriate dimension of
the shape. The program then outputs the following information about
the shape: For a rectangle, it outputs the area and perimeter; for a circle,
it outputs the area and circumference; and for a cylinder, it outputs the
volume and surface area. After rearranging the statements, your program
should be properly indented.
using namespace std;
#include <iostream>
int main()
{
string shape;
double height;
#include <string>
cout << "Enter the shape type: (rectangle, circle, cylinder) ";
cin >> shape;
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

256 |

Chapter 4: Control Structures I (Selection)

if (shape == "rectangle")
{
cout << "Area of the circle = "
<< PI * pow(radius, 2.0) << endl;
cout << "Circumference of the circle: "
<< 2 * PI * radius << endl;
cout << "Enter the height of the cylinder: ";
cin >> height;
cout << endl;
cout << "Enter the width of the rectangle: ";
cin >> width;
cout << endl;

cout << "Perimeter of the rectangle = "
<< 2 * (length + width) << endl;
double width;
}
cout << "Surface area of the cylinder: "
<< 2 * PI * radius * height + 2 * PI * pow(radius, 2.0)
<< end1;
}
else if (shape == "circle")
{
cout << "Enter the radius of the circle: ";
cin >> radius;
cout << endl;
cout << "Volume of the cylinder = "
<< PI * pow(radius, 2.0)* height << endl;
double length;
}
return 0;
else if (shape == "cylinder")
{
double radius;
cout << "Enter the length of the rectangle: ";
cin >> length;
cout << endl;
#include <iomanip>
cout << "Enter the radius of the base of the cylinder: ";
cin >> radius;
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

257

const double PI = 3.1416;
cout << "Area of the rectangle = "
<< length * width << endl;
else
cout << "The program does not handle " << shape << endl;
cout << fixed << showpoint << setprecision(2);
#include <cmath>
}
5.

6.

7.

In a right triangle, the square of the length of one side is equal to the sum
of the squares of the lengths of the other two sides. Write a program that
prompts the user to enter the lengths of three sides of a triangle and then
outputs a message indicating whether the triangle is a right triangle.
A box of cookies can hold 24 cookies, and a container can hold 75 boxes of
cookies. Write a program that prompts the user to enter the total number
of cookies, the number of cookies in a box, and the number of cookie
boxes in a container. The program then outputs the number of boxes and
the number of containers to ship the cookies. Note that each box must
contain the specified number of cookies, and each container must contain
the specified number of boxes. If the last box of cookies contains less than
the number of specified cookies, you can discard it and output the number
of leftover cookies. Similarly, if the last container contains less than the
number of specified boxes, you can discard it and output the number of
leftover boxes.
The roots of the quadratic equation ax2 + bx + c = 0, a 6¼ 0 are given by the
following formula:
b 

pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
b2  4ac
2a

In this formula, the term b2  4ac is called the discriminant. If b2  4ac = 0,
then the equation has a single (repeated) root. If b2  4ac > 0, the
equation has two real roots. If b2  4ac < 0, the equation has two
complex roots. Write a program that prompts the user to input the
value of a (the coefficient of x2), b (the coefficient of x), and c (the
constant term) and outputs the type of roots of the equation. Furthermore, if b2  4ac  0, the program should output the roots of the
quadratic equation. (Hint: Use the function pow from the header file
cmath to calculate the square root. Chapter 3 explains how the function pow is used.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

258 |

8.

Chapter 4: Control Structures I (Selection)

Write a program that mimics a calculator. The program should take as input
two integers and the operation to be performed. It should then output the
numbers, the operator, and the result. (For division, if the denominator is
zero, output an appropriate message.) Some sample outputs follow:
3 + 4 = 7
13 * 5 = 65

9.

10.

Redo Exercise 8 to handle floating-point numbers. (Format your output to
two decimal places.)
Redo Programming Exercise 16 of Chapter 2, taking into account that your
parents buy additional savings bonds for you as follows:
a.

b.

c.

11.

12.

13.

If you do not spend any money to buy savings bonds, then because you
had a summer job, your parents buy savings bonds for you in an
amount equal to 1% of the money you save after paying taxes and
buying clothes, other accessories, and school supplies.
If you spend up to 25% of your net income to buy savings bonds, your
parents spend $0.25 for each dollar you spend to buy savings bonds,
plus money equal to 1% of the money you save after paying taxes and
buying clothes, other accessories, and school supplies.
If you spend more than 25% of your net income to buy savings bonds,
your parents spend $0.40 for each dollar you spend to buy savings
bonds, plus money equal to 2% of the money you save after paying
taxes and buying clothes, other accessories, and school supplies.

Write a program that implements the algorithm given in Example 1-3
(Chapter 1), which determines the monthly wages of a salesperson.
Write a program that implements the algorithm that you designed in
Exercise 34 of this chapter.
The number of lines that can be printed on a paper depends on the paper size,
the point size of each character in a line, whether lines are double-spaced or
single-spaced, the top and bottom margin, and the left and right margins of
the paper. Assume that all characters are of the same point size, and all lines
are either single-spaced or double-spaced. Note that 1 inch = 72 points.
Moreover, assume that the lines are printed along the width of the paper. For
example, if the length of the paper is 11 inches and width is 8.5 inches, then
the maximum length of a line is 8.5 inches. Write a program that calculates
the number of characters in a line and the number of lines that can be printed
on a paper based on the following input from the user:
a.
b.
c.
d.

The length and width, in inches, of the paper
The top, bottom, left, and right margins
The point size of a line
If the lines are double-spaced, then double the point size of each character

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

14.

|

259

Write a program that calculates and prints the bill for a cellular telephone
company. The company offers two types of service: regular and premium.
Its rates vary, depending on the type of service. The rates are computed as
follows:
Regular service:
Premium service:
a.

b.

$10.00 plus first 50 minutes are free. Charges for
over 50 minutes are $0.20 per minute.
$25.00 plus:

For calls made from 6:00 a.m. to 6:00 p.m., the first 75 minutes are free;
charges for more than 75 minutes are $0.10 per minute.
For calls made from 6:00 p.m. to 6:00 a.m., the first 100 minutes are
free; charges for more than 100 minutes are $0.05 per minute.

Your program should prompt the user to enter an account number, a
service code (type char), and the number of minutes the service was
used. A service code of r or R means regular service; a service code of
p or P means premium service. Treat any other character as an error.
Your program should output the account number, type of service,
number of minutes the telephone service was used, and the amount
due from the user.

15.

16.

For the premium service, the customer may be using the service during
the day and the night. Therefore, to calculate the bill, you must ask the
user to input the number of minutes the service was used during the day
and the number of minutes the service was used during the night.
Write a program to implement the algorithm that you designed in Exercise
22 of Chapter 1. (Assume that the account balance is stored in the file
Ch4_Ex15_Data.txt.) Your program should output account balance before
and after withdrawal and service charges. Also save the account balance after
withdrawal in the file Ch4_Ex15_Output.txt.
A new author is in the process of negotiating a contract for a new romance
novel. The publisher is offering three options. In the first option, the author
is paid $5,000 upon delivery of the final manuscript and $20,000 when the
novel is published. In the second option, the author is paid 12.5% of the net
price of the novel for each copy of the novel sold. In the third option, the
author is paid 10% of the net price for the first 4000 copies sold, and 14%
of the net price for the copies sold over 4000. The author has some idea
about the number of copies that will be sold and would like to have an
estimate of the royalties generated under each option. Write a program that
prompts the author to enter the net price of each copy of the novel and the
estimated number of copies that will be sold. The program then outputs the
royalties under each option and the best option the author could choose.
(Use appropriate named constants to store the special values such as royalties
rates and fixed royalties.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

260 |

17.

18.

Chapter 4: Control Structures I (Selection)

Samantha and Vikas are looking to buy a house in a new development. After
looking at various models, the three models they like are colonial, split-entry,
and single-story. The builder gave them the base price and the finished area
in square feet of the three models. They want to know the model(s) with the
least price per square foot. Write a program that accepts as input the base
price and the finished area in square feet of the three models. The program
outputs the model(s) with the least price per square foot.
One way to determine how healthy a person is by measuring the body fat
of the person. The formulas to determine the body fat for female and male
are as follows:
Body fat formula for women:
A1 ¼ (body weight  0.732) + 8.987
A2 ¼ wrist measurement (at fullest point) / 3.140
A3 ¼ waist measurement (at navel)  0.157
A4 ¼ hip measurement (at fullest point)  0.249
A5 ¼ forearm measurement (at fullest point)  0.434
B ¼ A1 + A2 – A3 – A4 + A5
Body fat ¼ body weight – B
Body fat percentage ¼ body fat  100 / body weight
Body fat formula for men:
A1 ¼ (body weight  1.082) + 94.42
A2 ¼ wrist measurement  4.15
B ¼ A1 – A2
Body fat ¼ body weight – B
Body fat percentage ¼ body fat  100 / body weight

19.

Write a program to calculate the body fat of a person.
Ron bought several acres of farm to grow and sell vegetables. Suppose that
Ron wants to grow a maximum of two types of vegetables. Write a
program that prompts Ron or the user to do the following:
1. Enter the total farm area in acres.
2. The number of vegetables (one or two) that the user wants to grow.
3. If the user wants to grow two types of vegetables, then specify the
portion, as a percentage, of the farm land used for each type of vegetable.
4. Enter the seed cost, plantation cost, fertilizing cost, labor cost, for each acre.
5. Enter vegetable selling price per acre.
6. Output the total revenue.
7. Output the profit/loss.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

20.

21.

22.

|

261

The cost of renting a room at a hotel is, say $100.00 per night. For special
occasions, such as a wedding or conference, the hotel offers a special
discount as follows: If the number of rooms booked is at least 10, the
discount is 10%; at least 20, the discount is 20%; and at least 30, the
discount is 30%. Also if rooms are booked for at least 3 days, then there
is an additional 5% discount. Write a program that prompts the user to
enter the cost of renting one room, the number of rooms booked, the
number of days the rooms are booked, and the sales tax (as a percent). The
program outputs the cost of renting one room, the discount on each room
as a percent, the number of rooms booked, the number of days the rooms
are booked, the total cost of the rooms, the sales tax, and the total billing
amount. Your program must use appropriate named constants to store
special values such as various discounts.
Let l be a line in the x-y plane. If l is a vertical line, its equation is x = a for
some real number a. Suppose l is not a vertical line and its slope is m. Then
the equation of l is y = mx +b, where b is the y-intercept. If l passes through
the point (x0, y0,), the equation of l can be written as y  y0 = m(x  x0). If
(x1, y1) and (x2, y2) are two points in the x-y plane and x1 6¼ x2, the slope
of the line passing through these points is m = (y2  y1) / (x2  x1). Write
a program that prompts the user to enter two points in the x-y plane. The
program outputs the equation of the line and uses if statements to
determine and output whether the line is vertical, horizontal, increasing,
or decreasing. If l is a nonvertical line, output its equation in the form
y = mx +b.
The first 11 prime integers are 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31. A
positive integer between 1 and 1000 (inclusive), other than the first 11
prime integers, is prime if it is not divisible by 2, 3, 5, 7, 11, 13, 17, 19, 23,
29, and 31. Write a program that prompts the user to enter a positive
integer between 1 and 1000 (inclusive) and that outputs whether the
number is prime. If the number is not prime, then output all the numbers,
from the list of the first 11 prime integers, which divide the number.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

4

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

CHAPTER

ª HunThomas/Shutterstock.com

CONTROL S TRUCTURES II
(R EPETITION )
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about repetition (looping) control structures

2.

Learn how to use a while loop in a program

3.

Explore how to construct and use count-controlled,
sentinel-controlled, flag-controlled, and EOF-controlled
repetition structures

4.

Learn how to use a for loop in a program

5.

Learn how to use a do...while loop in a program

6.

Examine break and continue statements

7.

Discover how to form and use nested control structures

8.

Learn how to avoid bugs by avoiding patches

9.

Learn how to debug loops

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

264 |

Chapter 5: Control Structures II (Repetition)

Chapter 4 discussed how decisions are incorporated in programs. This chapter discusses
how repetitions are incorporated in programs.

Why Is Repetition Needed?
David needs to lower his cholesterol count to stay physically fit and reduce the risk of
heart attack, and he wants to accomplish this by doing regular exercises. He decided to
join a gym and, among other measures, keep track of the number of calories burned each
time he uses the gym. At the end of each week he wants to determine the average
number of calories burned each day. We need to write a program that David can use to
enter the number of calories burned each day and get as output the average number of
calories burned each day. Suppose that the numbers of calories burned each day in a
particular week are: 375, 425, 270, 190, 350, 200, and 365. To find the average
number of calories burned each day, we must add these numbers and divide the total by 7.
From what we have learned so far, we can write the following program to find the average
number of calories burned each day.
#include <iostream>
using namespace std;
int main()

{
int calBurnedDay1, calBurnedDay2, calBurnedDay3,
calBurnedDay4, calBurnedDay5, calBurnedDay6,
calBurnedDay7;
int calBurnedInAWeek;
cout << "Enter calories burned day 1: ";
cin >> calBurnedDay1;
cout << endl;
cout << "Enter calories burned day 2: ";
cin >> calBurnedDay2;
cout << endl;
cout << "Enter calories burned day 3: ";
cin >> calBurnedDay3;
cout << endl;
cout << "Enter calories burned day 4: ";
cin >> calBurnedDay4;
cout << endl;
cout << "Enter calories burned day 5: ";
cin >> calBurnedDay5;
cout << endl;
cout << "Enter calories burned day 6: ";
cin >> calBurnedDay6;
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Why Is Repetition Needed? |

265

cout << "Enter calories burned day 7: ";
cin >> calBurnedDay7;
cout << endl;
calBurnedInAWeek = calBurnedDay1 + calBurnedDay2 + calBurnedDay3
+ calBurnedDay4 + calBurnedDay5 + calBurnedDay6
+ calBurnedDay7;
cout << "Average number of calories burned each day: "
<< calBurnedInAWeek / 7 << endl;
return 0;
}

Sample Run: In this sample run, the user input is shaded.
Enter calories burned day 1: 375
Enter calories burned day 2: 425
Enter calories burned day 3: 270
Enter calories burned day 4: 190
Enter calories burned day 5: 350
Enter calories burned day 6: 200
Enter calories burned day 7: 365
Average number of calories burned each day: 310

As you can see, this program requires us to declare seven variables to store seven numbers.
Now if David wants to determine the average number of calories burned each day of
a month, then we need to add and average about 30 numbers, which will require us to
declare at least 30 variables, list them again in cin statements, and, perhaps, again in the
output statements. This takes an exorbitant amount of lines and time. Also, if you want to
run this program again with a different number of values, you have to rewrite the program.
Next, let us see if there is a better alternative. The numbers we want to add are: 375,
425, 270, 190, 350, 200, and 365.

Consider the following statements, in which calBurnedInAWeek and calBurnedInOneDay
are variables of the type int.
1. calBurnedInAWeek = 0;
2. cin >> calBurnedInOneDay;
3. calBurnedInAWeek = calBurnedInAWeek + calBurnedInOneDay;
The first statement initializes calBurnedInAWeek to 0. Next, let us execute statements
2 and 3 three times.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

266 |

Chapter 5: Control Structures II (Repetition)

St.

Execution of the Statement

Effect

2

cin >> calBurnedInOneDay;

calBurnedInOneDay = 375

3

calBurnedInAWeek =
calBurnedInAWeek +
calBurnedInOneDay;

calBurnedInAWeek = 0 + 375
= 375

2

cin >> calBurnedInOneDay;

calBurnedInOneDay = 425

3

calBurnedInAWeek =
calBurnedInAWeek +
calBurnedInOneDay;

calBurnedInAWeek = 375 + 425
= 800

2
3

cin >> calBurnedInOneDay;
calBurnedInAWeek =
calBurnedInAWeek +
calBurnedInOneDay;

calBurnedInOneDay = 270
calBurnedInAWeek = 800 + 270
= 1070

From this table it is clear that after executing statements 2 and 3 three times,
calBurnedInAWeek contains the sum of the calories burned in the first three days.
If we execute these two statements seven times, then calBurnedInAWeek contains

the sum of the calories burned in a week.
If you want to find the calories burned in 30 days, then you can repeat statements
2 and 3 thirty times, and if you want to find the calories burned in 100 days, you can
repeat statements 2 and 3 one hundred times. In either case, you do not have to
declare any additional variables, as you did in the previous C++ program. However, as
it is written now, we would have to rewrite statements 2 and 3 for each value of
calBurnedInOneDay we want to add to calBurnedInAWeek. We need a structure
that will tell the computer to repeat these same 2 statements 7 times, or 30 times, or
100 times, however many repetitions we want. Then we can use this C++ code to
add any number of values, whereas the earlier code adds a specific number of values
and requires you to drastically change the code to change the number of values.
There are many other situations in which it is necessary to repeat a set of statements. For
example, for each student in a class, the formula for determining the course grade is the
same. C++ has three repetition, or looping, structures that let you repeat statements over
and over until certain conditions are met. This chapter introduces all three looping
(repetition) structures. The next section discusses the first repetition structure, called
the while loop.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

|

267

while Looping (Repetition) Structure
In the previous section, you saw that sometimes it is necessary to repeat a set of statements
several times. C++ has three repetition, or looping, structures that allow you to repeat a
set of statements until certain conditions are met. This section discusses the first looping
structure, called a while loop.
The general form of the while statement is:
while (expression)
statement

In C++, while is a reserved word. Of course, the statement can be either a simple
or compound statement. The expression acts as a decision maker and is usually a
logical expression. The statement is called the body of the loop. Note that the
parentheses around the expression are part of the syntax. Figure 5-1 shows the flow
of execution of a while loop.

expression

true

statement

false

FIGURE 5-1

while loop

The expression provides an entry condition to the loop. If it initially evaluates
to true, the statement executes. The loop condition—the expression—is then
reevaluated. If it again evaluates to true, the statement executes again. The statement (body of the loop) continues to execute until the expression is no longer true.
A loop that continues to execute endlessly is called an infinite loop. To avoid an infinite
loop, make sure that the loop’s body contains statement(s) that assure that the entry
condition—the expression in the while statement—will eventually be false.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

268 |

Chapter 5: Control Structures II (Repetition)

Now that we know how to repeat statements using a while loop, next, we rewrite the
program to determine the average number of calories burned in a week.
#include <iostream >
using namespace std;
int main()

{
int calBurnedInADay;
int calBurnedInAWeek;
int day;
day = 1;
calBurnedInAWeek = 0;
while (day <= 7)
{
cout << "Enter calories burned each day " << day << ": ";
cin >> calBurnedInADay;
cout << endl;
calBurnedInAWeek = calBurnedInAWeek + calBurnedInADay;
day = day + 1;
}
cout << "Average number of calories burned each day: "
<< calBurnedInAWeek / 7 << endl;
return 0;
}

Sample Run: In this sample run, the user input is shaded.
Enter calories burned day 1: 375
Enter calories burned day 2: 425
Enter calories burned day 3: 270
Enter calories burned day 4: 190
Enter calories burned day 5: 350
Enter calories burned day 6: 200
Enter calories burned day 7: 365
Average number of calories burned each day: 310

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

|

269

Before considering more examples of while loops, in the next example, we note a few
things about the expression in a while statement.
EXAMPLE 5-1
Consider the following C++ program segment:
int i = 0;

//Line 1

while (i <= 20)
{
cout << i << " ";
i = i + 5;
}

//Line
//Line
//Line
//Line
//Line

cout << endl;

//Line 7

2
3
4
5
6

5

In this programming segment, the statement in Line 1, declares i to be an int variable
and initializes it to 0. The statements from Line 2 to Line 6 forms the while loop. The
expression in the while statement, i <= 20, is in Line 2, and the body of the while
loop is from Line 3 to Line 6. The body of the while loop continues to execute as long
as the expression i <= 20 evaluates to true. The following table shows the
iterations of the while loop.

Iteration

Value of i

Expression in Line 2

Statements in Lines 4 and 5

1

i = 0

i <= 20 is true

Output: 0
i = i + 5 = 0 + 5 = 5

2

i = 5

i <= 20 is true

Output: 5
i = i + 5 = 5 + 5 = 10

3

i = 10

i <= 20 is true

Output: 10
i = i + 5 = 10 + 5 = 15

4

i = 15

i <= 20 is true

Output: 15
i = i + 5 = 15 + 5 = 20

5

i = 20

i <= 20 is true

Output: 20
i = i + 5 = 20 + 5 = 25

6

i = 25

i <= 20 is false

The loop terminates

The preceding while loop produces the following output:
0 5 10 15 20

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

270 |

Chapter 5: Control Structures II (Repetition)

The variable i (in Line 2,) in the expression is called the loop control variable. Also, let us
note the following:
a. In the sixth iteration, i becomes 25 but is not printed because the entry
condition is false.
b. If you omit the statement:
i = i + 5;

from the body of the loop, you will have an infinite loop, continually
printing rows of zeros.
c. You must initialize the loop control variable i before you execute the
loop. If the statement:
i = 0;

(in Line 1) is omitted, the loop may not execute at all. (Recall that
variables in C++ are not automatically initialized.)
d. If the two statements in the body of the loop, Lines 4 and 5, are
interchanged, it may drastically alter the result. For example, consider
the following statements:
i = 0;
while (i <= 20)
{
i = i + 5;
cout << i << " ";
}
cout << endl;

Here, the output is:
5 10 15 20 25

e. If you put a semicolon at the end of the while loop (after the logical
expression), then the action statement of the while loop is empty or
null. For example, the action statement of the following while loop is
empty.
i = 0;
while (i <= 20);
{
i = i + 5;
cout << i <<
}

" ";

cout << endl;

The statements within the braces do not form the body of the while loop.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

|

271

Designing while Loops
As in Example 5-1, the body of a while executes only when the expression, in the while
statement, evaluates to true. Typically, the expression checks whether a variable, called the
loop control variable (LCV), satisfies certain conditions. For example, in Example 5-1, the
expression in the while statement checks whether i <= 20. The LCV must be properly
initialized before the while loop is encountered, and it should eventually make the expression evaluate to false. We do this by updating or assigning a new value to the LCV in the
body of the while loop. Therefore, generally while loops are written in the following form:
//initialize the loop control variable(s)
while (expression) //expression tests the LCV
{
.
.
.
//update the LCV
.
.
.
}

For instance, in Example 5-1, the statement in Line 1 initializes the LCV i to 0. The
expression, i <= 20, in Line 2, checks whether i is less than or equal to 20. The
statement in Line 5 updates the value of i, which eventually makes i greater than 20 and
the expression, i <= 20, evaluates to false.
It is possible that the expression in the while statement may contain more than one
variable to control the loop. In that case, the loop has more than one LCV and all LCVs
must be properly initialized and updated.
EXAMPLE 5-2
Consider the following C++ program segment:
i = 20;
while (i < 20)
{
cout << i << " ";
i = i + 5;
}
cout << endl;

//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7

It is easy to overlook the difference between this example and Example 5-1. In this example, at
Line 1, i is initialized to 20, which makes the expression i < 20 in the while statement
(Line 2) evaluate to false. Because initially the loop entry condition, i < 20, is false, the
body of the while loop never executes. Hence, no values are output and the value of i remains
20. This example demonstrates the importance of the value to which the LCV is initialized.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

272 |

Chapter 5: Control Structures II (Repetition)

The next few sections describe the various forms of while loops.

Case 1: Counter-Controlled while Loops
Suppose you know exactly how many times certain statements need to be executed. For
example, suppose you know exactly how many pieces of data (or entries) need to be read.
In such cases, the while loop assumes the form of a counter-controlled while loop.
That is, the LCV serves as a ‘‘counter.’’ Suppose that a set of statements needs to be executed
N times. You can set up a counter (initialized to 0 before the while statement) to track
how many items have been read. Before executing the body of the while statement, the
counter is compared with N. If counter < N, the body of the while statement executes.
The body of the loop continues to execute until the value of counter >= N. Thus, inside
the body of the while statement, the value of counter increments by 1 after it reads a new
item. In this case, the while loop might look like the following:
counter = 0;

//initialize the loop control variable

while (counter < N) //test the loop control variable
{
.
.
.
counter++;
//update the loop control variable
.
.
.
}

If N represents the number of data items in a file, then the value of N can be determined several
ways. The program can prompt you to enter the number of items in the file and an input
statement can read the value you entered; or you can specify the first item in the file as the
number of items in the file, so that you need not remember the number of input values (items).
This is useful if someone other than the programmer enters the data. Consider Example 5-3.
EXAMPLE 5-3
Students at a local middle school volunteered to sell fresh baked cookies to raise funds to
increase the number of computers for the computer lab. Each student reported the number
of boxes he/she sold. We will write a program that will output the total number of boxes of
cookies sold, the total revenue generated by selling the cookies, and the average number of
boxes sold by each student. The data provided is in the following form:
studentName numOf BoxesSold

Consider the following program:
//Program: Counter-Controlled Loop
//This program computes and outputs the total number of boxes of
//cookies sold, the total revenue, and the average number of
//boxes sold by each volunteer.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

|

#include <iostream >
#include <string>
#include <iomanip>

//Line 1
//Line 2
//Line 3

using namespace std;

//Line 4

int main()
{
string name;
int numOfVolunteers;
int numOfBoxesSold;
int totalNumOfBoxesSold;
int counter;
double costOfOneBox;

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

273

5
6
7
8
9
10
11
12

cout << fixed << showpoint << setprecision(2);

//Line 13

cout << "Line 14: Enter the number of "
<< "volunteers: ";
cin >> numOfVolunteers;
cout << endl;

//Line 14
//Line 15
//Line 16

totalNumOfBoxesSold = 0;
counter = 0;

//Line 17
//Line 18

while (counter < numOfVolunteers)
{
cout << "Line 21: Enter the volunteer’s name"
<< " and the number of boxes sold: ";
cin >> name >> numOfBoxesSold;
cout << endl;
totalNumOfBoxesSold = totalNumOfBoxesSold
+ numOfBoxesSold;
counter++;
}

//Line 19
//Line 20
//Line 21
//Line 22
//Line 23
//Line 24
//Line 25
//Line 26

cout << "Line 27: The total number of boxes sold: "
<< totalNumOfBoxesSold << endl;
//Line 27
cout << "Line 28: Enter the cost of one box: ";
cin >> costOfOneBox;
cout << endl;

//Line 28
//Line 29
//Line 30

cout << "Line 31: The total money made by selling "
<< "cookies: $"
<< totalNumOfBoxesSold * costOfOneBox << endl; //Line 31
if (counter
cout <<
<<
<<

!= 0)
"Line 33: The average number of "
"boxes sold by each volunteer: "
totalNumOfBoxesSold / counter << endl;

//Line 32
//Line 33

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

274 |

Chapter 5: Control Structures II (Repetition)

else
cout << "Line 35: No input." << endl;

//Line 34
//Line 35

return 0;

//Line 36
//Line 37

}

Sample Run: In this sample run, the user input is shaded.
Line 14: Enter the number of volunteers: 5
Line 21: Enter the volunteer’s name and the number of boxes sold: Sara 120
Line 21: Enter the volunteer’s name and the number of boxes sold: Lisa 128
Line 21: Enter the volunteer’s name and the number of boxes sold: Cindy 359
Line 21: Enter the volunteer’s name and the number of boxes sold: Nicole 267
Line 21: Enter the volunteer’s name and the number of boxes sold: Blair 165
Line 27: The total number of boxes sold: 1039
Line 28: Enter the cost of one box: 3.50
Line 31: The total money made by selling cookies: $3636.50
Line 33: The average number of boxes sold by each volunteer: 207

This program works as follows. The statements in Lines 7 to 12 declare the variables used in the
program. The statement in Line 14 prompts the user to enter the number of student volunteers.
The statement in Line 15 inputs this number into the variable numOfVolunteers. The
statements in Lines 17 and 18 initialize the variables totalNumOfBoxesSold and
counter. (The variable counter is the loop control variable.)
The while statement in Line 19 checks the value of counter to determine how
many students’ data have been read. If counter is less than numOfVolunteers, the
while loop proceeds for the next iteration. The statement in Line 21 prompts
the user to input the student’s name and the number of boxes sold by the student.
The statement in Line 22 inputs the student’s name into the variable name and the
number of boxes sold by the student into the variable numOfBoxesSold. The
statement in Line 24 updates the value of totalNumOfBoxesSold by adding
the value of numOfBoxesSold to its current value and the statement in Line
25 increments the value of counter by 1. The statement in Line 27 outputs the
total number of boxes sold, the statement in Line 28 prompts the user to input
the cost of one box of cookies, and the statement in Line 29 inputs the cost in the
variable costOfOneBox. The statement in Line 31 outputs the total money made by
selling cookies, and the statements in Lines 32 through 35 output the average
number of boxes sold by each volunteer.
Note that totalNumOfBoxesSold is initialized to 0 in Line 17 in this program. In Line
22, after reading the number of boxes sold by a student, the program adds it to the sum of
all the boxes sold before the current number of boxes sold. The first numOfBoxesSold

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

|

275

read will be added to zero (because totalNumOfBoxesSold is initialized to 0), giving
the correct sum of the first number. To find the average, divide totalNumOfBoxesSold
by counter. If counter is 0, then dividing by zero will terminate the program and you
will get an error message. Therefore, before dividing totalNumOfBoxesSold by
counter, you must check whether or not counter is 0.
Notice that in this program, the statement in Line 18 initializes the LCV counter to 0.
The expression counter < numOfVolunteers in Line 19 evaluates whether counter is
less than numOfVolunteers. The statement in Line 25 updates the value of counter.

Case 2: Sentinel-Controlled while Loops
You do not always know how many pieces of data (or entries) need to be read, but you
may know that the last entry is a special value, called a sentinel, that will tell the loop to
stop. In this case, you must read the first item before the while statement so the test
expression will have a valid value to test. If this item does not equal the sentinel, the
body of the while statement executes. The while loop continues to execute as long as
the program has not read the sentinel. Such a while loop is called a sentinelcontrolled while loop. In this case, a while loop might look like the following:
cin >> variable;

//initialize the loop control variable

while (variable != sentinel) //test the loop control variable
{
.
.
.
cin >> variable;
//update the loop control variable
.
.
.
}

EXAMPLE 5-4
The program in Example 5-3 computes and outputs the total number of boxes of
cookies sold, the total money made, and the average number of boxes sold by each
student. However, the program assumes that the programmer knows the exact number
of volunteers. Now suppose that the programmer does not know the exact number of
volunteers. Once again, assume that the data is in the following form: student’s name
followed by a space and the number of boxes sold by the student. Because we do not know
the exact number of volunteers, we assume that reading a value of -1 for name will
mark the end of the data, since it is a highly unlikely name to run into. So consider the
following program:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

276 |

Chapter 5: Control Structures II (Repetition)

//Program: Sentinel-Controlled Loop
//This program computes and outputs the total number of boxes of
//cookies sold, the total revenue, and the average number of
//boxes sold by each volunteer.
#include <iostream >
#include <string>
#include <iomanip>

//Line 1
//Line 2
//Line 3

using namespace std;

//Line 4

const string SENTINEL = "-1";

//Line 5

int main()
{
string name;
int numOfVolunteers;
int numOfBoxesSold;
int totalNumOfBoxesSold;
double costOfOneBox;

//Line
//Line
//Line
//Line
//Line
//Line
//Line

cout << fixed << showpoint << setprecision(2);
cout <<
<<
<<
<<

6
7
8
9
10
11
12

//Line 13

"Line 14: Enter each volunteer's name and "
"the number of boxes " << endl
"
sold by each volunteer, ending "
"with -1: " << endl;
//Line 14

totalNumOfBoxesSold = 0;
numOfVolunteers = 0;

//Line 15
//Line 16

cin >> name;

//Line 17

while (name != SENTINEL)
{
cin >> numOfBoxesSold;
totalNumOfBoxesSold = totalNumOfBoxesSold
+ numOfBoxesSold;
numOfVolunteers++;
cin >> name;
}

//Line 18
//Line 19
//Line 20

cout << endl;

//Line 25

//Line
//Line
//Line
//Line

21
22
23
24

cout << "Line 26: The total number of boxes sold: "
<< totalNumOfBoxesSold << endl;
//Line 26
cout << "Line 27: Enter the cost of one box: ";
cin >> costOfOneBox;
cout << endl;

//Line 27
//Line 28
//Line 29

cout << "Line 30: The total money made by selling "
<< "cookies: $"
<< totalNumOfBoxesSold * costOfOneBox << endl; //Line 30
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

if (numOfVolunteers != 0)
cout << "Line 32: The average number of "
<< "boxes sold by each volunteer: "
<< totalNumOfBoxesSold / numOfVolunteers
<< endl;
else
cout << "Line 34: No input." << endl;
return 0;
}

|

277

//Line 31

//Line 32
//Line 33
//Line 34
//Line 35
//Line 36

Sample Run: In this sample run, the user input is shaded.
Line 14: Enter each volunteer's name and the number of boxes
sold by each volunteer, ending with -1:
Sara 120
Lisa 128
Cindy 359
Nicole 267
Blair 165
Abby 290
Amy 190
Megan 450
Elizabeth 280
Meredith 290
Leslie 430
Chelsea 378
-1
Line 26: The total number of boxes sold: 3347
Line 27: Enter the cost of one box: 3.50
Line 30: The total money made by selling cookies: $11714.50
Line 32: The average number of boxes sold by each volunteer: 278

This program works as follows. The statements in Lines 8 to 12 declare the variables used in
the program. The statement in Line 14 prompts the user to enter the data ending with -1.
The statements in Lines 15 and 16 initialize the variables totalNumOfBoxesSold and
numOfVolunteers. The statement in Line 17 reads the first name and stores it in name.
The while statement in Line 18 checks whether name is not equal to SENTINEL. (The
variable name is the loop control variable.) If name is not equal to SENTINEL, the body of
the while loop executes. The statement in Line 20 reads and stores the number of boxes
sold by the student in the variable numOfBoxesSold and the statement in Line 21 updates
the value of totalNumOfBoxesSold by adding numOfBoxesSold to it. The statement
in Line 22 increments the value of numOfVolunteers by 1, and the statement in Line 23
reads and stores the next name into name. The statements in Lines 20 through 23 repeat
until the program reads the SENTINEL. The statement in Line 26 outputs the total number
of boxes sold, the statement in Line 27 prompts the user to input the cost of one box of
cookies, and the statement in Line 28 inputs the cost in the variable costOfOneBox. The
statement in Line 30 outputs the total money made by selling cookies, and the statements in
Lines 31 through 34 output the average number of boxes sold by each volunteer.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

278 |

Chapter 5: Control Structures II (Repetition)

Notice that the statement in Line 17 initializes the LCV name. The expression name !¼
SENTINEL in Line 18 checks whether the value of name is not equal to SENTINEL. The
statement in Line 23 updates the LCV name.
Next, consider another example of a sentinel-controlled while loop. In this example, the
user is prompted to enter the value to be processed. If the user wants to stop the program,
he or she can enter the sentinel.
EXAMPLE 5-5

Telephone Digits
The following program reads the letter codes A to Z and prints the corresponding
telephone digit. This program uses a sentinel-controlled while loop. To stop the
program, the user is prompted for the sentinel, which is #. This is also an example of a
nested control structure, where if...else and the while loop are nested.
//**********************************************************
// Program: Telephone Digits
// This is an example of a sentinel-controlled loop. This
// program converts uppercase letters to their corresponding
// telephone digits.
//**********************************************************
#include <iostream>

//Line 1

using namespace std;

//Line 2

int main()
{
char letter;
int digit, num;

//Line
//Line
//Line
//Line

3
4
5
6

cout << "Program to convert uppercase letters to "
<< "their corresponding telephone digits."
<< endl;
//Line 8
cout << "To stop the program enter #." << endl;

//Line 9

cout << "Enter an uppercase
cin >> letter;
cout << endl;

//Line 10
//Line 11
//Line 12

letter: ";

while (letter != '#')
{
cout << "Letter: " << letter;
cout << ", Corresponding telephone digit: ";
num = static_cast<int>(letter)
- static_cast<int>('A');

//Line
//Line
//Line
//Line

13
14
15
16

//Line 17

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

if (0 <= num && num < 26)
{
digit = (num / 3) + 2;

//Line 21
//Line 22
//Line 23

if (digit > 9)
digit = 9;

//Line 24
//Line 25

cout << digit << endl;
}
else
cout << "Invalid input." << endl;

//Line
//Line
//Line
//Line

cout <<
<<
<<
cout <<
<<

//Line 30

26
27
28
29

//Line 31

cout << "Enter a letter: ";
cin >> letter;
cout << endl;
}//end while

//Line
//Line
//Line
//Line

return 0;

//Line 36
//Line 37

}

279

//Line 18
//Line 19
//Line 20

if (((num / 3 == 6 ) || (num / 3 == 7))
&& (num % 3 == 0))
digit = digit - 1;

"\nEnter another uppercase "
"letter to find its corresponding "
"telephone digit." << endl;
"To stop the program enter #."
endl;

|

32
33
34
35

Sample Run: In this sample run, the user input is shaded.
Program to convert uppercase letters to their corresponding telephone
digits.
To stop the program enter #.
Enter a letter: A
Letter: A, Corresponding telephone digit: 2
Enter another uppercase letter to find its corresponding telephone
digit.
To stop the program enter #.
Enter a letter: M
Letter: M, Corresponding telephone digit: 6
Enter another uppercase letter to find its corresponding telephone
digit.
To stop the program enter #.
Enter a letter: Q
Letter: Q, Corresponding telephone digit: 7

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

280 |

Chapter 5: Control Structures II (Repetition)

Enter another uppercase letter to find its corresponding telephone
digit.
To stop the program enter #.
Enter a letter: V
Letter: V, Corresponding telephone digit: 8
Enter another uppercase letter to find its corresponding telephone
digit.
To stop the program enter #.
Enter a letter: Y
Letter: Y, Corresponding telephone digit: 9
Enter another uppercase letter to find its corresponding telephone
digit.
To stop the program enter #.
Enter a letter: #

This program works as follows. The statements in Lines 8 and 9 tell the user what to do.
The statement in Line 10 prompts the user to input a letter; the statement in Line 11 reads
and stores that letter into the variable letter. The while loop at Line 13 checks if letter
is #. If the letter entered by the user is not #, the body of the while loop executes. The
statement at Line 15 outputs the letter entered by the user. The statement in Line 17
determines the position of the letter in the English alphabet. (Note that the position of A
is 0, B is 1, and so on.) The if statement at Line 18 checks whether the letter entered by
the user is uppercase. If the letter entered by the user is uppercase, the statements between
Lines 19 and 27 determine and output the corresponding telephone digit. If the letter
entered by the user is not valid, the else (Line 28) executes.
Let us see how the statements in Lines 19 to 27 determine the corresponding telephone
digits. Now, the letters A, B, and C correspond to the telephone digit 2, letters D, E, and F
correspond to the telephone digit 3, and so on. Note that the letters P, Q, R, and S
correspond to telephone digit 7, and the letters W, X, Y, and Z correspond to the telephone
digit 9. The ASCII values of the letters A, B, and C, are 65, 66, and 67, respectively. We
subtract 65 from these values to get 0, 1, and 2. If we divide each of these numbers by 3,
then the quotient is 0, so we add 2 to the quotient to get the corresponding telephone
digit. Similarly, the ASCII values of the letters D, E, and F are 68, 69, and 70, respectively.
We subtract 65 from these values, to get 3, 4, and 5. Again we divide 3, 4, and 5 by 3 to
get the quotient 1, and then add 2 to get the corresponding telephone digit, which is 3.
The statements in Lines 18 to 23 handle the cases when four letters, such as P, Q, R, and S,
correspond to a telephone digit. We leave the details as an exercise.
Once the current letter is processed, the statements at Lines 30 and 31 again inform
the user what to do next. The statement at Line 32 prompts the user to enter a letter;
the statement at Line 33 reads and stores that letter into the variable letter. After
the statement at Line 34 (at the end of the while loop) executes, the control goes
back to the top of the while loop and the same process begins again. When the user
enters #, the program terminates.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

|

281

Notice that in this program, the variable letter is the loop control variable. First, it is
initialized in Line 11, by the input statement, and then updated in Line 33. The
expression in Line 13 checks whether letter is #.
The statements in Lines 17 to 29 can be written using a switch statement by checking
each letter and outputting the corresponding telephone digit as follows:

if (letter >= 'A' && letter <= 'Z')
switch (letter)
{
case 'A':
case 'B':
case 'C':
cout << 2 << endl;
break;
case 'D':
case 'E':
case 'F':
cout << 3 << endl;
break;
.
.
.
However, this code will be very long and occupy a considerable amount of space.

Case 3: Flag-Controlled while Loops
A flag-controlled while loop uses a bool variable to control the loop. A flag variable
is a bool variable that indicates whether a condition is true or false. It is generally
named for the true state of that condition: for example, isFound, isTallEnough, and
isFull. Suppose isFound is a bool variable. The flag-controlled while loop takes the
following form:
isFound = false;

//initialize the loop control variable

while (!isFound)
//test the loop control variable
{
.
.
.
if (expression)
isFound = true; //update the loop control variable
.
.
.
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

282 |

Chapter 5: Control Structures II (Repetition)

Example 5-6 further illustrates the use of a flag-controlled while loop.
EXAMPLE 5-6

Number Guessing Game
The following program randomly generates an integer greater than or equal to 0 and less
than 100. The program then prompts the user to guess the number. If the user guesses
the number correctly, the program outputs an appropriate message. Otherwise, the
program checks whether the guessed number is less than the random number. If the
guessed number is less than the random number generated by the program, the program
outputs the message ‘‘Your guess is lower than the number. Guess again!’’; otherwise, the
program outputs the message ‘‘Your guess is higher than the number. Guess again!’’. The
program then prompts the user to enter another number. The user is prompted to guess
the random number until the user enters the correct number.
To generate a random number, you can use the function rand from the header file
cstdlib. For example, the expression rand() returns an int value between 0 and
32767. Therefore, the statement:
cout << rand() << ", " << rand() << endl;

will output two numbers that appear to be random. However, each time the program is run,
this statement will output the same random numbers. This is because the function rand uses
an algorithm that produces the same sequence of random numbers each time the program is
executed on the same system. To generate different random numbers each time the program
is executed, you also use the function srand from the header file cstdlib. The function
srand takes as input an unsigned int, which acts as the seed for the algorithm. By
specifying different seed values, each time the program is executed, the function rand will
generate a different sequence of random numbers. To specify a different seed, you can use
the function time from the header file ctime, which returns the number of seconds elapsed
since January 1, 1970. For example, consider the following statements:
srand(time(0));
num = rand() % 100;

The first statement sets the seed, and the second statement generates a random number
greater than or equal to 0 and less than 100. Note how the function time is used. It is
used with an argument, that is, parameter, which is 0.
The program uses the bool variable isGuessed to control the loop. The bool variable
isGuessed is initialized to false. It is set to true when the user guesses the correct
number.
//Flag-controlled while loop.
//Number guessing game.
#include <iostream>
#include <cstdlib>
#include <ctime>
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

|

283

using namespace std;
int main()
{
//declare the variables
int num;
//variable to store the random
//number
int guess;
//variable to store the number
//guessed by the user
bool isGuessed; //boolean variable to control
//the loop
srand(time(0));
num = rand() % 100;

//Line 1
//Line 2

isGuessed = false;

//Line 3

while (!isGuessed)
{
cout << "Enter an integer greater"
<< " than or equal to 0 and "
<< "less than 100: ";

//Line 4
//Line 5

cin >> guess;
cout << endl;

//Line 6
//Line 7
//Line 8

if (guess == num)
//Line 9
{
//Line 10
cout << "You guessed the correct "
<< "number." << endl;
//Line 11
isGuessed = true;
//Line 12
}
//Line 13
else if (guess < num)
//Line 14
cout << "Your guess is lower than the "
<< "number.\n Guess again!"
<< endl;
//Line 15
else
//Line 16
cout << "Your guess is higher than "
<< "the number.\n Guess again!"
<< endl;
//Line 17
} //end while
//Line 18
return 0;
}

Sample Run: In this sample run, the user input is shaded.
Enter an integer greater than or equal to 0 and less than 100: 45
Your guess is higher than the number.
Guess again!
Enter an integer greater than or equal to 0 and less than 100: 20

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

284 |

Chapter 5: Control Structures II (Repetition)

Your guess is lower than the number.
Guess again!
Enter an integer greater than or equal to 0 and less than 100: 35
Your guess is higher than the number.
Guess again!
Enter an integer greater than or equal to 0 and less than 100: 28
Your guess is lower than the number.
Guess again!
Enter an integer greater than or equal to 0 and less than 100: 32
You guessed the correct number.

The preceding program works as follows: The statement in Line 2 creates an integer
greater than or equal to 0 and less than 100 and stores this number in the variable num.
The statement in Line 3 sets the bool variable isGuessed to false. The expression in
the while loop at Line 4 evaluates the expression !isGuessed. If isGuessed is
false, then !isGuessed is true and the body of the while loop executes; if
isGuessed is true, then !isGuessed is false, so the while loop terminates. We
could also have used isGuessed == false as the test expression, but !isGuessed
does the same thing and is shorter.
The statement in Line 6 prompts the user to enter an integer greater than or equal to 0
and less than 100. The statement in Line 7 stores the number entered by the user in the
variable guess. The expression in the if statement in Line 9 determines whether
the value of guess is the same as num, that is, if the user guessed the number correctly.
If the value of guess is the same as num, the statement in Line 11 outputs the message:
You guessed the correct number.

The statement in Line 12 sets the variable isGuessed to true. The control then goes
back to Line 3. If the expression in Line 9 evaluates to false, then the else statement
in Line 14 determines whether the value of guess is less than or greater than num and
outputs the appropriate message.

Case 4: EOF-Controlled while Loops
If the data file is frequently altered (for example, if data is frequently added or deleted), it’s
best not to read the data with a sentinel value. Someone might accidentally erase the sentinel
value or add data past the sentinel, especially if the programmer and the data entry person are
different people. Also, it can be difficult at times to select a good sentinel value. In such
situations, you can use an end-of-file (EOF)-controlled while loop.
Until now, we have used an input stream variable, such as cin, and the extraction
operator, >>, to read and store data into variables. However, the input stream variable
can also return a value after reading data, as follows:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

|

285

1. If the program has reached the end of the input data, the input stream
variable returns the logical value false.
2. If the program reads any faulty data (such as a char value into an int
variable), the input stream enters the fail state. Once a stream enters the fail
state, any further I/O operations using that stream are considered to be null
operations; that is, they have no effect. Unfortunately, the computer does
not halt the program or give any error messages. It just continues executing
the program, silently ignoring each additional attempt to use that stream. In
this case, the input stream variable returns the value false.
3. In cases other than (1) and (2), the input stream variable returns the
logical value true.
You can use the value returned by the input stream variable to determine whether the
program has reached the end of the input data. Because the input stream variable returns the
logical value true or false, in a while loop, it can be considered a logical expression.
The following is an example of an EOF-controlled while loop:
cin >> variable;

//initialize the loop control variable

while (cin)
//test the loop control variable
{
.
.
.
cin >> variable; //update the loop control variable
.
.
.
}

Notice that here, the variable cin acts as the loop control variable.

eof Function
In addition to checking the value of an input stream variable, such as cin, to determine
whether the end of the file has been reached, C++ provides a function that you can use
with an input stream variable to determine the end-of-file status. This function is called
eof. Like the I/O functions—such as get, ignore, and peek, discussed in Chapter 3—
the function eof is a member of the data type istream.
The syntax to use the function eof is:
istreamVar.eof()

in which istreamVar is an input stream variable, such as cin.
Suppose you have the declaration:
ifstream infile;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

286 |

Chapter 5: Control Structures II (Repetition)

Further suppose that you opened a file using the variable infile. Consider the expression:
infile.eof()

This is a logical (Boolean) expression. The value of this expression is true if the program has
read past the end of the input file, infile; otherwise, the value of this expression is false.
Using the function eof to determine the end-of-file status works best if the input is text.
The earlier method of determining the end-of-file status works best if the input consists
of numeric data.
Suppose you have the declaration:
ifstream infile;
char ch;
infile.open("inputDat.dat");

The following while loop continues to execute as long as the program has not reached
the end of the file:
infile.get(ch);
while (!infile.eof())
{
cout << ch;
infile.get(ch);
}

As long as the program has not reached the end of the input file, the expression:
infile.eof()

is false and so the expression:
!infile.eof()

in the while statement is true. When the program reads past the end of the input file,
the expression:
infile.eof()

becomes true, so the expression:
!infile.eof()

in the while statement becomes false and the loop terminates.
In the Windows console environment, the end-of-file marker is entered using Ctrl+z
(hold the Ctrl key and press z). In the UNIX environment, the end-of-file marker is
entered using Ctr+d (hold the Ctrl key and press d).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

|

287

EXAMPLE 5-7
The following code uses an EOF-controlled while loop to find the sum of a set of
numbers:
int sum = 0;
int num;
cin >> num;
while (cin)
{
sum = sum + num;
cin >> num;
}

//Add the number to sum
//Get the next number

5

cout << "Sum = " << sum << endl;

EXAMPLE 5-8
Suppose we are given a file consisting of students’ names and their test scores, a number
between 0 and 100 (inclusive). Each line in the file consists of a student name followed by
the test score. We want a program that outputs each student’s name followed by the test
score followed by the grade. The program also needs to output the average test score for
the class. Consider the following program:
//
//
//
//

This program reads data from a file consisting of students'
names and their test scores. The program outputs each student's
name followed by the test score followed by the grade. The
program also outputs the average test score for all the students.

#include
#include
#include
#include

<iostream>
<fstream>
<string>
<iomanip>

//Line
//Line
//Line
//Line

1
2
3
4

using namespace std;

//Line 5

int main()
{
//Declare variables to manipulate data
string firstName;
string lastName;
double testScore;
char grade = ' ';
double sum = 0;
int count = 0;

//Line 6
//Line 7
//Line
//Line
//Line
//Line
//Line
//Line

8
9
10
11
12
13

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

288 |

Chapter 5: Control Structures II (Repetition)

//Declare stream variables
ifstream inFile;
ofstream outFile;

//Line 14
//Line 15

//Open input file
inFile.open("Ch5_stData.txt");

//Line 16

if (!inFile)
{
cout << "Cannot open input file. "
<< "Program terminates!" << endl;
return 1;
}
//Open output file
outFile.open("Ch5_stData.out");

//Line 22

outFile << fixed << showpoint << setprecision(2);

//Line 23

inFile >> firstName >> lastName; //read the name
inFile >> testScore;
//read the test score

Line 24
Line 25

while (inFile)
{
sum = sum + testScore; //update sum
count++;
//increment count

//Line 17
//Line 18
//Line 19
//Line 20
//Line 21

//Line
//Line
Line
Line

26
27
28
29

//determine the grade
switch (static_cast<int> (testScore) / 10)
{
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
grade = 'F';
break;

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

30
31
32
33
34
35
36
37
38
39

case 6:
grade = 'D';
break;

//Line 40
//Line 41
//Line 42

case 7:
grade = 'C';
break;

//Line 43
//Line 44
//Line 45

case 8:
grade = 'B';
break;

//Line 46
//Line 47
//Line 48

case 9:
case 10:
grade = 'A';
break;

//Line
//Line
//Line
//Line

49
50
51
52

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

while Looping (Repetition) Structure

default:
cout << "Invalid score." << endl;
}//end switch

//Line 53
//Line 54
//Line 55

outFile <<
<<
<<
<<

//Line 56

left << setw(12) << firstName
setw(12) << lastName
right << setw(4) << testScore
setw(2) << grade << endl;

|

289

inFile >> firstName >> lastName; //read the name Line 57
inFile >> testScore;
//read the test score Line 58
}//end while
//Line 59
outFile << endl;

//Line 60

if (count != 0)
outFile << "Class Average: " << sum / count
<<endl;
else
outFile << "No data." << endl;

//Line 61
//Line 62
//Line 63
//Line 64

inFile.close();
outFile.close();

//Line 65
//Line 66

return 0;

//Line 67
//Line 68

}

Sample Run:
Input File:
Steve Gill 89
Rita Johnson 91.5
Randy Brown 85.5
Seema Arora 76.5
Samir Mann 73
Samantha McCoy 88.5

Output File:
Steve
Rita
Randy
Seema
Samir
Samantha

Gill
Johnson
Brown
Arora
Mann
McCoy

89.00
91.50
85.50
76.50
73.00
88.50

B
A
B
C
C
B

Class Average: 84.00

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

290 |

Chapter 5: Control Structures II (Repetition)

The preceding program works as follows. The statements in Lines 8 to 13 declare and
initialize variables needed by the program. The statements in Lines 14 and 15 declares
inFile to be an ifstream variable and outFile to be an ofstream variable. The
statement in Line 16 opens the input file using the variable inFile. If the input file does
not exist, the statements in Lines 17 to 21 output an appropriate message and terminate
the program. The statement in Line 22 opens the output file using the variable outFile.
The statement in Line 23 sets the output of floating-point numbers to two decimal places
in a fixed form with trailing zeros.
The statements in Lines 24 and 25 and the while loop in Line 26 read each student’s first
name, last name, and test score and then output the name followed by the test score
followed by the grade. Specifically, the statements in Lines 24 and 57 read the first and last
name; the statements in Lines 25 and 58 read the test score. The statement in Line 28
updates the value of sum. (After reading all the data, the value of sum stores the sum of all
the test scores.) The statement in Line 29 updates the value of count. (The variable
count stores the number of students in the class.) The switch statement from Lines 30
to 55 determines the grade from testScore and stores it in the variable grade. The
statement in Line 56 outputs a student’s first name, last name, test score, and grade.
The if...else statement in Lines 61 to 64 outputs the class average and the statements
in Lines 65 and 66 close the files.
The Programming Example: Checking Account Balance, available on the Web site
accompanying this book, further illustrates how to use an EOF-controlled while loop
in a program.

More on Expressions in while Statements
In the examples of the previous sections, the expression in the while statement is quite
simple. In other words, the while loop is controlled by a single variable. However, there
are situations when the expression in the while statement may be more complex.
For example, the program in Example 5-6 uses a flag-controlled while loop to implement the Number Guessing Game. However, the program gives as many tries as the user
needs to guess the number. Suppose you want to give the user no more than five tries to
guess the number. If the user does not guess the number correctly within five tries, then
the program outputs the random number generated by the program as well as a message
that you have lost the game. In this case, you can write the while loop as follows (assume
that noOfGuesses is an int variable initialized to 0):
while ((noOfGuesses < 5) && (!isGuessed))
{
cout << "Enter an integer greater than or equal to 0 and "
<< "less than 100: ";
cin >> guess;
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Fibonacci Number

|

291

noOfGuesses++;
if (guess == num)
{
cout << "Winner!. You guessed the correct number."
<< endl;
isGuessed = true;
}
else if (guess < num)
cout << "Your guess is lower than the number.\n"
<< "Guess again!" << endl;
else
cout << "Your guess is higher than the number.\n"
<< "Guess again!" << endl;
}//end while

You also need the following code to be included after the while loop in case the user
cannot guess the correct number in five tries:
if (!isGuessed)
cout << "You lose! The correct number is " << num << endl;

Programming Exercise 15 at the end of this chapter asks you to write a complete C++
program to implement the Number Guessing Game in which the user has, at most, five
tries to guess the number.
As you can see from the preceding while loop, the expression in a while statement can
be complex. The main objective of a while loop is to repeat certain statement(s) until
certain conditions are met.

PROGRAMMING EXAMPLE:

Fibonacci Number

So far, you have seen several examples of loops. Recall that in C++, while loops are
used when certain statements must be executed repeatedly until certain conditions are
met. Following is a C++ program that uses a while loop to find a Fibonacci number.
Watch
the Video

Consider the following sequence of numbers:
1, 1, 2, 3, 5, 8, 13, 21, 34, ....

This sequence is called the Fibonacci sequence. Given the first two numbers of the
sequence (say, a1 and a2), the nth number an, n >= 3, of this sequence is given by:
an ¼ an1 þ an2
Thus:
a3 ¼ a2 þ a1 ¼ 1 þ 1 ¼ 2,
a4 ¼ a3 þ a2 ¼ 2 þ 1 ¼ 3,
and so on.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

292 |

Chapter 5: Control Structures II (Repetition)

Note that a2 = 1 and a1 = 1. However, given any first two numbers, using this
process, you can determine the nth number, an,n >= 3, of the sequence. We will
again call such a sequence a Fibonacci sequence. Suppose a2 = 6 and a1 = 3.
Then:
a3 ¼ a2 þ a1 ¼ 6 þ 3 ¼ 9; a4 ¼ a3 þ a2 ¼ 9 þ 6 ¼ 15
Next, we write a program that determines the nth Fibonacci number given the first
two numbers.

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Input

The first two Fibonacci numbers and the desired Fibonacci number.

Output

The nth Fibonacci number.

To find, say, the tenth Fibonacci number of a sequence, you must first find a9 and a8,
which requires you to find a7 and a6, and so on. Therefore, to find a10, you must first
find a3, a4, a5, . . ., a9. This discussion translates into the following algorithm:
1. Get the first two Fibonacci numbers.
2. Get the desired Fibonacci position. That is, get the position, n, of the
Fibonacci number in the sequence.
3. Calculate the next Fibonacci number by adding the previous two
elements of the Fibonacci sequence.
4. Repeat Step 3 until the nth Fibonacci number is found.
5. Output the nth Fibonacci number.
Note that the program assumes that the first number of the Fibonacci sequence is less
than or equal to the second number of the Fibonacci sequence, and both numbers are
nonnegative. Moreover, the program also assumes that the user enters a valid value for
the position of the desired number in the Fibonacci sequence; that is, it is a positive
integer. (See Programming Exercise 11 at the end of this chapter.)

Variables Because the previous two numbers must be known in order to find the current

Fibonacci number, you need the following variables: two variables—say,
previous1 and previous2 to hold the previous two numbers of the Fibonacci
sequence; and one variable—say, current—to hold the current Fibonacci
number. The number of times that Step 2 of the algorithm repeats depends on
the position of the Fibonacci number you are calculating. For example, if you
want to calculate the tenth Fibonacci number, you must execute Step 3 eight
times. (Remember—the user gives the first two numbers of the Fibonacci
sequence.) Therefore, you need a variable to store the number of times Step 3
should execute. You also need a variable to track the number of times Step 3 has
executed, the loop control variable. You therefore need five variables for the data
manipulation:
int previous1;
int previous2;

//variable to store the first Fibonacci number
//variable to store the second Fibonacci number

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Fibonacci Number

|

293

int current;

//variable to store the current
//Fibonacci number
int counter;
//loop control variable
int nthFibonacci; //variable to store the desired
//Fibonacci number

To calculate the third Fibonacci number, add the values of previous1 and previous2
and store the result in current. To calculate the fourth Fibonacci number, add the value
of the second Fibonacci number (that is, previous2) and the value of the third Fibonacci
number (that is, current). Thus, when the fourth Fibonacci number is calculated, you
no longer need the first Fibonacci number. Instead of declaring additional variables, which
could be too many, after calculating a Fibonacci number to determine the next Fibonacci
number, previous1 is set to previous2 and previous2 is set to current. Therefore, you can again use the variable current to store the next Fibonacci number. This
process is repeated until the desired Fibonacci number is calculated. Initially, previous1
and previous2 are the first two elements of the sequence, supplied by the user. From the
preceding discussion, it follows that you need five variables.
MAIN
ALGORITHM

1. Prompt the user for the first two numbers—that is, previous1 and
previous2.
2. Read (input) the first two numbers into previous1 and previous2.
3. Output the first two Fibonacci numbers. (Echo input.)
4. Prompt the user for the position of the desired Fibonacci number.
5. Read the position of the desired Fibonacci number into
nthFibonacci.
6. a. if (nthFibonacci == 1)
The desired Fibonacci number is the first Fibonacci number.
Copy the value of previous1 into current.
b. else if (nthFibonacci == 2)
The desired Fibonacci number is the second Fibonacci number.
Copy the value of previous2 into current.
c. else calculate the desired Fibonacci number as follows:
Because you already know the first two Fibonacci numbers of
the sequence, start by determining the third Fibonacci number.
c.1.
c.2.

Initialize counter to 3 to keep track of the calculated
Fibonacci numbers.
Calculate the next Fibonacci number, as follows:

c.3.
c.4.
c.5.

Assign the value of previous2 to previous1.
Assign the value of current to previous2.
Increment counter by 1.

current = previous2 + previous1;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

294 |

Chapter 5: Control Structures II (Repetition)

Repeat Steps c.2 through c.5 until the Fibonacci number you want is calculated.
The following while loop executes Steps c.2 through c.5 and determines the
nth Fibonacci number.
while (counter <= nthFibonacci)
{
current = previous2 + previous1;
previous1 = previous2;
previous2 = current;
counter++;
}

7. Output the nthFibonacci number, which is stored in the variable
current.
COMPLETE PROGRAM LISTING
//*************************************************************
// Authors: D.S. Malik
//
// Program: nth Fibonacci number
// Given the first two numbers of a Fibonacci sequence, this
// program determines and outputs the desired number of the
// Fibonacci sequence.
//*************************************************************
#include <iostream >
using namespace std;
int main()
{
int
int
int
int
int

//Declare variables
previous1;
previous2;
current;
counter;
nthFibonacci;

cout << "Enter the first two Fibonacci "
<< "numbers: ";
//Step 1
cin >> previous1 >> previous2;
//Step 2
cout << endl;
cout << "The first two Fibonacci numbers are "
<< previous1 << " and " << previous2
<< endl;
//Step 3
cout << "Enter the position of the desired "
<< "Fibonacci number: ";
//Step 4
cin >> nthFibonacci;
//Step 5
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

for Looping (Repetition) Structure

if (nthFibonacci == 1)
current = previous1;
else if (nthFibonacci == 2)
current = previous2;
else
{
counter = 3;
//Steps 6.c.2 - 6.c.5
while (counter <= nthFibonacci)
{
current = previous2 + previous1;
previous1 = previous2;
previous2 = current;
counter++;
}//end while
}//end else
cout << "The Fibonacci number at position "
<< nthFibonacci << " is " << current
<< endl;

|

295

//Step 6.a
//Step 6.b
//Step 6.c
//Step 6.c.1

//Step
//Step
//Step
//Step

6.c.2
6.c.3
6.c.4
6.c.5

//Step 7

return 0;
}//end main

Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1:
Enter the first two Fibonacci numbers: 12 16
The first two Fibonacci numbers are 12 and 16
Enter the position of the desired Fibonacci number: 10
The Fibonacci number at position 10 is 796

Sample Run 2:
Enter the first two Fibonacci numbers: 1 1
The first two Fibonacci numbers are 1 and 1
Enter the position of the desired Fibonacci number: 15
The Fibonacci number at position 15 is 610

for Looping (Repetition) Structure
The while loop discussed in the previous section is general enough to implement
most forms of repetitions. The C++ for looping structure discussed here is a specialized
form of the while loop. Its primary purpose is to simplify the writing of counter-controlled
loops. For this reason, the for loop is typically called a counted or indexed for loop.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

296 |

Chapter 5: Control Structures II (Repetition)

The general form of the for statement is:
for (initial statement; loop condition; update statement)
statement

The initial statement, loop condition, and update statement (called for
loop control statements) enclosed within the parentheses control the body (statement)
of the for statement. Figure 5-2 shows the flow of execution of a for loop.

initial
statement

loop
condition

true

statement

update
statement

false

FIGURE 5-2

for loop

The for loop executes as follows:
1. The initial statement executes.
2. The loop condition is evaluated. If the loop condition evaluates
to true:
i. Execute the for loop statement.
ii. Execute the update statement (the third expression in the parentheses).
3. Repeat Step 2 until the loop condition evaluates to false.
The initial statement usually initializes a variable (called the for loop control, or
for indexed, variable).
In C++, for is a reserved word.
As the name implies, the initial statement in the for loop is the first statement to
execute; it executes only once.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

for Looping (Repetition) Structure

|

297

EXAMPLE 5-9
The following for loop prints the first 10 nonnegative integers:
for (i = 0; i < 10; i++)
cout << i << " ";
cout << endl;

The initial statement, i = 0;, initializes the int variable i to 0. Next, the loop
condition, i < 10, is evaluated. Because 0 < 10 is true, the print statement executes and
outputs 0. The update statement, i++, then executes, which sets the value of i to 1.
Once again, the loop condition is evaluated, which is still true, and so on. When i
becomes 10, the loop condition evaluates to false, the for loop terminates, and
the first statement following the for loop executes.
A for loop can have either a simple or compound statement.
The following examples further illustrate how a for loop executes.
EXAMPLE 5-10
1. The following for loop outputs Hello! and a star (on separate lines)
five times:
for (i = 1; i <= 5; i++)
{
cout << "Hello!" << endl;
cout << "*" << endl;
}

2. Consider the following for loop:
for (i = 1; i <= 5; i++)
cout << "Hello!" << endl;
cout << "*" << endl;

The output of this for loop is:
Hello!
Hello!
Hello!
Hello!
Hello!
*

The for loop controls only the first output statement because the two
output statements are not made into a compound statement using
braces. Therefore, the first output statement executes five times because
the for loop body executes five times. After the for loop executes, the
second output statement executes only once. The indentation, which is
ignored by the compiler, is nevertheless misleading.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

298 |

Chapter 5: Control Structures II (Repetition)

EXAMPLE 5-11
The following for loop executes five empty statements:
for (i = 0; i < 5; i++);
cout << "*" << endl;

//Line 1
//Line 2

The semicolon at the end of the for statement (before the output statement, Line 1)
terminates the for loop. The action of this for loop is empty, that is, null. As in
Example 5-10(2), the indentation of Line 2 is misleading.

The preceding examples show that care is required in getting a for loop to perform the
desired action.
The following are some comments on for loops:
•
•

•

•
•
•

If the loop condition is initially false, the loop body does not execute.
The update expression, when executed, changes the value of the
loop control variable (initialized by the initial expression), which should
change in such a way that eventually sets the value of the loop condition
to false. The for loop body executes indefinitely if the loop
condition is always true.
C++ allows you to use fractional values for loop control variables of the
double type (or any real data type). Because different computers can
give these loop control variables different results, you should avoid using
such variables.
A semicolon at the end of the for statement (just before the body of the
loop) is a semantic error. In this case, the action of the for loop is empty.
In the for statement, if the loop condition is omitted, it is assumed
to be true.
In a for statement, you can omit all three statements—initial
statement, loop condition, and update statement. However,
the for statement must contain two semicolons. The following is a legal
for loop:
for (;;)
cout << "Hello" << endl;

This is an infinite for loop, continuously printing the word Hello.
Following are more examples of for loops.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

for Looping (Repetition) Structure

|

299

EXAMPLE 5-12
You can count backward using a for loop if the for loop control expressions are set correctly.
For example, consider the following for loop:
for (i = 10; i >= 1; i--)
cout << " " << i;
cout << endl;

The output is:
10 9 8 7 6 5 4 3 2 1

In this for loop, the variable i is initialized to 10. After each iteration of the loop, i is
decremented by 1. The loop continues to execute as long as i >= 1.

EXAMPLE 5-13
You can increment (or decrement) the loop control variable by any fixed number. In the
following for loop, the variable is initialized to 1; at the end of the for loop, i is
incremented by 2. This for loop outputs the first 10 positive odd integers.
for (i = 1; i <= 20; i = i + 2)
cout << " " << i;
cout << endl;

The output is:
1 3 5 7 9 11 13 15 17 19

EXAMPLE 5-14
Suppose that i is an int variable.
1. Consider the following for loop:
for (i = 10; i <= 9; i++)
cout << i << " ";
cout << endl;

In this for loop, the initial statement sets i to 10. Because initially the loop
condition (i <= 9) is false, nothing happens.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

300 |

Chapter 5: Control Structures II (Repetition)

2. Consider the following for loop:
for (i = 9; i >= 10; i--)
cout << i << " ";
cout << endl;

In this for loop, the initial statement sets i to 9. Because initially the loop condition
(i >= 10) is false, nothing happens.
3. Consider the following for loop:
for (i = 10; i <= 10; i++)
cout << i << " ";
cout << endl;

//Line 1
//Line 2
//Line 3

In this for loop, the initial statement sets i to 10. The loop condition (i <= 10)
evaluates to true, so the output statement in Line 2 executes, which outputs 10.
Next, the update statement increments the value of i by 1, so the value of i becomes
11. Now the loop condition evaluates to false and the for loop terminates. Note
that the output statement in Line 2 executes only once.
4. Consider the following for loop:
for (i = 1; i <= 10; i++);
cout << i << " ";
cout << endl;

//Line 1
//Line 2
//Line 3

This for loop has no effect on the output statement in Line 2. The semicolon at the
end of the for statement terminates the for loop; the action of the for loop is thus
empty. The output statement is all by itself and executes only once.
5. Consider the following for loop:
for (i = 1; ; i++)
cout << i << " ";
cout << endl;

In this for loop, because the loop condition is omitted from the for statement,
the loop condition is always true. This is an infinite loop.
6. The following for loop outputs the positive powers of 2 up to 100.
for (i = 2; i < 100; i = 2 * i)
cout << i << " "; //output power of 2
cout << endl;

The output is:
2 4 8 16 32 64

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

for Looping (Repetition) Structure

|

301

EXAMPLE 5-15
In this example, a for loop reads five numbers and finds their sum and average.
Consider the following program code, in which i, newNum, sum, and average are
int variables:
sum = 0;
for (i = 1; i <= 5; i++)
{
cin >> newNum;
sum = sum + newNum;
}

5

average = sum / 5;
cout << "The sum is " << sum << endl;
cout << "The average is " << average << endl;

In the preceding for loop, after reading a newNum, this value is added to the previously
calculated (partial) sum of all the numbers read before the current number. The variable
sum is initialized to 0 before the for loop. Thus, after the program reads the first number
and adds it to the value of sum, the variable sum holds the correct sum of the first number.

The syntax of the for loop, which is:
for (initial expression; logical expression; update expression)

statement
is functionally equivalent to the following while statement:
initial expression
while (expression)
{
statement
update expression
}
For example, the following for and while loops are equivalent:
for (int i = 0; i < 10; i++)
cout << i << " ";
cout << endl;

int i = 0;
while (i < 10)
{
cout << i <<
i++;
}
cout << endl;

" ";

If the number of iterations of a loop is known or can be determined in advance, typically
programmers use a for loop.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

302 |

Chapter 5: Control Structures II (Repetition)

EXAMPLE 5-16 (FIBONACCI NUMBER PROGRAM: REVISITED)
The Programming Example: Fibonacci Number given in the previous section uses a
while loop to determine the desired Fibonacci number. You can replace the while
loop with an equivalent for loop as follows:
for (counter = 3; counter <= nthFibonacci; counter++)
{
current = previous2 + previous1;
previous1 = previous2;
previous2 = current;
counter++;
}//end for

The complete program listing of the program that uses a for loop to determine the
desired Fibonacci number is given at the Web site accompanying this book. The program
is named Ch5_FibonacciNumberUsingAForLoop.cpp.
In the following C++ program, we recommend that you walk through each step.
EXAMPLE 5-17
The following C++ program finds the sum of the first n positive integers.
//Program to determine the sum of the first n positive integers.
#include <iostream >
using namespace std;
int main()
{
int counter;
int sum;
int n;

//loop control variable
//variable to store the sum of numbers
//variable to store the number of
//first positive integers to be added

cout << "Line 1: Enter the number of positive "
<< "integers to be added: ";
//Line 1
cin >> n;
//Line 2
sum = 0;
//Line 3
cout << endl;
//Line 4
for (counter = 1; counter <= n; counter++)
sum = sum + counter;

//Line 5
//Line 6

cout << "Line 7: The sum of the first " << n
<< " positive integers is " << sum
<< endl;

//Line 7

return 0;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Classifying Numbers

|

303

Sample Run: In this sample run, the user input is shaded.
Line 1: Enter the number of positive integers to be added: 100
Line 7: The sum of the first 100 positive integers is 5050

The statement in Line 1 prompts the user to enter the number of positive integers to be added.
The statement in Line 2 stores the number entered by the user in n, and the statement in Line
3 initializes sum to 0. The for loop in Line 5 executes n times. In the for loop, counter is
initialized to 1 and is incremented by 1 after each iteration of the loop. Therefore, counter
ranges from 1 to n. Each time through the loop, the value of counter is added to sum. The
variable sum was initialized to 0, counter ranges from 1 to n, and the current value of
counter is added to the value of sum. Therefore, after the for loop executes, sum contains
the sum of the first n values, which in the sample run is 100 positive integers.
Recall that putting one control structure statement inside another is called nesting. The
following programming example demonstrates a simple instance of nesting. It also nicely
demonstrates counting.

PROGRAMMING EXAMPLE:

Classifying Numbers

This program reads a given set of integers and then prints the number of odd and
even integers. It also outputs the number of zeros.
The program reads 20 integers, but you can easily modify it to read any set of
numbers. In fact, you can modify the program so that it first prompts the user to
specify how many integers are to be read.

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Input

20 integers—positive, negative, or zeros.

Output

The number of zeros, even numbers, and odd numbers.

After reading a number, you need to check whether it is even or odd. Suppose the
value is stored in number. Divide number by 2 and check the remainder. If the
remainder is 0, number is even. Increment the even count and then check whether
number is 0. If it is, increment the zero count. If the remainder is not 0, increment
the odd count.
The program uses a switch statement to decide whether number is odd or even.
Suppose that number is odd. Dividing by 2 gives the remainder 1 if number is
positive and the remainder -1 if it is negative. If number is even, dividing by 2 gives
the remainder 0 whether number is positive or negative. You can use the mod
operator, %, to find the remainder. For example:
6 % 2 = 0; -4 % 2 = 0; -7 % 2 = -1; 15 % 2 = 1

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

304 |

Chapter 5: Control Structures II (Repetition)

Repeat the preceding process of analyzing a number for each number in the list.
This discussion translates into the following algorithm:
1. For each number in the list:
a. Get the number.
b. Analyze the number.
c. Increment the appropriate count.
2. Print the results.
Variables

Because you want to count the number of zeros, even numbers, and odd numbers,
you need three variables of type int—say, zeros, evens, and odds—to track the
counts. You also need a variable—say, number—to read and store the number to be
analyzed and another variable—say, counter—to count the numbers analyzed.
Therefore, you need the following variables in the program:
int
int
int
int
int

counter;
number;
zeros;
evens;
odds;

//loop control variable
//variable to store the
//variable to store the
//variable to store the
//variable to store the

number read
zero count
even count
odd count

Clearly, you must initialize the variables zeros, evens, and odds to zero. You can
initialize these variables when you declare them.
MAIN
ALGORITHM

1. Declare and initialize the variables.
2. Prompt the user to enter 20 numbers.
3. For each number in the list:
a. Read the number.
b. Output the number (echo input).
c. If the number is even:
{

i. Increment the even count.
ii. If the number is zero, increment the zero count.
}

otherwise
Increment the odd count.
4. Print the results.
Before writing the C++ program, let us describe Steps 1–4 in greater detail. Then it
will be much easier for you to write the instructions in C++.
1. Initialize the variables. You can initialize the variables zeros,
evens, and odds when you declare them.
2. Use an output statement to prompt the user to enter 20 numbers.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Classifying Numbers

|

305

3. For Step 3, you can use a for loop to process and analyze the 20
numbers. In pseudocode, this step is written as follows:
for (counter = 1; counter <= 20; counter++)
{
read the number;
output number;
switch (number % 2)
// check the remainder
{
case 0:
increment even count;
if (number == 0)
increment zero count;
break;
case 1:
case –1:
increment odd count;
}//end switch
}//end for

4. Print the result. Output the value of the variables zeros, evens,
and odds.
COMPLETE PROGRAM LISTING
//********************************************************
// Author: D.S. Malik
//
// Program: Counts zeros, odds, and evens
// This program counts the number of odd and even numbers.
// The program also counts the number of zeros.
//********************************************************
#include <iostream>
#include <iomanip>
using namespace std;
const int N = 20;
int main()
{
//Declare variables
int counter;
//loop control variable
int number;
//variable to store the new number
int zeros = 0;
//Step 1
int odds = 0;
//Step 1
int evens = 0;
//Step 1

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

306 |

Chapter 5: Control Structures II (Repetition)

cout << "Please enter " << N << " integers, "
<< "positive, negative, or zeros."
<< endl;

//Step 2

cout << "The numbers you entered are:" << endl;
for (counter = 1; counter <= N; counter++)
{
cin >> number;
cout << number << " ";

//Step 3
//Step 3a
//Step 3b

//Step 3c
switch (number % 2)
{
case 0:
evens++;
if (number == 0)
zeros++;
break;
case 1:
case -1:
odds++;
} //end switch
} //end for loop
cout << endl;
cout <<
<<
<<
cout <<
<<

//Step 4
"There are " << evens << " evens, "
"which includes " << zeros << " zeros."
endl;
"The number of odd numbers is: " << odds
endl;

return 0;
}

Sample Run: In this sample run, the user input is shaded.
Please enter 20 integers, positive, negative, or zeros.
The numbers you entered are:
0 0 -2 -3 -5 6 7 8 0 3 0 -23 -8 0 2 9 0 12 67 54
0 0 -2 -3 -5 6 7 8 0 3 0 -23 -8 0 2 9 0 12 67 54
There are 13 evens, which includes 6 zeros.
The number of odd numbers is: 7

We recommend that you do a walk-through of this program using the above sample
input.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

do. . .While Looping (Repetition) Structure

|

307

do...while Looping (Repetition) Structure
This section describes the third type of looping or repetition structure, called a do. . .while
loop. The general form of a do. . .while statement is as follows:
do
statement
while (expression);

Of course, statement can be either a simple or compound statement. If it is a
compound statement, enclose it between braces. Figure 5-3 shows the flow of execution
of a do. . .while loop.

5

statement

expression

true

false

FIGURE 5-3

do...while loop

In C++, do is a reserved word.
The statement executes first, and then the expression is evaluated. If the expression
evaluates to true, the statement executes again. As long as the expression in a
do...while statement is true, the statement executes. To avoid an infinite loop, you
must, once again, make sure that the loop body contains a statement that ultimately makes
the expression false and assures that it exits properly.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

308 |

Chapter 5: Control Structures II (Repetition)

EXAMPLE 5-18
i = 0;
do
{
cout << i << " ";
i = i + 5;
}
while (i <= 20);

The output of this code is:
0 5 10 15 20

After 20 is output, the statement:
i = i + 5;

changes the value of i to 25 and so i <= 20 becomes false, which halts the loop.
In a while and for loop, the loop condition is evaluated before executing the body of the
loop. Therefore, while and for loops are called pretest loops. On the other hand, the
loop condition in a do. . .while loop is evaluated after executing the body of the loop.
Therefore, do. . .while loops are called posttest loops.
Because the while and for loops both have entry conditions, these loops may never
activate. The do...while loop, on the other hand, has an exit condition and therefore
always executes the statement at least once.
EXAMPLE 5-19
Consider the following two loops:
a.

i = 11;
while (i <= 10)
{
cout << i << " ";
i = i + 5;
}
cout << endl;

b. i = 11;
do
{
cout << i << " ";
i = i + 5;
}
while (i <= 10);
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

do. . .While Looping (Repetition) Structure

|

309

cout << endl;

In (a), the while loop produces nothing, the statement never executes. In (b), the
do...while loop outputs the number 11 and also changes the value of i to 16. This
is expected because in a do...while, the statement must always execute at least once.
A do...while loop can be used for input validation. Suppose that a program prompts a user
to enter a test score, which must be greater than or equal to 0 and less than or equal to 50. If
the user enters a score less than 0 or greater than 50, the user should be prompted to re-enter
the score. The following do...while loop can be used to accomplish this objective:
int score;

5

do
{
cout << "Enter a score between 0 and 50: ";
cin >> score;
cout << endl;
}
while (score < 0 || score > 50);

EXAMPLE 5-20

Divisibility Test by 3 and 9
Suppose that m and n are integers and m is nonzero. Then m is called a divisor of n
if n ¼ mt for some integer t; that is, when m divides n, the remainder is 0.
Let n ¼ akak-1ak-2. . .a1a0 be an integer. Let s = ak + ak-1 + ak-2 +    + a1 + a0 be the sum of the
digits of n. It is known that n is divisible by 3 and 9 if s is divisible by 3 and 9. In other words,
an integer is divisible by 3 and 9 if and only if the sum of its digits is divisible by 3 and 9.
For example, suppose n = 27193257. Then s = 2 + 7 + 1 + 9 + 3 + 2 + 5 + 7 = 36. Because
36 is divisible by both 3 and 9, it follows that 27193257 is divisible by both 3 and 9.
Next, we write a program that determines whether a positive integer is divisible by 3
and 9 by first finding the sum of its digits and then checking whether the sum is divisible
by 3 and 9.
To find the sum of the digits of a positive integer, we need to extract each digit of the
number. Consider the number 951372. Note that 951372 % 10 = 2, which is the last
digit of 951372. Also note that 951372 / 10 = 95137; that is, when the number is
divided by 10, it removes the last digit. Next, we repeat this process on the number
95137. Of course, we need to add the extracted digits.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

310 |

Chapter 5: Control Structures II (Repetition)

Suppose that sum and num are int variables and the positive integer is stored in num. We
thus have the following algorithm to find the sum of the digits:
sum = 0;
do
{
sum = sum + num % 10; //extract the last digit
//and add it to sum
num = num / 10;
//remove the last digit
}
while (num > 0);

Using this algorithm, we can write the following program that uses a do. . .while loop to
implement the preceding divisibility test algorithm.
//Program: Divisibility test by 3 and 9
#include <iostream >
using namespace std;
int main()
{
int num, temp, sum;
cout << "Enter a positive integer: ";
cin >> num;
cout << endl;
temp = num;
sum = 0;
do
{
sum = sum + num % 10; //extract the last digit
//and add it to sum
num = num / 10;
//remove the last digit
}
while (num > 0);
cout << "The sum of the digits = " << sum << endl;
if (sum % 9 == 0)
cout << temp <<
else if (sum % 3 ==
cout << temp <<
else
cout << temp <<

" is divisible by 3 and 9" << endl;
0)
" is divisible by 3, but not 9" << endl;
" is not divisible by 3 or 9" << endl;

}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

break and continue Statements |

311

Sample Runs: In these sample runs, the user input is shaded.

Sample Run 1
Enter a positive integer: 27193257
The sum of the digits = 36
27193257 is divisible by 3 and 9

Sample Run 2
Enter a positive integer: 609321
The sum of the digits = 21
609321 is divisible by 3, but not 9

Sample Run 3
Enter a positive integer: 161905102
The sum of the digits = 25
161905102 is not divisible by 3 or 9

Choosing the Right Looping Structure
All three loops have their place in C++. If you know, or the program can determine in
advance, the number of repetitions needed, the for loop is the correct choice. If you do
not know, and the program cannot determine in advance the number of repetitions
needed, and it could be 0, the while loop is the right choice. If you do not know, and
the program cannot determine in advance the number of repetitions needed, and it is at
least 1, the do...while loop is the right choice.

break and continue Statements
The break statement, when executed in a switch structure, provides an immediate
exit from the switch structure. Similarly, you can use the break statement in
while, for, and do. . .while loops to immediately exit from the loop structure.
The break statement is typically used for two purposes:
•
•

To exit early from a loop.
To skip the remainder of the switch structure.

After the break statement executes, the program continues to execute with the first
statement after the structure. The use of a break statement in a loop can eliminate the
use of certain (flag) variables. The following C++ code segment helps illustrate this idea.
(Assume that all variables are properly declared.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

312 |

Chapter 5: Control Structures II (Repetition)

sum = 0;
isNegative = false;
cin >> num;
while (cin && !isNegative)
{
if (num < 0)
//if num is negative, terminate the loop
//after this iteration
{
cout << "Negative number found in the data." << endl;
isNegative = true;
}
else
{
sum = sum + num;
cin >> num;
}
}

This while loop is supposed to find the sum of a set of positive numbers. If the data set
contains a negative number, the loop terminates with an appropriate error message. This
while loop uses the flag variable isNegative to signal the presence of a negative number.
The variable isNegative is initialized to false before the while loop. Before adding
num to sum, a check is made to see if num is negative. If num is negative, an error message
appears on the screen and isNegative is set to true. In the next iteration, when the
expression in the while statement is evaluated, it evaluates to false because
!isNegative is false. (Note that because isNegative is true, !isNegative is
false.)
The following while loop is written without using the variable isNegative:
sum = 0;
cin >> num;
while (cin)
{
if (num < 0)
//if num is negative, terminate the loop
{
cout << "Negative number found in the data." << endl;
break;
}
sum = sum + num;
cin >> num;
}

In this form of the while loop, when a negative number is found, the expression in the
if statement evaluates to true; after printing an appropriate message, the break
statement terminates the loop. (After executing the break statement in a loop, the
remaining statements in the loop are discarded.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

break and continue Statements |

313

The break statement is an effective way to avoid extra variables to control a loop and
produce an elegant code. However, break statements must be used very sparingly
within a loop. An excessive use of these statements in a loop will produce spaghetti-code
(loops with many exit conditions) that can be very hard to understand and manage. You
should be extra careful in using break statements and ensure that the use of the break
statements makes the code more readable and not less readable. If you’re not sure, don’t
use break statements.

The continue statement is used in while, for, and do. . .while structures. When
the continue statement is executed in a loop, it skips the remaining statements in the
loop and proceeds with the next iteration of the loop. In a while and do. . .while
structure, the expression (that is, the loop-continue test) is evaluated immediately
after the continue statement. In a for structure, the update statement is executed
after the continue statement, and then the loop condition (that is, the loopcontinue test) executes.
If the previous program segment encounters a negative number, the while loop terminates. If you want to discard the negative number and read the next number rather than
terminate the loop, replace the break statement with the continue statement, as shown
in the following example:
sum = 0;
cin >> num;
while (cin)
{
if (num < 0)
{
cout << "Negative number found in the data." << endl;
cin >> num;
continue;
}
sum = sum + num;
cin >> num;
}

It was stated earlier that all three loops have their place in C++ and that one
loop can often replace another. The execution of a continue statement, however,
is where the while and do. . .while structures differ from the for structure.
When the continue statement is executed in a while or a do. . .while loop, the
update statement may not execute. In a for structure, the update statement always
executes.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

314 |

Chapter 5: Control Structures II (Repetition)

Nested Control Structures
In this section, we give examples that illustrate how to use nested loops to achieve useful
results and process data.
EXAMPLE 5-21
Suppose you want to create the following pattern:
*
**
***
****
*****

Clearly, you want to print five lines of stars. In the first line, you want to print one star, in
the second line, two stars, and so on. Because five lines will be printed, start with the
following for statement:
for (i = 1; i <= 5; i++)

The value of i in the first iteration is 1, in the second iteration it is 2, and so on. You
can use the value of i as the limiting condition in another for loop nested within this
loop to control the number of stars in a line. A little more thought produces the
following code:
for (i = 1; i <= 5; i++)
{
for (j = 1; j <= i; j++)
cout << "*";
cout << endl;
}

//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6

A walk-through of this code shows that the for loop in Line 1 starts with i = 1. When
i is 1, the inner for loop in Line 3 outputs one star and the insertion point moves to the
next line. Then i becomes 2, the inner for loop outputs two stars, and the output
statement in Line 5 moves the insertion point to the next line, and so on. This process
continues until i becomes 6 and the loop stops.
What pattern does this code produce if you replace the for statement in Line 1 with the
following?
for (i = 5; i >= 1; i--)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Nested Control Structures |

315

EXAMPLE 5-22
Suppose you want to create the following multiplication table:
1 2 3 4
2 4 6 8
3 6 9 12
4 8 12 16
5 10 15 20

5
10
15
20
25

6
12
18
24
30

7
14
21
28
35

8
16
24
32
40

9
18
27
36
45

10
20
30
40
50

The multiplication table has five lines. Therefore, as in Example 5-21, we use a for
statement to output these lines as follows:
for (i = 1; i <= 5; i++)
//output a line of numbers

In the first line, we want to print the multiplication table of 1, in the second line we want
to print the multiplication table of 2, and so on. Notice that the first line starts with 1 and
when this line is printed, i is 1. Similarly, the second line starts with 2 and when this line
is printed, the value of i is 2, and so on. If i is 1, i * 1 is 1; if i is 2, i * 2 is 2; and so
on. Therefore, to print a line of numbers, we can use the value of i as the starting
number and 10 as the limiting value. That is, consider the following for loop:
for (j = 1; j <= 10; j++)
cout << setw(3) << i * j;

Let us take a look at this for loop. Suppose i is 1. Then we are printing the first line of
the multiplication table. Also, j goes from 1 to 10 and so this for loop outputs the
numbers 1 through 10, which is the first line of the multiplication table. Similarly, if i is
2, we are printing the second line of the multiplication table. Also, j goes from 1 to 10,
and so this for loop outputs the second line of the multiplication table, and so on.
A little more thought produces the following nested loops to output the desired grid:
for (i = 1; i <= 5; i++)
{
for (j = 1; j <= 10; j++)
cout << setw(3) << i * j;
cout << endl;
}

//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6

EXAMPLE 5-23
Consider the following data:
65 78
87 34
-999
23 99
62 35

65 89 25 98 -999
89 99 26 78 64 34 -999
98 97 26 78 100 63 87 23 -999
78 99 12 93 19 -999

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

316 |

Chapter 5: Control Structures II (Repetition)

The number -999 at the end of each line acts as a sentinel and therefore is not part
of the data. Our objective is to find the sum of the numbers in each line and output
the sum. Moreover, assume that this data is to be read from a file, say,
Exp_5_23.txt. We assume that the input file has been opened using the input file
stream variable infile.
This particular data set has five lines of input. So we can use a for loop or a countercontrolled while loop to process each line of data. Let us use a while loop to process
these five lines. It follows that the while loop takes the following form:
counter = 0;
while (counter < 5)
{
//process the line

//Line
//Line
//Line
//Line

1
2
3
4

//output the sum
counter++;
}

Let us now concentrate on processing a line. Each line has a varying number of data
items. For example, the first line has six numbers, the second line has eight numbers, and
so on. Because each line ends with -999, we can use a sentinel-controlled while loop to
find the sum of the numbers in each line with -999 as the sentinel value. Consider the
following while loop:
sum = 0;
infile >> num;
while (num != -999)
{
sum = sum + num;
infile >> num;
}

//Line
//Line
//Line
//Line
//Line
//Line
//Line

4
5
6
7
8
9
10

The statement in Line 4 initializes sum to 0, and the statement in Line 5 reads and stores the
first number of the line into num. The Boolean expression num != -999 in Line 6 checks
whether the number is -999. If num is not -999, the statements in Lines 8 and 9 execute.
The statement in Line 8 updates the value of sum; the statement in Line 9 reads and stores the
next number into num. The loop continues to execute as long as num is not -999.
It now follows that the nested loop to process the data is as follows. (Assume that all
variables are properly declared.)
counter = 0;
while (counter < 5)
{
sum = 0;
infile >> num;
while (num != -999)
{
sum = sum + num;
infile >> num;
}

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7
8
9
10

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Nested Control Structures |

counter++;
cout << "Line " << counter
<< ": Sum = " << sum << endl;
}

317

//Line 11
//Line 12
//Line 13

EXAMPLE 5-24
Suppose that we want to process data similar to the data in Example 5-23, but the input
file is of an unspecified length. That is, each line contains the same data as the data in each
line in Example 5-23, but we do not know the number of input lines.
Because we do not know the number of input lines, we must use an EOF-controlled
while loop to process the data. In this case, the required code is as follows. (Assume that
all variables are properly declared and the input file has been opened using the input file
stream variable infile.)
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7
8
9
10

counter++;
//Line
cout << "Line " << counter
<< ": Sum = " << sum << endl; //Line
infile >> num;
//Line
//Line

11

counter = 0;
infile >> num;
while (infile)
{
sum = 0;
while (num != -999)
{
sum = sum + num;
infile >> num;
}

}

12
13
14

Notice that we have again used the variable counter, this time to allow us to print the
line number with the sum of each line.

EXAMPLE 5-25
Consider the following data:
101
John Smith
65 78 65 89 25 98 -999
102
Peter Gupta
87 34 89 99 26 78 64 34 -999
103
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

318 |

Chapter 5: Control Structures II (Repetition)

Buddy Friend
23 99 98 97 26 78 100 63 87 23 -999
104
Doctor Miller
62 35 78 99 12 93 19 -999
...

The number -999 at the end of a line acts as a sentinel and therefore is not part of the data.
Assume that this is the data of certain candidates seeking the student council’s presidential seat.
For each candidate, the data is in the following form:
ID
Name
Votes

The objective is to find the total number of votes received by the candidate. We assume
that the data is input from the file Exp_5_25.txt of unknown size. We also assume that
the input file has been opened using the input file stream variable infile.
Because the input file is of an unspecified length, we use an EOF-controlled while loop.
For each candidate, the first data item is the ID of type int on a line by itself; the second
data item is the name, which may consist of more than one word; and the third line
contains the votes received from the various departments.
To read the ID, we use the extraction operator >>; to read the name, we use the stream
function getline. Notice that after reading the ID, the reading marker is after the ID and the
character after the ID is the newline character. Therefore, after reading the ID, the reading
marker is after the ID and before the newline character (of the line containing the ID).
The function getline reads until the end of the line. Therefore, if we read the name
immediately after reading the ID, then what is stored in the variable name is the newline
character (after the ID). It follows that to read the name, we must read and discard the
newline character after the ID, which we can accomplish using the stream function get.
Therefore, the statements to read the ID and name are as follows:
infile >> ID;
infile.get(ch);
getline(infile, name);

//read the ID
//read the newline character after the ID
//read the name

(Assume that ch is a variable of type char.) The general loop to process the data is:
infile >> ID;
while (infile)
{
infile.get(ch);
getline(infile, name);

//Line
//Line
//Line
//Line
//Line

1
2
3
4
5

//process the numbers in each line
//Line 6
//output the name and total votes
infile >> ID;
//begin processing the next line
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Avoiding Bugs by Avoiding Patches |

319

The code to read and sum up the voting data is:
//Line
//Line
//Line
//Line
//Line
//Line
//Line

sum = 0;
infile >> num;
while (num != -999)
{
sum = sum + num;
infile >> num;
}

6
7; read the first number
8
9
10; update sum
11; read the next number
12

We can now write the following nested loop to process data as follows:
infile >> ID;
while (infile)
{
infile.get(ch);
getline(infile, name);
sum = 0;
infile >> num;
while (num != -999)
{
sum = sum + num;
infile >> num;
}
cout << "Name: " << name
<< ", Votes: " << sum
<< endl;
infile >> ID;

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7; read the first number
8
9
10; update sum
11; read the next number

//Line 12

//Line 13; begin processing the next line

}

Avoiding Bugs by Avoiding Patches
Debugging sections in the previous chapters illustrated how to debug syntax and logical
errors, and how to avoid partially understood concepts. In this section, we illustrate how
to avoid a software patch to fix a code. A software patch is a piece of code written on top
of an existing piece of code intended to fix a bug in the original code.
Suppose that the following data is in the file Ch5_LoopWithBugsData.txt.
87 78 83 94
23 89 92 70
92 78 34 56

The objective is to find the sum of the numbers in each line. For each line, output the
numbers together with their sum. Let us consider the following program:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

320 |

Chapter 5: Control Structures II (Repetition)

#include <iostream>
#include <fstream>
using namespace std;
int main()
{
ifstream infile;
int
int
int
int

i;
j;
sum;
num;

infile.open("Ch5_LoopWithBugsData.txt");
for (i = 1; i <= 4; i++)
{
sum = 0;
for (j = 1; j <= 4; j++)
{
infile >> num;
cout << num << " ";
sum = sum + num;
}
cout << "sum = " << sum << endl;
}
return 0;
}

Sample Run:
87
23
92
56

78
89
78
56

83
92
34
56

94
70
56
56

sum
sum
sum
sum

=
=
=
=

342
274
260
224

The sample run shows that there is a bug in the program because the file contains
three lines of input and the output contains four lines. Also, the number 56 in the
last line repeats four times. Clearly, there is a bug in the program and we must fix
the code. Some programmers, especially some beginners, address the symptom of the
problem by adding a software patch. In this case, the output should contain only
three lines of output. A beginning programmer might fix the code by adding a
software patch to manually cut off the unwanted fourth line, as shown in the
following modified program:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Avoiding Bugs by Avoiding Patches |

321

#include <iostream>
#include <fstream>
using namespace std;
int main()
{
ifstream infile;
int
int
int
int

i;
j;
sum;
num;

infile.open("Ch5_LoopWithBugsData.txt");
for (i = 1; i <= 4; i++)
{
sum = 0;
if (i != 4)
//software patch
{
for (j = 1; j <= 4; j++)
{
infile >> num;
cout << num << " ";
sum = sum + num;
}
cout << "sum = " << sum << endl;
}
}
return 0;
}

Sample Run:
87 78 83 94 sum = 342
23 89 92 70 sum = 274
92 78 34 56 sum = 260

Clearly, the program is working correctly now.
As we can see, the programmer merely observed the symptom and addressed the problem by
adding a software patch. However, if you look at the code, not only does the program
execute extra statements, it is also an example of a partially understood concept. It appears that
the programmer does not have a good grasp of why the earlier program produced four lines
rather than three. Adding a patch eliminated the symptom, but it is a poor programming
practice. The programmer must resolve why the program produced four lines. Looking at the
program closely, we can see that the four lines are produced because the outer loop executes
four times. The values assigned to loop control variable i are 1, 2, 3, and 4. This is an example

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

322 |

Chapter 5: Control Structures II (Repetition)

of the classic ‘‘off-by-one’’ problem. (In an ‘‘off-by-one problem,’’ either the loop executes
one too many or one too few times.) We can eliminate this problem by correctly setting the
values of the loop control variable. For example, we can rewrite the loops as follows:
for (i = 1; i <= 3; i++)
{
sum = 0;
for (j = 1; j <= 4; j++)
{
infile >> num;
cout << num << " ";
;
sum = sum + num;
}
cout << "sum = " << sum << endl;
}

This code fixes the original problem without using a software patch. It also represents
good programming practice. The complete modified program is available at the Web site
accompanying this book and is named Ch5_LoopWithBugsCorrectedProgram.cpp.

Debugging Loops
As we have seen in the earlier debugging sections, no matter how careful a program is
designed and coded, errors are likely to occur. If there are syntax errors, the compiler will
identify them. However, if there are logical errors, we must carefully look at the code or
even maybe at the design and try to find the errors. To increase the reliability of the
program, errors must be discovered and fixed before the program is released to the users.
Once an algorithm is written, the next step is to verify that it works properly. If the algorithm
is a simple sequential flow or contains a branch, it can be hand traced or you can use the
debugger, if any, provided by the IDE. Typically, loops are harder to debug. The correctness
of a loop can be verified by using loop invariants. A loop invariant is a set of statements that
remains true each time the loop body is executed. Let p be a loop invariant and q be the
(logical) expression in a loop statement. Then p && q remains true before each iteration of the
loop and p && not(q) is true after the loop terminates. The full discussion of loop invariants is
beyond the scope of the book. However, you can learn about loop invariants in the book: Discrete
Mathematics: Theory and Applications (Revised Edition), D.S. Malik and M.K. Sen, Cengage
Learning Asia, Singapore, 2010. Here, we give a few tips that you can use to debug a loop.
As discussed in the previous section, the most common error associated with loops is offby-one. If a loop turns out to be an infinite loop, the error is most likely in the logical
expression that controls the execution of the loop. Check the logical expression carefully
and see if you have reversed an inequality, an assignment statement symbol appears in place
of the equality operator, or && appears in place of ||. If the loop changes the values of
variables, you can print the values of the variables before and/or after each iteration or you
can use your IDE’s debugger, if any, and watch the values of variables during each iteration.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

323

The debugging sections in this book are designed to help you understand the debugging
process. However, as you will realize, debugging can be a tiresome process. If your
program is very bad, do not debug. Throw it away and start over.

QUICK REVIEW
1.
2.

C++ has three looping (repetition) structures: while, for, and
do. . .while.
The syntax of the while statement is:
while (expression)
statement

3.
4.
5.
6.
7.
8.

9.
10.
11.

12.

13.
14.
15.

In C++, while is a reserved word.
In the while statement, the parentheses around the expression (the decision
maker) are important; they mark the beginning and end of the expression.
The statement is called the body of the loop.
The body of the while loop must contain a statement that eventually sets
the expression to false.
A counter-controlled while loop uses a counter to control the loop.
In a counter-controlled while loop, you must initialize the counter before
the loop, and the body of the loop must contain a statement that changes
the value of the counter variable.
A sentinel is a special value that marks the end of the input data. The
sentinel must be similar to, yet differ from, all the data items.
A sentinel-controlled while loop uses a sentinel to control the loop. The
while loop continues to execute until the sentinel is read.
An EOF-controlled while loop uses an end-of-file marker to control the
loop. The while loop continues to execute until the program detects the
end-of-file marker.
In the Windows console environment, the end-of-file marker is entered using
Ctrl+z (hold the Ctrl key and press z). In the UNIX environment, the
end-of-file marker is entered using Ctrl+d (hold the Ctrl key and press d).
A for loop simplifies the writing of a counter-controlled while loop.
In C++, for is a reserved word.
The syntax of the for loop is:
for (initialize statement; loop condition; update statement)
statement

statement is called the body of the for loop.
16.

Putting a semicolon at the end of the for loop (before the body of the for
loop) is a semantic error. In this case, the action of the for loop is empty.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

324 |

17.

Chapter 5: Control Structures II (Repetition)

The syntax of the do. . .while statement is:
do
statement
while (expression);

18.
19.
20.
21.
22.
23.

statement is called the body of the do. . .while loop.
Both while and for loops are called pretest loops. A do. . .while loop is
called a posttest loop.
The while and for loop bodies may not execute at all, but the do. . .
while loop body always executes at least once.
Executing a break statement in the body of a loop immediately terminates
the loop.
Executing a continue statement in the body of a loop skips the loop’s
remaining statements and proceeds with the next iteration.
When a continue statement executes in a while or do. . .while loop,
the expression update statement in the body of the loop may not execute.
After a continue statement executes in a for loop, the update statement
is the next statement executed.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.

b.

c.
d.

e.

A loop is a control structure that causes certain statements to execute
over and over. (1)
In a counter-controlled while loop, it is not necessary to initialize the
loop control variable. (2)
It is possible that the body of a while loop may not execute at all. (2)
In an infinite while loop, the while expression (the decision maker) is
initially false, but after the first iteration it is always true. (2)
The while loop:
j = 0;
while (j <= 10)
j++;

f.

g.

terminates if j > 10. (2, 3)
A sentinel-controlled while loop is an event-controlled while loop
whose termination depends on a special value. (2, 3)
To read data from a file of an unspecified length, an EOF-controlled
loop is a good choice. (3)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

h.

2.

|

325

When a while loop terminates, the control first goes back to the statement
just before the while statement, and then the control goes to the statement
immediately following the while loop. (2, 3)

What is the output of the following C++ code? (2, 3)
int i = 2;
int temp = 1;
while (i < 10)
{
temp = temp * (i - 1);
i = i + 1;
}
cout << "i = " << i << " and temp = " << temp << endl;

3.

What is the output of the following C++ code? (2, 3)
int count = 0;
int sum = 0;
while (count <= 8)
{
sum = sum + static_cast<int>(sqrt(count));
count++;
}
cout << sum << endl;

4.

What is the output of the following C++ code? (2, 3)
int num = 0;
while (num * num <= 6 * num)
{
num = num + 1;
cout << num << " ";
}
cout << endl;

5.

When does the following while loop terminate? (2, 3)
ch = 'D';
while ('A' <= ch && ch <= 'Z')
ch = static_cast<char>(static_cast<int>(ch) + 1);

6.

Suppose that the input is 1 20 35 15 28 66 -1. What is the output of the
following code? (2, 3)
int num;
int sum;
int count;
cin >> count;
cin >> sum;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

326 |

Chapter 5: Control Structures II (Repetition)

while (count <= 4)
{
cin >> num;
sum = sum + num;
count++;
}
cout << "Sum = " << sum << endl;
7.

Suppose that the input is 3 4 6 7 2 -1. What is the output of the following
code? (2, 3)
int
int
cin
num

num;
sum;
>> sum;
= sum;

while (num != -1)
{
cin >> num;
sum = sum + 2 * num;
}
cout << "Sum = " << sum << endl;
8.

Suppose that the input is 3 4 6 7 2 -1. What is the output of the
following code? (2, 3)
int num;
int sum;
cin >> num;
sum = num;
while (num != -1)
{
sum = sum + 2 * num;
cin >> num;
}
cout << "Sum = " << sum << endl;

9.

Suppose that the input is 10 -6 12 -5 -4 0. What is the output of the
following code? (2, 3)
int num;
int sum = 0;
cin >> num;
while (num != 0)
{
if (num > 0)
sum = sum + num;
else
sum = sum - num;
cin >> num;
}
cout << "Sum = " << sum << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

10.

|

327

Correct the following code so that it reads and finds the sum of 20 numbers: (2, 3)
int count = 0;
int sum = 0;
cin >> num;
while (count <= 20);
{
cin >> num;
count++;
sum = sum + count;
}

11.

Consider the following program: (2, 3)
#include <iostream>

5

using namespace std;
int main()
{
int num1, num2;
int temp = 0;
cout << "Enter two integers: ";
cin >> num1 >> num2 ;
cout << endl ;
while (num1 % 3 != num2 % 5)
{
temp = num1 + num2;
num1 = num2;
num2 = temp;
cout << temp << " ";
}
cout << endl;
return 0;
}

What is the output if the
b. What is the output if the
c. What is the output if the
d. What is the output if the
Suppose that the input is:
a.

12.

58

23

46

75

98

150

input
input
input
input

12

is
is
is
is

10 17?
-4 11?
2 29?
7 43?

176

145 -999

What is the output of the following program? (2, 3)
#include <iostream>
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

328 |

Chapter 5: Control Structures II (Repetition)

int main()
{
int num;
int count = 0;
cin >> num;
while (num != -999)
{
count++;
cout << num % count << "
cin >> num;
}

";

cout << endl;
return 0;
}
13.

The following program is designed to input two numbers and output their
sum. It asks the user if he/she would like to run the program. If the answer
is Y or y, it prompts the user to enter two numbers. After adding the
numbers and displaying the results, it again asks the user if he/she would
like to add more numbers. However, the program fails to do so. Correct the
program so that it works properly. (2, 3)
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
char response;
double num1;
double num2;
cout << "This program adds two numbers." << endl;
cout << "Would you like to run the program: (Y/y) ";
cin >> response;
cout << endl;
cout << fixed << showpoint << setprecision(2);
while (response == 'Y' && response == 'y')
{
cout << "Enter two numbers: ";
cin >> num1 >> num2;
cout << endl;
cout << num1 << " + " << num2 << " = " << (num1 - num2)
<< endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

329

cout << "Would you like to add again: (Y/y) ";
cin >> response;
cout << endl;
}
return 0;
}
14.

What is the output of the following program segment? (2, 3)
int count = 1;
while (count++ <= 5)
cout << "count: " << count << endl;

15.

What is the output of the following program segment? (2, 3)
int count = 5;
while (count > 0)
cout << count-- << " ";
cout << endl;

16.

What is the output of the following program segment? (2, 3)
int count = 5;
while (count-- > 0)
cout << count << " ";
cout << endl;

17.

What is the output of the following program segment? (2, 3)
int count = 1;
while (count++ <= 5)
cout << count * (count - 2) << " ";
cout << endl;

18.

What type of loop, such as counter-control or sentinel-control, will you use
in each of the following situations? (3)
a.

Sum the following series: 1 + (2 / 1) + (3 / 2) + (4 / 3) + (5 / 4)
+ ... + (10 / 9)

b.
c.
19.

Sum the following numbers, except the last number: 17, 32, 62, 48, 58, -1
A file contains an employee’s salary. Update the employee’s salary.

Consider the following for loop: (4)
int j, s;
s = 0;
for (j = 1; j <= 10; j++)
s = s + j * (j - 1);

In this for loop, identify the loop control variable, the initialization statement, the
loop condition, the update statement, and the statement that updates the value of s.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

330 |

20.

Chapter 5: Control Structures II (Repetition)

What is the output of the following program segment? (4)
int num = 1;
int i;
for (i = 0; i < 5; i++)
{
num = num * (5 - i);
cout << num << " ";
}
cout << endl;

21.

What is the output of the following program segment? (4)
int num = 0;
int count;
int y = 0;
for (count = 1; count <= 5; ++count)
{
num = 3 * (count - 1) + (y - count);
cout << num << " ";
}
cout << count << " " << endl;

22.

Assume that the following code is correctly inserted into a program: (4)
int s = 0;
int i;
for (i = 0; i < 5; i++)
{
s = 2 * s + i;
cout << s << " ";
}
cout << endl;
a.

b.

c.

23.

What is the final value of s?
(i) 11
(ii) 4
(iii) 26
(iv) none of these
If a semicolon is inserted after the right parenthesis in the for loop
statement, what is the final value of s?
(ii) 1
(iii) 2
(iv) 5
(v) none of these
(i) 0
If the 5 is replaced with a 0 in the for loop control expression, what is
the final value of s?
(ii) 1
(iii) 2
(iv) none of these
(i) 0

State what output, if any, results from each of the following statements: (4)
a.

for (i = 1; i <= 1; i++)
cout << "*";
cout << endl;

b.

for (i = 2; i >= 1; i++)
cout << "*";
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

24.
25.

c.

for (i = 1; i <= 1; i--)
cout << "*";
cout << endl;

d.

for (i = 12; i >= 9; i--)
cout << "*";
cout << endl;

e.

for (i = 0; i <= 5; i++)
cout << "*";
cout << endl;

f.

for (i = 1; i <= 5; i++)
{
cout << "*";
i = i + 1;
}
cout << endl;

|

331

Write a for statement to add all the multiples of 3 between 1 and 100. (4)
What is the output of the following code? Is there a relationship between
the variables x and y? If yes, state the relationship? What is the output? (4)
int x = 19683;
int i;
int y = 0;
for (i = x; i >= 1; i = i / 3)
y++;
cout << "x = " << x << ", y = " << y << endl;

26.

What is the output of the following code? (4)
for (int i = 1; i <= 10000; i = 5 * i)
cout << i << " ";
cout << endl;

27.

What is the output of the following C++ program segment? Assume all
variables are properly declared. (4)
for (j = 0; j < 8; j++)
{
cout << j * 25 << " - ";
if (j != 7)
cout << (j + 1) * 25 - 1 << endl;
else
cout << (j + 1) * 25 << endl;
}

28.

Suppose that the input is 3 5 7 -6 10. What is the output of the
following code? (4)
int temp = 0;
int num;
int count;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

332 |

Chapter 5: Control Structures II (Repetition)

cin >> temp;
for (count = 0; count <= 3; count++)
{
cout << temp << " ";
cin >> num;
temp = temp + num * (count - 1);
}
cout << endl;
29.

Which of the following apply to the while loop only? To the do. . .while
loop only? To both? (2, 5)
a.
b.
c.

d.
30.

It is considered a conditional loop.
The body of the loop executes at least once.
The logical expression controlling the loop is evaluated before the loop
is entered.
The body of the loop may not execute at all.

The following program contains errors that prevent it from compiling and/
or running. Correct all such errors. (4)
#include <iostream>
using namespace sdt;
const int SECRET = 111.25;
int main ()
{
int num1, num2:
double x, y;
cout >> "Enter two integers: ""
cin << num1 << num2;
cout >> endl;
for (count = 1 count > Secret; ++count)
{
x = (num1 + num2) / 2.0;
y = (num1 - num2) % 2.0;
num1 := num1 + num2;
num2 := num2 * (count - SECRET - 1)
}
cout << num1 << " " << num2 << " << x % 5
<< " " << (y % 7) << end;
return;
}

31.

What is the difference between a pretest loop and a posttest loop? (2, 4, 5)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

32.

33.
34.

|

333

How many times will each of the following loops execute? What is the
output in each case? (5)
a.

x = 5; y = 50;
do
x = x + 10;
while (x < y);
cout << x << " " << y << endl;

b.

x = 5; y = 80;
do
x = x * 2;
while (x < y);
cout << x << " " << y << endl;

c.

x = 5; y = 20;
do
x = x + 2;
while (x >= y);
cout << x << " " << y << endl;

d.

x = 5; y = 35;
while (x < y)
x = x + 10;
cout << x << " " << y << endl;

e.

x = 5; y = 30;
while (x <= y)
x = x * 2;
cout << x << " " << y << endl;

f.

x = 5; y = 30;
while (x > y)
x = x + 2;
cout << x << " " << y << endl;

Write an input statement validation loop that prompts the user to enter a
number less than 20 or greater than 75. (2, 4, 5)
Rewrite the following as a for loop: (2, 4)
int i = 0, value = 0;
while (i <= 20)
{
if (i % 2 == 0 &&
value = value
else if (i % 2 ==
value = value
else
value = value
i = i + 1;
}

i
+
0
+

<= 10)
i * i;
&& i > 10)
i;

- i;

cout << "value = " << value << endl;

35.

What is the output of this loop?
Write the while loop of Exercise 34 as a do. . .while loop. (2, 5)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

334 |

36.

Chapter 5: Control Structures II (Repetition)

The do. . .while loop in the following program is supposed to read some
numbers until it reaches a sentinel (in this case, -1). It is supposed to add all
of the numbers except for the sentinel. If the data looks like:
12

5

30

48

-1

the program does not add the numbers correctly. Correct the program so that it adds
the numbers correctly. (5)
#include <iostream>
using namespace std;
int main()
{
int total = 0,
count = 0,
number;
do
{
cin >> number;
total = total + number;
count++;
}
while (number != -1);
cout << "The number of data read is " << count << endl;
cout << "The sum of the numbers entered is " << total
<< endl;
return 0;
}
37.

Using the same data as in Exercise 36, the following loop also fails. Correct it. (2)
cin >> number;
while (number != -1)
total = total + number;
cin >> number;
cout << endl;
cout << total << endl;

38.

Using the same data as in Exercise 36, the following loop also fails. Correct it. (2)
cin >> number;
while (number != -1)
{
cin >> number;
total = total + number;
}
cout << endl;
cout << total << endl;

39.

Given the following program segment: (2, 4, 5)
for (number = 1; number <= 10; number++)
cout << setw(3) << number;

write a while loop and a do. . .while loop that have the same output.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

40.

|

335

Given the following program segment: (2, 4, 5)
int limit = 4;
int first = 5;
int j;
for (j = 1; j <= limit; j++)
{
cout << first * j << endl;
first = first + (j - 1);
}
cout << endl;

41.

write a while loop and a do. . .while loop that have the same output.
Consider the following program: (5)
#include <iostream >

5

using namespace std;
int main()
{
int num1, num2;
int temp = 0;
cout << "Enter two integers: ";
cin >> num1 >> num2;
cout << endl ;
do
{
temp
num1
num2
cout

= num1 + num2 ;
= num2 ;
= temp ;
<< temp << " ";

}
while (((num1 + num2) % 5) != 0);
cout << endl;
return 0;
}
a.
b.
c.
d.

What
What
What
What

is
is
is
is

the
the
the
the

output
output
output
output

if
if
if
if

the
the
the
the

input
input
input
input

is
is
is
is

13 16?
-4 6?
3 5?
13 15?

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

336 |

42.

Chapter 5: Control Structures II (Repetition)

To learn how nested for loops work, do a walk-through of the following
program segments and determine, in each case, the exact output. (4, 7)
a.

int i, j;
for (i = 1; i <= 5; i++)
{
for (j = 1; j <= 5; j++)
cout << setw(3) << i;
cout << endl;
}

b.

int i, j;
for (i = 1; i <= 5; i++)
{
for (j = (i + 1); j <= 5; j++)
cout << setw(5) << j;
cout << endl;
}

c.

int i, j;
for (i = 1; i <= 5; i++)
{
for (j = 1; j <= i; j++)
cout << setw(3) << j;
cout << endl;
}

d.

const int M = 10;
const int N = 10;
int i, j;
for (i = 1; i <= M; i++)
{
for (j = 1; j <= N; j++)
cout << setw(3) << M * (i - 1) + j;
cout << endl;
}

e.

int i, j;
for (i = 1; i <= 9; i++)
{
for (j = 1; j <= (9 - i); j++)
cout << " ";
for (j = 1; j <= i; j++)
cout << setw(1) << j;
for (j = (i - 1); j >= 1; j--)
cout << setw(1) << j;
cout << endl;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

43.

|

337

What is the output of the following program segment? (5)
int count = 1;
do
cout << count * (count - 2) << " ";
while (count++ <= 5);
cout << endl;

44.

What is the output of the following code? (6)
int num = 12;
while (num >= 0)
{
if (num % 5 == 0)
break;
cout << num << " ";
num = num - 2;
}
cout << endl;

45.

What is the output of the following code? (6)
int num = 12;
while (num >= 0)
{
if (num % 5 == 0)
{
num++;
continue;
}
cout << num << " ";
num = num - 2;
}
cout << endl;

46.

What does a break statement do in a loop? (6)

PROGRAMMING EXERCISES
1.

Write a program that prompts the user to input an integer and then outputs
both the individual digits of the number and the sum of the digits. For
example, it should output the individual digits of 3456 as 3 4 5 6, output
the individual digits of 8030 as 8 0 3 0, output the individual digits of
2345526 as 2 3 4 5 5 2 6, output the individual digits of 4000 as 4 0 0 0,
and output the individual digits of -2345 as 2 3 4 5.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

338 |

2.

Chapter 5: Control Structures II (Repetition)

The value of p can be approximated by using the following series:


1 1 1
1
1
 ¼ 4 1  þ  þ  þ
þ
:
3 5 7
2n  1 2n þ 1
The following program uses this series to find the approximate value of p. However,
the statements are in the incorrect order, and there is also a bug in this program.
Rearrange the statements and remove the bug so that this program can be used to
approximate p.
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
double pi = 0;
long i;
long n;
cin >> n;
cout << "Enter the value of n: ";
cout << endl;
if (i % 2 == 0)
pi = pi + (1 / (2 * i + 1));
else
pi = pi - (1 / (2 * i + 1));
for (i = 0; i < n; i++)
{
pi = 0;
pi = 4 * pi;
}
cout << endl << "pi = " << pi << endl;
return 0;
}

3.

4.

The program Telephone Digits outputs only telephone digits that correspond to uppercase letters. Rewrite the program so that it processes both
uppercase and lowercase letters and outputs the corresponding telephone
digit. If the input is something other than an uppercase or lowercase letter,
the program must output an appropriate error message.
To make telephone numbers easier to remember, some companies use letters
to show their telephone number. For example, using letters, the telephone
number 438-5626 can be shown as GET LOAN. In some cases, to make a
telephone number meaningful, companies might use more than seven letters.
For example, 225-5466 can be displayed as CALL HOME, which uses eight

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

5.

6.

7.

8.

b.
c.

d.
e.

f.

10.
11.

339

letters. Write a program that prompts the user to enter a telephone number
expressed in letters and outputs the corresponding telephone number in digits. If
the user enters more than seven letters, then process only the first seven letters.
Also output the – (hyphen) after the third digit. Allow the user to use both
uppercase and lowercase letters as well as spaces between words. Moreover,
your program should process as many telephone numbers as the user wants.
Write a program that reads a set of integers and then finds and prints the
sum of the even and odd integers.
Write a program that prompts the user to input a positive integer. It should
then output a message indicating whether the number is a prime number.
(Note: An even number is prime if it is 2. An odd integer is prime if it is not
divisible by any odd integer less than or equal to the square root of the
number.)
Let n = akak-1ak-2. . .a1a0 be an integer and t = a0 - a1 + a2 -    + (-1)k ak. It
is known that n is divisible by 11 if and only if t is divisible by 11. For
example, suppose that n = 8784204. Then, t = 4 - 0 + 2 - 4 + 8 - 7 + 8 =
11. Because 11 is divisible by 11, it follows that 8784204 is divisible by 11.
If n ¼ 54063297, then t = 7 - 9 + 2 - 3 + 6 - 0 + 4 - 5 = 2. Because 2 is not
divisible by 11, 54063297 is not divisible by 11. Write a program that
prompts the user to enter a positive integer and then uses this criterion to
determine whether the number is divisible by 11.
Write a program that uses while loops to perform the following steps:
a.

9.

|

Prompt the user to input two integers: firstNum and secondNum
(firstNum must be less than secondNum).
Output all odd numbers between firstNum and secondNum.
Output the sum of all even numbers between firstNum and
secondNum.
Output the numbers and their squares between 1 and 10.
Output the sum of the square of the odd numbers between firstNum
and secondNum.
Output all uppercase letters.

Redo Programming Exercise 8 using for loops.
Redo Programming Exercise 8 using do. . .while loops.
The program in the Programming Example: Fibonacci Number does not
check whether the first number entered by the user is less than or equal to
the second number and whether both the numbers are nonnegative. Also,
the program does not check whether the user entered a valid value for the
position of the desired number in the Fibonacci sequence. Rewrite that
program so that it checks for these things.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

340 |

12.

13.

14.

15.

16.

Chapter 5: Control Structures II (Repetition)

The population of a town A is less than the population of town B.
However, the population of town A is growing faster than the population
of town B. Write a program that prompts the user to enter the population
and growth rate of each town. The program outputs after how many years
the population of town A will be greater than or equal to the population of
town B and the populations of both the towns at that time. (A sample input
is: Population of town A ¼ 5000, growth rate of town A ¼ 4%, population
of town B ¼ 8000, and growth rate of town B ¼ 2%.)
Suppose that the first number of a sequence is x, in which x is an integer.
Define a0 ¼ x; an+1 ¼ an/2 if an is even; an+1 ¼ 3  an + 1 if an is odd.
Then, there exists an integer k such that ak ¼ 1. Write a program that prompts
the user to input the value of x. The program output the integer k such
that ak ¼ 1 and the numbers a0, a1, a2, . . . , ak. (For example, if x ¼ 75, then
k ¼ 14, and the numbers a0, a1, a2, . . ., a14, respectively, are 75, 226, 113, 340,
170, 85, 256, 128, 64, 32, 16, 8, 4, 2, 1.) Test your program for the following
values of x: 75, 111, 678, 732, 873, 2048, and 65535.
Enhance your program from Programming Exercise 13 by outputting the
position of the largest number and the largest number of the sequence a0, a1,
a2, . . ., ak. (For example, the largest number of the sequence 75, 226, 113, 340,
170, 85, 256, 128, 64, 32, 16, 8, 4, 2, 1 is 340, and its position is 4.) Test your
program for the following values of x: 75, 111, 678, 732, 873, 2048, and 65535.
The program in Example 5-6 implements the Number Guessing Game.
However, in that program, the user is given as many tries as needed to guess
the correct number. Rewrite the program so that the user has no more than
five tries to guess the correct number. Your program should print an
appropriate message, such as ‘‘You win!’’ or ‘‘You lose!’’.
Example 5-6 implements the Number Guessing Game program. If the
guessed number is not correct, the program outputs a message indicating
whether the guess is low or high. Modify the program as follows: Suppose
that the variables num and guess are as declared in Example 5-6 and diff
is an int variable. Let diff = the absolute value of (num – guess). If diff
is 0, then guess is correct and the program outputs a message indicating
that the user guessed the correct number. Suppose diff is not 0. Then the
program outputs the message as follows:
a.

b.

c.

If diff is greater than or equal to 50, the program outputs the message
indicating that the guess is very high (if guess is greater than num) or
very low (if guess is less than num).
If diff is greater than or equal to 30 and less than 50, the program
outputs the message indicating that the guess is high (if guess is greater
than num) or low (if guess is less than num).
If diff is greater than or equal to 15 and less than 30, the program
outputs the message indicating that the guess is moderately high (if guess
is greater than num) or moderately low (if guess is less than num).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

d.

|

341

If diff is greater than 0 and less than 15, the program outputs the
message indicating that the guess is somewhat high (if guess is greater
than num) or somewhat low (if guess is less than num).

As in Programming Exercise 15, give the user no more than five tries to guess
the number. (To find the absolute value of num – guess, use the expression
abs(num – guess). The function abs is from the header file cstdlib.)
17.

18.

19.

20.

Write a program to implement the algorithm that you designed in Exercise
21 of Chapter 1. Your program should allow the user to buy as many items
as the user desires.
The program in Example 5-4 uses a sentinel control loop to process
cookies sales data. Assume that the data is provided in a file and the first
line in the file specifies the cost of one box. Modify the program so that it
uses an EOF-controlled loop to process the data.
Enhance the program that you wrote in Exercise 18 by modifying it as
follows: When the students started selling cookies, they were told that the
students who sell the maximum number of boxes will have 10% of the money
they generate donated to their favorite charitable organization. So, in addition
to the output your program generated in Exercise 18, your program should
output the names of all the students selling the maximum number of boxes
and the amount that will be donated to their charitable organization.
When you borrow money to buy a house, a car, or for some other purpose,
you repay the loan by making periodic payments over a certain period of time.
Of course, the lending company will charge interest on the loan. Every
periodic payment consists of the interest on the loan and the payment toward
the principal amount. To be specific, suppose that you borrow $1000 at the
interest rate of 7.2% per year and the payments are monthly. Suppose that your
monthly payment is $25. Now, the interest is 7.2% per year and the payments
are monthly, so the interest rate per month is 7.2/12 ¼ 0.6%. The first month’s
interest on $1000 is 1000  0.006 ¼ 6. Because the payment is $25 and
interest for the first month is $6, the payment toward the principal amount is
25 – 6 ¼ 19. This means after making the first payment, the loan amount is
1000 – 19 ¼ 981. For the second payment, the interest is calculated on $981.
So the interest for the second month is 981  0.006 ¼ 5.886, that is,
approximately $5.89. This implies that the payment toward the principal is
25 – 5.89 ¼ 19.11 and the remaining balance after the second payment is 981 –
19.11 ¼ 961.89. This process is repeated until the loan is paid. Write a
program that accepts as input the loan amount, the interest rate per year,
and the monthly payment. (Enter the interest rate as a percentage. For
example, if the interest rate is 7.2% per year, then enter 7.2.) The program
then outputs the number of months it would take to repay the loan. (Note
that if the monthly payment is less than the first month’s interest, then after
each payment, the loan amount will increase. In this case, the program
must warn the borrower that the monthly payment is too low, and with
this monthly payment, the loan amount could not be repaid.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

342 |

21.

22.
23.
24.
25.
26.
27.

Chapter 5: Control Structures II (Repetition)

Enhance your program from Exercise 20 by first telling the user the
minimum monthly payment and then prompting the user to enter the
monthly payment. Your last payment might be more than the remaining
loan amount and interest on it. In this case, output the loan amount before
the last payment and the actual amount of the last payment. Also, output the
total interest paid.
Write a complete program to test the code in Example 5-21.
Write a complete program to test the code in Example 5-22.
Write a complete program to test the code in Example 5-23.
Write a complete program to test the code in Example 5-24.
Write a complete program to test the code in Example 5-25.
(The conical paper cup problem) You have been given the contract for
making little conical cups that come with bottled water. These cups are to
be made from a circular waxed paper of 4 inches in radius by removing a
sector of length x (see Figure 5-4). By closing the remaining part of the
circle, a conical cup is made. Your objective is to remove the sector so that
the cup is of maximum volume.

r

x

4
h

FIGURE 5-4

28.

4

Conical paper cup

Write a program that prompts the user to enter the radius of the circular
waxed paper. The program should then output the length of the removed
sector so that the resulting cup is of maximum volume. Calculate your
answer to two decimal places.
(Apartment problem) A real estate office handles, say, 50 apartment units.
When the rent is, say, $600 per month, all the units are occupied. However,
for each, say, $40 increase in rent, one unit becomes vacant. Moreover,
each occupied unit requires an average of $27 per month for maintenance.
How many units should be rented to maximize the profit?

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

343

Write a program that prompts the user to enter:
a.
b.
c.
d.

29.

30.

31.

The total number of units.
The rent to occupy all the units.
The increase in rent that results in a vacant unit.
Amount to maintain a rented unit.

The program then outputs the number of units to be rented to maximize the profit.
Let n be a nonnegative integer. The factorial of n, written n!, is defined by
0!=1, n! = 123  n if n  1. For example, 4! = 1234 = 24. Write a
program that prompts the user to enter a nonnegative integer and outputs
the factorial of the number.
n
Let n be an integer. The value of the expression limn!1 ð1 þ n1Þ is written as e.
This number e appears in many places in mathematics. For example, it appears
in the formula A = Pert to compute the total amount accumulated when the
interest is compounded continuously. It also appears in problems relating to
exponential growth and decay. It is known that e is an irrational number. The
value of e to nine decimal places is e = 2.718281827. Write a program that
n
computes the value of the expression limn!1 ð1 þ n1Þ between certain
values of n and then compare the values with e. For example, you can
compute the values of the expression between 100 and 10000 with an
increment of 100, or between 1000 and 1000000 with an increment of 1000.
Exercise 30 defines the number e. The value of e can be approximated using
the following expression:
2 þ 2!1 þ 3!1 þ    þ n!1 ’

32.

where n is a positive integer. Write a program that uses this formula to
approximate the value of e. Test your program for n = 4, 8, 10, and 12.
Exercise 30 defines the number e and Exercise 31 shows how to approximate the value of e using a different expression. Interestingly, the value of e
can also be approximated using the following expression:
2+ 1
1+ 1
2+ 2
3+ 3
4+ 4
5 + 5.
.
.

(n – 1)
(n – 1) + n + n

Write a program that uses this formula to approximate the value of e. Test
your program for n = 3, 5, 10, 50, and 100.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

CHAPTER

ª HunThomas/Shutterstock.com

U SER -D EFINED F UNCTIONS
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about standard (predefined) functions and discover how to use them in a program

2.

Learn about user-defined functions

3.

Examine value-returning functions, including actual and formal parameters

4.

Explore how to construct and use a value-returning, user-defined function in a program

5.

Learn about function prototypes

6.

Learn how to construct and use void functions in a program

7.

Discover the difference between value and reference parameters

8.

Explore reference parameters and value-returning functions

9.

Learn about the scope of an identifier

10.

Examine the difference between local and global identifiers

11.

Discover static variables

12.

Learn how to debug programs using drivers and stubs

13.

Learn function overloading

14.

Explore functions with default parameters

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

346 |

Chapter 6: User-Defined Functions

In Chapter 2, you learned that a C++ program is a collection of functions. One such
function is main. The programs in Chapters 1 through 5 use only the function
main; the programming instructions are packed into one function. This technique,
however, is good only for short programs. For large programs, it is not practical
(although it is possible) to put the entire programming instructions into one function,
as you will soon discover. You must learn to break the problem into manageable
pieces. This chapter first discusses the functions previously defined and then discusses
user-defined functions.
Let us imagine an automobile factory. When an automobile is manufactured, it is not
made from basic raw materials; it is put together from previously manufactured parts.
Some parts are made by the company itself; others, by different companies.
Functions are like building blocks. They let you divide complicated programs into
manageable pieces. They have other advantages, too:
•

While working on one function, you can focus on just that part of the
program and construct it, debug it, and perfect it.
• Different people can work on different functions simultaneously.
• If a function is needed in more than one place in a program or in
different programs, you can write it once and use it many times.
• Using functions greatly enhances the program’s readability because it
reduces the complexity of the function main.
Functions are often called modules. They are like miniature programs; you can put
them together to form a larger program. When user-defined functions are discussed,
you will see that this is the case. This ability is less apparent with predefined functions
because their programming code is not available to us. However, because predefined
functions are already written for us, you will learn these first so that you can use them
when needed.

Predefined Functions
Before formally discussing predefined functions in C++, let us review a concept from a
college algebra course. In algebra, a function can be considered a rule or correspondence
between values, called the function’s arguments, and the unique values of the function
associated with the arguments. Thus, if f(x) = 2x + 5, then f(1) = 7, f(2) = 9, and
f(3) = 11, where 1, 2, and 3 are the arguments of f, and 7, 9, and 11 are the
corresponding values of the function f.
In C++, the concept of a function, either predefined or user-defined, is similar to that of
a function in algebra. For example, every function has a name and, depending on the
values specified by the user, it does some computation. This section discusses various
predefined functions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Predefined Functions |

347

Some of the predefined mathematical functions are pow(x, y), sqrt(x), and
floor(x).
The power function, pow(x, y), calculates xy; that is, the value of pow(x, y)= xy.
For example, pow(2.0, 3)= 2.03 = 8.0 and pow(2.5, 3)= 2.53 = 15.625. Because
the value of pow(x, y) is of type double, we say that the function pow is of type
double or that the function pow returns a value of type double. Moreover, x and y
are called the parameters (or arguments) of the function pow. Function pow has two
parameters.
The square root function, sqrt(x), calculates the nonnegative square root of x for
x >= 0.0. For example, sqrt(2.25) is 1.5. The function sqrt is of type double
and has only one parameter.
The floor function, floor(x), calculates the largest whole number that is less than or
equal to x. For example, floor(48.79) is 48.0. The function floor is of type
double and has only one parameter.
In C++, predefined functions are organized into separate libraries. For example, the
header file iostream contains I/O functions, and the header file cmath contains
math functions. Table 6-1 lists some of the more commonly used predefined functions, the name of the header file in which each function’s specification can be
found, the data type of the parameters, and the function type. The function type is
the data type of the value returned by the function. (For a list of additional
predefined functions, see Appendix F.)

TABLE 6-1

Predefined Functions

Function

Header File

Purpose

Parameter(s)
Result
Type

abs(x)

<cmath>

Returns the absolute value
of its argument: abs(-7) = 7

int
(double)

int
(double)

ceil(x)

<cmath>

Returns the smallest whole
number that is not less than
x: ceil(56.34) = 57.0

double

double

cos(x)

<cmath>

Returns the cosine of angle:
x: cos(0.0) = 1.0

double
(radians)

double

exp(x)

<cmath>

double

double

fabs(x)

<cmath>

double

double

Returns ex, where e = 2.718:

exp(1.0) = 2.71828
Returns the absolute value
of its argument:

fabs(-5.67) = 5.67

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

348 |

Chapter 6: User-Defined Functions

TABLE 6-1

Predefined Functions (continued)

Function

Header File

Purpose

Parameter(s)
Result
Type

floor(x)

<cmath>

Returns the largest whole
number that is not greater than
x:floor(45.67) = 45.00

double

double

<cctype>

Returns 1 (true) if x is a
lowercase letter; otherwise,
it returns 0 (false);
islower('h') is 1 (true)

int

int

<cctype>

Returns 1 (true) if x is an
uppercase letter; otherwise,
it returns 0 (false);
isupper('K') is 1 (true)

int

int

double

double

double

double

islower(x)

isupper(x)

pow(x, y)

<cmath>

Returns xy; if x is negative, y
must be a whole number:

pow(0.16, 0.5) = 0.4

sqrt(x)

<cmath>

Returns the nonnegative
square root of x; x must be
nonnegative: sqrt(4.0) =

2.0
tolower(x)

<cctype>

Returns the lowercase value
of x if x is uppercase;
otherwise, it returns x

int

int

toupper(x)

<cctype>

Returns the uppercase value
of x if x is lowercase;
otherwise, it returns x

int

int

To use predefined functions in a program, you must include the header file that contains
the function’s specification via the include statement. For example, to use the function
pow, the program must include:
#include <cmath>

Example 6-1 shows you how to use some of the predefined functions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Predefined Functions |

349

EXAMPLE 6-1
// How to use predefined functions.
#include <iostream>
#include <cmath>
#include <cctype>
#include <iomanip>

//Line
//Line
//Line
//Line

using namespace std;

//Line 5

int main()
{
int num;
double firstNum, secondNum;
char ch = 'T';

//Line
//Line
//Line
//Line
//Line

cout << fixed << showpoint << setprecision (2)
<< endl;
cout <<
<<
<<
cout <<
<<

"Line 12: Is " << ch
" a lowercase letter? "
islower(ch) << endl;
"Line 13: Uppercase a is "
static_cast<char>(toupper('a')) << endl;

6
7
8
9
10

//Line 11

//Line 12
//Line 13

cout << "Line 14: 4.5 to the power 6.0 = "
<< pow(4.5, 6.0) << endl;

//Line 14

cout << "Line 15: Enter two decimal numbers: ";
cin >> firstNum >> secondNum;
cout << endl;

//Line 15
//Line 16
//Line 17

cout << "Line 18: " << firstNum
<< " to the power of " << secondNum
<< " = " << pow(firstNum, secondNum) << endl;

//Line 18

cout << "Line 19: 5.0 to the power of 4 = "
<< pow(5.0, 4) << endl;

//Line 19

firstNum = firstNum + pow(3.5, 7.2);
cout << "Line 21: firstNum = " << firstNum << endl;

//Line 20
//Line 21

num = -32;
cout << "Line 23: Absolute value of " << num
<< " = " << abs(num) << endl;

//Line 22
//Line 23

cout << "Line 24: Square root of 28.00 = "
<< sqrt(28.00) << endl;

//Line 24

return 0;
}

1
2
3
4

//Line 25
//Line 26

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

350 |

Chapter 6: User-Defined Functions

Sample Run: In this sample run, the user input is shaded.
Line
Line
Line
Line

12:
13:
14:
15:

Is T a lowercase letter? 0
Uppercase a is A
4.5 to the power 6.0 = 8303.77
Enter two decimal numbers: 24.7 3.8

Line
Line
Line
Line
Line

18:
19:
21:
23:
24:

24.70 to the power of 3.80 = 195996.55
5.0 to the power of 4 = 625.00
firstNum = 8290.60
Absolute value of -32 = 32
Square root of 28.00 = 5.29

This program works as follows. The statements in Lines 1 to 4 include the header files
that are necessary to use the functions used in the program. The statements in Lines 8 to
10 declare the variables used in the program. The statement in Line 11 sets the output of
decimal numbers in fixed decimal format with two decimal places. The statement in Line
12 uses the function islower to determine and output whether ch is a lowercase letter.
The statement in Line 13 uses the function toupper to output the uppercase letter that
corresponds to 'a', which is A. Note that the function toupper returns an int value.
Therefore, the value of the expression toupper('a') is 65, which is the ASCII value of
'A'. To print the character A rather than the value 65, you need to apply the cast
operator as shown in the statement in Line 13. The statement in Line 14 uses the function
pow to output 4.56.0. In C++ terminology, it is said that the function pow is called with
the parameters 4.5 and 6.0. The statements in Lines 15 to 17 prompt the user to enter
two decimal numbers and store the numbers entered by the user in the variables
firstNum and secondNum. In the statement in Line 18, the function pow is used to
output firstNumsecondNum. In this case, the function pow is called with the parameters
firstNum and secondNum and the values of firstNum and secondNum are passed to the
function pow. The other statements have similar meanings. Once again, note that the
program includes the header files cctype and cmath, because it uses the functions
islower, toupper, pow, abs, and sqrt from these header files.

User-Defined Functions
As Example 6-1 illustrates, using functions in a program greatly enhances the program’s
readability because it reduces the complexity of the function main. Also, once you write
and properly debug a function, you can use it in the program (or different programs)
again and again without having to rewrite the same code repeatedly. For instance, in
Example 6-1, the function pow is used more than once.
Because C++ does not provide every function that you will ever need and designers
cannot possibly know a user’s specific needs, you must learn to write your own
functions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

351

User-defined functions in C++ are classified into two categories:
•

Value-returning functions—functions that have a return type. These
functions return a value of a specific data type using the return statement,
which we will explain shortly. Note that the function main has used a
return statement to return the value 0 in every program we’ve seen so far.
• Void functions—functions that do not have a return type. These
functions do not use a return statement to return a value.
We will first discuss value-returning functions. Many of the concepts discussed in regard
to value-returning functions also apply to void functions.

Value-Returning Functions
The previous section introduced some predefined C++ functions such as pow, abs,
islower, and toupper. These are examples of value-returning functions. To use these
functions in your programs, you must know the name of the header file that contains the
functions’ specification. You need to include this header file in your program using the
include statement and know the following items:
1.
2.
3.
4.

The name of the function
The parameters, if any
The data type of each parameter
The data type of the value computed (that is, the value returned) by the
function, called the type of the function

Because a value-returning function returns only one value, the natural thing for
you to do is to use the value in one of three ways:
•
•

Save the value for further calculation. For example, x = pow(3.0, 2.5);
Use the value in some calculation. For example,
area = PI * pow(radius, 2.0);

•

Print the value. For example, cout << abs(-5) << endl;

This suggests that a value-returning function is used:
•
•
•

In an assignment statement.
As a parameter in a function call.
In an output statement.

That is, a value-returning function is used (called) in an expression.
Before we look at the syntax of a user-defined, value-returning function, let us consider
the things associated with such functions. In addition to the four properties described
previously, one more thing is associated with functions (both value-returning and void):
5. The code required to accomplish the task
The first four properties form, what is called, the heading of the function (also called the
function header); the fifth property is called the body of the function. Together, these
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

352 |

Chapter 6: User-Defined Functions

five properties form, what is called, the definition of the function. For example, for the
function abs, the heading might look like:
int abs(int number)

Similarly, the function abs might have the following definition:
int abs(int number)
{
if (number < 0)
number = -number;
return number;
}

The variable declared in the heading of the function abs is called a formal parameter
of the function abs. Thus, the formal parameter of abs is number.
The program in Example 6-1 contains several statements that use the function pow. That
is, in C++ terminology, the function pow is called several times. Later in this chapter, we
discuss what happens when a function is called.
Suppose that the heading of the function pow is:
double pow(double base, double exponent)

From the heading of the function pow, it follows that the formal parameters of pow are
base and exponent. Consider the following statements:
double u = 2.5;
double v = 3.0;
double x, y;
x = pow(u, v);
y = pow(2.0, 3.2) + 5.1;
cout << u << " to the power of 7 = " <<

pow(u, 7) << endl;

//Line 1
//Line 2
//Line 3

In Line 1, the function pow is called with the parameters u and v. In this case, the values
of u and v are passed to the function pow. In fact, the value of u is copied into base, and
the value of v is copied into exponent. The variables u and v that appear in the call to
the function pow in Line 1 are called the actual parameters of that call. In Line 2, the
function pow is called with the parameters 2.0 and 3.2. In this call, the value 2.0 is
copied into base, and 3.2 is copied into exponent. Moreover, in this call of the
function pow, the actual parameters are 2.0 and 3.2, respectively. Similarly, in Line 3,
the actual parameters of the function pow are u and 7; the value of u is copied into base,
and 7.0 is copied into exponent.
We can now formally present two definitions:
Formal Parameter: A variable declared in the function heading.
Actual Parameter: A variable or expression listed in a call to a function.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

353

For predefined functions, you only need to be concerned with the first four properties.
Software companies, typically, do not give out the actual source code, which is the body
of the function.

Syntax: Value-Returning Function
The syntax of a value-returning function is:
functionType functionName(formal parameter list)
{
statements
}

in which statements are usually declaration statements and/or executable statements.
In this syntax, functionType is the type of the value that the function returns. The
functionType is also called the data type or the return type of the value-returning
function. Moreover, statements enclosed between curly braces form the body of the function.

Syntax: Formal Parameter List
The syntax of the formal parameter list is:
dataType identifier, dataType identifier, ...

Consider the definition of the function abs given earlier in this chapter. Figure 6-1
identifies various parts of this function.
Function return type

Function name

Formal parameter

Function heading

int abs(int number)
Formal parameter list
{
if (number < 0
)
number = -number;
Function body
return number;
}

FIGURE 6-1

Various parts of the function abs

Function Call
The syntax to call a value-returning function is:
functionName(actual parameter list)

For example, in the expression x = abs(-5);, the function abs is called.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

354 |

Chapter 6: User-Defined Functions

Syntax: Actual Parameter List
The syntax of the actual parameter list is:
expression or variable, expression or variable, ...

(In this syntax, expression can be a single constant value.) Thus, to call a valuereturning function, you use its name, with the actual parameters (if any) in parentheses.
A function’s formal parameter list can be empty. However, if the formal parameter list is
empty, the parentheses are still needed. The function heading of the value-returning
function thus takes, if the formal parameter list is empty, the following form:
functionType functionName()

If the formal parameter list of a value-returning function is empty, the actual parameter is
also empty in a function call. In this case (that is, an empty formal parameter list), in a
function call, the empty parentheses are still needed. Thus, a call to a value-returning
function with an empty formal parameter list is:
functionName()

In a function call, the number of actual parameters, together with their data types, must
match with the formal parameters in the order given. That is, actual and formal parameters have a one-to-one correspondence. (Later in this chapter, we discuss functions
with default parameters.)
As stated previously, a value-returning function is called in an expression. The expression
can be part of either an assignment statement or an output statement, or a parameter in a
function call. A function call in a program causes the body of the called function to
execute.

return Statement
Once a value-returning function computes the value, the function returns this value via
the return statement. In other words, it passes this value outside the function via the
return statement.

Syntax: return Statement
The return statement has the following syntax:
return expr;

in which expr is a variable, constant value, or expression. The expr is evaluated, and its
value is returned. The data type of the value that expr computes must match the
function type.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

355

In C++, return is a reserved word.
When a return statement executes in a function, the function immediately terminates
and the control goes back to the calling function. Moreover, the function call statement is
replaced by the value returned by the return statement. When a return statement
executes in the function main, the program terminates.
To put the ideas in this discussion to work, let us write a function that determines the
larger of two numbers. Because the function compares two numbers, it follows that this
function has two parameters and that both parameters are numbers. Let us assume that
the data type of these numbers is floating-point (decimal)—say, double. Because the
larger number is of type double, the function’s data type is also double. Let us name
this function larger. The only thing you need to complete this function is the body of
the function. Thus, following the syntax of a function, you can write this function as
follows:
double larger(double x, double y)
{
double max;

6

if (x >= y)
max = x;
else
max = y;
return max;
}

Note that the function larger uses an additional variable max (called a local declaration,
in which max is a variable local to the function larger). Figure 6-2 describes various parts
of the function larger.

Function Function
return type name
Function
heading

Formal
parameters

double larger(double x, double y)
{
double max;
Formal parameters list
if (x >= y)
max = x;
else
max = Y;

Function
body

return

Local variable

Function return value

max;

}

FIGURE 6-2

Various parts of the function larger

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

356 |

Chapter 6: User-Defined Functions

Suppose that num, num1, and num2 are double variables. Also suppose that num1 = 45.75
and num2 = 35.50. Figure 6-3 shows various ways the function larger can be called.
Function call

Actual parameters

num = larger(23.50, 37.80);
Function call

Actual parameters

num = larger(num1, num2);
Function call

Actual parameters

num = larger(34.50, num1);

FIGURE 6-3

Function calls

In Figure 6-3, in the first statement, the function larger determines the larger of
23.50 and 37.80, and the assignment statement stores the result in num. The meaning of
the other two statements is similar.
You can also write the definition of the function larger as follows:
double larger(double x, double y)
{
if (x >= y)
return x;
else
return y;
}

Because the execution of a return statement in a function terminates the function, the
preceding function larger can also be written (without the word else) as:
double larger(double x, double y)
{
if (x >= y)
return x;
return y;
}

Note that these forms of the function larger do not require you to declare any local variable.
1.

In the definition of the function larger, x and y are formal parameters.

2.

The return statement can appear anywhere in the function. Recall that once a
return statement executes, all subsequent statements are skipped. Thus, it’s
a good idea to return the value as soon as it is computed.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

357

EXAMPLE 6-2
Now that the function larger is written, the following C++ code illustrates how to use it:
double num1 = 13.00;
double num2 = 36.53;
double maxNum;

Consider the following statements:
cout << "The larger of 5 and 6 is " << larger(5, 6)
<< endl;

//Line 1

cout << "The larger of " << num1 << " and " << num2
<< " is " << larger(num1, num2) << endl;

//Line 2

cout << "The larger of " << num1 << " and 29 is "
<< larger(num1, 29) << endl;

//Line 3

maxNum = larger(38.45, 56.78);

//Line 4

•

The expression larger(5, 6) in Line 1 is a function call, and 5 and 6
are actual parameters. When the expression larger(5, 6) executes, 5 is
copied into x, and 6 is copied into y. Therefore, the statement in Line 1
outputs the larger of 5 and 6.
• The expression larger(num1, num2) in Line 2 is a function call. Here, num1
and num2 are actual parameters. When the expression larger(num1, num2)
executes, the value of num1 is copied into x, and the value of num2 is copied
into y. Therefore, the statement in Line 2 outputs the larger of num1 and num2.
• The expression larger(num1, 29) in Line 3 is also a function call. When
the expression larger(num1, 29) executes, the value of num1 is copied
into x, and 29 is copied into y. Therefore, the statement in Line 3
outputs the larger of num1 and 29. Note that the first parameter, num1, is
a variable, while the second parameter, 29, is a constant value.
• The expression larger(38.45, 56.78) in Line 4 is a function call. In this
call, the actual parameters are 38.45 and 56.78. In this statement, the value
returned by the function larger is assigned to the variable maxNum.

In a function call, you specify only the actual parameter, not its data type. For example, in
Example 6-2, the statements in Lines 1, 2, 3, and 4 show how to call the function larger with
the actual parameters. However, the following statements contain incorrect calls to the function
larger and would result in syntax errors. (Assume that all variables are properly declared.)

x = larger(int one, 29);
y = larger(int one, int 29);
cout << larger(int one, int two);

//illegal
//illegal
//illegal

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

358 |

Chapter 6: User-Defined Functions

Once a function is written, you can use it anywhere in the program. The function
larger compares two numbers and returns the larger of the two. Let us now write
another function that uses this function to determine the largest of three numbers. We
call this function compareThree.
double compareThree(double x, double y, double z)
{
return larger(x, larger(y, z));
}

In the function heading, x, y, and z are formal parameters.
Let us take a look at the expression:
larger(x, larger(y, z))

in the definition of the function compareThree. This expression has two calls to the
function larger. The actual parameters to the outer call are x and larger(y, z);
the actual parameters to the inner call are y and z. It follows that, first, the expression
larger(y, z) is evaluated; that is, the inner call executes first, which gives the larger of y
and z. Suppose that larger(y, z) evaluates to, say, t. (Notice that t is either y or z.)
Next, the outer call determines the larger of x and t. Finally, the return statement returns
the largest number. It thus follows that to execute a function call, the parameters must be
evaluated first. For example, the actual parameter larger(y, z) of the outer call is evaluated
first to render a resulting value that is sent with x to the outer call to larger.
Note that the function larger is much more general purpose than the function
compareThree. Here, we are merely illustrating that once you have written a function,
you can use it to write other functions. Later in this chapter, we will show how to use the
function larger to determine the largest number from a set of numbers.

Function Prototype
Now that you have some idea of how to write and use functions in a program, the next
question relates to the order in which user-defined functions should appear in a program.
For example, do you place the function larger before or after the function main?
Should larger be placed before compareThree or after it? Following the rule that you
must declare an identifier before you can use it and knowing that the function main uses
the identifier larger, logically you must place larger before main.
In reality, C++ programmers customarily place the function main before all other userdefined functions. However, this organization could produce a compilation error because
functions are compiled in the order in which they appear in the program. For example, if
the function main is placed before the function larger, the identifier larger will be
undefined when the function main is compiled. To work around this problem of
undeclared identifiers, we place function prototypes before any function definition
(including the definition of main).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

359

The function prototype is not a definition. It gives the program the name of the function,
the number and data types of the parameters, and the data type of the returned value: just
enough information to let C++ use the function. It is also a promise that the full
definition will appear later in the program. If you neglect to write the definition of the
function, the program may compile, but it will not execute.
Function Prototype: The function heading, terminated by a semicolon, ;, without the

body of the function.

Syntax: Function Prototype
The general syntax of the function prototype of a value-returning function is:
functionType functionName(parameter list);

(Note that the function prototype ends with a semicolon.)

6

For the function larger, the prototype is:
double larger(double x, double y);

//function prototype

When writing the function prototype, you do not have to specify the variable name in the
parameter list. However, you must specify the data type of each parameter.
You can rewrite the function prototype of the function larger as follows:

double larger(double, double);

//function prototype

FINAL PROGRAM
You now know enough to write the entire program, compile it, and run it. The following
program uses the functions larger, compareThree, and main to determine the larger/
largest of two or three numbers.
//Program: Largest of three numbers
#include <iostream>
using namespace std;
double larger(double x, double y);
double compareThree(double x, double y, double z);
int main()
{
double one, two;
cout << "Line 2: The larger of 5 and 10 is "
<< larger(5, 10) << endl;

//Line 1
//Line 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

360 |

Chapter 6: User-Defined Functions

cout << "Line 3: Enter two numbers: ";
cin >> one >> two;
cout << endl;
cout <<
<<
<<
cout <<
<<
<<
<<

//Line 3
//Line 4
//Line 5

"Line 6: The larger of " << one
" and " << two << " is "
larger(one, two) << endl;
//Line 6
"Line 7: The largest of 43.48, 34.00, "
"and 12.65 is "
compareThree(43.48, 34.00, 12.65)
endl;
//Line 7

return 0;
}
double larger(double x, double y)
{
double max;
if (x >= y)
max = x;
else
max = y;
return max;
}
double compareThree (double x, double y, double z)
{
return larger(x, larger(y, z));
}

Sample Run: In this sample run, the user input is shaded.
Line 2: The larger of 5 and 10 is 10
Line 3: Enter two numbers: 25.6 73.85
Line 6: The larger of 25.6 and 73.85 is 73.85
Line 7: The largest of 43.48, 34.00, and 12.65 is 43.48
In the previous program, the function prototypes of the functions larger and
compareThree appear before their function definitions. Therefore, the definition of
the functions larger and compareThree can appear in any order.

Value-Returning Functions: Some Peculiarities
A value-returning function must return a value. Consider the following function, secret,
that takes as a parameter an int value. If the value of the parameter, x, is greater than 5, it
returns twice the value of x.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

int secret(int x)
{
if (x > 5)
return 2 * x;
}

361

//Line 1
//Line 2

Because this is a value-returning function of type int, it must return a value of type int.
Suppose the value of x is 10. Then the expression x > 5 in Line 1 evaluates to true. So
the return statement in Line 2 returns the value 20. Now suppose that x is 3. The
expression x > 5 in Line 1 now evaluates to false. The if statement therefore fails, and
the return statement in Line 2 does not execute. However, there are no more statements
to be executed in the body of the function. In this case, the function returns a strange
value. It thus follows that if the value of x is less than or equal to 5, the function does not
contain any valid return statements to return a value of type int.
A correct definition of the function secret is:
int secret(int x)
{
if (x > 5)
return 2 * x;

6
//Line 1
//Line 2
//Line 3

return x;
}

Here, if the value of x is less than or equal to 5, the return statement in Line 3
executes, which returns the value of x. On the other hand, if the value of x is, say
10, the return statement in Line 2 executes, which returns the value 20 and also
terminates the function.
Recall that in a value-returning function, the return statement returns the value.
Consider the following return statement:
return x, y;

//only the value of y will be returned

This is a legal return statement. You might think that this return statement is returning
the values of x and y. However, this is not the case. Remember, a return statement returns
only one value, even if the return statement contains more than one expression. If a return
statement contains more than one expression, only the value of the last expression is returned.
Therefore, in the case of the above return statement, the value of y is returned. The
following program further illustrates this concept:
//
//
//
//

This program illustrates that a value-returning function
returns only one value, even if the return statement
contains more than one expression. This is a legal, but not
a recommended code.

#include <iostream>
using namespace std;
int funcRet1();
int funcRet2(int z);
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

362 |

Chapter 6: User-Defined Functions

int main()
{
int num = 4;
cout <<
<<
cout <<
<<

"Line 1: The value returned by funcRet1: "
funcRet1() << endl;
"Line 2: The value returned by funcRet2: "
funcRet2(num) << endl;

// Line 1
// Line 2

return 0;
}
int funcRet1()
{
int x = 45;
return 23, x;

//only the value of x is returned

}
int funcRet2(int z)
{
int a = 2;
int b = 3;
return 2 * a + b, z + b; //only the value of z + b is returned
}

Sample Run:
Line 1: The value returned by funcRet1: 45
Line 2: The value returned by funcRet2: 7

Even though a return statement can contain more than one expression, a return
statement in your program should contain only one expression. Having more than one
expression in a return statement may result in redundancy, wasted code, and a confusing
syntax.

More Examples of Value-Returning Functions
EXAMPLE 6-3
In this example, we write the definition of the function courseGrade. This function
takes as a parameter an int value specifying the score for a course and returns the
grade, a value of type char, for the course. (We assume that the test score is a value
between 0 and 100 inclusive.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

363

char courseGrade(int score)
{
switch (score / 10)
{
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
return 'F';
case 6:
return 'D';
case 7:
return 'C';
case 8:
return 'B';
case 9:
case 10:
return 'A';
}
}

You can also write an equivalent definition of the function courseGrade that uses an
if. . .else structure to determine the course grade.

EXAMPLE 6-4 (ROLLING A PAIR OF DICE)
In this example, we write a function that rolls a pair of dice until the sum of the numbers
rolled is a specific number. We also want to know the number of times the dice are rolled
to get the desired sum.
The smallest number on each die is 1, and the largest number is 6. So the smallest sum of
the numbers rolled is 2, and the largest sum of the numbers rolled is 12. Suppose that we
have the following declarations:
int
int
int
int

die1;
die2;
sum;
rollCount = 0;

We use the random number generator, discussed in Chapter 5, to randomly generate a
number between 1 and 6. Then, the following statement randomly generates a number
between 1 and 6 and stores that number into die1, which becomes the number rolled
by die1.
die1 = rand() % 6 + 1;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

364 |

Chapter 6: User-Defined Functions

Similarly, the following statement randomly generates a number between 1 and 6 and
stores that number into die2, which becomes the number rolled by die2.
die2 = rand() % 6 + 1;

The sum of the numbers rolled by two dice is:
sum = die1 + die2;

Next, we determine whether sum contains the desired sum of the numbers rolled by the
dice. (Assume that the int variable num contains the desired sum to be rolled.) If sum is
not equal to num, then we roll the dice again. This can be accomplished by the
following do...while loop.
do
{
die1 = rand() % 6 + 1;
die2 = rand() % 6 + 1;
sum = die1 + die2;
rollCount++;
}
while (sum != num);

We can now write the function rollDice that takes as a parameter the desired sum of
the numbers to be rolled and returns the number of times the dice are rolled to roll the
desired sum.
int rollDice(int num)
{
int die1;
int die2;
int sum;
int rollCount = 0;
srand(time(0));
do
{
die1 = rand() % 6 + 1;
die2 = rand() % 6 + 1;
sum = die1 + die2;
rollCount++;
}
while (sum != num);
return rollCount;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

365

The following program shows how to use the function rollDice in a program:
//Program: Roll dice
#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;
int rollDice(int num);
int main()
{
cout <<
<<
cout <<
<<

"The
"get
"The
"get

number of times the dice are rolled to "
the sum 10 = " << rollDice(10) << endl;
number of times the dice are rolled to "
the sum 6 = " << rollDice(6) << endl;

return 0;
}
int rollDice(int num)
{
int die1;
int die2;
int sum;
int rollCount = 0;
srand(time(0));
do
{
die1 = rand() % 6 + 1;
die2 = rand() % 6 + 1;
sum = die1 + die2;
rollCount++;
}
while (sum != num);
return rollCount;
}

Sample Run:
The number of times the dice are rolled to get the sum 10 = 11
The number of times the dice are rolled to get the sum 6 = 7

We leave it as an exercise for you to modify this program so that it allows the user to enter the
desired sum of the numbers to be rolled. (See Programming Exercise 7 at the end of this chapter.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

366 |

Chapter 6: User-Defined Functions

EXAMPLE 6-5 (FIBONACCI NUMBER)
In the first programming example in Chapter 5, we designed and implemented an
algorithm to find the number of a Fibonacci sequence. In this example, we modify the
main program by writing a function that computes and returns the desired number of a
Fobinacci sequence. Because we have already designed and discussed how to determine a
specific number of a Fibonacci sequence, next, we give the definition of the function to
implement the algorithm.
Given the first number, the second number, and the position of the desired Fibonacci
number, the following function returns the Fibonacci number:
int nthFibonacciNum(int first, int second, int nthFibNum)
{
int current;
int counter;
if (nthFibNum == 1)
current = first;
else if (nthFibNum == 2)
current = second;
else
{
counter = 3;
while (counter <= nthFibNum)
{
current = second + first;
first = second;
second = current;
counter++;
}//end while
}//end else
return current;
}

The following shows how to use this function in a program.
//Program: Fibonacci number
#include <iostream>
using namespace std;
int nthFibonacciNum(int first, int second, int position);
int main()
{
int firstFibonacciNum;
int secondFibonacciNum;
int nthFibonacci;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

367

cout << "Enter the first two Fibonacci "
<< "numbers: ";
cin >> firstFibonacciNum >> secondFibonacciNum;
cout << endl;
cout <<
<<
<<
<<

"The first two Fibonacci numbers are "
firstFibonacciNum << " and "
secondFibonacciNum
endl;

cout << "Enter the position of the desired "
<< "Fibonacci number: ";
cin >> nthFibonacci;
cout << endl;
cout << "The Fibonacci number at position "
<< nthFibonacci << " is "
<< nthFibonacciNum(firstFibonacciNum, secondFibonacciNum,
nthFibonacci)
<< endl;
return 0;
}
int nthFibonacciNum(int first, int second, int nthFibNum)
{
int current;
int counter;
if (nthFibNum == 1)
current = first;
else if (nthFibNum == 2)
current = second;
else
{
counter = 3;
while (counter <= nthFibNum)
{
current = second + first;
first = second;
second = current;
counter++;
}//end while
}//end else
return current;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

368 |

Chapter 6: User-Defined Functions

Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1:
Enter the first two Fibonacci numbers: 12 16
The first two Fibonacci numbers are 12 and 16
Enter the position of the desired Fibonacci number: 10
The Fibonacci number at position 10 is 796

Sample Run 2:
Enter the first two Fibonacci numbers: 1 1
The first two Fibonacci numbers are 1 and 1
Enter the position of the desired Fibonacci number: 15
The Fibonacci number at position 15 is 610

The following is an example of a function that returns a Boolean value.
EXAMPLE 6-6 (PALINDROME)
In this example, a function, isPalindrome, is designed that returns true if a string is a
palindrome and false otherwise. A string is a palindrome if it reads forward and
backward in the same way. For example, the strings "madamimadam", "5", "434", and
"789656987" are all palindromes.
Suppose str is a string. To determine whether str is a palindrome, first compare the first
and the last characters of str. If they are not the same, str is not a palindrome and so the
function should return false. If the first and the last characters of str are the same, then
we compare the second character with the second character from the end, and so on.
Note that if length = str.length(), the number of characters in str, then we need to
compare str[0] with str[length - 1], str[1] with str[length - 2], and in
general str[i] with str[length - 1 - i],where 0 <= i <= length / 2.
The following algorithm implements this discussion:
1. int length = str.length();
2. for (int i = 0; i < length / 2; i++)
if (str[i] != str[length - 1 - i])
return false;
return true;

The following function implements this algorithm:
bool isPalindrome(string str)
{
int length = str.length();

//Step 1

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

for (int i = 0; i < length / 2; i++)
if (str[i] != str[length - 1 - i])
return false;

369

//Step 2

return true;
}

EXAMPLE 6-7 (CABLE COMPANY)
Chapter 4 contains a program to calculate the bill for a cable company. In that
program, all of the programming instructions are packed in the function main. Here,
we rewrite the same program using user-defined functions, further illustrating structured programming.
Because there are two types of customers, residential and business, the program contains two
separate functions: one to calculate the bill for residential customers and one to calculate the
bill for business customers. Both functions calculate the billing amount and then return the
billing amount to the function main. The function main prints the amount due. Let us call
the function that calculates the residential bill residential and the function that calculates
the business bill business. The formulas to calculate the bills are the same as before.
Function residential: To compute the residential bill, you need to know the number
of premium channels to which the customer subscribes. Based on the number of
premium channels, you can calculate the billing amount. After calculating the billing
amount, the function returns the billing amount using the return statement. The
following four steps describe this function:
a. Prompt the user for the number of premium channels.
b. Read the number of premium channels.
c. Calculate the amount due.
d. Return the amount due.
This function contains a statement to prompt the user to enter the number of premium
channels (Step a) and a statement to read the number of premium channels (Step b). Other
items needed to calculate the billing amount, such as the cost of basic service connection and
bill processing fees, are defined as named constants (before the definition of the function
main). Therefore, to calculate the billing amount, this function does not need to get any
value from the function main. This function, therefore, has no parameters.
From the previous discussion, it follows that the function residential requires local
variables to store both the number of premium channels and the billing amount. This
function needs only these two local variables to calculate the billing amount:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

370 |

Chapter 6: User-Defined Functions

int noOfPChannels;
double bAmount;

//number of premium channels
//billing amount

The definition of the function residential can now be written as follows:
double residential()
{
int noOfPChannels;
double bAmount;

//number of premium channels
//billing amount

cout << "Enter the number of premium "
<< "channels used: ";
cin >> noOfPChannels;
cout << endl;
bAmount= RES_BILL_PROC_FEES +
RES_BASIC_SERV_COST +
noOfPChannels * RES_COST_PREM_CHANNEL;
return bAmount;
}

Function business: To compute the business bill, you need to know the number of both
the basic service connections and the premium channels to which the customer subscribes.
Then, based on these numbers, you can calculate the billing amount. The billing amount is
then returned using the return statement. The following six steps describe this function:
a.
b.
c.
d.
e.
f.

Prompt the user for the number of basic service connections.
Read the number of basic service connections.
Prompt the user for the number of premium channels.
Read the number of premium channels.
Calculate the amount due.
Return the amount due.

This function contains the statements to prompt the user to enter the number of basic
service connections and premium channels (Steps a and c). The function also contains
statements to input the number of basic service connections and premium channels (Steps b
and d). Other items needed to calculate the billing amount, such as the cost of basic service
connections and bill processing fees, are defined as named constants (before the definition of
the function main). It follows that to calculate the billing amount this function does not
need to get any values from the function main. Therefore, it has no parameters.
From the preceding discussion, it follows that the function business requires variables
to store the number of basic service connections and the number of premium channels, as
well as the billing amount. In fact, this function needs only these three local variables to
calculate the billing amount:
int noOfBasicServiceConnections;
int noOfPChannels; //number of premium channels
double bAmount;
//billing amount

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

371

The definition of the function business can now be written as follows:
double business()
{
int noOfBasicServiceConnections;
int noOfPChannels; //number of premium channels
double bAmount;
//billing amount
cout << "Enter the number of basic "
<< "service connections: ";
cin >> noOfBasicServiceConnections;
cout << endl;
cout << "Enter the number of premium "
<< "channels used: ";
cin >> noOfPChannels;
cout << endl;
if (noOfBasicServiceConnections <= 10)
bAmount = BUS_BILL_PROC_FEES + BUS_BASIC_SERV_COST +
noOfPChannels * BUS_COST_PREM_CHANNEL;
else
bAmount = BUS_BILL_PROC_FEES + BUS_BASIC_SERV_COST +
(noOfBasicServiceConnections - 10) *
BUS_BASIC_CONN_COST +
noOfPChannels * BUS_COST_PREM_CHANNEL;
return bAmount;
}

The algorithm for the main program is as follows:
1. To output floating-point numbers in a fixed decimal format with the decimal
point and trailing zeros, set the manipulators fixed and showpoint.
2. To output floating-point numbers to two decimal places, set the
precision to two decimal places.
3. Prompt the user for the account number.
4. Get the account number.
5. Prompt the user to enter the customer type.
6. Get the customer type.
7. a. If the customer type is R or r,
i. Call the function residential to calculate the bill.
ii. Print the bill.
b. If the customer type is B or b,
i. Call the function business to calculate the bill.
ii. Print the bill.
c. If the customer type is other than R, r, B, or b, it is an invalid
customer type.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

372 |

Chapter 6: User-Defined Functions

PROGRAM LISTING
//***********************************************************
// Author: D. S. Malik
//
// Program: Cable Company Billing
// This program calculates and prints a customer's bill for
// a local cable company. The program processes two types of
// customers: residential and business.
//***********************************************************
#include <iostream>
#include <iomanip>
using namespace std;
//Named constants - residential customers
const double RES_BILL_PROC_FEES = 4.50;
const double RES_BASIC_SERV_COST = 20.50;
const double RES_COST_PREM_CHANNEL = 7.50;
const
const
const
const

//Named constants - business customers
double BUS_BILL_PROC_FEES = 15.00;
double BUS_BASIC_SERV_COST = 75.00;
double BUS_BASIC_CONN_COST = 5.00;
double BUS_COST_PREM_CHANNEL = 50.00;

double residential();
double business();

//Function prototype
//Function prototype

int main()
{
//declare variables
int accountNumber;
char customerType;
double amountDue;
cout << fixed << showpoint;
cout << setprecision(2);

//Step 1
//Step 2

cout << "This program computes a cable bill."
<< endl;
cout << "Enter account number: ";
//Step 3
cin >> accountNumber;
//Step 4
cout << endl;
cout << "Enter customer type: R, r "
<< "(Residential), B, b (Business): ";
cin >> customerType;
cout << endl;

//Step 5
//Step 6

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value-Returning Functions |

switch (customerType)
{
case 'r':
case 'R':
amountDue = residential();
cout << "Account number = "
<< accountNumber << endl;
cout << "Amount due = $"
<< amountDue << endl;
break;
case 'b':
case 'B':
amountDue = business();
cout << "Account number = "
<< accountNumber << endl;
cout << "Amount due = $"
<< amountDue << endl;
break;
default:
cout << "Invalid customer type."
<< endl;
}

373

//Step 7
//Step 7a
//Step 7a.i
//Step 7a.ii
//Step 7a.ii
//Step 7b
//Step 7b.i
//Step 7b.ii
//Step 7b.ii

6
//Step 7c

return 0;
}
//Place the definitions of the functions residential and business here.

Sample Run: In this sample run, the user input is shaded.
This program computes a cable bill.
Enter account number: 21341
Enter customer type: R, r (Residential), B, b (Business): B
Enter the number of basic service connections: 25
Enter the number of premium channels used: 9
Account number = 21341
Amount due = $615.00

Flow of Compilation and Execution
As stated earlier, a C++ program is a collection of functions. Recall that functions can
appear in any order. The only thing that you have to remember is that you must declare
an identifier before you can use it. The program is compiled by the compiler sequentially
from beginning to end. Thus, if the function main appears before any other user-defined
functions, it is compiled first. However, if main appears at the end (or middle) of the
program, all functions whose definitions (not prototypes) appear before the function
main are compiled before the function main, in the order they are placed.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

374 |

Chapter 6: User-Defined Functions

Function prototypes appear before any function definition, so the compiler complies
these first. The compiler can then correctly translate a function call. However, when the
program executes, the first statement in the function main always executes first, regardless of
where in the program the function main is placed. Other functions execute only when
they are called.
A function call transfers control to the first statement in the body of the function. In
general, after the last statement of the called function executes, control is passed back
to the point immediately following the function call. A value-returning function
returns a value. Therefore, after executing the value-returning function, when the
control goes back to the caller, the value that the function returns replaces the
function call statement. The execution continues at the point immediately following
the function call.
Suppose that a program contains functions funcA and funcB, and funcA contains
a statement that calls funcB. Suppose that the program calls funcA. When the statement
that contains a call to funcB executes, funcB executes, and while funcB is executing,
the execution of the current call of funcA is on hold until funcB is done.

PROGRAMMING EXAMPLE:

Largest Number

In this programming example, the function larger is used to determine the largest
number from a set of numbers. For the purpose of illustration, this program
determines the largest number from a set of 10 numbers. You can easily enhance
this program to accommodate any set of numbers.

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Input

A set of 10 numbers.

Output

The largest of 10 numbers.

Suppose that the input data is:
10 56 73 42 22 67 88 26 62 11

Read the first number of the data set. Because this is the only number read to
this point, you may assume that it is the largest number so far and call it max.
Read the second number and call it num. Now compare max and num and store
the larger number into max. Now max contains the larger of the first two
numbers. Read the third number. Compare it with max and store the larger
number into max. At this point, max contains the largest of the first three
numbers. Read the next number, compare it with max, and store the larger
into max. Repeat this process for each remaining number in the data set.
Eventually, max will contain the largest number in the data set. This discussion
translates into the following algorithm:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Largest Number

|

375

1. Read the first number. Because this is the only number that you
have read so far, it is the largest number so far. Save it in a variable
called max.
2. For each remaining number in the list:
a. Read the next number. Store it in a variable called num.
b. Compare num and max. If max < num, then num is the new
largest number, so update the value of max by copying num into
max. If max >= num, discard num; that is, do nothing.
3. Because max now contains the largest number, print it.
To find the larger of two numbers, the program uses the function larger.
COMPLETE PROGRAM LISTING
//********************************************************
// Author: D.S. Malik
//
// This program finds the largest number of a set of 10
// numbers.
//********************************************************
#include <iostream>
using namespace std;
double larger(double x, double y);
int main()
{
double num; //variable to hold the current number
double max; //variable to hold the larger number
int count; //loop control variable
cout << "Enter 10 numbers." << endl;
cin >> num;
max = num;
for (count = 1; count < 10; count++)
{
cin >> num;
max = larger(max, num);
}
cout << "The largest number is " << max
<< endl;

//Step 1
//Step 1
//Step 2
//Step 2a
//Step 2b

//Step 3

return 0;
} //end main

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

376 |

Chapter 6: User-Defined Functions

double larger(double x, double y)
{
if (x >= y)
return x;
else
return y;
}

Sample Run: In this sample run, the user input is shaded.
Enter 10 numbers.
10 56 73 42 22 67 88 26 62 11
The largest number is 88

Void Functions
Earlier in this chapter, you learned how to use value-returning functions. In this section,
you will explore user-defined functions in general and, in particular, those C++ functions
that do not have a data type, called void functions.
Void functions and value-returning functions have similar structures. Both have a heading
and a body. Like value-returning functions, you can place user-defined void functions either
before or after the function main. However, the program execution always begins with the
first statement in the function main. If you place a user-defined void function after the
function main, you should place the function prototype before the function main. A void
function does not have a data type. Therefore, functionType—that is, the return type—in
the heading part and the return statement in the body of the void functions are meaningless.
However, in a void function, you can use the return statement without any value; it is
typically used to exit the function early. Like value-returning functions, void functions may
or may not have formal parameters.
Because void functions do not have a data type, they are not used (called) in an expression.
A call to a void function is a stand-alone statement. Thus, to call a void function, you use
the function name together with the actual parameters (if any) in a stand-alone statement.
Before giving examples of void functions, next we give the syntax of a void function.
FUNCTION DEFINITION
The function definition of void functions with parameters has the following syntax:
void functionName(formal parameter list)
{
statements
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Void Functions |

377

in which statements are usually declaration and/or executable statements. The formal
parameter list may be empty, in which case, in the function heading, the empty parentheses
are still needed.
FORMAL PARAMETER LIST
The formal parameter list has the following syntax:
dataType& variable, dataType& variable, ...

You must specify both the data type and the variable name in the formal parameter list.
The symbol & after dataType has a special meaning; some parameters will have & and
some will not, and we will explain why later in this chapter.
FUNCTION CALL
The function call has the following syntax:
functionName(actual parameter list);

ACTUAL PARAMETER LIST
The actual parameter list has the following syntax:
expression or variable, expression or variable, ...

in which expression can consist of a single constant value. As with value-returning
functions, in a function call, the number of actual parameters together with their data
types must match the formal parameters in the order given. Actual and formal parameters have a one-to-one correspondence. (Functions with default parameters are
discussed at the end of this chapter.) A function call results in the execution of the
body of the called function.
Example 6-8 shows a void function with parameters.
EXAMPLE 6-8
void funexp(int a, double b, char c, int x)
{
.
.
.
}

The function funexp has four parameters.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

378 |

Chapter 6: User-Defined Functions

PARAMETER TYPES
Parameters provide a communication link between the calling function (such as main)
and the called function. They enable functions to manipulate different data each time
they are called. In general, there are two types of formal parameters: value parameters
and reference parameters.
Value parameter: A formal parameter that receives a copy of the content of the

corresponding actual parameter.
Reference parameter: A formal parameter that receives the location (memory address) of

the corresponding actual parameter.
When you attach & after the dataType in the formal parameter list of a function, the
variable following that dataType becomes a reference parameter.
Example 6-9 shows a void function with value and reference parameters.
EXAMPLE 6-9
Consider the following function definition:
void areaAndPerimeter(double length, double width,
double& area, double& perimeter)
{
area = length * width;
perimeter = 2 * (length + width);
}

The function areaAndPerimeter has four parameters: length and width are value
parameters of type double; and area and perimeter are reference parameters of
type double.
Figure 6-4 describes various parts of the function areaAndPerimeter.

Function name

Value parameters

Function
heading

void areaAndPerimeter(double length, double width,
double& area, double& perimeter)
{
area = length * width;
Function body
perimeter = 2 * (length + width); Reference parameters
}

FIGURE 6-4

Various parts of the function areaAndPerimeter

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Void Functions |

379

EXAMPLE 6-10
Consider the following definition:
void averageAndGrade(int testScore, int progScore,
double& average, char& grade)
{
average = (testScore + progScore) / 2.0;
if (average >= 90.00)
grade = 'A';
else if (grade >= 80.00)
grade = 'B';
else if (grade >= 70.00)
grade = 'C';
else if (grade >= 60.00)
grade = 'D';
else
grade = 'F';
}

The function averageAndGrade has four parameters: testScore and progScore are
value parameters of type int, average is a reference parameter of type double, and
grade is a reference parameter of type char. Using visual diagrams, Examples 6-13,
6-14, and 6-15 explicitly show how value and reference parameters work.

EXAMPLE 6-11
We write a program to print a pattern (a triangle of stars) similar to the following:
*
* *
* * *
* * * *

The first line has one star with some blanks before the star, the second line has
two stars, some blanks before the stars, and a blank between the stars, and so on.
Let’s write the function printStars that has two parameters, a parameter to
specify the number of blanks before the stars in a line and a second parameter to
specify the number of stars in a line. To be specific, the definition of the function
printStars is:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

380 |

Chapter 6: User-Defined Functions

void printStars(int blanks, int starsInLine)
{
int count;
//print the number of blanks before the stars in a line
for (count = 1; count <= blanks; count++)
cout << ' ';
//print the number of stars with a blanks between stars
for (count = 1; count <= starsInLine; count++)
cout << " *";
cout << endl;
} //end printStars

The first parameter, blanks, determines how many blanks to print preceding the star(s);
the second parameter, starsInLine, determines how many stars to print in a line. If
the value of the parameter blanks is 30, for instance, then the first for loop in the
function printStars executes 30 times and prints 30 blanks. Also, because you want to
print a space between the stars, every iteration of the second for loop in the function
printStars prints the string " *"—a blank followed by a star.
Next, consider the following statements:
int numberOfLines = 15;
int numberOfBlanks = 30;
for (counter = 1; counter <= numberOfLines; counter++)
{
printStars(numberOfBlanks, counter);
numberOfBlanks--;
}

The for loop calls the function printStars. Every iteration of this for loop specifies
the number of blanks followed by the number of stars to print in a line, using the
variables numberOfBlanks and counter. Every invocation of the function printStars
receives one fewer blank and one more star than the previous call. For example, the first
iteration of the for loop in the function main specifies 30 blanks and 1 star (which are
passed as the parameters numberOfBlanks and counter to the function printStars).
The for loop then decrements the number of blanks by 1 by executing the statement,
numberOfBlanks--;. At the end of the for loop, the number of stars is incremented by 1
for the next iteration. This is done by executing the update statement counter++ in the
for statement, which increments the value of the variable counter by 1. In other words,
the second call of the function printStars receives 29 blanks and 2 stars as parameters.
Thus, the previous statements will print a triangle of stars consisting of 15 lines.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Void Functions |

381

//Program: Print a triangle of stars
#include <iostream>
using namespace std;
void printStars(int blanks, int starsInLine);
int main()
{
int noOfLines; //variable to store the number of lines
int counter;
//for loop control variable
int noOfBlanks; //variable to store the number of blanks
cout << "Enter the number of star lines (1 to 20) "
<< "to be printed: ";
//Line 1
cin >> noOfLines;

//Line 2

while (noOfLines < 0 || noOfLines > 20)
{
cout << "Number of star lines should be "
<< "between 1 and 20" << endl;
cout << "Enter the number of star lines "
<< "(1 to 20) to be printed: ";
cin >> noOfLines;
}

//Line 3

cout << endl << endl;
noOfBlanks = 30;

//Line 7
//Line 8

for (counter = 1; counter <= noOfLines; counter++)
{
printStars(noOfBlanks, counter);
noOfBlanks--;
}

//Line 9

return 0;

//Line 12

//Line 4
//Line 5
//Line 6

//Line 10
//Line 11

}
void printStars(int blanks, int starsInLine)
{
int count;
for (count = 1; count <= blanks; count++)
cout << ' ';
for (count = 1; count <= starsInLine; count++)
cout << " *";
cout << endl;

//Line
//Line
//Line
//Line

13
14
15
16

}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

382 |

Chapter 6: User-Defined Functions

Sample Run: In this sample run, the user input is shaded.
Enter the number of star lines (1 to 20) to be printed: 15
*
* *
* * *
* * * *
* * * * *
* * * * * *
* * * * * * *
* * * * * * * *
* * * * * * * * *
* * * * * * * * * *
* * * * * * * * * * *
* * * * * * * * * * * *
* * * * * * * * * * * * *
* * * * * * * * * * * * * *
* * * * * * * * * * * * * * *

In the function main, the user is first asked to specify how many lines of stars to print
(Line 1). (In this program, the user is restricted to 20 lines because a triangular grid of up
to 20 lines fits nicely on the screen.) Because the program is restricted to only 20 lines, the
while loop at Lines 3 through 6 ensures that the program prints only the triangular grid
of stars if the number of lines is between 1 and 20.

Value Parameters
The previous section defined two types of parameters—value parameters and reference
parameters. Example 6-10 showed a program that uses a function with parameters.
Before considering more examples of void functions with parameters, let us make the
following observation about value and reference parameters. When a function is called,
the value of the actual parameter is copied into the corresponding formal parameter. If
the formal parameter is a value parameter, then after copying the value of the actual
parameter, there is no connection between the formal parameter and actual parameter;
that is, the formal parameter is a separate variable with its own copy of the data.
Therefore, during program execution, the formal parameter manipulates the data stored
in its own memory space. The program in Example 6-12 further illustrates how a value
parameter works.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value Parameters

|

383

EXAMPLE 6-12
The following program shows how a formal parameter of a simple data type works.
//Example 6-12
//Program illustrating how a value parameter works.
#include <iostream>
using namespace std;
void funcValueParam(int num);
int main()
{
int number = 6;

//Line 1

6

cout << "Line 2: Before calling the function "
<< "funcValueParam, number = " << number
<< endl;

//Line 2

funcValueParam(number);

//Line 3

cout << "Line 4: After calling the function "
<< "funcValueParam, number = " << number
<< endl;

//Line 4

return 0;
}
void funcValueParam(int num)
{
cout << "Line 5: In the function funcValueParam, "
<< "before changing, num = " << num
<< endl;
//Line 5
num = 15;

//Line 6

cout << "Line 7: In the function funcValueParam, "
<< "after changing, num = " << num
<< endl;
//Line 7
}

Sample Run:
Line
Line
Line
Line

2:
5:
7:
4:

Before calling the function funcValueParam, number = 6
In the function funcValueParam, before changing, num = 6
In the function funcValueParam, after changing, num = 15
After calling the function funcValueParam, number = 6

This program works as follows. The execution begins at the function main. The
statement in Line 1 declares and initializes the int variable number. The statement in
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

384 |

Chapter 6: User-Defined Functions

Line 2 outputs the value of number before calling the function funcValueParam; the
statement in Line 3 calls the function funcValueParam. The value of the variable
number is then passed to the formal parameter num. Control now transfers to the
function funcValueParam.
The statement in Line 5 outputs the value of num before changing its value. The
statement in Line 6 changes the value of num to 15; the statement in Line 7 outputs
the value of num. After this statement executes, the function funcValueParam exits and
control goes back to the function main.
The statement in Line 4 outputs the value of number after calling the function
funcValueParam. The sample run shows that the value of number (Lines 2 and 4)
remains the same even though the value of its corresponding formal parameter num was
changed within the function funcValueParam.
The output shows the sequence in which the statements execute.
After copying data, a value parameter has no connection with the actual parameter, so a
value parameter cannot pass any result back to the calling function. When the function
executes, any changes made to the formal parameters do not in any way affect the actual
parameters. The actual parameters have no knowledge of what is happening to the formal
parameters. Thus, value parameters cannot pass information outside of the function.
Value parameters provide only a one-way link from the actual parameters to the formal
parameters. Hence, functions with only value parameters have limitations.

Reference Variables as Parameters
The program in Example 6-12 illustrates how a value parameter works. On the other
hand, suppose that a formal parameter is a reference parameter. Because a reference
parameter receives the address (memory location) of the actual parameter, reference
parameters can pass one or more values from a function and can change the value of
the actual parameter.
Reference parameters are useful in three situations:
•
•

When the value of the actual parameter needs to be changed
When you want to return more than one value from a function (recall
that the return statement can return only one value)
• When passing the address would save memory space and time relative to
copying a large amount of data
The first two situations are illustrated throughout this book. Chapters 8 and 10 discuss the
third situation, when arrays and classes are introduced.
Recall that when you attach & after the dataType in the formal parameter list of a
function, the variable following that dataType becomes a reference parameter.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Reference Variables as Parameters

|

385

You can declare a reference (formal) parameter as a constant by using the keyword
const. This will prevent the formal parameter from being able to change the value of
the corresponding actual parameter. Chapters 9 and 10 discuss constant reference
parameters. Until then, the reference parameters that you use will be nonconstant as
defined in this chapter. From the definition of a reference parameter, it follows that a
constant value or an expression cannot be passed to a nonconstant reference parameter.
If a formal parameter is a nonconstant reference parameter, during a function call,
its corresponding actual parameter must be a variable.

EXAMPLE 6-13

Calculate Grade
The following program takes a course score (a value between 0 and 100) and determines
a student’s course grade. This program has three functions: main, getScore, and
printGrade, as follows:
1. main
a. Get the course score.
b. Print the course grade.
2. getScore
a. Prompt the user for the input.
b. Get the input.
c. Print the course score.
3. printGrade
a. Calculate the course grade.
b. Print the course grade.
The complete program is as follows:
//This program reads a course score and prints the
//associated course grade.
#include <iostream>
using namespace std;
void getScore(int& score);
void printGrade(int score);
int main()
{
int courseScore;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

386 |

Chapter 6: User-Defined Functions

cout << "Line 1: Based on the course score, \n"
<< "
this program computes the "
<< "course grade." << endl;

//Line 1

getScore(courseScore);

//Line 2

printGrade(courseScore);

//Line 3

return 0;
}
void getScore(int& score)
{
cout << "Line 4: Enter course score: ";
cin >> score;
cout << endl << "Line 6: Course score is "
<< score << endl;
}
void printGrade(int cScore)
{
cout << "Line 7: Your grade for the course is ";
if (cScore >= 90)
cout << "A." << endl;
else if (cScore >= 80)
cout << "B." << endl;
else if(cScore >= 70)
cout << "C." << endl;
else if (cScore >= 60)
cout << "D." << endl;
else
cout << "F." << endl;

//Line 4
//Line 5
//Line 6

//Line 7
//Line 8

}

Sample Run: In this sample run, the user input is shaded.
Line 1: Based on the course score,
this program computes the course grade.
Line 4: Enter course score: 85
Line 6: Course score is 85
Line 7: Your grade for the course is B.

This program works as follows. The program starts to execute at Line 1, which prints the
first line of the output (see the sample run). The statement in Line 2 calls the function
getScore with the actual parameter courseScore (a variable declared in main). Because
the formal parameter score of the function getScore is a reference parameter, the
address (that is, the memory location of the variable courseScore) passes to score.
Thus, both score and courseScore now refer to the same memory location, which is
courseScore (see Figure 6-5).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Reference Variables as Parameters

main

387

getScore

courseScore

FIGURE 6-5

|

score

Variable courseScore and the parameter score

Any changes made to score immediately change the value of courseScore.
Control is then transferred to the function getScore, and the statement in Line 4
executes, printing the second line of output. This statement prompts the user to enter
the course score. The statement in Line 5 reads and stores the value entered by
the user (85 in the sample run) in score, which is actually courseScore (because
score is a reference parameter). Thus, at this point, the value of both variables score
and courseScore is 85 (see Figure 6-6).

main
courseScore

FIGURE 6-6

getScore
score

85

Variable courseScore and the parameter score after the statement in Line 5

executes

Next, the statement in Line 6 outputs the value of score as shown by the third line of the
sample run. After Line 6 executes, control goes back to the function main (see Figure 6-7).

main
courseScore

85

Variable courseScore after the statement in Line 6 is executed and control goes
back to main

FIGURE 6-7

The statement in Line 3 executes next. It is a function call to the function printGrade
with the actual parameter courseScore. Because the formal parameter cScore of the
function printGrade is a value parameter, the parameter cScore receives the value of
the corresponding actual parameter courseScore. Thus, the value of cScore is 85.
After copying the value of courseScore into cScore, no communication exists
between cScore and courseScore (see Figure 6-8).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

388 |

Chapter 6: User-Defined Functions

main
courseScore

FIGURE 6-8

printGrade
85

85

cScore

Variable courseScore and the parameter cScore

The program then executes the statement in Line 7, which outputs the fourth line. The
if. . .else statement in Line 8 determines and outputs the grade for the course. Because
the output statement in Line 7 does not contain the newline character or the manipulator
endl, the output of the if. . .else statement is part of the fourth line of the output. After
the if. . .else statement executes, control goes back to the function main. Because the
next statement to execute in the function main is the last statement of the function main,
the program terminates.
In this program, the function main first calls the function getScore to obtain the
course score from the user. The function main then calls the function printGrade to
calculate and print the grade based on this course score. The course score is retrieved by
the function getScore; later, this course score is used by the function printGrade.
Because the value retrieved by the getScore function is used later in the program, the
function getScore must pass this value outside. Because getScore is written as a void
function, the formal parameter that holds this value must be a reference parameter.

Value and Reference Parameters and Memory
Allocation
When a function is called, memory for its formal parameters and variables declared in
the body of the function (called local variables) is allocated in the function data area.
Recall that in the case of a value parameter, the value of the actual parameter is copied
into the memory cell of its corresponding formal parameter. In the case of a reference
parameter, the address of the actual parameter passes to the formal parameter. That is,
the content of the formal parameter is an address. During data manipulation, the address
stored in the formal parameter directs the computer to manipulate the data of the
memory cell at that address. Thus, in the case of a reference parameter, both the actual
and formal parameters refer to the same memory location. Consequently, during
program execution, changes made by the formal parameter permanently change the
value of the actual parameter.
Stream variables (for example, ifstream and ofstream) should be passed by reference to a function. After opening the input/output file or after reading and/or outputting
data, the state of the input and/or output stream can then be passed outside the function.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value and Reference Parameters and Memory Allocation

|

389

Because parameter passing is fundamental to any programming language, Examples 6-14
and 6-15 further illustrate this concept. Each covers a different scenario.
EXAMPLE 6-14
The following program shows how reference and value parameters work.
//Example 6-14: Reference and value parameters
#include <iostream>
using namespace std;
void funOne(int a, int& b, char v);
void funTwo(int& x, int y, char& w);
int main()
{
int num1, num2;
char ch;

6

num1 = 10;
num2 = 15;
ch = 'A';

//Line 1
//Line 2
//Line 3

cout << "Line 4: Inside main: num1 = " << num1
<< ", num2 = " << num2 << ", and ch = "
<< ch << endl;

//Line 4

funOne(num1, num2, ch);

//Line 5

cout << "Line 6: After funOne: num1 = " << num1
<< ", num2 = " << num2 << ", and ch = "
<< ch << endl;
//Line 6
funTwo(num2, 25, ch);

//Line 7

cout << "Line 8: After funTwo: num1 = " << num1
<< ", num2 = " << num2 << ", and ch = "
<< ch << endl;
//Line 8
return 0;
}
void funOne(int a, int& b, char v)
{
int one;
one = a;
a++;
b = b * 2;
v = 'B';

//Line
//Line
//Line
//Line

9
10
11
12

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

390 |

Chapter 6: User-Defined Functions

cout << "Line 13: Inside funOne: a = " << a
<< ", b = " << b << ", v = " << v
<< ", and one = " << one << endl;

//Line 13

}
void funTwo(int& x, int y, char& w)
{
x++;
y = y * 2;
w = 'G';

//Line 14
//Line 15
//Line 16

cout << "Line 17: Inside funTwo: x = " << x
<< ", y = " << y << ", and w = " << w
<< endl;

//Line 17

}

Sample Run:
Line
Line
Line
Line
Line

4: Inside main: num1 = 10, num2 = 15, and ch = A
13: Inside funOne: a = 11, b = 30, v = B, and one = 10
6: After funOne: num1 = 10, num2 = 30, and ch = A
17: Inside funTwo: x = 31, y = 50, and w = G
8: After funTwo: num1 = 10, num2 = 31, and ch = G

Let us walk through this program. The values of the variables are shown before and/or
after each statement executes.
Just before the statement in Line 1 executes, memory is allocated only for the variables of
the function main; this memory is not initialized. After the statement in Line 3 executes,
the variables are as shown in Figure 6-9.
main
num1 10
num2 15
ch

FIGURE 6-9

A

Values of the variables after the statement in Line 3 executes

The statement in Line 4 produces the following output:
Line 4: Inside main: num1 = 10, num2 = 15, and ch = A

The statement in Line 5 is a function call to the function funOne. Now function funOne
has three parameters (a, b, and v) and one local variable (one). Memory for the
parameters and the local variable of function funOne is allocated. Because the formal
parameter b is a reference parameter, it receives the address (memory location) of the
corresponding actual parameter, which is num2. The other two formal parameters are
value parameters, so they copy the values of their corresponding actual parameters.
Just before the statement in Line 9 executes, the variables are as shown in Figure 6-10.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value and Reference Parameters and Memory Allocation

391

funOne

main
num1 10

10 a

num2 15

b

ch

|

A

A

v
one

FIGURE 6-10

Values of the variables just before the statement in Line 9 executes

The following shows how the variables are manipulated after each statement from
Line 9 to 12 executes.
St. in Line
9

Value of the Variables
main

Statement and Effect
funOne

num1 10

10 a

num2 15

b

ch

A

A

one = a;
Copy the value of a into one.

v

10 one
10

main

funOne

num1 10

11 a

num2 15

b

ch

A

A

a++;
Increment the value of a by 1.

v

10 one
11

main

funOne

num1 10

11 a

num2 30

b

ch

A

A

v

b = b * 2;
Multiply the value of b by 2
and store the result in b.
Because b is the reference
parameter and contains the address
of num, the value of num is
updated.

10 one
12

main

funOne

num1 10

11 a

num2 30

b

ch

A

B

v = 'B';
Store 'B' into v.

v

10 one
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

392 |

Chapter 6: User-Defined Functions

The statement in Line 13 produces the following output:
Line 13: Inside funOne: a = 11, b = 30, v = B, and one = 10

After the statement in Line 13 executes, control goes back to Line 6 in main and the
memory allocated for the variables of function funOne is deallocated. Figure 6-11 shows
the values of the variables of the function main.

main
num1 10
num2 30
ch

FIGURE 6-11

A

Values of the variables after the statement in Line 6

Line 6 produces the following output:
Line 6: After funOne: num1 = 10, num2 = 30, and ch = A

The statement in Line 7 is a function call to the function funTwo. Now funTwo has three
parameters: x, y, and w. Also, x and w are reference parameters, and y is a value parameter.
Thus, x receives the address of its corresponding actual parameter, which is num2, and w
receives the address of its corresponding actual parameter, which is ch. The variable y
copies the value 25 into its memory cell. Figure 6-12 shows the values before the
statement in Line 14 executes.

funTwo

main
num1 10

x

num2 30

25 y

ch

FIGURE 6-12

A

w

Values of the variables before the statement in Line 14 executes

The following shows how the variables are manipulated after each statement from
Line 14 to 16 executes.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value and Reference Parameters and Memory Allocation

St. in Line
14

Value of the Variables

15

16

funTwo

num1 10

x

num2 31

25 y
w

A

main

funTwo

num1 10

x

num2 31

50 y

ch

x++;
Increment the value of x
by 1. Because x is the reference
parameter and contains the
address of num2, the value
of num2 is incremented by 1.

y = y * 2;
Multiply the value of y by 2 and
store the result in y.

w

A

main

funTwo

num1 10

x

num2 31

50 y

ch

393

Statement and Effect

main

ch

|

w

G

w = 'G';
Store 'G' in w. Because w
is the reference parameter and
contains the address of ch,
the value of ch is updated.

Line 17 produces the following output:
Line 17: Inside funTwo: x = 31, y = 50, and w = G

After the statement in Line 17 executes, control goes to Line 8. The memory allocated
for the variables of function funTwo is deallocated. The values of the variables of the
function main are as shown in Figure 6-13.

main
num1 10
num2 31
ch

FIGURE 6-13

G

Values of the variables after the statement in Line 8

The statement in Line 8 produces the following output:
Line 8: After funTwo: num1 = 10, num2 = 31, and ch = G

After the statement in Line 8 executes, the program terminates.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

394 |

Chapter 6: User-Defined Functions

EXAMPLE 6-15
This example also shows how reference parameters manipulate actual parameters.
//Example 6-15: Reference and value parameters.
//Program: Makes you think.
#include <iostream>
using namespace std;
void addFirst(int& first, int& second);
void doubleFirst(int one, int two);
void squareFirst(int& ref, int val);
int main()
{
int num = 5;
cout << "Line 1: Inside main: num = " << num
<< endl;

//Line 1

addFirst(num, num);
cout << "Line 3: Inside main after addFirst:"
<< " num = " << num << endl;

//Line 2

doubleFirst(num, num);
cout << "Line 5: Inside main after "
<< "doubleFirst: num = " << num << endl;

//Line 4

squareFirst(num, num);
cout << "Line 7: Inside main after "
<< "squareFirst: num = " << num << endl;

//Line 3

//Line 5
//Line 6
//Line 7

return 0;
}
void addFirst(int& first, int& second)
{
cout << "Line 8: Inside addFirst: first = "
<< first << ", second = " << second << endl; //Line 8
first = first + 2;

//Line 9

cout << "Line 10: Inside addFirst: first = "
<< first << ", second = " << second << endl; //Line 10
second = second * 2;

//Line 11

cout << "Line 12: Inside addFirst: first = "
<< first << ", second = " << second << endl; //Line 12
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Value and Reference Parameters and Memory Allocation

void doubleFirst(int one, int two)
{
cout << "Line 13: Inside doubleFirst: one = "
<< one << ", two = " << two << endl;

|

395

//Line 13

one = one * 2;

//Line 14

cout << "Line 15: Inside doubleFirst: one = "
<< one << ", two = " << two << endl;

//Line 15

two = two + 2;

//Line 16

cout << "Line 17: Inside doubleFirst: one = "
<< one << ", two = " << two << endl;

//Line 17

}
void squareFirst(int& ref, int val)
{
cout << "Line 18: Inside squareFirst: ref = "
<< ref << ", val = " << val << endl;

//Line 18

ref = ref * ref;

//Line 19

cout << "Line 20: Inside squareFirst: ref = "
<< ref << ", val = " << val << endl;

//Line 20

val = val + 2;

//Line 21

cout << "Line 22: Inside squareFirst: ref = "
<< ref << ", val = " << val << endl;

//Line 22

}

Sample Run:
Line
Line
Line
Line
Line
Line
Line
Line
Line
Line
Line
Line
Line

1: Inside main: num = 5
8: Inside addFirst: first = 5, second = 5
10: Inside addFirst: first = 7, second = 7
12: Inside addFirst: first = 14, second = 14
3: Inside main after addFirst: num = 14
13: Inside doubleFirst: one = 14, two = 14
15: Inside doubleFirst: one = 28, two = 14
17: Inside doubleFirst: one = 28, two = 16
5: Inside main after doubleFirst: num = 14
18: Inside squareFirst: ref = 14, val = 14
20: Inside squareFirst: ref = 196, val = 14
22: Inside squareFirst: ref = 196, val = 16
7: Inside main after squareFirst: num = 196

Both parameters of the function addFirst are reference parameters, and both parameters
of the function doubleFirst are value parameters. The statement:
addFirst(num, num);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

396 |

Chapter 6: User-Defined Functions

in the function main (Line 2) passes the reference of num to both formal parameters first
and second of the function addFirst, because the corresponding actual parameters for
both formal parameters are the same. That is, the variables first and second refer to the
same memory location, which is num. Figure 6-14 illustrates this situation.

addFirst

main

first
num

FIGURE 6-14

5

second

Parameters of the function addFirst

Any changes that first makes to its value immediately change the value of second and
num. Similarly, any changes that second makes to its value immediately change first
and num, because all three variables refer to the same memory location. (Note that num
was initialized to 5.)
The formal parameters of the function doubleFirst are value parameters. So the
statement:
doubleFirst(num, num);

in the function main (Line 4) copies the value of num into one and two because the
corresponding actual parameters for both formal parameters are the same. Figure 6-15
illustrates this scenario.
doubleFirst

main

14 one
num

FIGURE 6-15

14

14 two

Parameters of the function doubleFirst

Because both one and two are value parameters, any changes that one makes to its value
do not affect the values of two and num. Similarly, any changes that two makes to its value
do not affect one and num. (Note that the value of num before the function doubleFirst
executes is 14.)
The formal parameter ref of the function squareFirst is a reference parameter, and
the formal parameter val is a value parameter. The variable ref receives the address of its
corresponding actual parameter, which is num, and the variable val copies the value of its
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Scope of an Identifier |

397

corresponding actual parameter, which is also num. Thus, both num and ref refer to the
same memory location, which is num. Figure 6-16 illustrates this situation.

squareFirst

main

ref
num

FIGURE 6-16

14

14 val

Parameters of the function squareFirst

Any changes that ref makes immediately change num. Any changes made by val do not
affect num. (Note that the value of num before the function squareFirst executes is 14.)
We recommend that you walk through the program in Example 6-15. The output shows
the order in which the statements execute.

Reference Parameters and Value-Returning
Functions
Earlier in this chapter, in the discussion of value-returning functions, you learned how to use
value parameters only. You can also use reference parameters in a value-returning function,
although this approach is not recommended. By definition, a value-returning function
returns a single value; this value is returned via the return statement. If a function needs
to return more than one value, as a rule of good programming style, you should change it to a
void function and use the appropriate reference parameters to return the values.

Scope of an Identifier
The previous sections presented several examples of programs with user-defined functions.
Identifiers are declared in a function heading, within a block, or outside a block. A question
naturally arises: Are you allowed to access any identifier anywhere in the program? The
answer is no. You must follow certain rules to access an identifier. The scope of an identifier
refers to where in the program an identifier is accessible (visible). Recall that an identifier is
the name of something in C++, such as a variable or function name.
This section examines the scope of an identifier. First, we define the following two terms:
Local identifier: Identifiers declared within a function (or block).

Local identifiers are not accessible outside of the function (block).
Global identifier: Identifiers declared outside of every function definition.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

398 |

Chapter 6: User-Defined Functions

Also, C++ does not allow the nesting of functions. That is, you cannot include the
definition of one function in the body of another function.
In general, the following rules apply when an identifier is accessed:
1. Global identifiers (such as variables) are accessible by a function or a block if:
a. The identifier is declared before the function definition (block),
b. The function name is different than the identifier,
c. All parameters of the function have names different than the name
of the identifier, and
d. All local identifiers (such as local variables) have names different
than the name of the identifier.
2. (Nested Block) An identifier declared within a block is accessible:
a.

Only within the block from the point at which it is declared until
the end of the block, and
b. By those blocks that are nested within that block if the nested block
does not have an identifier with the same name as that of the outside
block (the block that encloses the nested block).
3. The scope of a function name is similar to the scope of an identifier
declared outside any block. That is, the scope of a function name is the
same as the scope of a global variable.
Before considering an example to explain these scope rules, first note the scope of the
identifier declared in the for statement. C++ allows the programmer to declare a variable in
the initialization statement of the for statement. For example, the following for statement:
for (int count = 1; count < 10; count++)
cout << count << endl;

declares the variable count and initializes it to 1. The scope of the variable count is
limited to only the body of the for loop.
This scope rule for the variable declared in a for statement may not apply to Standard C++,
that is, non ANSI/ISO Standard C++. In Standard C++, the scope of the variable declared in
the initialize statement may extend from the point at which it is declared until the end
of the block that immediately surrounds the for statement. (To be absolutely sure, check
your compiler’s documentation.)

The following C++ program helps illustrate the scope rules:
#include <iostream>
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Scope of an Identifier |

399

const double RATE = 10.50;
int z;
double t;
void one(int x, char y);
void two(int a, int b, char x);
void three(int one, double y, int z);
int main()
{
int num, first;
double x, y, z;
char name, last;
.
.
.
return 0;
}
void one(int x, char y)
{
.
.
.
}
int w;
void two(int a, int b, char x)
{
int count;
.
.
.
}
void three(int one, double y, int z)
{
char ch;
int a;
.
.
.
//Block four
{
int x;
char a;
.
.
}//end Block four
.
.
.
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

400 |

Chapter 6: User-Defined Functions

Table 6-2 summarizes the scope (visibility) of the identifiers.
TABLE 6-2

Scope (Visibility) of the Identifiers

Identifier

Visibility
in one

Visibility
in two

Visibility
Visibility in in Block
three
four

Visibility
in main

RATE (before main)

Y

Y

Y

Y

Y

z (before main)

Y

Y

N

N

N

t (before main)

Y

Y

Y

Y

Y

main

Y

Y

Y

Y

Y

local variables of main

N

N

N

N

Y

one (function name)

Y

Y

N

N

Y

x (one’s formal parameter)

Y

N

N

N

N

y (one’s formal parameter)

Y

N

N

N

N

w (before function two)

N

Y

Y

Y

N

two (function name)

Y

Y

Y

Y

Y

a (two’s formal parameter)

N

Y

N

N

N

b (two’s formal parameter)

N

Y

N

N

N

x (two’s formal parameter)

N

Y

N

N

N

local variables of two

N

Y

N

N

N

three (function name)

Y

Y

Y

Y

Y

N

N

Y

Y

N

N

N

Y

Y

N

N

N

Y

Y

N

ch (three’s local variable)

N

N

Y

Y

N

a (three’s local variable)

N

N

Y

N

N

x (block four’s local
variable)

N

N

N

Y

N

a (block four’s local
variable)

N

N

N

Y

N

one (three’s formal
parameter)

y (three’s formal
parameter)

z (three’s formal
parameter)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Global Variables, Named Constants, and Side Effects |

401

Note that function three cannot call function one, because function three has a formal
parameter named one. Similarly, the block marked four in function three cannot use
the int variable a, which is declared in function three, because block four has an
identifier named a.
Before closing this section, let us note the following about global variables:
1. Chapter 2 stated that C++ does not automatically initialize variables.
However, some compilers initialize global variables to their default
values. For example, if a global variable is of type int, char, or double,
it is initialized to zero.
2. In C++, :: is called the scope resolution operator. By using the
scope resolution operator, a global variable declared before the definition
of a function (block) can be accessed by the function (or block) even if
the function (or block) has an identifier with the same name as the
variable. In the preceding program, by using the scope resolution
operator, the function main can refer to the global variable z as ::z.
Similarly, suppose that a global variable t is declared before the definition of the function—say, funExample. Then, funExample can access
the variable t using the scope resolution operator even if funExample
has an identifier t. Using the scope resolution operator, funExample
refers to the variable t as ::t. Also, in the preceding program, using the
scope resolution operator, function three can call function one.
3. C++ provides a way to access a global variable declared after the definition of a function. In this case, the function must not contain any
identifier with the same name as the global variable. In the preceding
program, the global variable w is declared after the definition of function
one. The function one does not contain any identifier named w; therefore, w can be accessed by function one only if you declare w as an
external variable inside one. To declare w as an external variable inside
function one, the function one must contain the following statement:
extern int w;

In C++, extern is a reserved word. The word extern in the
above statement announces that w is a global variable declared elsewhere.
Thus, when function one is called, no memory for w, as declared inside
one, is allocated. In C++, external declaration also has another use, but
it is not discussed in this book.

Global Variables, Named Constants,
and Side Effects
A C++ program can contain global variables and you might be tempted to make all of the
variables in a program global variables so that you do not have to worry about what a
function knows about which variable. Using global variables, however, has side effects. If
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

402 |

Chapter 6: User-Defined Functions

more than one function uses the same global variable and something goes wrong, it is
difficult to discover what went wrong and where. Problems caused by global variables in one
area of a program might be misunderstood as problems caused in another area.
For example, consider the following program:
//Global variable
#include <iostream>
using namespace std;
int t;
void funOne(int& a);
int main()
{
t = 15;

//Line 1

cout << "Line 2: In main: t = " << t << endl;

//Line 2

funOne(t);

//Line 3

cout << "Line 4: In main after funOne: "
<< " t = " << t << endl;

//Line 4

return 0;

//Line 5

}
void funOne(int& a)
{
cout << "Line 6: In funOne: a = " << a
<< " and t = " << t << endl;

//Line 6
//Line 7

a = a + 12;
cout << "Line 8: In funOne: a = " << a
<< " and t = " << t << endl;

//Line 8

t = t + 13;

//Line 9

cout << "Line 10: In funOne: a = " << a
<< " and t = " << t << endl;

//Line 10

}

Sample Run:
Line
Line
Line
Line
Line

2: In main: t = 15
6: In funOne: a = 15 and t = 15
8: In funOne: a = 27 and t = 27
10: In funOne: a = 40 and t = 40
4: In main after funOne: t = 40

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Global Variables, Named Constants, and Side Effects |

403

This program has a variable t that is declared before the definition of any function. Because
none of the functions has an identifier t, the variable t is accessible anywhere in the program.
Also, the program consists of a void function with a reference parameter.
In Line 3, the function main calls the function funOne, and the actual parameter passed
to funOne is t. So, a, the formal parameter of funOne, receives the address of t. Any
changes that a makes to its value immediately change t. Because t can be directly
accessed anywhere in the program, in Line 9, the function funOne changes the value of t
by using t itself. Thus, you can manipulate the value of t by using either a reference
parameter or t itself.
In the previous program, if the last value of t is incorrect, it would be difficult to
determine what went wrong and in which part of the program. We strongly recommend
that you do not use global variables; instead, use the appropriate parameters.
In the programs given in this book, we typically placed named constants before the function
main, outside of every function definition. That is, the named constants we used are global

named constants. Unlike global variables, global named constants have no side effects because
their values cannot be changed during program execution. Moreover, placing a named
constant in the beginning of the program can increase readability, even if it is used only in
one function. If you need to later modify the program and change the value of a named
constant, it will be easier to find if it is placed in the beginning of the program.
EXAMPLE 6-16 (FACTORING A SECOND DEGREE POLYNOMIAL)
In an algebra course, one learns how to factor a polynomial by using various
techniques. In this example, we write a program to factor a second degree
polynomial of the form x2 þ bx þ c, i.e., write x2 þ bx þ c ¼ ðx  uÞðx  vÞ. For
simplicity, we restrict this program to factor polynomials, where b, c, u, and v are integers.
For example, x2 þ 5x þ 6 ¼ ðx þ 2Þðx þ 3Þ, x2 þ 10x  24 ¼ ðx þ 12Þðx  2Þ, and
x2  25 ¼ ðx þ 5Þðx  5Þ.
It can be shown that the values of u and v are given by
pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
b þ b2  4c
u¼
2
pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
b  b2  4c
v¼
2
If b2  4c < 0, then u and v are complex numbers; if b2  4c > 0 and b2  4c is not the
square of an integer,
then ﬃu and v are p
not
integers.
Also, if b2  4c is the square of an
pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
ﬃ
2
2
integer and b þ b  4c and b  b  4c are not divisible by 2, then
u andﬃ v are
pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
2  4c and
not integers.
It
follows
that
for
u
and
v
to
be
integers,
b
þ
b
pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
b  b2  4c must be divisible by 2. The following function takes as a parameter,
the values of b and c, and returns the values of u and v as well as indicating whether the
polynomial is factorable.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

404 |

Chapter 6: User-Defined Functions

void factorization(int b, int c, int& u1, int& v1, bool& isFactorable)
{
double discriminant;
int temp;
isFactorable = true;
discriminant = b * b - 4 * c;
if (discriminant < 0)
isFactorable = false;
else
{
temp = static_cast<int>(sqrt(discriminant));
if (temp * temp != discriminant)
isFactorable = false;
else
{
if (((-b + temp) % 2 != 0) || ((-b - temp) % 2 != 0))
isFactorable = false;
else
{
u1 = (-b + temp) / 2;
v1 = (-b - temp) / 2;
}
}
}
}

The following program shows how to use the function factorization in a program.
//Program: Second degree polynomial factorization
#include <iostream>
#include <cmath>
using namespace std;
void factorization(int b, int c, int& u1, int& v1, bool& isFactorable);
int main()
{
int coeffOfX;
int constantTerm;
int u;
int v;
bool isPolynomialFactorable;
cout << "Enter the coefficient of x: ";
cin >> coeffOfX;
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Global Variables, Named Constants, and Side Effects |

405

cout << "Enter the constant term: ";
cin >> constantTerm;
cout << endl;
factorization(coeffOfX, constantTerm, u, v,
isPolynomialFactorable);
if (isPolynomialFactorable)
{
cout << "x^2";
if (coeffOfX > 0)
cout << " + " << coeffOfX << "x";
else if (coeffOfX < 0)
cout << " - " << abs(coeffOfX) << "x";
if (constantTerm > 0)
cout << " + " << constantTerm;
else if (constantTerm < 0)
cout << " - " << abs(constantTerm);
cout << " = (x";
if (u > 0)
cout << " - " << u << ")(x";
else if (u < 0)
cout << " + " << abs(u) << ")(x";
if (v > 0)
cout << " - " << v << ")" << endl;
else if (v < 0)
cout << " + " << abs(v) << ")" << endl;
}
else
cout << "The polynomial is not factorable." << endl;
return 0;
}
//Place the definition of the function factorization here.

Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1:
Enter the coefficient of x: 5
Enter the constant term: 6
x^2 + 5x + 6 = (x + 3)(x + 2)

Sample Run 2:
Enter the coefficient of x: 0
Enter the constant term: -25
x^2 - 25 = (x - 5)(x + 5)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

406 |

Chapter 6: User-Defined Functions

Sample Run 3:
Enter the coefficient of x: 8
Enter the constant term: 16
x^2 + 8x + 16 = (x + 4)(x + 4)

Sample Run 4:
Enter the coefficient of x: -13
Enter the constant term: 20
The polynomial is not factorable.

EXAMPLE 6-17 (MENU-DRIVEN PROGRAM)
The following is an example of a menu-driven program. When the program executes,
it gives the user a list of choices to choose from. This program further illustrates how
value and reference parameters work. It converts length from feet and inches to meters
and centimeters and vice versa. The program contains three functions: showChoices,
feetAndInchesToMetersAndCent, and metersAndCentToFeetAndInches. The function showChoices informs the user how to use the program. The user has the choice to
run the program as long as the user wishes.
//Menu-driven program.
#include <iostream>
using namespace std;
const double CONVERSION = 2.54;
const int INCHES_IN_FOOT = 12;
const int CENTIMETERS_IN_METER = 100;
void showChoices();
void feetAndInchesToMetersAndCent(int f, int in,
int& mt, int& ct);
void metersAndCentToFeetAndInches(int mt, int ct,
int& f, int& in);
int main()
{
int feet, inches;
int meters, centimeters;
int choice;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Global Variables, Named Constants, and Side Effects |

407

do
{
showChoices();
cin >> choice;
cout << endl;
switch (choice)
{
case 1:
cout << "Enter feet and inches: ";
cin >> feet >> inches;
cout << endl;
feetAndInchesToMetersAndCent(feet, inches,
meters, centimeters);
cout << feet << " feet(foot), "
<< inches << " inch(es) = "
<< meters << " meter(s), "
<< centimeters << " centimeter(s)." << endl;
break;
case 2:
cout << "Enter meters and centimeters: ";
cin >> meters >> centimeters;
cout << endl;
metersAndCentToFeetAndInches(meters, centimeters,
feet, inches);
cout << meters << " meter(s), "
<< centimeters << " centimeter(s) = "
<< feet << " feet(foot), "
<< inches << " inch(es)."
<< endl;
break;
case 99:
break;
default:
cout << "Invalid input." << endl;
}
}
while (choice != 99);
return 0;
}
void showChoices()
{
cout << "Enter--" << endl;
cout << "1: To convert from feet and inches to meters "
<< "and centimeters." << endl;
cout << "2: To convert from meters and centimeters to feet "
<< "and inches." << endl;
cout << "99: To quit the program." << endl;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

408 |

Chapter 6: User-Defined Functions

void feetAndInchesToMetersAndCent(int f, int in,
int& mt, int& ct)
{
int inches;
inches = f * INCHES_IN_FOOT + in;
ct = static_cast<int>(inches * CONVERSION);
mt = ct / CENTIMETERS_IN_METER;
ct = ct % CENTIMETERS_IN_METER;
}
void metersAndCentToFeetAndInches(int mt, int ct,
int& f, int& in)
{
int centimeters;
centimeters = mt * CENTIMETERS_IN_METER + ct;
in = static_cast<int>(centimeters / CONVERSION);
f = in / INCHES_IN_FOOT;
in = in % INCHES_IN_FOOT;
}

Sample Run: In this sample run, the user input is shaded.
Enter-1: To convert from feet and inches to meters and centimeters.
2: To convert from meters and centimeters to feet and inches.
99: To quit the program.
2
Enter meters and centimeters: 4 25
4 meter(s), 25 centimeter(s) = 13 feet(foot), 11 inch(es).
Enter-1: To convert from feet and inches to meters and centimeters.
2: To convert from meters and centimeters to feet and inches.
99: To quit the program.
1
Enter feet and inches: 15 8
15 feet(foot), 8 inch(es) = 4 meter(s), 77 centimeter(s).
Enter-1: To convert from feet and inches to meters and centimeters.
2: To convert from meters and centimeters to feet and inches.
99: To quit the program.
99

The do. . .while loop in the function main continues to execute as long as the user has
not entered 99, which allows the user to run the program as long as the user wishes. The
preceding output is self-explanatory.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Static and Automatic Variables |

409

Static and Automatic Variables
The variables discussed so far have followed two simple rules:
1. Memory for global variables remains allocated as long as the program executes.
2. Memory for a variable declared within a block is allocated at block entry
and deallocated at block exit. For example, memory for the formal
parameters and local variables of a function is allocated when the function is called and deallocated when the function exits.
A variable for which memory is allocated at block entry and deallocated at block exit is
called an automatic variable. A variable for which memory remains allocated as long as
the program executes is called a static variable. Global variables are static variables, and
by default, variables declared within a block are automatic variables. You can declare a
static variable within a block by using the reserved word static. The syntax for
declaring a static variable is:
static dataType identifier;

The statement:
static int x;

declares x to be a static variable of type int.
Static variables declared within a block are local to the block, and their scope is the same
as that of any other local identifier of that block.
Most compilers initialize static variables to their default values. For example, static int
variables are initialized to 0. However, it is a good practice to initialize static variables
yourself, especially if the initial value is not the default value. In this case, static variables
are initialized when they are declared. The statement:
static int x = 0;

declares x to be a static variable of type int and initializes x to 0, the first time the
function is called.
EXAMPLE 6-18
The following program shows how static and automatic variables behave.
//Program: Static and automatic variables
#include <iostream>
using namespace std;
void test();

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

410 |

Chapter 6: User-Defined Functions

int main()
{
int count;
for (count = 1; count <= 5; count++)
test();
return 0;
}
void test()
{
static int x = 0;
int y = 10;
x = x + 2;
y = y + 1;
cout << "Inside test x = " << x << " and y = "
<< y << endl;
}

Sample Run:
Inside
Inside
Inside
Inside
Inside

test
test
test
test
test

x
x
x
x
x

=
=
=
=
=

2 and y = 11
4 and y = 11
6 and y = 11
8 and y = 11
10 and y = 11

In the function test, x is a static variable initialized to 0, and y is an automatic
variable initialized to 10. The function main calls the function test five times. Memory
for the variable y is allocated every time the function test is called and deallocated when
the function exits. Thus, every time the function test is called, it prints the same value
for y. However, because x is a static variable, memory for x remains allocated as long as
the program executes. The variable x is initialized once to 0, the first time the function is
called. The subsequent calls of the function test use the value x had when the program
last left (executed) the function test.
Because memory for static variables remains allocated between function calls, static
variables allow you to use the value of a variable from one function call to another
function call. Even though you can use global variables if you want to use certain values
from one function call to another, the local scope of a static variable prevents other
functions from manipulating its value.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Debugging: Using Drivers and Stubs |

411

Debugging: Using Drivers and Stubs
In this and the previous chapters, you learned how to write functions to divide a problem
into subproblems, solve each subproblem, and then combine the functions to form the
complete program to get a solution of the problem. A program may contain a number of
functions. In a complex program, usually, when a function is written, it is tested and
debugged alone. You can write a separate program to test the function. The program that
tests a function is called a driver program. For example, the program in Example 6-15
contains functions to convert the length from feet and inches to meters and centimeters
and vice versa. Before writing the complete program, you could write separate driver
programs to make sure that each function is working properly.
Sometimes, the results calculated by one function are needed in another function. In that
case, the function that depends on another function cannot be tested alone. For example,
consider the following program that determines the time needed to fill a swimming pool.
#include <iostream>
#include <iomanip>
using namespace std;
const double GALLONS_IN_A_CUBIC_FOOT = 7.48;
double poolCapacity(double len, double wid, double dep);
void poolFillTime(double len, double wid, double dep,
double fRate, int& fTime);
void print(int fTime);
int main()
{
double length, width, depth;
double fillRate;
int fillTime;
cout << fixed << showpoint << setprecision(2);
cout << "Enter the length, width, and the depth of the "
<< "pool (in feet): ";
cin >> length >> width >> depth;
cout << endl;
cout << "Enter the rate of the water (in gallons per minute): ";
cin >> fillRate;
cout << endl;
poolFillTime(length, width, depth, fillRate, fillTime);
print(fillTime);
return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

412 |

Chapter 6: User-Defined Functions

double poolCapacity(double len, double wid, double dep)
{
double volume;
double poolWaterCapacity;
volume = len * wid * dep;
poolWaterCapacity = volume * GALLONS_IN_A_CUBIC_FOOT;
return poolWaterCapacity;
}
void poolFillTime(double len, double wid, double dep,
double fRate, int& fTime)
{
double poolWaterCapacity;
poolWaterCapacity = poolCapacity(len, wid, dep);
fTime = static_cast<int> (poolWaterCapacity / fRate + 0.5);
}
void print(int fTime)
{
cout << "The time to fill the pool is approximately: "
<< fTime / 60 << " hour(s) and " << fTime % 60
<< " minute(s)." << endl;
}

Sample Run: In this sample run, the user input is shaded.
Enter the length, width, and the depth of the pool (in feet): 30 15 10
Enter the rate of the water, (in gallons per minute): 100
The time to fill the pool is approximately: 5 hour(s) and 37 minute(s).

As you can see, the program contains the function poolCapacity to find the amount of
water needed to fill the pool, the function poolFillTime to find the time to fill the pool,
and some other functions. Now, to calculate the time to fill the pool, you must know the
amount of the water needed and the rate at which the water is released in the pool. Because
the results of the function poolCapacity are needed in the function poolFillTime, the
function poolFillTime cannot be tested alone. Does this mean that we must write the
functions in a specific order? Not necessarily, especially when different people are working
on different parts of the program. In situations such as these, we use function stubs.
A function stub is a function that is not fully coded. For a void function, a function stub
might consist of only a function header and a set of empty braces, {}, and for a valuereturning function it might contain only a return statement with a plausible and easy to use
return value. For example, the function stub for the function poolCapacity can be:
double poolCapacity(double len, double wid, double dep)
{
return 1000.00;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Function Overloading: An Introduction

|

413

This allows the function poolCapacity to be called while the program is being coded.
Ultimately, the stub for function poolCapacity is replaced with a function that properly
calculates the amount of water needed to fill the pool based on the values of the
parameters. In the meantime, the function stub allows work to continue on other parts
of the program that call the function poolCapacity.
Because a stub looks a lot like a viable function, it must be properly documented in a way
that would remind you to replace it with the actual definition. If you forget to replace a
stub with the actual definition, the program will generate erroneous results, which
sometimes might be embarrassing.
Before we look at some programming examples, another concept about functions is
worth mentioning: function overloading.

Function Overloading: An Introduction
In a C++ program, several functions can have the same name. This is called function
overloading, or overloading a function name. Before we state the rules to overloading a function, let us define the following:
Two functions are said to have different formal parameter lists if both functions have:
•
•

A different number of formal parameters or
The same number of formal parameters and the data types of the formal
parameters, in the order listed, differ in at least one position.

For example, consider the following function headings:
void functionOne(int x)
void functionTwo(int x, double y)
void functionThree(double y, int x)
int functionFour(char ch, int x, double y)
int functionFive(char ch, int x, string name)

These functions all have different formal parameter lists.
Now consider the following function headings:
void functionSix(int x, double y, char ch)
void functionSeven(int one, double u, char firstCh)

The functions functionSix and functionSeven both have three formal parameters,
and the data type of the corresponding parameters is the same. Therefore, these functions
have the same formal parameter list. Note that it is the data types and not the parameter
names or the return type that are examined.
To overload a function name, any two definitions of the function must have different
formal parameter lists.
Function overloading: Creating several functions with the same name.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

414 |

Chapter 6: User-Defined Functions

The signature of a function consists of the function name and its formal parameter list. Two
functions have different signatures if they have either different names or different formal parameter lists. (Note that the signature of a function does not include the return type of the function.)
If a function’s name is overloaded, then all of the functions in the set have the same name.
Therefore, all the functions in the overloaded set must have different formal parameter lists.
Thus, the following function headings correctly overload the function functionXYZ:
void
void
void
void

functionXYZ()
functionXYZ(int x, double y)
functionXYZ(double one, int y)
functionXYZ(int x, double y, char ch)

Consider the following function headings to overload the function functionABC:
void functionABC(int x, double y)
int functionABC(int x, double y)

Both of these function headings have the same name and same formal parameter list.
Therefore, these function headings to overload the function functionABC are incorrect.
In this case, the compiler will generate a syntax error. (Notice that the return types of
these function headings are different.)
If a function is overloaded, then in a call to that function the formal parameter list of the
function determines which function to execute.
Some authors define the signature of a function as the formal parameter list, and some
consider the entire heading of the function as its signature. However, in this book, the
signature of a function consists of the function’s heading and its formal parameter list. If
the function’s names are different, then, of course, the compiler would have no problem
in identifying which function is called, and it will correctly translate the code. However, if
a function’s name is overloaded, then, as noted, the function’s formal parameter list
determines which function’s body executes.

Suppose you need to write a function that determines the larger of two items. Both items
can be integers, floating-point numbers, characters, or strings. You could write several
functions as follows:
int largerInt(int x, int y);
char largerChar(char first, char second);
double largerDouble(double u, double v);
string largerString(string first, string second);

The function largerInt determines the larger of two integers; the function largerChar
determines the larger of two characters, and so on. All of these functions perform similar
operations. Instead of giving different names to these functions, you can use the same
name—say, larger—for each function; that is, you can overload the function larger.
Thus, you can write the previous function prototypes simply as:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Functions with Default Parameters

|

415

int larger(int x, int y);
char larger(char first, char second);
double larger(double u, double v);
string larger(string first, string second);

If the call is larger(5, 3), for example, the version having int parameters is executed. If
the call is larger('A', '9'), the version having char parameters is executed, and so on.
Function overloading is used when you have the same action for different sets of data.
Of course, for function overloading to work, you must give a separate definition for
each function.

Functions with Default Parameters
This section is not needed until Chapter 10.

6
This section discusses functions with default parameters. Recall that when a function is
called, the number of actual and formal parameters must be the same. C++ relaxes this
condition for functions with default parameters. You specify the value of a default
parameter when the function name appears for the first time, usually in the prototype.
In general, the following rules apply for functions with default parameters:
•
•
•

•
•
•

If you do not specify the value of a default parameter, the default value is
used for that parameter.
All of the default parameters must be the far-right parameters of the function.
Suppose a function has more than one default parameter. In a function
call, if a value to a default parameter is not specified, then you must omit
all of the arguments to its right.
Default values can be constants, global variables, or function calls.
The caller has the option of specifying a value other than the default for
any default parameter.
You cannot assign a constant value as a default value to a reference parameter.

Consider the following function prototype:
void funcExp(int t, int u, double v, char w = 'A', int x = 67,
char y = 'G', double z = 78.34);

The function funcExp has seven parameters. The parameters w, x, y, and z are default
parameters. If no values are specified for w, x, y, and z in a call to the function funcExp,
their default values are used.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

416 |

Chapter 6: User-Defined Functions

Suppose you have the following statements:
int a, b;
char ch;
double d;

The following function calls are legal:
1. funcExp(a, b, d);
2. funcExp(a, 15, 34.6, 'B', 87, ch);
3. funcExp(b, a, 14.56, 'D');
In statement 1, the default values of w, x, y, and z are used. In statement 2, the
default value of w is replaced by 'B', the default value of x is replaced by 87, the
default value of y is replaced by the value of ch, and the default value of z is used. In
statement 3, the default value of w is replaced by 'D', and the default values of x, y,
and z are used.
The following function calls are illegal:
1. funcExp(a, 15, 34.6, 46.7);
2. funcExp(b, 25, 48.76, 'D', 4567, 78.34);
In statement 1, because the value of w is omitted, all other default values must be omitted.
In statement 2, because the value of y is omitted, the value of z should be omitted, too.
The following are illegal function prototypes with default parameters:
1. void funcOne(int x, double z = 23.45, char ch, int u = 45);
2. int funcTwo(int length = 1, int width, int height = 1);
3. void funcThree(int x, int& y = 16, double z = 34);
In statement 1, because the second parameter z is a default parameter, all other parameters
after z must also be default parameters. In statement 2, because the first parameter is a
default parameter, all parameters must be default parameters. In statement 3, a constant
value cannot be assigned to y because y is a reference parameter.
Example 6-19 further illustrates functions with default parameters.
EXAMPLE 6-19
#include <iostream>
#include <iomanip>
using namespace std;
int volume(int l = 1, int w = 1, int h = 1);
void funcOne(int& x, double y = 12.34, char z = 'B');

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Functions with Default Parameters

|

417

int main()
{
int a = 23;
double b = 48.78;
char ch = 'M';
cout << fixed << showpoint;
cout << setprecision(2);
cout <<
<<
cout <<
<<
cout <<
<<
cout <<
<<
cout <<
<<

"Line 1: a = " << a << ", b = "
b << ", ch = " << ch << endl;
"Line 2: Volume = " << volume()
endl;
"Line 3: Volume = " << volume(5, 4)
endl;
"Line 4: Volume = " << volume(34)
endl;
"Line 5: Volume = "
volume(6, 4, 5) << endl;

//Line 1
//Line 2
//Line 3
//Line 4
//Line 5

funcOne(a);
funcOne(a, 42.68);
funcOne(a, 34.65, 'Q');

//Line 6
//Line 7
//Line 8

cout << "Line 9: a = " << a << ", b = "
<< b << ", ch = " << ch << endl;

//Line 9

return 0;
}
int volume(int l, int w, int h)
{
return l * w * h;
}
void funcOne(int& x, double y, char z)
{
x = 2 * x;
cout << "Line 12: x = " << x << ", y = "
<< y << ", z = " << z << endl;
}

//Line 10

//Line 11
//Line 12

Sample Run:
Line
Line
Line
Line
Line
Line
Line
Line
Line

1: a = 23, b = 48.78, ch = M
2: Volume = 1
3: Volume = 20
4: Volume = 34
5: Volume = 120
12: x = 46, y = 12.34, z = B
12: x = 92, y = 42.68, z = B
12: x = 184, y = 34.65, z = Q
9: a = 184, b = 48.78, ch = M

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

418 |

Chapter 6: User-Defined Functions

In programs in this book, and as is recommended, the definition of the function main is
placed before the definition of any user-defined functions. You must, therefore, specify the
default value for a parameter in the function prototype and in the function prototype only, not
in the function definition because this must occur at the first appearance of the function name.

PROGRAMMING EXAMPLE:

Classify Numbers

In this example, we use functions to rewrite the program that determines the number of
odds and evens from a given list of integers. This program was first written in Chapter 5.
The main algorithm remains the same:
1. Initialize the variables, zeros, odds, and evens to 0.
2. Read a number.
3. If the number is even, increment the even count, and if the number is also
zero, increment the zero count; otherwise, increment the odd count.
4. Repeat Steps 2 and 3 for each number in the list.
The main parts of the program are: initialize the variables, read and classify the
numbers, and then output the results. To simplify the function main and further
illustrate parameter passing, the program includes:
•

A function initialize to initialize the variables, such as zeros,
odds, and evens.
• A function getNumber to get the number.
• A function classifyNumber to determine whether the number is
odd or even (and whether it is also zero). This function also increments the appropriate count.
• A function printResults to print the results.
Let us now describe each of these functions.
initialize

The function initialize initializes variables to their initial values. The variables that
we need to initialize are zeros, odds, and evens. As before, their initial values are
all zero. Clearly, this function has three parameters. Because the values of the formal
parameters initializing these variables must be passed outside of the function, these
formal parameters must be reference parameters. Essentially, this function is:
void initialize(int& zeroCount, int& oddCount, int& evenCount)
{
zeroCount = 0;
oddCount = 0;
evenCount = 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Classify Numbers

getNumber

|

419

The function getNumber reads a number and then passes this number to the function
main. Because you need to pass only one number, this function has only one
parameter. The formal parameter of this (void) function must be a reference parameter
because the number read is passed outside of the function. Essentially, this function is:
void getNumber(int& num)
{
cin >> num;
}

You can also write the function getNumber as a value-returning function. See the
note at the end of this programming example.
classifyNumber

The function classifyNumber determines whether the number is odd or even, and
if the number is even, it also checks whether the number is zero. It also updates the
values of some of the variables, zeros, odds, and evens. This function needs to
know the number to be analyzed; therefore, the number must be passed as a
parameter. Because this function also increments the appropriate count, the variables
(that is, zeros, odds, and evens declared in main) holding the counts must be
passed as parameters to this function. Thus, this function has four parameters.
Because the number will only be analyzed and not altered, you need to pass only its
value. Thus, the formal parameter corresponding to this variable is a value parameter.
After analyzing the number, this function increments the values of some of the variables,
zeros, odds, and evens. Therefore, the formal parameters corresponding to these
variables must be reference parameters. The algorithm to analyze the number and
increment the appropriate count is the same as before. The definition of this function is:
void classifyNumber(int num, int& zeroCount, int& oddCount,
int& evenCount)
{
switch (num % 2)
{
case 0:
evenCount++;
if (num == 0)
zeroCount++;
break;
case 1:
case -1:
oddCount++;
} //end switch
} //end classifyNumber

printResults

The function printResults prints the final results. To print the results (that is, the
number of zeros, odds, and evens), this function must have access to the values of the
variables, zeros, odds, and evens declared in the function main. Therefore,
this function has three parameters. Because this function doesn’t change the values of

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

420 |

Chapter 6: User-Defined Functions

the variables but only prints them, the formal parameters are value parameters. The
definition of this function is:
void printResults(int zeroCount, int oddCount, int evenCount)
{
cout << "There are " << evenCount << " evens, "
<< "which includes " << zeroCount << " zeros"
<< endl;
cout << "The number of odd numbers is: " << oddCount
<< endl;
} //end printResults

We now give the main algorithm and show how the function main calls these
functions.
MAIN
ALGORITHM

1. Call the function initialize to initialize the variables.
2. Prompt the user to enter 20 numbers.
3. For each number in the list:
a. Call the function getNumber to read a number.
b. Output the number.
c. Call the function classifyNumber to classify the number and
increment the appropriate count.
4. Call the function printResults to print the final results.
COMPLETE PROGRAM LISTING
//*************************************************************
// Author: D.S. Malik
//
// Program: Classify Numbers
// This program reads 20 numbers and outputs the number of
// zeros, odd, and even numbers.
//*************************************************************
#include <iostream>
#include <iomanip>
using namespace std;
const int N = 20;
//Function prototypes
void initialize(int& zeroCount, int& oddCount, int& evenCount);
void getNumber(int& num);
void classifyNumber(int num, int& zeroCount, int& oddCount,
int& evenCount);
void printResults(int zeroCount, int oddCount, int evenCount);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Classify Numbers

int main()
{
//Variable declaration
int counter; //loop control variable
int number; //variable to store the
int zeros;
//variable to store the
int odds;
//variable to store the
int evens;
//variable to store the

421

new number
number of zeros
number of odd integers
number of even integers

initialize(zeros, odds, evens);
cout <<
<<
cout <<
<<

|

"Please enter " << N << " integers."
endl;
"The numbers you entered are: "
endl;

for (counter = 1; counter <= N; counter++)
{
getNumber(number);
cout << number << " ";
classifyNumber(number, zeros, odds, evens);
} // end for loop

//Step 1
//Step 2

//Step 3
//Step 3a
//Step 3b
//Step 3c

cout << endl;
printResults(zeros, odds, evens);

//Step 4

return 0;
}
void initialize(int& zeroCount, int& oddCount, int& evenCount)
{
zeroCount = 0;
oddCount = 0;
evenCount = 0;
}
void getNumber(int& num)
{
cin >> num;
}
void classifyNumber(int num, int& zeroCount, int& oddCount,
int& evenCount)
{
switch (num % 2)
{
case 0:
evenCount++;
if (num == 0)
zeroCount++;
break;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

422 |

Chapter 6: User-Defined Functions

case 1:
case -1:
oddCount++;
} //end switch
} //end classifyNumber
void printResults(int zeroCount, int oddCount, int evenCount)
{
cout << "There are " << evenCount << " evens, "
<< "which includes " << zeroCount << " zeros"
<< endl;
cout << "The number of odd numbers is: " << oddCount
<< endl;
} //end printResults

Sample Run: In this sample run, the user input is shaded.
Please enter 20 integers.
The numbers you entered are:
0 0 12 23 45 7 -2 -8 -3 -9 4 0 1 0 -7 23 -24 0 0 12
0 0 12 23 45 7 -2 -8 -3 -9 4 0 1 0 -7 23 -24 0 0 12
There are 12 evens, which includes 6 zeros
The number of odd numbers is: 8

In the previous program, because the data is assumed to be input from the standard
input device (the keyboard) and the function getNumber returns only one value, you
can also write the function getNumber as a value-returning function. If written as a
value-returning function, the definition of the function getNumber is:

int getNumber()
{
int num;
cin >> num;
return num;
}

In this case, the statement (function call):
getNumber(number);

in the function main should be replaced by the statement:
number = getNumber();

Of course, you also need to change the function prototype.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Data Comparison

PROGRAMMING EXAMPLE:

|

423

Data Comparison

This programming example illustrates:

Watch
the Video

•
•
•
•
•

How to read data from more than one file in the same program.
How to send output to a file.
How to generate bar graphs.
With the help of functions and parameter passing, how to use the
same program segment on different (but similar) sets of data.
How to use structured design to solve a problem and how to perform
parameter passing.

This program is broken into two parts. First, you learn how to read data from more
than one file. Second, you learn how to generate bar graphs.
Two groups of students at a local university are enrolled in certain special courses
during the summer semester. The courses are offered for the first time and are taught
by different teachers. At the end of the semester, both groups are given the same tests
for the same courses, and their scores are recorded in separate files. The data in each
file is in the following form:
courseNo
courseNo
.
.
.

score1, score2, ..., scoreN –999
score1, score2, ..., scoreM –999

Let us write a program that finds the average course score for each course for each
group. The output is of the following form:
Course No
CSC

ENG

Group No
1
2

Course Average
83.71
80.82

1
2

82.00
78.20

.
.
.
Avg for group 1: 82.04
Avg for group 2: 82.01
Input

Because the data for the two groups are recorded in separate files, the input
data appears in two separate files.

Output

As shown above.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

424 |

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Chapter 6: User-Defined Functions

Reading input data from both files is straightforward. Suppose the data is stored in the file
group1.txt for group 1 and file group2.txt for group 2. After processing the data for
one group, we can process the data for the second group for the same course and continue
until we run out of data. Processing data for each course is similar and is a two-step process:
1. a. Sum the scores for the course.
b. Count the number of students in the course.
c. Divide the total score by the number of students to find the
course average.
2. Output the results.
We are comparing only the averages of the corresponding courses in each group, and
the data in each file is ordered according to course ID. To ensure that only the
averages of the corresponding courses are compared, we compare the course IDs for
each group. If the corresponding course IDs are not the same, we output an error
message and terminate the program.
This discussion suggests that we should write a function, calculateAverage, to find the
course average. We should also write another function, printResult, to output the data
in the form given. By passing the appropriate parameters, we can use the same functions,
calculateAverage and printResult, to process each course’s data for both groups.
(In the second part of the program, we modify the function printResult.)
The preceding discussion translates into the following algorithm:
1.
2.
3.
4.
5.
6.
7.

Variables
(Function
main)

Initialize the variables.
Get the course IDs for group 1 and group 2.
If the course IDs are different, print an error message and exit the program.
Calculate the course averages for group 1 and group 2.
Print the results in the form given above.
Repeat Steps 2 through 5 for each course.
Print the final results.

The preceding discussion suggests that the program needs the following variables for
data manipulation in the function main:
string courseId1;
string courseId2;
int numberOfCourses;
double avg1;
double avg2;
double avgGroup1;
double avgGroup2;
ifstream group1;
ifstream group2;

//course ID for group 1
//course ID for group 2

ofstream outfile;

//output stream variable

//average for a course in group 1
//average for a course in group 2
//average group 1
//average group 2
//input stream variable for group 1
//input stream variable for group 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Data Comparison

|

425

Next, we discuss the functions calculateAverage and printResult. Then, we
will put the function main together.
calculate
Average

This function calculates the average for a course. Because the input is stored in a file and
the input file is opened in the function main, we must pass the ifstream variable
associated with the input file to this function. Furthermore, after calculating the course
average, this function must pass the course average to the function main. Therefore,
this function has two parameters, and both parameters must be reference parameters.
To find the course average, we must first find the sum of all scores for the course and the
number of students who took the course and then divide the sum by the number of
students. Thus, we need a variable to find the sum of the scores, a variable to count the
number of students, and a variable to read and store a score. Of course, we must initialize
the variable to find the sum and the variable to count the number of students to zero.

Local
Variables
(Function
calculate
Average)

In the previous discussion of data manipulation, we identified three variables for the
function calculateAverage:
double totalScore = 0.0;
int numberOfStudents = 0;
int score;

The above discussion translates into the following algorithm for the function
calculateAverage:

1. Declare and initialize variables.
2. Get the (next) course score, score.
3. while the score is not -999
a. Update totalScore by adding the course score.
b. Increment numberOfStudents by 1.
c. Get the (next) course score, score.
4. courseAvg = totalScore / numberOfStudents;
We are now ready to write the definition of the function calculateAverage.
void calculateAverage(ifstream& inp, double& courseAvg)
{
double totalScore = 0.0;
int numberOfStudents = 0;
int score;
inp >> score;
while (score != -999)
{
totalScore = totalScore + score;
numberOfStudents++;
inp >> score;
} //end while

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

426 |

Chapter 6: User-Defined Functions

courseAvg = totalScore / numberOfStudents;
} //end calculate Average
printResult

The function printResult prints the group’s course ID, group number, and course
average. The output is stored in a file. So we must pass four parameters to this function:
the ofstream variable associated with the output file, the group number, the course
ID, and the course average for the group. The ofstream variable must be passed by
reference. Because the function uses only the values of the other variables, the
remaining three parameters should be value parameters. Also, from the output, it is
clear that we print the course ID only before the group number.
In pseudocode, the algorithm is:
if (group number == 1)
print course ID
else
print a blank
print group number and course average

The definition of the function printResult follows:
void printResult(ofstream& outp, string courseID, int groupNo,
double avg)
{
if (groupNo == 1)
outp << " " << courseID << "
";
else
outp << "
";
outp << setw(8) << groupNo << setw(17) << avg << endl;
} //end printResult

Now that we have designed and defined the functions calculateAverage and
printResult, we can describe the algorithm for the function main. Before
outlining the algorithm, however, we note the following: It is quite possible that
in both input files, the data is ordered according to the course IDs, but one file
might have one or more additional courses that are not in the other file. We do
not discover this error until after we have processed both files and discovered that
one file has unprocessed data. Make sure to check for this error before printing the
final answer—that is, the averages for group 1 and group 2.
MAIN
ALGORITHM:
Function main

1. Declare the variables (local declaration).
2. Open the input files.
3. Print a message if you are unable to open a file and terminate the
program.
4. Open the output file.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Data Comparison

|

427

5. To output floating-point numbers in a fixed decimal format
with the decimal point and trailing zeros, set the manipulators
fixed and showpoint. Also, to output floating-point numbers to
two decimal places, set the precision to two decimal places.
6. Initialize the course average for group 1 to 0.0.
7. Initialize the course average for group 2 to 0.0.
8. Initialize the number of courses to 0.
9. Print the heading.
10. Get the course ID, courseId1, for group 1.
11. Get the course ID, courseId2, for group 2.
12. For each course in group 1 and group 2,
a. if (courseId1 != courseId2)
{
cout << "Data error: Course IDs do not match.\n";
return 1;
}

b. else
{

i. Calculate the course average for group 1 (call the function
calculateAverage and pass the appropriate parameters).
ii. Calculate the course average for group 2 (call the function
calculateAverage and pass the appropriate parameters).
iii. Print the results for group 1 (call the function
printResult and pass the appropriate parameters).
iv. Print the results for group 2 (call the function
printResult and pass the appropriate parameters).
v. Update the average for group 1.
vi. Update the average for group 2.
vii. Increment the number of courses.
}

c. Get the course ID, courseId1, for group 1.
d. Get the course ID, courseId2, for group 2.
13.

a. if not_end_of_file on group 1 and end_of_file on group 2
print ‘‘Ran out of data for group 2 before group 1’’
b. else if end_of_file on group 1 and not_end_of_file on group 2
print ‘‘Ran out of data for group 1 before group 2’’
c. else print the average of group 1 and group 2.

14.

Close the input and output files.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

428 |

Chapter 6: User-Defined Functions

COMPLETE PROGRAM LISTING
//**********************************************************
// Author: D.S. Malik
//
// Program: Comparison of Class Averages
// This program computes and compares the class averages of
// two groups of students.
//**********************************************************
#include <iostream>
#include <iomanip>
#include <fstream>
#include <string>
using namespace std;
//Function prototypes
void calculateAverage(ifstream& inp, double& courseAvg);
void printResult(ofstream& outp, string courseId,
int groupNo, double avg);
int main()
{
//Step 1
string courseId1;
string courseId2;
int numberOfCourses;
double avg1;
double avg2;
double avgGroup1;
double avgGroup2;
ifstream group1;
ifstream group2;
ofstream outfile;

//course ID for group 1
//course ID for group 2
//average for a course in group 1
//average for a course in group 2
//average group 1
//average group 2
//input stream variable for group 1
//input stream variable for group 2
//output stream variable

group1.open("group1.txt");
group2.open("group2.txt");

//Step 2
//Step 2

if (!group1 || !group2)
//Step 3
{
cout << "Unable to open files." << endl;
cout << "Program terminates." << endl;
return 1;
}
outfile.open("student.out");
outfile << fixed << showpoint;
outfile << setprecision(2);

//Step 4
//Step 5
//Step 5

avgGroup1 = 0.0;
avgGroup2 = 0.0;

//Step 6
//Step 7

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Data Comparison

429

//Step 8

numberOfCourses = 0;
outfile << "Course No
Group No
<< "Course Average" << endl;

|

"
//Step 9

group1 >> courseId1;
//Step
group2 >> courseId2;
//Step
while (group1 && group2)
//Step
{
if (courseId1 != courseId2)
//Step
{
cout << "Data error: Course IDs "
<< "do not match." << endl;
cout << "Program terminates." << endl;
return 1;
}
else
//Step
{
calculateAverage(group1, avg1);
//Step
calculateAverage(group2, avg2);
//Step
printResult(outfile, courseId1,
1, avg1);
//Step
printResult(outfile, courseId2,
2, avg2);
//Step
avgGroup1 = avgGroup1 + avg1;
//Step
avgGroup2 = avgGroup2 + avg2;
//Step
outfile << endl;
numberOfCourses++;
//Step
}

10
11
12
12a

12b
12b.i
12b.ii
12b.iii
12b.iv
12b.v
12b.vi
12b.vii

group1 >> courseId1;
group2 >> courseId2;
} //end while

//Step 12c
//Step 12d

if (group1 && !group2)
cout << "Ran out of data for group 2 "
<< "before group 1." << endl;
else if (!group1 && group2)
cout << "Ran out of data for group 1 "
<< "before group 2." << endl;
else
{
outfile << "Avg for group 1: "
<< avgGroup1 / numberOfCourses
<< endl;
outfile << "Avg for group 2: "
<< avgGroup2 / numberOfCourses
<< endl;
}

//Step 13a
//Step 13b
//Step 13c

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

430 |

Chapter 6: User-Defined Functions

//Step 14
//Step 14
//Step 14

group1.close();
group2.close();
outfile.close();
return 0;
}

void calculateAverage(ifstream& inp, double& courseAvg)
{
double totalScore = 0.0;
int numberOfStudents = 0;
int score;
inp >> score;
while (score != -999)
{
totalScore = totalScore + score;
numberOfStudents++;
inp >> score;
}//end while
courseAvg = totalScore / numberOfStudents;
} //end calculate Average
void printResult(ofstream& outp, string courseID, int groupNo,
double avg)
{
if (groupNo == 1)
outp << " " << courseID << "
";
else
outp << "
";
outp << setw(8) << groupNo << setw(17) << avg << endl;
} //end printResult

Sample Run:
Course No
CSC

Group No
1
2

Course Average
83.71
80.82

ENG

1
2

82.00
78.20

HIS

1
2

77.69
84.15

MTH

1
2

83.57
84.29

PHY

1
2

83.22
82.60

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Data Comparison

|

431

Avg for group 1: 82.04
Avg for group 2: 82.01

Input Data Group 1
CSC
ENG
HIS
MTH
PHY

80 100 70 80 72 90 89 100 83 70 90 73 85 90 -999
80 90 80 94 90 74 78 63 83 80 90 -999
90 70 80 70 90 50 89 83 90 68 90 60 80 -999
74 80 75 89 90 73 90 82 74 90 84 100 90 79 -999
100 83 93 80 63 78 88 89 75 -999

Input Data Group 2
CSC
ENG
HIS
MTH
PHY
BAR
GRAPH

90 75 90 75 80 89 100 60 80 70 80 -999
80 80 70 68 70 78 80 90 90 76 -999
100 80 80 70 90 76 88 90 90 75 90 85 80 -999
80 85 85 92 90 90 74 90 83 65 72 90 84 100 -999
90 93 73 85 68 75 67 100 87 88 -999

In the business world, company executives often like to see results in some visual
form, such as bar graphs. Many currently available software packages can analyze data
in several forms and then display the results in a visual form, such as bar graphs or pie
charts. The second part of this program aims to display the results found earlier in the
form of bar graphs, as shown below:
Course
ID
CSC
ENG

Course Average
0
10
20
30
40
50
60
70
80
90
100
|....|....|....|....|....|....|....|....|....|....|
*****************************************
########################################
*****************************************
#######################################

.
.
.
Group 1 -- ****
Group 2 -- ####
Avg for group 1: 82.04
Avg for group 2: 82.01

Each symbol (* or #) in the bar graph represents two points. If a course average is less
than 2, no symbol is printed.
Because the output is in the form of a bar graph, we need to modify the function
printResult.
Print Bars

The function printResult prints the course ID and the bar graph representing the
average for a course. The output is stored in a file. So we must pass four parameters to
this function: the ofstream variable associated with the output file, the group

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

432 |

Chapter 6: User-Defined Functions

number (to print * or #), the course ID, and the course average for the department.
To print the bar graph, we can use a loop to print one symbol for every two points.
To find the number of symbols to print, we can use integer division as follows:
numberOfSymbols = static_cast<int>(average) / 2;

For example, static_cast<int>(78.45) / 2 = 78 / 2 = 39. If the average is 78.45,
we must print 39 symbols to represent this average.
Following this discussion, the definition of the function printResult is:
void printResult(ofstream& outp, string courseID,
int groupNo, double avg)
{
int noOfSymbols;
int count;
if (groupNo == 1)
outp << setw(4) << courseID << "
else
outp << "
";

";

noOfSymbols = static_cast<int>(avg)/2;
if (groupNo == 1)
for (count = 1; count <= noOfSymbols; count++)
outp << '*';
else
for (count = 1; count <= noOfSymbols; count++)
outp << '#';
outp << endl;
} //end printResult

We also include a function printHeading to print the first two lines of the output.
The definition of this function is:
void printHeading(ofstream& outp)
{
outp << "Course
Course Average" << endl;
outp << " ID
0
10
20
30
40
50
60
70"
<< "
80
90
100" << endl;
outp << "
|....|....|....|....|....|....|....|"
<< "....|....|....|" << endl;
} //end printHeading

Replace the function printResult in the preceding program, include the function
printHeading, include the statements to output — Group 1 -- **** and Group 2
-- #### — , and rerun the program. Your program should generate a bar graph
similar to the bar graph shown earlier. (The complete program listing is available on
the Web site accompanying this book.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

433

QUICK REVIEW
1.
2.
3.
4.

Functions, also called modules, are like miniature programs.
Functions enable you to divide a program into manageable tasks.
The C++ system provides the standard (predefined) functions.
To use a standard function, you must:
i.
ii.
iii.

5.
6.
7.
8.
9.
10.

11.

Know the name of the header file that contains the function’s specification,
Include that header file in the program, and
Know the name and type of the function and number and types of the
parameters (arguments).

There are two types of user-defined functions: value-returning functions
and void functions.
Variables defined in a function heading are called formal parameters.
Expressions, variables, or constant values used in a function call are called
actual parameters.
In a function call, the number of actual parameters and their types must
match with the formal parameters in the order given.
To call a function, use its name together with the actual parameter list.
A value-returning function returns a value. Therefore, a value-returning
function is used (called) in either an expression or an output statement or as
a parameter in a function call.
The general syntax of a user-defined function is:
functionType functionName(formal parameter list)
{
statements
}

12.

13.
14.
15.
16.

17.
18.

The line functionType functionName(formal parameter list) is
called the function heading (or function header). Statements enclosed
between braces ({ and }) are called the body of the function.
The function heading and the body of the function are called the definition
of the function.
If a function has no parameters, you still need the empty parentheses in
both the function heading and the function call.
A value-returning function returns its value via the return statement.
A function can have more than one return statement. However, whenever a return statement executes in a function, the remaining statements
are skipped and the function exits.
A return statement returns only one value.
A function prototype is the function heading without the body of the
function; the function prototype ends with the semicolon.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

434 |

19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.

31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.

Chapter 6: User-Defined Functions

A function prototype announces the function type, as well as the type and
number of parameters, used in the function.
In a function prototype, the names of the variables in the formal parameter
list are optional.
Function prototypes help the compiler correctly translate each function call.
In a program, function prototypes are placed before every function
definition, including the definition of the function main.
When you use function prototypes, user-defined functions can appear in
any order in the program.
When the program executes, the execution always begins with the first
statement in the function main.
Functions execute only when they are called.
A call to a function transfers control from the caller to the called
function.
In a function call statement, you specify only the actual parameters, not
their data type or the function type.
When a function exits, control goes back to the caller.
A function that does not have a data type is called a void function.
A return statement without any value can be used in a void function. If
a return statement is used in a void function, it is typically used to exit the
function early.
The heading of a void function starts with the word void.
In C++, void is a reserved word.
A void function may or may not have parameters.
A call to a void function is a stand-alone statement.
To call a void function, you use the function name together with the actual
parameters in a stand-alone statement.
There are two types of formal parameters: value parameters and reference
parameters.
A value parameter receives a copy of its corresponding actual parameter.
A reference parameter receives the address (memory location) of its corresponding actual parameter.
The corresponding actual parameter of a value parameter is an expression,
a variable, or a constant value.
A constant value cannot be passed to a reference parameter.
The corresponding actual parameter of a reference parameter must be
a variable.
When you include & after the data type of a formal parameter, the formal
parameter becomes a reference parameter.
The stream variables should be passed by reference to a function.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

44.

45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.

435

If a formal parameter needs to change the value of an actual parameter, in
the function heading, you must declare this formal parameter as a reference
parameter.
The scope of an identifier refers to those parts of the program where it is
accessible.
Variables declared within a function (or block) are called local variables.
Variables declared outside of every function definition (and block) are
called global variables.
The scope of a function name is the same as the scope of an identifier
declared outside of any block.
See the scope rules in this chapter (section, Scope of an Identifier).
C++ does not allow the nesting of function definitions.
An automatic variable is a variable for which memory is allocated on function
(or block) entry and deallocated on function (or block) exit.
A static variable is a variable for which memory remains allocated
throughout the execution of the program.
By default, global variables are static variables.
In C++, a function can be overloaded.
Two functions are said to have different formal parameter lists if both
functions have:
•
•

56.

57.
58.
59.
60.
61.

62.
63.
64.

A different number of formal parameters, or
The same number of formal parameters and the data types of the
formal parameters, in the order listed, differ in at least one position.
The signature of a function consists of the function name and its formal
parameter list. Two functions have different signatures if they have either
different names or different formal parameter lists.
If a function is overloaded, then in a call to that function the formal
parameter list of the function determines which function to execute.
C++ allows functions to have default parameters.
If you do not specify the value of a default parameter, the default value is
used for that parameter.
All of the default parameters must be the far-right parameters of the function.
Suppose a function has more than one default parameter. In a function call,
if a value to a default parameter is not specified, then you must omit all
arguments to its right.
Default values can be constants, global variables, or function calls.
The calling function has the option of specifying a value other than the
default for any default parameter.
You cannot assign a constant value as a default value to a reference
parameter.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

436 |

Chapter 6: User-Defined Functions

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false:
a.

b.
c.

d.

e.
f.
g.

h.

i.

j.

k.

l.

m.
n.

2.

To use a predefined function in a program, you need to know only the
name of the function and how to use it. (1)
A value-returning function returns only one value. (2, 3)
Parameters allow you to use different values each time the function is
called. (2, 7, 9)
When a return statement executes in a user-defined function, the
function immediately exits. (3, 4)
A value-returning function returns only integer values. (4)
A variable name cannot be passed to a value parameter. (3, 6)
If a C++ function does not use parameters, parentheses around the
empty parameter list are still required. (2, 3, 6)
In C++, the names of the corresponding formal and actual parameters
must be the same. (3, 4, 6)
A function that changes the value of a reference parameter also changes
the value of the actual parameter. (7)
Whenever the value of a reference parameter changes, the value of the
actual parameter changes. (7)
In C++, function definitions can be nested; that is, the definition of
one function can be enclosed in the body of another function. (9)
Using global variables in a program is a better programming style than
using local variables, because extra variables can be avoided. (10)
In a program, global constants are as dangerous as global variables. (10)
The memory for a static variable remains allocated between function
calls. (11)

Determine the value of each of the following expressions: (1)
a.

static_cast<char>(toupper('7'))

b.

static_cast<char>(toupper('@'))

c.

static_cast<char>(toupper('s'))

d.

static_cast<char>(toupper('J'))

e.

static_cast<char>(tolower('*'))

f.

static_cast<char>(tolower(';'))

g.

static_cast<char>(tolower('w'))

h.

static_cast<char>(tolower('('))

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

3.

b. fabs(-56.38) c. fabs(13.00)

e. pow(6.2, 1.5)

f. sqrt(34.56)

j.

ceil(6.5)

l.

floor(-5.89) + ceil(-2.31)

d. pow(3.0, 2)

g. sqrt(144.0)

h. sqrt(49.00) * pow(6.0, 3.0) / abs(-3)

i. floor(13.45)

k. floor(5.89) + ceil(5.89)

m. floor(-2.3) - ceil(81.2)
o. pow(3.0, -5.0)

5.

437

Determine the value of each of the following expressions. (For decimal
numbers, round your answer to two decimal places.) (1)
a. abs(-25)

4.

|

n.

pow(-3.0, 5.0)

p. pow(4.2, 1/5.0)

Using the functions described in Table 6-1, write each of the following as a C++ expression. (The expression in (e) denotes the absolute value
of x + 2y  3.) (1)
pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
b þ b2  4ac
3.2
2*x
2
a. 8.50
b.
d.
e. jx þ 2y  3j
3x  y c. (w+u)
2a
Consider the following function definition:
int func(int x, double y, char u, string name)
{
//function body
}

Which of the following are correct function prototypes of the function func? (4, 6)
a.

6.

int func(x, y, u, name);

b.

int func(int s, double k, char ch, string name);

c.

int func(int, double, char, string);

d.

func(int, double, char, string)

Consider the following program: (1)
#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;
int main()
{
int num1;
int num2;
cout << fixed << showpoint << setprecision(2);
cout << "Enter two integers: ";
cin >> num1 >> num2;
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

438 |

Chapter 6: User-Defined Functions

if (num1 != 0 && num2 != 0)
cout << sqrt(abs(num1 + num2) + 0.5) << endl;
else if (num1 != 0)
cout << floor(num1 + 0.5) << endl;
else if (num2 != 0)
cout << ceil(num2 + 0.5) << endl;
else
cout << 0 << endl;
return 0;
}
a.
b.
c.
d.
e.
7.

What
What
What
What
What

is
is
is
is
is

the
the
the
the
the

output
output
output
output
output

if
if
if
if
if

the
the
the
the
the

input
input
input
input
input

is
is
is
is
is

-23 8?
12 32?
15 0?
0 -36?
0 0?

Consider the following statements:
int num1, num2, num3;
double length, width, height;
double volume;
num1 = 6; num2 = 7; num3 = 4;
length = 6.2; width = 2.3; height = 3.4

and the function prototype:
double box(double, double, double);

Which of the following statements are valid? If they are invalid,
explain why. (4)

8.

a.

volume = box(length, width, height);

b.

volume = box(length, 3.8, height);

c.

cout << box(num1, num3, num2) << endl;

d.

cout << box(length, width, 7.0) << endl;

e.

volume = box(length, num1, height);

f.

cout << box(6.2, , height) << endl;

g.

volume = box(length + width, height);

h.

volume = box(num1, num2 + num3);

Consider the following functions: (4)
int find(int num1, int num2)
{
int first, second;
first = num1 * num2;
second = first - num1 + num2;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

439

if (second > 50)
num1 = first / 10;
else
num2 = second / 20;
return num1 + num2;
}
int discover(int
{
int secret =
for (int i =
secret =

one, int two)
1;
one; i < two; i++)
secret * i;

return secret;
}

What is the output of each of the following program segments?

9.

a.

cout << find(15, 25) << endl;

b.

cout << discover(3, 9) << endl;

c.

cout << find(10, 10) << " " << discover(10, find(10, 10)) << endl;

d.

x = 20; y = 10;
cout << discover(x, y) << endl;

Consider the following function prototypes:
int func1(int, double);
double func2(string, int, double);
char func3(int, int, double, char);
string join(string, string);

Answer the following questions: (3, 4)
a.

b.

c.

d.

e.

f.

How many parameters does the function func1 have? What is the type
of the function func1?
How many parameters does function func2 have? What is the type of
function func2?
How many parameters does function func3 have? What is the type of
function func3?
How many parameters does function join have? What is the type of
function join?
How many actual parameters are needed to call the function func1?
What is the type of each actual parameter, and in what order should
you use these parameters in a call to the function func1?
Write a C++ statement that prints the value returned by the function
func1 with the actual parameters 3 and 8.5.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

440 |

g.

h.

10.

11.

12.

Chapter 6: User-Defined Functions

Write a C++ statement that prints the value returned by function join with
the actual parameters "John" and "Project Manager", respectively.
Write a C++ statement that prints the next character returned by
function func3. (Use your own actual parameters.)

Why do you need to include function prototypes in a program that contains
user-defined functions? (5)
Write the definition of a function that takes as input a char value and
returns true if the character is uppercase; otherwise, it returns false. (4)
Consider the following function:
int mystery(int x, double y, char ch)
{
if (x == 0 && ch > 'A')
return(static_cast<int>(pow(y, 2)) + static_cast<int>(ch));
else if (x > 0)
return(x + static_cast<int>(sqrt(y)) - static_cast<int>(ch));
else
return(2 * x + static_cast<int>(y) - static_cast<int>(ch));
}

What is the output of the following C++ statements? (1, 4)

13.

a.

cout << mystery(0, 6.5, 'K') << endl;

b.

cout << mystery(4, 16.0, '#') << endl;

c.

cout << 2 * mystery(-11, 13.8, '8') << endl;

Consider the following function: (4)
int secret(int m, int n)
{
int temp = 1;
for (int i = 1; i < abs(n); i++)
temp = temp * m;
return temp;
}
a.

b.
14.

What is the output of the following C++ statements?
i.

cout << secret(2, 5) << endl;

ii.

cout << secret(3, -4) << endl;

What does the function secret do?

Write the definition of a function that takes as input the three numbers.
The function returns true if the first number to the power of the second
number equals the third number; otherwise, it returns false. (Assume that
the three numbers are of type double.) (4)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

15.

|

441

Consider the following C++ program: (1, 4)
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
int temp = 0;
for (int counter = 1; counter <= 100; counter++)
if (pow(floor(sqrt(counter / 1.0)), 2.0) == counter)
temp = temp + counter;
cout << temp << endl;
return 0;
}
a.
b.

16.

What is the output of this program?
What does this program do?

What is the output of the following program? (4)
#include <iostream>
using namespace std;
int mystery(int x, int y, int z);
int main()
{
cout <<
cout <<
cout <<
cout <<
cout <<

mystery(7, 8, 3) << endl;
mystery(10, 5, 30) << endl;
mystery(9, 12, 11) << endl;
mystery(5, 5, 8) << endl;
mystery(10, 10, 10) << endl;

return 0;
}
int mystery(int x, int y, int z)
{
if (x <= y && x <= z)
return (y + z - x);
else if (y <= z && y <= x)
return (z + x - y);
else
return (x + y - z);
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

442 |

17.

18.

Chapter 6: User-Defined Functions

Write the definition of a function that takes as input three decimal numbers
and returns the first number multiplied by the second number to the power
of the third number: (4)
Consider the following C++ function: (4)
int mystery(int num)
{
int y = 1;
if (num == 0)
return 0;
else if (num < 0)
for (int count =
y = y - (num
else
for (int count =
y = y * (num

0; count > num; count- -)
+ count);
1; count < num; count++)
- count);

return y;
}

What is the output of the following statements?

19.

a.

cout << mystery(7) << endl;

b.

cout << mystery(0) << endl;

c.

cout << mystery(-7) << endl;

d.

cout << mystery(10) << endl;

a.

How would you use a return statement in a void function? (6)
Why would you want to use a return statement in a void function? (6)

b.
20.

Identify the following items in the programming code shown below: (5, 6)
a.

b.
c.
d.
e.

Function prototype, function heading, function body, and function
definitions.
Function call statements, formal parameters, and actual parameters.
Value parameters and reference parameters.
Local variables and global variables.
Named constants.
#include <iostream>

//Line 1

using namespace std;

//Line 2

const double NUM = 3.5;

//Line 3

int temp;

//Line 4

void func(int, double&, char);

//Line 5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

int main()
{
int num;
double one;
char ch;

6
7
8
9
10

func(num, one, ch);
cout << num << " " << one << " " << ch << endl;
func(16, one, '%');
cout << num << " " << one << " " << ch << endl;

//Line
//Line
//Line
//Line

11
12
13
14

return 0;
}

//Line 15
//Line 16

void func(int first, double& second, char ch)
{
int num;
double y;
int u;

//Line
//Line
//Line
//Line
//Line

17
18
19
20
21

//Line
//Line
//Line
//Line
//Line

22
23
24
25
26

}

b.
c.
22.

443

//Line
//Line
//Line
//Line
//Line

num = 2 * first;
y = second * first;
u = static_cast<int> (ch);
second = num + y * u;
21. a.

|

Explain the difference between an actual and a formal parameter.
(4, 6, 7, 10)
Explain the difference between a value and a reference parameter.
Explain the difference between a local and a global variable.

What is the output of the following program? (6)
#include <iostream>
using namespace std;
void func1();
void func2();
int main()
{
int num;
cout << "Enter 1 or 2: ";
cin >> num;
cout << endl;
cout << "Take ";

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

444 |

Chapter 6: User-Defined Functions

if (num == 1)
func1();
else if (num == 2)
func2();
else
cout << "Invalid input. You must enter a 1 or 2" << endl;
return 0;
}
void func1()
{
cout << "Programming I." <<endl;
}
void func2()
{
cout << "Programming II." << endl;
}
a.
b.
c.
d.
23.

24.

25.

26.

27.

What
What
What
What

is
is
is
is

the
the
the
the

output
output
output
output

if
if
if
if

the
the
the
the

input
input
input
input

is
is
is
is

1?
2?
3?
-1?

Write the definition of a void function that takes as input a decimal number
and outputs 3 times the value of the decimal number. Format your output
to two decimal places. (6, 7, 8)
Write the definition of a void function that takes as input two decimal
numbers. If the first number is nonzero, it outputs the second number
divided by the first number; otherwise, it outputs a message indicating that
the second number cannot be divided by the first number because the first
number is 0. (6, 7, 8)
Write the definition of a void function with three reference parameters of type
int, double, and string. The function sets the values of the int and double
variables to 0 and the value of the string variable to an empty string. (6, 7, 8)
Write the definition of a void function that takes as input three parameters
of type int, say sum, prod, and num. The function updates the value of sum
by adding the value of num, and the value of prod by multiplying the value
of num. The new values of sum and prod are reflected in the calling
environment. (6, 7, 8)
What is the output of the following program? (6, 7, 8)
#include <iostream>
using namespace std;
void find(int& a, int b, int& c);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

445

int main()
{
int one, two, three;
one = 1;
two = 2;
three = 3;
find(one, two, three);
cout << one << ", " << two << ", " << three << endl;
find(two, one, three);
cout << one << ", " << two << ", " << three << endl;
find(three, two, one);
cout << one << ", " << two << ", " << three << endl;
find(two, three, one);
cout << one << ", " << two << ", " << three << endl;
return 0;
}
void find(int& a, int b, int& c)
{
int temp;
c = a * b + 2;
temp = c;
if (b
a
a = a
c = b

= = 0)
= c / (b + 1);
+ c - b;
* temp;

}
28.

What is the output of the following program? (6, 7, 8)
#include <iostream>
using namespace std;
int x;
void summer(int&, int);
void fall(int, int&);
int main()
{
int intNum1 = 2;
int intNum2 = 5;
x = 6;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

446 |

Chapter 6: User-Defined Functions

summer(intNum1, intNum2);
cout << intNum1 << " " << intNum2 << " " << x << endl;
fall(intNum1, intNum2);
cout << intNum1 << " " << intNum2 << " " << x << endl;
return 0;
}
void summer(int& a, int b)
{
int intNum1;
intNum1 = b + 12;
a = 2 * b + 5;
b = intNum1 + 4;
}
void fall(int u, int& v)
{
int intNum2;
intNum2= x;
v = intNum2 * 4;
x = u - v;
}
29.

In the following program, number the marked statements to show the order
in which they will execute (the logical order of execution). Also, what is
the output if the input is 10? (6, 7, 8)
#include <iostream>
using namespace std;
int secret(int, int);
void func(int x, int& y);
int main()
{
int num1, num2;
num1 = 6;
cout << "Enter a positive integer: ";
cin >> num2;
cout << endl;
cout << secret(num1, num2) << endl;
num2 = num2 - num1;
cout << num1 << " " << num2 << endl;
func(num2, num1);
cout << num1 << " " << num2 << endl;
return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

447

int secret(int a, int b)
{
int d;
d = a + b;
b = a * d;
return b;
}
void func (int x, int& y)
{
int val1, val2;
val1 = x + y;
val2 = x * y;
y = val1 + val2;
cout << val1 << " " << val2 << endl;
}
30.

Consider the following program: (6, 7, 8)
#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;
void traceMe(double x, double y);
int main()
{
double one, two;
cout << "Enter two numbers: ";
cin >> one >> two;
cout << endl;
traceMe(one, two);
traceMe(two, one);
return 0;
}
void traceMe(double x, double y)
{
double z;
if (x != 0)
z = sqrt(y) / x;
else

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

448 |

Chapter 6: User-Defined Functions

{
cout << "Enter a nonzero number: ";
cin >> x;
cout << endl;
z = floor(pow(y, x));
}
cout << fixed << showpoint << setprecision(2);
cout << x << ", " << y << ", " << z << endl;
}
a.
b.
c.
31.

32.
33.

What is the output if the input is 3 625?
What is the output if the input is 24 1024?
What is the output if the input is 0 196?

The function traceMe in Exercise 30 outputs the values of x, y, and z.
Modify the definition of this function so that rather than print these values,
it sends the values back to the calling environment and the calling environment prints these values. (6, 7, 8)
In Exercise 30, determine the scope of each identifier. (9)
What is the output of the following code fragment? (9)
int alpha = 5;
int beta = 10;
if (beta >= alpha)
{
int alpha;
int temp;
alpha = 20;
temp = beta - alpha;
beta = beta * temp;
cout << alpha << ' ' << beta << endl;
}
cout << alpha << ' ' << beta << endl;

34.

Consider the following program. What is its exact output? Show the values
of the variables after each line executes, as in Example 6-14. (6, 7, 8)
#include <iostream>
using namespace std;
void funOne(int& a);
int main()
{
int num1, num2;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

num1 = 10;

//Line 1

num2 = 20;

//Line 2

cout << "Line 3: In main: num1 = " << num1
<< ", num2 = " << num2 << endl;

//Line 3

449

//Line 4

funOne(num1);
cout << "Line 5: In main after funOne: num1 = "
<< num1 << ", num2 = " << num2 << endl;

//Line 5

return 0;

//Line 6

}
void funOne(int& a)
{
int x = 12;
int z;
z = a + x;

//Line 7

cout << "Line 8: In funOne: a = " << a
<< ", x = " << x
<< ", and z = " << z << endl;

//Line 8

x = x + 5;

//Line 9

cout << "Line 10: In funOne: a = " << a
<< ", x = " << x
<< ", and z = " << z << endl;

//Line 10

a = a + 8;

//Line 11

cout << "Line 12: In funOne: a = " << a
<< ", x = " << x
<< ", and z = " << z << endl;

//Line 12

}
35.

What is the output of the following program? (11)
#include <iostream>
using namespace std;
void tryMe(int& v);
int main()
{
int x = 8;
for (int count = 1; count < 5; count++)
tryMe(x);
return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

450 |

Chapter 6: User-Defined Functions

void tryMe(int& v)
{
static int num = 2;
if (v % 2 == 0)
{
num++;
v = v + 3;
}
else
{
num--;
v = v + 5;
}
cout << v << ", " << num << endl;
}
36.
37.

What is the signature of a function? (13)
Consider the following function prototype:
void funcDefaultParam(double x = 7.3, int y = 4, string z = "*");

Which of the following function calls is correct? (14)

38.

a.

funcDefaultParam();

b.

funcDefaultParam(2.8);

c.

funcDefaultParam(3.2, 0, "h");

d.

funcDefaultParam(9.2, "*");

e.

funcDefaultParam(7, 3);

Consider the following function definition:
void defaultParam(int num1, int num2 = 7, double z = 2.5)
{
int num3;
num1 = num1 + static_cast<int>(z);
z = num2 + num1 * z;
num3 = num2 - num1;
cout << "num3 = " << num3 << endl;
}

What is the output of the following function calls? (14)
a.

defaultParam(7);

b.

defaultParam(8, 2);

c.

defaultParam(0, 1, 7.5);

d.

defaultParam(1, 2, 3.0);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

451

PROGRAMMING EXERCISES
1.

a.

Write a program that uses the function isPalindrome given in
Example 6-6 (Palindrome). Test your program on the following
strings: "madam", "abba", "22", "67876", "444244", and
"trymeuemyrt"

b.

2.

3.

4.

Modify the function isPalindrome of Example 6-6 so that when
determining whether a string is a palindrome, cases are ignored, that is,
uppercase and lowercase letters are considered the same.

Write a value-returning function, isVowel, that returns the value true if a
given character is a vowel and otherwise returns false.
Write a program that prompts the user to input a sequence of characters and
outputs the number of vowels. (Use the function isVowel written in
Programming Exercise 2.)
Write a program that defines the named constant PI, const double
PI = 3.14159;, which stores the value of p. The program should use PI
and the functions listed in Table 6-1 to accomplish the following:
pﬃﬃﬃ
a. Output the value of
p.
b. Prompt the user to input the value of a double variable r, which stores
the radius of a sphere. The program then outputs the following:
i.
ii.

5.

The value of 4pr2, which is the surface area of the sphere.
The value of (4/3)pr3, which is the volume of the sphere.

The following program is designed to find the area of a rectangle, the area of
a circle, or the volume of a cylinder. However, (a) the statements are in the
incorrect order; (b) the function calls are incorrect; (c) the logical expression
in the while loop is incorrect; and (d) the function definitions are incorrect.
Rewrite the program so that it works correctly. Your program must be
properly indented. (Note that the program is menu driven and allows the
user to run the program as long as the user wishes.)
#include <iostream>
using namespace std;
const double PI = 3.1419;
double rectangle(double l, double w);
#include <iomanip>
int main()
{
double radius;
double height;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

452 |

Chapter 6: User-Defined Functions

cout << fixed << showpoint << setprecision(2) << endl;
cout << "This program can calculate the area of a rectangle, "
<< "the area of a circle, or volume of a cylinder." << endl;
cout << "To run the program enter: " << endl;
cout << "1: To find the area of rectangle." << endl;
cout << "2: To find the area of a circle." << endl;
cout << "3: To find the volume of a cylinder." << endl;
cout << "-1: To terminate the program." << endl;
cin >> choice;
cout << endl;
int choice;
while (choice == -1)
{
{
case 1:
cout << "Enter the radius of the base and the "
<< "height of the cylinder: ";
cin >> radius >> height;
cout << endl;
cout << "Area = " << circle(length, height) << endl;
break;
case 3:
double length, width;
cout << "Enter the radius of the circle: ";
cin >> radius;
cout << endl;
cout << "Area = " << rectangle(radius)
<< endl;
break;
case 2:
cout << "Enter the length and the width "
<< "of the rectangle: ";
cin >> length >> width;
cout << endl;
cout << "Volume = " << cylinder(radius, height)
<< endl;
break;
default:
cout << "Invalid choice!" << endl;
}
switch (choice)
}
double circle(double r)
double cylinder(double bR, double h);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

453

cout << "To run the program enter: " << endl;
cout << "2: To find the area of a circle." << endl;
cout << "1: To find the area of rectangle." << endl;
cout << "3: To find the volume of a cylinder." << endl;
cout << "-1: To terminate the program." << endl;
cin >> choice;
cout << endl;
return 0;
}
double rectangle(double l, double w)
{
return l * r;
}
double circle(double r)
{
return PI * r * w;
}
double cylinder(double bR, double h)
{
return PI * bR * bR * l;
}
6.

7.

8.

Write a function, reverseDigit, that takes an integer as a parameter and
returns the number with its digits reversed. For example, the value of
reverseDigit(12345) is 54321; the value of reverseDigit(5600)
is 65; the value of reverseDigit(7008) is 8007; and the value of
reverseDigit(-532) is -235.
Modify the roll dice program, Example 6-4, so that it allows the user to enter
the desired sum of the numbers to be rolled. Also allow the user to call the
rollDice function as many times as the user desires.
The following formula gives the distance between two points, (x1, y1) and
(x2, y2) in the Cartesian plane:
qﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
ðx2  x1 Þ2 þ ðy2  y1 Þ2
Given the center and a point on the circle, you can use this formula to find the
radius of the circle. Write a program that prompts the user to enter the center and a
point on the circle. The program should then output the circle’s radius, diameter,
circumference, and area. Your program must have at least the following functions:
a.

b.

distance: This function takes as its parameters four numbers that

represent two points in the plane and returns the distance between them.
radius: This function takes as its parameters four numbers that represent the center and a point on the circle, calls the function distance to
find the radius of the circle, and returns the circle’s radius.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

454 |

c.

d.

9.

circumference: This function takes as its parameter a number that

represents the radius of the circle and returns the circle’s circumference.
(If r is the radius, the circumference is 2pr.)
area: This function takes as its parameter a number that represents the radius
of the circle and returns the circle’s area. (If r is the radius, the area is pr2.)

Assume that p = 3.1416.
Rewrite the program in Programming Exercise 14 of Chapter 4 (cell phone
company) so that it uses the following functions to calculate the billing
amount. (In this programming exercise, do not output the number of
minutes during which the service is used.)
a.

b.

10.

Chapter 6: User-Defined Functions

regularBill: This function calculates and returns the billing amount
for regular service.
premiumBill: This function calculates and returns the billing amount
for premium service.

Write a program that takes as input five numbers and outputs the mean
(average) and standard deviation of the numbers. If the numbers are x1, x2,
x3, x4, and x5, then the mean is x ¼ (x1 + x2 + x3 + x4 + x5)/5 and the
standard deviation is:
sﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
ðx1  xÞ2 þ ðx2  xÞ2 þ ðx3  xÞ2 þ ðx4  xÞ2 þ ðx5  xÞ2
s¼
5
Your program must contain at least the following functions: a function that
calculates and returns the mean and a function that calculates the standard
deviation.

11.

When you borrow money to buy a house, a car, or for some other
purposes, then you typically repay it by making periodic payments. Suppose
that the loan amount is L, r is the interest rate per year, m is the number of
payments in a year, and the loan is for t years. Suppose that i ¼ (r / m) and
r is in decimal. Then the periodic payment is:
R¼

Li
;
1  ð1 þ iÞmt

You can also calculate the unpaid loan balance after making certain payments.
For example, the unpaid balance after making k payments is:
"
#
1  ð1 þ iÞðmtkÞ
0
;
L ¼R
i
where R is the periodic payment. (Note that if the payments are monthly,
then m ¼ 12.)
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

12.

|

455

Write a program that prompts the user to input the values of L, r, m, t, and k. The
program then outputs the apropriate values. Your program must contain at least
two functions, with appropriate parameters, to calculate the periodic payments
and the unpaid balance after certain payments. Make the program menu driven
and use a loop so that the user can repeat the program for different values.
During the tax season, every Friday, the J&J accounting firm provides assistance
to people who prepare their own tax returns. Their charges are as follows:
a.

b.

If a person has low income (<¼ 25,000) and the consulting time is less
than or equal to 30 minutes, there are no charges; otherwise, the service
charges are 40% of the regular hourly rate for the time over 30 minutes.
For others, if the consulting time is less than or equal to 20 minutes, there
are no service charges; otherwise, service charges are 70% of the
regular hourly rate for the time over 20 minutes.

(For example, suppose that a person has low income and spent 1 hour and 15 minutes, and
the hourly rate is $70.00. Then the billing amount is 70.00  0.40  (45 / 60) ¼ $21.00.)

13.

Write a program that prompts the user to enter the hourly rate, the total consulting time,
and whether the person has low income. The program should output the billing
amount. Your program must contain a function that takes as input the hourly rate, the
total consulting time, and a value indicating whether the person has low income. The
function should return the billing amount. Your program may prompt the user to enter
the consulting time in minutes.
During winter when it is very cold, typically, everyone would like to know
the windchill factor, especially, before going out. Meteorologists use the
following formula to compute the windchill factor, W:
W = 35.74 + 0.6215 * T 35.75 * V

14.

0.16

+ 0.4275 * T * V

0.16

,

where V is the wind speed in miles per hour and T is the temperature in
degrees Fahrenheit. Write a program that prompts the user to input the
wind speed, in miles per hour, and the temperature in degrees Fahrenheit.
The program then outputs the windchill factor. Your program must contain
at least two functions: one to get the user input and the other to determine
the windchill factor.
Consider the definition of the function main:
int main()
{
int x, y;
char z;
double rate, hours;
double amount;
.
.
.
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

456 |

Chapter 6: User-Defined Functions

The variables x, y, z, rate, and hours referred to in items a through f below
are the variables of the function main. Each of the functions described must
have the appropriate parameters to access these variables. Write the following
definitions:
Write the definition of the function initialize that initializes x and
y to 0 and z to the blank character.
b.
Write the definition of the function getHoursRate that prompts the
user to input the hours worked and rate per hour to initialize the
variables hours and rate of the function main.
c.
Write the definition of the value-returning function payCheck that calculates
and returns the amount to be paid to an employee based on the hours worked
and rate per hour. The hours worked and rate per hour are stored in the
variables hours and rate, respectively, of the function main. The formula
for calculating the amount to be paid is as follows: For the first 40 hours, the
rate is the given rate; for hours over 40, the rate is 1.5 times the given rate.
d.
Write the definition of the function printCheck that prints the hours
worked, rate per hour, and the salary.
e.
Write the definition of the function funcOne that prompts the user to
input a number. The function then changes the value of x by assigning
the value of the expression 2 times the (old) value of x plus the value of
y minus the value entered by the user.
f.
Write the definition of the function nextChar that sets the value of z
to the next character stored in z.
g.
Write the definition of a function main that tests each of these functions.
Consider the following C++ code:
a.

15.

#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;
void func1();
void func2(/*formal parameters*/);
int main()
{
int num1, num2;
double num3;
int choice;
cout << fixed << showpoint << setprecision(2);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

457

do
{
func1();
cin >> choice;
cout << endl;
if (choice == 1)
{
func2(num1, num2, num3);
cout << num1 << ", " << num2 << ", " << num3 << endl;
}
}
while (choice != 99);
return 0;
}
void func1()
{
cout << "To run the program, enter 1." << endl;
cout << "To exit the pogram, enter 99." << endl;
cout << "Enter 1 or 99: ";
}
void func2(/*formal parameters*/)
{
//Write the body of func2.
}

The function func2 has three parameters of type int, int, and double, say
a, b, and c, respectively. Write the definition of func2 so that its action is as follows:
a.

b.

c.

d.

e.

Prompt the user to input two integers and store the numbers in a and b,
respectively.
If both of the numbers are nonzero:
i.
If a >= b, the value assigned to c is a to the power b, that is, ab.
a
ii. If a < b, the value assigned to c is b to the power a, that is, b .
If a is nonzero and b is zero, the value assigned to c is the square root of
the absolute value of a.
If b is nonzero and a is zero, the value assigned to c is the square root of
the absolute value of b.
Otherwise, the value assigned to c is 0.

The values of a, b, and c are passed back to the calling environment.
After completing the definition of the func2 and writing its function
prototype, test run your program.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

458 |

16.

Chapter 6: User-Defined Functions

The statements in the following program are not in the correct order.
Rearrange the statements so that the program outputs the total time an
employee spent on the job each day. The program asks the user to enter the
employee’s name, the arrival time (arrival hour, arrival minute, AM or PM),
and departure time (departure hour, departure minute, AM or PM). The
program also allows the user to run the program as long as the user wishes.
After rearranging the statements, your program must be properly indented.
#include <iostream>
#include <string>
using namespace std;
int main()
{
string employeeName;
int arrivalHr;
int departureHr;
int departureMin;
bool departureAM;
char response;
char discard;
char isAM;
cout << "This program calculates the total time spent by an "
<< "employee on the job." << endl;
cout << "To run the program, enter (y/Y): ";
cin >> response;
cout << endl;
cin.get(discard);
while (response == 'y' || response == 'Y')
{
cout << "Enter employee's name: ";
getline(cin, employeeName);
cout << endl;
if (isAM == 'y' || isAM == 'Y')
arrivalAM = true;
else
arrivalAM = false;
cout << "Enter departure hour: ";
cin >> departureHr;
cout << endl;
cout << "Enter departure minute: ";
cin >> departureMin;
cout << endl;
cout << "Enter (y/Y) if departure is before 12:00PM: ";
cin >> isAM;
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

459

if (isAM == 'y' || isAM == 'Y')
departureAM = true;
else
departureAM = false;
cout << employeeName << endl;
timeOnJob(arrivalHr, arrivalMin, arrivalAM,
departureHr, departureMin, departureAM);
cout << "Enter arrival hour: ";
cin >> arrivalHr;
cout << endl;
cout << "Enter arrival minute: ";
cin >> arrivalMin;
cout << endl;
cout << "Enter (y/Y) if arrival is before 12:00PM: ";
cin >> isAM;
cout << endl;
int arrivalMin;
bool arrivalAM;
cout << "Run program again (y/Y): ";
cin >> response;
cout << endl;
cin.get(discard);
}
return 0;
}
void timeOnJob(int arvHr, int arvMin, bool arvIsAM,
int depHr, int depMin, bool depIsAM)
{
int arvTimeInMin;
int depTimeInMin;
int timeOnJobInMin;
else if (arvIsAM == true && depIsAM == false)
{
arvTimeInMin = arvHr * 60 + arvMin;
depTimeInMin = depHr * 60 + depMin;
timeOnJobInMin = (720 - arvTimeInMin) + depTimeInMin;
cout << "Time spent of job: "
<< timeOnJobInMin / 60 << " hour(s) and "
<< timeOnJobInMin % 60 << " minutes." << endl;
}
else
if (arvTimeInMin <= depTimeInMin)
{
timeOnJobInMin = depTimeInMin - arvTimeInMin;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

460 |

Chapter 6: User-Defined Functions

cout << "Time spent of job: "
<< timeOnJobInMin / 60 << " hour(s) and "
<< timeOnJobInMin % 60 << " minutes." << endl;
}
else
cout << "Invalid input." << endl;
if ((arvIsAM == true && depIsAM == true)
|| (arvIsAM == false && depIsAM == false))
{
cout << "Invalid input." << endl;
}
void timeOnJob(int arvHr, int arvMin, bool arvIsAM,
int depHr, int depMin, bool depIsAM);
}
17.

18.

The function printGrade in Example 6-13 is written as a void function
to compute and output the course grade. The course score is passed as
a parameter to the function printGrade. Rewrite the function
printGrade as a value-returning function so that it computes and returns
the course grade. (The course grade must be output in the function main.)
Also, change the name of the function to calculateGrade.
In this exercise, you are to modify the Classify Numbers programming
example in this chapter. As written, the program inputs the data from the
standard input device (keyboard) and outputs the results on the standard
output device (screen). The program can process only 20 numbers. Rewrite
the program to incorporate the following requirements:
Data to the program is input from a file of an unspecified length; that is,
the program does not know in advance how many numbers are in the file.
b. Save the output of the program in a file.
c. Modify the function getNumber so that it reads a number from the
input file (opened in the function main), outputs the number to the
output file (opened in the function main), and sends the number read
to the function main. Print only 10 numbers per line.
d. Have the program find the sum and average of the numbers.
e. Modify the function printResult so that it outputs the final results to
the output file (opened in the function main). Other than outputting the
appropriate counts, this new definition of the function printResult
should also output the sum and average of the numbers.
Write a program that prints the day number of the year, given the date in
the form month-day-year. For example, if the input is 1-1-2006, the day
number is 1; if the input is 12-25-2006, the day number is 359. The
program should check for a leap year. A year is a leap year if it is divisible
by 4, but not divisible by 100. For example, 1992 and 2008 are divisible by
a.

19.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

20.

21.

22.

23.

24.

25.

|

461

4, but not by 100. A year that is divisible by 100 is a leap year if it is also
divisible by 400. For example, 1600 and 2000 are divisible by 400. However, 1800 is not a leap year because 1800 is not divisible by 400.
Write a progam that reads a string and outputs the number of times each
lowercase vowel appears in it. Your program must contain a function with one
of its parameters as a string variable and return the number of times each
lowercase vowel appears in it. Also write a program to test your function. (Note
that if str is a variable of type string, then str.at(i) returns the character
at the ith position. The position of the first character is 0. Also, str.length()
returns the length of the str, that is, the number of characters in str.)
Redo Programming Exercise 20 as follows. Write a progam that reads a string
and outputs the number of times each lowercase vowel appears in it. Your
program must contain a function with one of its parameters as a char
variable, and if the character is a vowel, it increments that vowel’s count.
Write a function that takes as a parameter an integer (as a long long value)
and returns the number of odd, even, and zero digits. Also write a program
to test your function.
The cost to become a member of a fitness center is as follows: (a) the senior
citizens discount is 30%; (b) if the membership is bought and paid for 12 or
more months, the discount is 15%; and (c) if more than five personal training
sessions are bought and paid for, the discount on each session is 20%. Write
a menu-driven program that determines the cost of a new membership.
Your program must contain a function that displays the general information
about the fitness center and its charges, a function to get all of the necessary
information to determine the membership cost, and a function to determine
the membership cost. Use appropriate parameters to pass information in and
out of a function. (Do not use any global variables.)
Write a program that outputs inflation rates for two successive years and
whether the inflation is increasing or decreasing. Ask the user to input the
current price of an item and its price one year and two years ago. To
calculate the inflation rate for a year, subtract the price of the item for that
year from the price of the item one year ago and then divide the result by
the price a year ago. Your program must contain at least the following
functions: a function to get the input, a function to calculate the results, and
a function to output the results. Use appropriate parameters to pass the
information in and out of the function. Do not use any global variables.
Write a program to convert the time from 24-hour notation to 12-hour
notation and vice versa. Your program must be menu driven, giving the user
the choice of converting the time between the two notations. Furthermore,
your program must contain at least the following functions: a function to convert
the time from 24-hour notation to 12-hour notation, a function to convert the
time from 12-hour notation to 24-hour notation, a function to display the
choices, function(s) to get the input, and function(s) to display the results. (For
12-hour time notation, your program must display AM or PM.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

6

462 |

26.

Chapter 6: User-Defined Functions

Jason opened a coffee shop at the beach and sells coffee in three sizes: small
(9oz), medium (12oz), and large (15oz). The cost of one small cup is $1.75,
one medium cup is $1.90, and one large cup is $2.00. Write a menu-driven
program that will make the coffee shop operational. Your program should
allow the user to do the following:
Buy coffee in any size and in any number of cups.
At any time show the total number of cups of each size sold.
c. At any time show the total amount of coffee sold.
d. At any time show the total money made.
Your program should consist of at least the following functions: a function
to show the user how to use the program, a function to sell coffee, a
function to show the number of cups of each size sold, a function to show
the total amount of coffee sold, and a function to show the total money
made. Your program should not use any global variables and special values
such as coffee cup sizes and cost of a coffee cup must be declared as named
constants.
a.
b.

27.

(The box problem) You have been given a flat cardboard of area, say, 70
square inches to make an open box by cutting a square from each corner
and folding the sides (see Figure 6-17). Your objective is to determine the
dimensions, that is, the length and width, and the side of the square to be
cut from the corners so that the resulting box is of maximum length.

z

z

y

FIGURE 6-17

z

y

x

x

x
y

Cardboard box

Write a program that prompts the user to enter the area of the flat cardboard. The program then outputs the length and width of the cardboard
and the length of the side of the square to be cut from the corner so that
the resulting box is of maximum volume. Calculate your answer to three
decimal places. Your program must contain a function that takes as input
the length and width of the cardboard and returns the side of the square
that should be cut to maximize the volume. The function also returns the
maximum volume.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

28.

|

463

(The power station problem) A power station is on one side of a river
that is one-half mile wide, and a factory is eight miles downstream on the
other side of the river (see Figure 6-18). It costs $7 per foot to run power
lines over land and $9 per foot to run them under water. Your objective is
to determine the most economical path to lay the power line. That is,
determine how long the power line should run under water and how long
it should run over land to achieve the minimum total cost of laying the
power line.

6
1/2 mile

y miles
x miles
8 miles

FIGURE 6-18

Power station, river, and factory

Write a program that prompts the user to enter:
a.
b.
c.
d.

29.

The
The
The
The

width of the river
distance of the factory downstream on the other side of the river
cost of laying the power line under water
cost of laying the power line over land

The program then outputs the length of the power line that should run
under water and the length that should run over land so the cost of
constructing the power line is at the minimum. The program should also
output the total cost of constructing the power line.
(Pipe problem, requires trigonometry) A pipe is to be carried around
the right-angled corner of two intersecting corridors. Suppose that
the widths of the two intersecting corridors are 5 feet and 8 feet (see
Figure 6-19). Your objective is to find the length of the longest pipe,
rounded to the nearest foot, that can be carried level around the rightangled corner.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

464 |

Chapter 6: User-Defined Functions

5
θ
8

FIGURE 6-19

30.

31.

Pipe problem

Write a program that prompts the user to input the widths of both of the
hallways. The program then outputs the length of the longest pipe, rounded to
the nearest foot, that can be carried level around the right-angled corner. (Note
that the length of the pipe is given by l = AB + BC = 8 / sin y + 5 / cos y,
where 0 < y < p/2.)
Let a and b be integers such that either a or b is nonzero. The greatest
common divisor, written gcd(a, b), of a and b is the largest positive integer that
divides both a and b. Your program must contain a function that takes as
input two integers and returns the gcd of the integers.
Example 6-16 shows how to write a program to factor a polynomial of the
form x2 + bx + c, where b and c are integers. Modify the program so that
it can also factor polynomials of the form ax2 + bx + c, where a, b, and c
are integers. Note that the polynomial –2x2 – 3x + 2 can be factored as:
–2x2 – 3x + 2 = (–2x + 1) (x + 2) = – (2x – 1) (x + 2).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

CHAPTER

ª HunThomas/Shutterstock.com

U SER -D EFINED S IMPLE D ATA
T YPES , N AMESPACES , AND
THE string T YPE
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn how to create your own simple data type—called the enumeration type

2.

Explore how the assignment statement, and arithmetic and relational operators work
with enum types

3.

Learn how to use for loops with enum types

4.

Learn how to input data into an enum variable

5.

Learn how to output data stored in an enum variable

6.

Explore how to write functions to process enum types

7.

Learn how to declare variables when defining the enumeration type

8.

Become familiar with anonymous types

9.

Become familiar with the typedef statement

10.

Learn about the namespace mechanism

11.

Explore the string data type, and learn how to use string functions to
manipulate strings

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

466 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

In Chapter 2, you learned that C++’s simple data type is divided into three categories:
integral, floating-point, and enum. In subsequent chapters, you worked mainly with
integral and floating-point data types. In this chapter, you will learn about the enum
type. Moreover, the statement using namespace std; (discussed in Chapter 2) is used
in every C++ program that uses ANSI/ISO Standard C++ style header files. The second
half of this chapter examines the purpose of this statement. In fact, you will learn what the
namespace mechanism is. You will also learn about the string type and many useful
functions that you can use to effectively manipulate strings.

Enumeration Type
This section may be skipped without any loss of continuity.

Chapter 2 defined a data type as a set of values together with a set of operations on them.
For example, the int data type consists of integers from -2,147,483,648 to
2,147,483,647 and the set of operations on these numbers—namely, the arithmetic
operations (+, -, *, /, and %). Because the main objective of a program is to manipulate
data, the concept of a data type becomes fundamental to any programming language. By
providing data types, you specify what values are legal and tell the user what kinds of
operations are allowed on those values. The system thus provides you with built-in
checks against errors.
The data types that you have worked with until now were mostly int, bool, char, and
double. Even though these data types are sufficient to solve just about any problem,
situations occur when these data types are not adequate to solve a particular problem.
C++ provides a mechanism for users to create their own data types, which greatly
enhances the flexibility of the programming language.
In this section, you will learn how to create your own simple data types, known as the
enumeration types. In ensuing chapters, you will learn more advanced techniques to
create complex data types.
To define an enumeration type, you need the following items:
•
•
•

A name for the data type
A set of values for the data type
A set of operations on the values

C++ lets you define a new simple data type wherein you specify its name and values, but
not the operations. Preventing users from creating their own operations helps to avoid
potential system failures.
The values that you specify for the data type must be identifiers.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Enumeration Type |

467

The syntax for enumeration type is:
enum typeName {value1, value2, ...};

in which value1, value2, ... are identifiers called enumerators. In C++, enum is a
reserved word.
By listing all of the values between the braces, you also specify an ordering between
the values. That is, value1 < value2 < value3 <.... Thus, the enumeration
type is an ordered set of values. Moreover, the default value assigned to these
enumerators starts at 0. That is, the default value assigned to value1 is 0,
the default value assigned to value2 is 1, and so on. (You can assign different
values—other than the default values—for the enumerators when you define the
enumeration type.) Also notice that the enumerators value1, value2, ... are not
variables.
EXAMPLE 7-1
The statement:
enum colors {BROWN, BLUE, RED, GREEN, YELLOW};

defines a new data type called colors, and the values belonging to this data type are
BROWN, BLUE, RED, GREEN, and YELLOW.

EXAMPLE 7-2
The statement:
enum standing {FRESHMAN, SOPHOMORE, JUNIOR, SENIOR};

defines standing to be an enumeration type. The values belonging to standing are
FRESHMAN, SOPHOMORE, JUNIOR, and SENIOR.

EXAMPLE 7-3
Consider the following statements:
enum grades {'A', 'B', 'C', 'D', 'F'}; //illegal enumeration type
enum places {1ST, 2ND, 3RD, 4TH}; //illegal enumeration type

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

468 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

These are illegal enumeration types because none of the values is an identifier. The
following, however, are legal enumeration types:
enum grades {A, B, C, D, F};
enum places {FIRST, SECOND, THIRD, FOURTH};

If a value has already been used in one enumeration type, it cannot be used by any other
enumeration type in the same block. The same rules apply to enumeration types declared
outside of any blocks. Example 7-4 illustrates this concept.
EXAMPLE 7-4
Consider the following statements:
enum mathStudent {JOHN, BILL, CINDY, LISA, RON};
enum compStudent {SUSAN, CATHY, JOHN, WILLIAM}; //illegal

Suppose that these statements are in the same program in the same block. The second
enumeration type, compStudent, is not allowed because the value JOHN was used in the
previous enumeration type mathStudent.

Declaring Variables
Once a data type is defined, you can declare variables of that type. The syntax for
declaring variables of an enum type is the same as before:
dataType identifier, identifier,...;

The statement:
enum sports {BASKETBALL, FOOTBALL, HOCKEY, BASEBALL, SOCCER,
VOLLEYBALL};

defines an enumeration type called sports. The statement:
sports popularSport, mySport;

declares popularSport and mySport to be variables of type sports.

Assignment
Once a variable is declared, you can store values in it. Assuming the previous declaration,
the statement:
popularSport = FOOTBALL;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Enumeration Type |

469

stores FOOTBALL in popularSport. The statement:
mySport = popularSport;

copies the value of popularSport into mySport.

Operations on Enumeration Types
No arithmetic operations are allowed on the enumeration type. So the following statements are illegal:
mySport = popularSport + 2;
popularSport = FOOTBALL + SOCCER;
popularSport = popularSport * 2;

//illegal
//illegal
//illegal

Also, the increment and decrement operations are not allowed on enumeration types. So
the following statements are illegal:
popularSport++; //illegal
popularSport––; //illegal

Suppose you want to increment the value of popularSport by 1. You can use the cast
operator as follows:
popularSport = static_cast<sports>(popularSport + 1);

When the type name is used, the compiler assumes that the user understands what he or
she is doing. Thus, the preceding statement is compiled, and during execution, it advances
the value of popularSport to the next value in the list. Consider the following
statements:
popularSport = FOOTBALL;
popularSport = static_cast<sports>(popularSport + 1);

After the second statement, the value of popularSport is HOCKEY. Similarly, the
statements:
popularSport = FOOTBALL;
popularSport = static_cast<sports>(popularSport - 1);

result in storing BASKETBALL in popularSport.

Relational Operators
Because an enumeration is an ordered set of values, the relational operators can be used
with the enumeration type. Once again, suppose you have the enumeration type sports
and the variables popularSport and mySport as defined earlier. Then:
FOOTBALL <= SOCCER is true
HOCKEY > BASKETBALL is true
BASEBALL < FOOTBALL is false

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

470 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

Suppose that:
popularSport = SOCCER;
mySport = VOLLEYBALL;

Then:
popularSport < mySport is true

ENUMERATION TYPES AND LOOPS
Recall that the enumeration type is an integral type and that, using the cast operator (that
is, type name), you can increment, decrement, and compare the values of the enumeration type. Therefore, you can use these enumeration types in loops. Suppose mySport is
a variable as declared earlier. Consider the following for loop:
for (mySport = BASKETBALL; mySport <= SOCCER;
mySport = static_cast<sports>(mySport + 1))
.
.
.

This for loop has five iterations.
Using enumeration types in loops increases the readability of the program.

Input /Output of Enumeration Types
Because input and output are defined only for built-in data types such as int, char,
double, and so on, the enumeration type can be neither input nor output (directly).
However, you can input and output enumeration indirectly. Example 7-5 illustrates this
concept.
EXAMPLE 7-5
Suppose you have the following statements:
enum courses {ALGEBRA, BASIC, PASCAL, CPP, PHILOSOPHY, ANALYSIS,
CHEMISTRY, HISTORY};
courses registered;

The first statement defines an enumeration type, courses; the second declares a variable
registered of type courses. You can read (that is, input) the enumeration type with
the help of the char data type. Note that you can distinguish between some of the values
in the enumeration type courses just by reading the first character and others by reading
the first two characters. For example, you can distinguish between ALGEBRA and BASIC
just by reading the first character; you can distinguish between ALGEBRA and ANALYSIS
by reading the first two characters. To read these values from, say, the keyboard, you read
two characters and then use a selection structure to assign the value to the variable
registered. Thus, you need to declare two variables of type char.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Enumeration Type |

471

char ch1, ch2;
cin >> ch1 >> ch2; //Read two characters

The following switch statement assigns the appropriate value to the variable registered:
switch (ch1)
{
case 'a':
case 'A':
if (ch2 == 'l' || ch2 == 'L')
registered = ALGEBRA;
else
registered = ANALYSIS;
break;
case 'b':
case 'B':
registered = BASIC;
break;
case 'c':
case 'C':
if (ch2 == 'h' || ch2 == 'H')
registered = CHEMISTRY;
else
registered = CPP;
break;
case 'h':
case 'H':
registered = HISTORY;
break;
case 'p':
case 'P':
if (ch2 == 'a' || ch2 == 'A')
registered = PASCAL;
else
registered = PHILOSOPHY;
break;
default:
cout << "Illegal input." << endl;
}

You can also use the string type to input value in the variable registered. For
example, the following code accomplishes this:
string course;
cin >> course;
if (course == "algebra")
registered = ALGEBRA;
else if (course == "analysis")
registered = ANALYSIS;
else if (course == "basic")
registered = BASIC;
else if (course == "chemistry")
registered = CHEMISTRY;
else if (course == "cpp")
registered = CPP;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

472 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

else if (course == "history")
registered = HISTORY;
else if (course == "pascal")
registered = PASCAL;
else if (course == "philosophy")
registered = PHILOSOPHY;
else
cout << "Illegal input." << endl;

Similarly, you can output the enumeration type indirectly:
switch (registered)
{
case ALGEBRA:
cout << "Algebra";
break;
case ANALYSIS:
cout << "Analysis";
break;
case BASIC:
cout << "Basic";
break;
case CHEMISTRY:
cout << "Chemistry";
break;
case CPP:
cout << "CPP";
break;
case HISTORY:
cout << "History";
break;
case PASCAL:
cout << "Pascal";
break;
case PHILOSOPHY:
cout << "Philosophy";
}
If you try to output the value of an enumerator directly, the computer will output the value
assigned to the enumerator. For example, suppose that registered = ALGEBRA;.
The following statement will output the value 0 because the (default) value assigned to
ALGEBRA is 0:

cout << registered << endl;

Similarly, the following statement will output 4:
cout << PHILOSOPHY << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Enumeration Type |

473

Functions and Enumeration Types
You can pass the enumeration type as a parameter to functions just like any other simple
data type—that is, by either value or reference. Also, just like any other simple data type,
a function can return a value of the enumeration type. Using this facility, you can use
functions to input and output enumeration types.
The following function inputs data from the keyboard and returns a value of the
enumeration type. Assume that the enumeration type courses is defined as before:
courses readCourses()
{
courses registered;
char ch1, ch2;
cout << "Enter the first two letters of the course: "
<< endl;
cin >> ch1 >> ch2;
switch (ch1)
{
case 'a':
case 'A':
if (ch2 == 'l' || ch2 == 'L')
registered = ALGEBRA;
else
registered = ANALYSIS;
break;
case 'b':
case 'B':
registered = BASIC;
break;
case 'c':
case 'C':
if (ch2 == 'h' || ch2 == 'H')
registered = CHEMISTRY;
else
registered = CPP;
break;
case 'h':
case 'H':
registered = HISTORY;
break;
case 'p':
case 'P':
if (ch2 == 'a' || ch2 == 'A')
registered = PASCAL;
else
registered = PHILOSOPHY;
break;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

474 |

}

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

default:
cout << "Illegal input." << endl;
}
return registered;
//end readCourses

As shown previously, you can also use the string type in the function readCourses to
input a value in a variable of type courses. We leave the details as an exercise.
The following function outputs an enumeration type value:
void printEnum(courses registered)
{
switch (registered)
{
case ALGEBRA:
cout << "Algebra";
break;
case ANALYSIS:
cout << "Analysis";
break;
case BASIC:
cout << "Basic";
break;
case CHEMISTRY:
cout << "Chemistry";
break;
case CPP:
cout << "CPP";
break;
case HISTORY:
cout << "History";
break;
case PASCAL:
cout << "Pascal";
break;
case PHILOSOPHY:
cout << "Philosophy";
}//end switch
}//end printEnum

Declaring Variables When Defining the Enumeration Type
In previous sections, you first defined an enumeration type and then declared variables of that
type. C++ allows you to combine these two steps into one. That is, you can declare variables
of an enumeration type when you define an enumeration type. For example, the statement:
enum grades {A, B, C, D, F} courseGrade;

defines an enumeration type, grades, and declares a variable courseGrade of type
grades.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Enumeration Type |

475

Similarly, the statement:
enum coins {PENNY, NICKEL, DIME, HALFDOLLAR, DOLLAR} change, usCoins;

defines an enumeration type, coins, and declares two variables, change and usCoins,
of type coins.

Anonymous Data Types
A data type wherein you directly specify values in the variable declaration with no type
name is called an anonymous type. The following statement creates an anonymous type:
enum {BASKETBALL, FOOTBALL, BASEBALL, HOCKEY} mySport;

This statement specifies the values and declares a variable mySport, but no name is given
to the data type.
Creating an anonymous type, however, has drawbacks. First, because there is no name for
the type, you cannot pass an anonymous type as a parameter to a function, and a function
cannot return an anonymous type value. Second, values used in one anonymous type can
be used in another anonymous type, but variables of those types are treated differently.
Consider the following statements:
enum {ENGLISH, FRENCH, SPANISH, GERMAN, RUSSIAN} languages;
enum {ENGLISH, FRENCH, SPANISH, GERMAN, RUSSIAN} foreignLanguages;

Even though the variables languages and foreignLanguages have the same values,
the compiler treats them as variables of different types. The following statement is,
therefore, illegal:
languages = foreignLanguages; //illegal

Even though these facilities are available, use them with care. To avoid confusion, first
define an enumeration type and then declare the variables.
We now describe the typedef statement in C++.

typedef Statement
In C++, you can create synonyms or aliases to a previously defined data type by using the
typedef statement. The general syntax of the typedef statement is:
typedef existingTypeName newTypeName;

In C++, typedef is a reserved word. Note that the typedef statement does not create
any new data type; it only creates an alias to an existing data type.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

476 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

EXAMPLE 7-6
The statement:
typedef int integer;

creates an alias, integer, for the data type int. Similarly, the statement:
typedef double real;

creates an alias, real, for the data type double. The statement:
typedef double decimal;

creates an alias, decimal, for the data type double.
Using the typedef statement, you can create your own Boolean data type, as shown in
Example 7-7.

EXAMPLE 7-7
From Chapter 4, recall that logical (Boolean) expressions in C++ evaluate to 1 or 0,
which are, in fact, int values. As a logical value, 1 represents true and 0 represents
false. Consider the following statements:
typedef int Boolean;
const Boolean TRUE = 1;
const Boolean FALSE = 0;
Boolean flag;

//Line
//Line
//Line
//Line

1
2
3
4

The statement in Line 1 creates an alias, Boolean, for the data type int. The
statements in Lines 2 and 3 declare the named constants TRUE and FALSE and initialize
them to 1 and 0, respectively. The statement in Line 4 declares flag to be a variable of
type Boolean. Because flag is a variable of type Boolean, the following statement is
legal:
flag = TRUE;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: The Game of Rock, Paper, and Scissors | 477

PROGRAMMING EXAMPLE:

Watch
the Video

The Game of Rock, Paper, and Scissors

Children often play the game of rock, paper, and scissors. This game has two players,
each of whom chooses one of the three objects: rock, paper, or scissors. If player 1
chooses rock and player 2 chooses paper, player 2 wins the game because paper
covers the rock. The game is played according to the following rules:
•
•
•
•

If both players choose the same object, this play is a tie.
If one player chooses rock and the other chooses scissors, the player
choosing the rock wins this play because the rock breaks the scissors.
If one player chooses rock and the other chooses paper, the player
choosing the paper wins this play because the paper covers the rock.
If one player chooses scissors and the other chooses paper, the player
choosing the scissors wins this play because the scissors cut the paper.

Write an interactive program that allows two people to play this game.
Input

This program has two types of input:
•

The users’ responses when asked to play the game.

•

The players’ choices.

The players’ choices and the winner of each play. After the game is over,
the total number of plays and the number of times that each player won
should be output as well.
Two players play this game. Players enter their choices via the keyboard. Each
player enters R or r for Rock, P or p for Paper, or S or s for Scissors. While the
first player enters a choice, the second player looks elsewhere. Once both entries
are in, if the entries are valid, the program outputs the players’ choices and declares
the winner of the play. The game continues until one of the players decides to quit
the game. After the game ends, the program outputs the total number of plays and
the number of times that each player won. This discussion translates into the
following algorithm:
Output

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

1.
2.
3.
4.
5.
6.
7.

Provide a brief explanation of the game and how it is played.
Ask the users if they want to play the game.
Get plays for both players.
If the plays are valid, output the plays and the winner.
Update the total game count and winner count.
Repeat Steps 2 through 5 while the users agree to play the game.
Output the number of plays and times that each player won.

We will use the enumeration type to describe the objects.
enum objectType {ROCK, PAPER, SCISSORS};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

478 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

Variables It is clear that you need the following variables in the function main:
(Function main)
int gameCount; //variable to store the number of
//games played
int winCount1; //variable to store the number of games
//won by player 1
int winCount2; //variable to store the number of games
//won by player 2
int gamewinner;
char response; //variable to get the user's response to
//play the game
char selection1;
char selection2;
objectType play1; //player1's selection
objectType play2; //player2's selection

This program is divided into the following functions, which the ensuing sections
describe in detail.
•

displayRules: This function displays some brief information about the
game and its rules.

•

validSelection: This function checks whether a player’s selection is valid.
The only valid selections are R, r, P, p, S, and s.

•

retrievePlay: Because enumeration types cannot be read directly, this function converts the entered choice (R, r, P, p, S, or s) and returns the
appropriate object type.

•

gameResult: This function outputs the players’ choices and the winner of
the game.

•

convertEnum: This function is called by the function gameResult to
output the enumeration type values.

•

winningObject: This function determines and returns the winning
object.

•

displayResults: After the game is over, this function displays the final
results.

Function This function has no parameters. It consists only of output statements to explain the
displayRules game and rules of play. Essentially, this function’s definition is:
void displayRules()
{
cout << " Welcome to the game of Rock, Paper, "
<< "and Scissors." << endl;
cout << " This is a game for two players. For each "
<< "game, each" << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: The Game of Rock, Paper, and Scissors | 479

cout <<
<<
cout <<
cout <<
<<
cout <<
<<
cout <<
<<
cout <<
<<
cout <<
<<

" player selects one of the objects Rock, "
"Paper, or Scissors." << endl;
" The rules for winning the game are: " << endl;
"1. If both players select the same object, it "
"is a tie." << endl;
"2. Rock breaks Scissors: So player who selects "
"Rock wins." << endl;
"3. Paper covers Rock: So player who selects "
"Paper wins." << endl;
"4. Scissors cuts Paper: So player who selects "
"Scissors wins." << endl << endl;
"Enter R or r to select Rock, P or p to select "
"Paper, and S or s to select Scissors." << endl;

}

Function This function checks whether a player’s selection is valid.
validSelection
if selection is 'R' or 'r' or 'S' or 's' or 'P' or 'p', then
it is a valid selection;
otherwise the selection is invalid.

Let’s use a switch statement to check for the valid selection. The definition of this
function is:
bool validSelection(char selection)
{
switch (selection)
{
case 'R':
case 'r':
case 'P':
case 'p':
case 'S':
case 's':
return true;
default:
return false;
}
}

Function Because the enumeration type cannot be read directly, this function converts the entered
retrievePlay choice (R, r, P, p, S, or s) and returns the appropriate object type. This function thus has
one parameter, of type char. It is a value-returning function, and it returns a value of
type objectType. In pseudocode, the algorithm of this function is:
if selection is 'R' or 'r'
return ROCK;
if selection is 'P' or 'p'
return PAPER;
if selection is 'S' or 's'
return SCISSORS;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

480 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

The definition of the function retrievePlay is:
objectType retrievePlay(char selection)
{
objectType object;
switch (selection)
{
case 'R':
case 'r':
object = ROCK;
break;
case 'P':
case 'p':
object = PAPER;
break;
case 'S':
case 's':
object = SCISSORS;
}
return object;
}

Function This function decides whether a game is a tie or which player is the winner. It
gameResult outputs the players’ selections and the winner of the game. Clearly, this function has

three parameters: player 1’s choice, player 2’s choice, and a parameter to return the
winner. In pseudocode, this function is:
a. if player1 and player2 have the same selection, then
this is a tie game.
b. else
{
1. Determine the winning object. (Call function winningObject)
2. Output each player's choice.
3. Determine the winning player.
4. Return the winning player via a reference parameter to the
function main so that the function main can update the
winning player's win count.
}

The definition of this function is:
void gameResult(objectType play1, objectType play2,
int& winner)
{
objectType winnerObject;
if (play1 == play2)
{
winner = 0;
cout << "Both players selected ";

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: The Game of Rock, Paper, and Scissors | 481

convertEnum(play1);
cout << ". This game is a tie." << endl;
}
else
{
winnerObject = winningObject(play1, play2);
//Output each player's choice
cout << "Player 1 selected ";
convertEnum(play1);
cout << " and player 2 selected ";
convertEnum(play2);
cout << ". ";
//Decide the winner
if (play1 == winnerObject)
winner = 1;
else if (play2 == winnerObject)
winner = 2;
//Output the winner
cout << "Player " << winner << " wins this game."
<< endl;
}
}

Function Because enumeration types cannot be output directly, let’s write the function
convertEnum convertEnum to output objects of the enum type objectType. This function
has one parameter, of type objectType. It outputs the string that corresponds to the
objectType. In pseudocode, this function is:
if object is ROCK
output "Rock"
if object is PAPER
output "Paper"
if object is SCISSORS
output "Scissors"

The definition of the function convertEnum is:
void convertEnum(objectType object)
{
switch (object)
{
case ROCK:
cout << "Rock";
break;
case PAPER:
cout << "Paper";
break;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

482 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

case SCISSORS:
cout << "Scissors";
}
}

Function To decide the winner of the game, you look at the players’ selections and then at the
winningObject rules of the game. For example, if one player chooses ROCK and another chooses
PAPER, the player who chose PAPER wins. In other words, the winning object is
PAPER. The function winningObject, given two objects, decides and returns the
winning object. Clearly, this function has two parameters of type objectType, and
the value returned by this function is also of type objectType. The definition of

this function is:
objectType winningObject(objectType play1, objectType play2)
{
if ((play1 == ROCK && play2 == SCISSORS)
|| (play2 == ROCK && play1 == SCISSORS))
return ROCK;
else if ((play1 == ROCK && play2 == PAPER)
|| (play2 == ROCK && play1 == PAPER))
return PAPER;
else
return SCISSORS;
}

Function After the game is over, this function outputs the final results—that is, the total
displayResults number of plays and the number of plays won by each player. The total number of
plays is stored in the variable gameCount, the number of plays won by player 1 is
stored in the variable winCount1, and the number of plays won by player 2 is stored
in the variable winCount2. This function has three parameters corresponding to

these three variables. Essentially, the definition of this function is:
void displayResults(int gCount, int wCount1, int wCount2)
{
cout << "The total number of plays: " << gCount
<< endl;
cout << "The number of plays won by player 1: "
<< wCount1 << endl;
cout << "The number of plays won by player 2: "
<< wCount2 << endl;
}

We are now ready to write the algorithm for the function main.
MAIN
ALGORITHM

1.
2.
3.
4.

Declare the variables.
Initialize the variables.
Display the rules.
Prompt the users to play the game.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: The Game of Rock, Paper, and Scissors

|

483

5. Get the users’ responses to play the game.
6. while (response is yes)
{

a.
b.
c.
d.
e.

Prompt player 1 to make a selection.
Get the play for player 1.
Prompt player 2 to make a selection.
Get the play for player 2.
If both plays are legal:
{

i. Increment the total game count.
ii. Declare the winner of the game.
iii. Increment the winner’s game win count by 1.
}

f. Prompt the users to determine whether they want to play again.
g. Get the players’ responses.
}

7. Output the game results.
PROGRAM LISTING
//*************************************************************
// Author: D.S. Malik
//
// Program: Rock, Paper, and Scissors
// This program plays the game of rock, paper, and scissors.
//*************************************************************
#include <iostream>
using namespace std;
enum objectType {ROCK, PAPER, SCISSORS};
//Function prototypes
void displayRules();
objectType retrievePlay(char selection);
bool validSelection(char selection);
void convertEnum(objectType object);
objectType winningObject(objectType play1, objectType play2);
void gameResult(objectType play1, objectType play2, int& winner);
void displayResults(int gCount, int wCount1, int wCount2);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

484 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

int main()
{
//Step 1
int gameCount; //variable to store the number of
//games played
int winCount1; //variable to store the number of games
//won by player 1
int winCount2; //variable to store the number of games
//won by player 2
int gamewinner;
char response; //variable to get the user's response to
//play the game
char selection1;
char selection2;
objectType play1; //player1's selection
objectType play2; //player2's selection
//Initialize variables; Step 2
gameCount = 0;
winCount1 = 0;
winCount2 = 0;
displayRules();

//Step 3

cout << "Enter Y/y to play the game: ";
cin >> response;
cout << endl;
while (response == 'Y' || response == 'y')
{
cout << "Player 1 enter your choice: ";
cin >> selection1;
cout << endl;

//Step 4
//Step 5

cout << "Player 2 enter your choice: ";
cin >> selection2;
cout << endl;

//Step 6
//Step 6a
//Step 6b
//Step 6c
//Step 6d

//Step 6e
if (validSelection(selection1)
&& validSelection(selection2))
{
play1 = retrievePlay(selection1);
play2 = retrievePlay(selection2);
gameCount++;
//Step 6e.i
gameResult(play1, play2, gamewinner); //Step 6e.ii
if (gamewinner == 1)
winCount1++;
else if (gamewinner == 2)
winCount2++;
}//end if

//Step 6e.iii

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Namespaces

cout << "Enter Y/y to play the game: ";
cin >> response;
cout << endl;
}//end while
displayResults(gameCount, winCount1,
winCount2);

|

485

//Step 6f
//Step 6g

//Step 7

return 0;
}//end main
//Place the definitions of the functions displayRules,
//validSelection, retrievePlay, convertEnum, winningObject,
//gameResult, and displayResults as described previously here.

Namespaces
In July 1998, ANSI/ISO Standard C++ was officially approved. Most recent compilers
are also compatible with ANSI/ISO Standard C++. (To be absolutely sure, check your
compiler’s documentation.) The two standards, Standard C++ and ANSI/ISO Standard
C++, are virtually the same. The ANSI/ISO Standard C++ language has some features
that are not available in Standard C++, which the remainder of this chapter addresses.
In subsequent chapters, unless specified otherwise, the C++ syntax applies to both
standards. First, we discuss the namespace mechanism of the ANSI/ISO Standard
C++, which was introduced in Chapter 2.
When a header file, such as iostream, is included in a program, the global identifiers in the
header file also become the global identifiers in the program. Therefore, if a global identifier
in a program has the same name as one of the global identifiers in the header file, the
compiler generates a syntax error (such as ‘‘identifier redefined’’). The same problem can
occur if a program uses third-party libraries. To overcome this problem, third-party vendors
begin their global identifiers with a special symbol. In Chapter 2, you learned that because
compiler vendors begin their global identifier names with an underscore (_), to avoid linking
errors, you should not begin identifier names in your program with an underscore (_).
ANSI/ISO Standard C++ tries to solve this problem of overlapping global identifier
names with the namespace mechanism.
The general syntax of the statement namespace is:
namespace namespace_name
{
members
}

where members is usually named constants, variable declarations, functions, or another
namespace. Note that namespace_name is a C++ identifier.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

486 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

In C++, namespace is a reserved word.
EXAMPLE 7-8
The statement:
namespace globalType
{
const int N = 10;
const double RATE = 7.50;
int count = 0;
void printResult();
}

defines globalType to be a namespace with four members: named constants N and
RATE, the variable count, and the function printResult.
The scope of a namespace member is local to the namespace. You can usually
access a namespace member outside the namespace in one of two ways, as described
below.
The general syntax for accessing a namespace member is:
namespace_name::identifier

Recall that in C++, :: is called the scope resolution operator.
To access the member RATE of the namespace globalType, the following statement is
required:
globalType::RATE

To access the member printResult (which is a function), the following statement is
required:
globalType::printResult();

Thus, to access a member of a namespace, you use the namespace_name, followed by
the scope resolution operator, followed by the member name.
To simplify the accessing of a namespace member, ANSI/ISO Standard C++ provides
the use of the statement using. The syntax to use the statement using is as follows:
a.

To simplify the accessing of all namespace members:
using namespace namespace_name;

b. To simplify the accessing of a specific namespace member:
using namespace_name::identifier;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Namespaces

|

487

For example, the using statement:
using namespace globalType;

simplifies the accessing of all members of the namespace globalType. The statement:
using globalType::RATE;

simplifies the accessing of the member RATE of the namespace globalType.
In C++, using is a reserved word.
You typically put the using statement after the namespace declaration. For the
namespace globalType, for example, you usually write the code as follows:
namespace globalType
{
const int N = 10;
const double RATE = 7.50;
int count = 0;
void printResult();
}
using namespace globalType;

After the using statement, to access a namespace member, you do not have to put the
namespace_name and the scope resolution operator before the namespace member.
However, if a namespace member and a global identifier in a program have the same
name, to access this namespace member in the program, the namespace_name and
the scope resolution operator must precede the namespace member. Similarly, if a
namespace member and an identifier in a block have the same name, to access this
namespace member in the block, the namespace_name and the scope resolution
operator must precede the namespace member.
Examples 7-9 through 7-12 help clarify the use of the namespace mechanism.
EXAMPLE 7-9
Consider the following C++ code:
#include <iostream>
using namespace std;
.
.
.
int main()
{
.
.
.
}
.
.
.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

488 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

In this example, you can refer to the global identifiers of the header file iostream, such
as cin, cout, and endl, without using the prefix std:: before the identifier name. The
obvious restriction is that the block (or function) that refers to the global identifier (of the
header file iostream) must not contain any identifier with the same name as this global
identifier.

EXAMPLE 7-10
Consider the following C++ code:
#include <cmath>
int main()
{
double x = 15.3;
double y;
y = std::pow(x, 2);
.
.
.
}

This example accesses the function pow of the header file cmath.

EXAMPLE 7-11
Consider the following C++ code:
#include <iostream>
.
.
.
int main()
{
using namespace std;
.
.
.
}
.
.
.

In this example, the function main can refer to the global identifiers of the header file
iostream without using the prefix std:: before the identifier name. The using

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Namespaces

|

489

statement appears inside the function main. Therefore, other functions (if any) should use
the prefix std:: before the name of the global identifier of the header file iostream
unless the function has a similar using statement.

EXAMPLE 7-12
Consider the following C++ code:
#include <iostream>
using namespace std;

//Line 1

int t;
double u;

//Line 2
//Line 3

namespace expN
{
int x;
char t;
double u;
void printResult();
}

//Line
//Line
//Line
//Line

4
5
6
7

using namespace expN;
int main()
{
int one;
double t;
double three;

//Line 8
//Line 9
//Line 10

.
.
.
}
void expN::printResult() //Definition of the function printResult
{
.
.
.
}

In this C++ program:
1. To refer to the variable t in Line 2 in main, use the scope resolution
operator, which is :: (that is, refer to t as ::t), because the function
main has a variable named t (declared in Line 9). For example, to copy
the value of x into t, you can use the statement ::t = x;.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

490 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

2. To refer to the member t (declared in Line 5) of the namespace expN
in main, use the prefix expN:: with t (that is, refer to t as expN::t)
because there is a global variable named t (declared in Line 2) and a
variable named t in main.
3. To refer to the member u (declared in Line 6) of the namespace expN
in main, use the prefix expN:: with u (that is, refer to u as expN::u)
because there is a global variable named u (declared in Line 3).
4. You can reference the member x (declared in Line 4) of the namespace
expN in main as either x or expN::x because there is no global
identifier named x and the function main does not contain any identifier
named x.
5. The definition of a function that is a member of a namespace, such
as printResult, is usually written outside the namespace as in
the preceding program. To write the definition of the function
printResult, the name of the function in the function heading
can be either printResult or expN::printResult (because no
other global identifier is named printResult).
The identifiers in the system-provided header files, such as iostream, cmath, and
iomanip, are defined in the namespace std. For this reason, to simplify the
accessing of identifiers from these header files, we have been using the following
statement in the programs that we write:

using namespace std;

string Type
In Chapter 2, you were introduced to the data type string. Recall that prior to the
ANSI/ISO C++ language standard, the Standard C++ library did not provide a string
data type. Compiler vendors often supplied their own programmer-defined string
type, and the syntax and semantics of string operations often varied from vendor to
vendor.
The data type string is a programmer-defined type and is not part of the C++
language; the C++ standard library supplies it. Before using the data type string, the
program must include the header file string, as follows:
#include <string>

Recall that in C++, a string is a sequence of zero or more characters, and strings are
enclosed in double quotation marks.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

string Type |

491

The statement:
string name = "William Jacob";

declares name to be a string variable and initializes name to "William Jacob".
The position of the first character, W, in name is 0; the position of the second character,
i, is 1; and so on. That is, the position of the first character in a string variable starts
with 0, not 1.
The variable name can store (just about) any size string.
Chapter 3 discussed I/O operations on the string type; Chapter 4 explained relational
operations on the string type. We recommend that you revisit Chapters 3 and 4 and
review the I/O and relational operations on the string type.
Other operators, such as the binary operator + (to allow the string concatenation
operation) and the array index (subscript) operator [], have also been defined for the
data type string. Let’s see how these operators work on the string data type.
Suppose you have the following declarations:
string str1, str2, str3;

The statement:
str1 = "Hello There";

stores the string "Hello There" in str1. The statement:
str2 = str1;

copies the value of str1 into str2.
If str1 = "Sunny", the statement:
str2 = str1 + " Day";

stores the string "Sunny Day" into str2.
Suppose str1 = "Hello" and str2 = "There". The statement:
str3 = str1 + " " + str2;

stores "Hello There" into str3. This statement is equivalent to the statement:
str3 = str1 + ' ' + str2;

Also, the statement:
str1 = str1 + " Mickey";

updates the value of str1 by appending the string " Mickey" to its old value. Therefore,
the new value of str1 is "Hello Mickey".

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

492 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

For the operator + to work with the string data type, one of the operands of + must be a
string variable. For example, the following statements will not work:

str1 = "Hello " + "there!"; //illegal
str2 = "Sunny Day" + '!';
//illegal

If str1 = "Hello there", the statement:
str1[6] = 'T';

replaces the character t with the character T. Recall that the position of the first character
in a string variable is 0. Therefore, because t is the seventh character in str1, its
position is 6.
In C++, [] is called the array subscript operator.
As illustrated previously, using the array subscript operator together with the position of
the character, you can access an individual character within a string.
EXAMPLE 7-13
The following program shows the effect of the preceding statements.
//Example string operations
#include <iostream>
#include <string>
using namespace std;
int main()
{
string name = "William Jacob";
string str1, str2, str3, str4;

//Line 1
//Line 2

cout << "Line 3: Name = " << name << endl;

//Line 3

str1 = "Hello There";
cout << "Line 5: str1 = " << str1 << endl;

//Line 4
//Line 5

str2 = str1;
cout << "Line 7: str2 = " << str2 << endl;

//Line 6
//Line 7

str1 = "Sunny";
str2 = str1 + " Day";
cout << "Line 10: str2 = " << str2 << endl;

//Line 8
//Line 9
//Line 10

str1
str2
str3
cout

//Line
//Line
//Line
//Line

= "Hello";
= "There";
= str1 + " " + str2;
<< "Line 14: str3 = " << str3 << endl;

11
12
13
14

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

string Type |

str3 = str1 + ' ' + str2;
cout << "Line 16: str3 = " << str3 << endl;

//Line 15
//Line 16

str1 = str1 + " Mickey";
cout << "Line 18: str1 = " << str1 << endl;

//Line 17
//Line 18

str1 = "Hello there";
cout << "Line 20: str1[6 ] = " << str1[6 ]
<< endl;

//Line 19

str1[6] = 'T';
cout << "Line 22: str1 = " << str1 << endl;

//Line 21
//Line 22

//String input operations
cout << "Line 23: Enter a string with "
<< "no blanks: ";
cin >> str1;

//Line 23
//Line 24

char ch;
cin.get(ch);
cout << endl;

493

//Line 20

//Line 25
//Read the newline character; Line 26
//Line 27

7

cout << "Line 28: The string you entered = "
<< str1 << endl;

//Line 28

cout << "Line 29: Enter a sentence: ";
getline(cin, str2);
cout << endl;

//Line 29
//Line 30
//Line 31

cout << "Line 32: The sentence is: " << str2
<< endl;

//Line 32

return 0;
}

Sample Run: In the following sample run, the user input is shaded.
Line
Line
Line
Line
Line
Line
Line
Line
Line
Line

3: Name = William Jacob
5: str1 = Hello There
7: str2 = Hello There
10: str2 = Sunny Day
14: str3 = Hello There
16: str3 = Hello There
18: str1 = Hello Mickey
20: str1[6] = t
22: str1 = Hello There
23: Enter a string with no blanks: Programming

Line 28: The string you entered = Programming
Line 29: Enter a sentence: Testing string operations
Line 32: The sentence is: Testing string operations

The preceding output is self-explanatory, and its unraveling is left as an exercise for you.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

494 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

Additional string Operations
The data type string has a data type, string::size_type, and a named constant,
string::npos, defined as follows:
string::size_type
string::npos

An unsigned integer (data) type
The maximum value of the (data) type string::size_type,
a number such as 4294967295 on many machines

The data type string contains several other functions for string manipulation. The
following table describes some of these functions. In this table, we assume that strVar is
a string variable and str is a string variable, a string constant, or a character array.
(Arrays are discussed in Chapter 8.)
TABLE 7-1

Some string functions

Expression

Effect

strVar.at(index)

Returns the element at the position specified by
index.

strVar[index]

Returns the element at the position specified by
index.

strVar.append(n, ch)

Appends n copies of ch to strVar, in which
ch is a char variable or a char constant.

strVar.append(str)

Appends str to strVar.

strVar.clear()

Deletes all the characters in strVar.

strVar.compare(str)

Returns 1 if strVar > str; returns 0
if strVar == str; returns -1
if strVar < str.

strVar.empty()

Returns true if strVar is empty; otherwise,
it returns false.

strVar.erase()

Deletes all the characters in strVar.

strVar.erase(pos, n)

Deletes n characters from strVar starting at
position pos.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

string Type |

TABLE 7-1

495

Some string functions (continued)

Expression

Effect

strVar.find(str)

Returns the index of the first occurrence of str
in strVar. If str is not found, the special
value string::npos is returned.

strVar.find(str, pos)

Returns the index of the first occurrence at or
after pos where str is found in strVar.

strVar.find_first_of
(str, pos)

Returns the index of the first occurrence of any
character of strVar in str. The search starts
at pos.

strVar.find_first_not_of
(str, pos)

Returns the index of the first occurrence of any
character of str not in strVar. The search
starts at pos.

strVar.insert(pos, n, ch);

Inserts n occurrences of the character ch at
index pos into strVar; pos and n are of type
string::size_type; ch is a character.

strVar.insert(pos, str);

Inserts all the characters of str at index pos
into strVar.

strVar.length()

Returns a value of type string::size_type
giving the number of characters strVar.

strVar.replace(pos, n,
str);

Starting at index pos, replaces the next n
characters of strVar with all the characters of
str. If n > length of strVar, then all the
characters until the end of strVar are
replaced.

strVar.substr(pos, len)

Returns a string that is a substring of strVar
starting at pos. The length of the substring is at
most len characters. If len is too large, it
means ‘‘to the end‘‘ of the string in strVar.

strVar.size()

Returns a value of type string::size_type
giving the number of characters strVar.

strVar.swap(str1);

Swaps the contents of strVar and str1.
str1 is a string variable.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

496 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

Next, we show how some of these functions work.
E X A M P L E 7 - 1 4 (clear, empty, erase, length, AND size FUNCTIONS)
Consider the following statements:
string
string
string
string
string
string
string

firstName = "Elizabeth";
name = firstName + " Jones";
str1 = "It is sunny.";
str2 = "";
str3 = "computer science";
str4 = "C++ programming.";
str5 = firstName + " is taking " + str4;

string::size_type len;

Next, we show the effect of clear, empty, erase, length, and size functions.
Statement
str3.clear();
str1.empty();
str2.empty();
str4.erase(11, 4);
cout << firstName.length() << endl;
cout << name.length() << endl;
cout << str1.length() << endl;
cout << str5.size() << endl;
len = name.length();

Effect
str3 ¼ "";
Returns false
Returns true
str4 ¼ "C++ program.";
Outputs 9
Outputs 15
Outputs 12
Outputs 36
The value of len is 15

The following program illustrates the use of the length function.
//Example: clear, empty, erase, length, and size functions
#include <iostream>
#include <string>
using namespace std;
int main()
{
string
string
string
string
string
string
string

firstName = "Elizabeth";
name = firstName + " Jones";
str1 = "It is sunny.";
str2 = "";
str3 = "computer science";
str4 = "C++ programming.";
str5 = firstName + " is taking " + str4;

//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

string Type |

string::size_type len;

//Line 8

cout << "Line 9: str3: " << str3 << endl;
str3.clear();
cout << "Line 11: After clear, str3: " << str3
<< endl;

//Line 9
//Line 10

cout <<
<<
cout <<
<<

"Line 12: str1.empty(): " << str1.empty()
endl;
"Line 13: str2.empty(): " << str2.empty()
endl;

cout << "Line 14: str4: " << str4 << endl;
str4.erase(11, 4);
cout << "Line 16: After erase(11, 4), str4: "
<< str4 << endl;
cout <<
<<
<<
cout <<
<<
<<
cout <<
<<
<<
cout <<
<<
<<

497

//Line 11
//Line 12
//Line 13
//Line 14
//Line 15
//Line 16

"Line 17: Length of \"" << firstName << "\" = "
static_cast<unsigned int> (firstName.length())
endl;
//Line
"Line 18: Length of \"" << name << "\" = "
static_cast<unsigned int> (name.length())
endl;
//Line
"Line 19: Length of \"" << str1 << "\" = "
static_cast<unsigned int> (str1.length())
endl;
//Line
"Line 20: Size of \"" << str5 << "\" = "
static_cast<unsigned int> (str5.size())
endl;
//Line

17
18
19
20

//Line 21

len = name.length();
cout << "Line 22: len = "
<< static_cast<unsigned int> (len) << endl;

//Line 22

return 0;

//Line 23

}

Sample Run:
Line
Line
Line
Line
Line
Line
Line
Line
Line
Line
Line

9: str3: computer science
11: After clear, str3:
12: str1.empty(): 0
13: str2.empty(): 1
14: str4: C++ programming.
16: After erase(11, 4), str4: C++ program.
17: Length of "Elizabeth" = 9
18: Length of "Elizabeth Jones" = 15
19: Length of "It is sunny." = 12
20: Size of "Elizabeth is taking C++ programming." = 36
22: len = 15

The output of this program is self-explanatory. The details are left as an exercise for you.
Notice that this program uses the static cast operator to output the value returned by the

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

498 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

function length. This is because the function length returns a value of the type
string::size_type. Without the cast operator, some compilers might give the
following warning message:
conversion from 'size_t' to 'unsigned int', possible loss of data

EXAMPLE 7-15 (find FUNCTION)
Suppose str1 and str2 are of type string. The following are valid calls to the
function find:
str1.find(str2)
str1.find("the")
str1.find('a')
str1.find(str2 + "xyz")
str1.find(str2 + 'b')

Consider the following statements:
string sentence = "Outside it is cloudy and warm.";
string str = "cloudy";
string::size_type position;

Next, we show the effect of the find function.
Statement
cout << sentence.find("is") << endl;
cout << sentence.find('s') << endl;
cout << sentence.find(str) << endl;
cout << sentence.find("the") << endl;
cout << sentence.find('i', 6) << endl;
position = sentence.find("warm");

Effect
Outputs 11
Outputs 3
Outputs 14
Outputs the value of string::npos
Outputs 8
Assigns 25 to position

Note that the search is case sensitive. Therefore, the position of o (lowercase o) in the
string sentence is 16.
The following program evaluates the previous statements.
//Example: find function
#include <iostream>
#include <string>
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

string Type |

499

int main()
{
string sentence = "Outside it is cloudy and warm."; //Line 1
string str = "cloudy";
//Line 2
string::size_type position;

//Line 3

cout << "Line 4: sentence = \"" << sentence
<< "\"" << endl;

//Line 4

cout << "Line 5: The position of \"is\" in sentence = "
<< static_cast<unsigned int> (sentence.find("is"))
<< endl;
//Line 5
cout << "Line 6: The position of 's' in sentence = "
<< static_cast<unsigned int> (sentence.find('s'))
<< endl;
//Line 6
cout <<
<<
<<
<<

"Line 7: The position of \"" << str
"\" in sentence = "
static_cast<unsigned int> (sentence.find(str))
endl;
//Line 7

cout << "Line 8: The position of \"the\" in sentence = "
<< static_cast<unsigned int> (sentence.find("the"))
<< endl;
//Line 8
cout <<
<<
<<
<<

"Line 9: The first occurrence of \'i\' in "
"sentence \n
after position 6 = "
static_cast<unsigned int> (sentence.find('i', 6))
endl;
//Line 9

position = sentence.find("warm");
cout << "Line 11: " << "Position = "
<< position << endl;

//Line 10

return 0;

//Line 12

//Line 11

}

Sample Run:
Line
Line
Line
Line
Line
Line

4:
5:
6:
7:
8:
9:

sentence = "Outside it is cloudy and warm."
The position of "is" in sentence = 11
The position of 's' in sentence = 3
The position of "cloudy" in sentence = 14
The position of "the" in sentence = 4294967295
The first occurrence of 'i' in sentence
after position 6 = 8
Line 11: Position = 25

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

500 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

The output of this program is self-explanatory. The details are left as an exercise for you.
Notice that this program uses the static cast operator to output the value returned by
the function find. This is because the function find returns a value of the type
string::size_type. Without the cast operator, some compilers might give the
following warning message:
conversion from 'size_t' to 'unsigned int', possible loss of data

EXAMPLE 7-16 (insert AND replace FUNCTIONS)
Suppose that you have the following statements:
string
string
string
string
string

firstString = "Cloudy and warm.";
secondString ="Hello there";
thirdString = "Henry is taking programming I.";
str1 = " very ";
str2 = "Lisa";

Next, we show the effect of insert and replace functions.
Statement
firstString.insert(10, str1);

Effect
firstString = "Cloudy and very
warm."
secondString.insert(11, 5, '!'); secondString = "Hello there!!!!!"
thirdString.replace(0, 5, str2); thirdString = "Lisa is taking
programming I."

The following program evaluates the previous statements.
//Example: insert and replace functions
#include <iostream>
#include <string>
using namespace std;
int main()
{
string firstString = "Cloudy and warm.";
//Line 1
string secondString = "Hello there";
//Line 2
string thirdString = "Henry is taking programming I."; //Line 3

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

string Type |

string str1 = " very ";
string str2 = "Lisa";
cout << "Line 6: firstString = " << firstString
<< endl;
firstString.insert(10, str1);
cout << "Line 8: After insert; firstString = "
<< firstString << endl;
cout << "Line 9: secondString = " << secondString
<< endl;
secondString.insert(11, 5, '!');
cout << "Line 11: After insert; secondString = "
<< secondString << endl;
cout << "Line 12: thirdString = " << thirdString
<< endl;
thirdString.replace(0, 5, str2);
cout << "Line 14: After replace, thirdString = "
<< thirdString << endl;
return 0;

501

//Line 4
//Line 5
//Line 6
//Line 7
//Line 8
//Line 9
//Line 10
//Line 11
//Line 12
//Line 13
//Line 14
//Line 15

}

Sample Run:
Line
Line
Line
Line
Line
Line

6: firstString = Cloudy and warm.
8: After insert; firstString = Cloudy and very warm.
9: secondString = Hello there
11: After insert; secondString = Hello there!!!!!
12: thirdString = Henry is taking programming I.
14: After replace, thirdString = Lisa is taking programming I.

The output of this program is self-explanatory. The details are left as an exercise
for you.

EXAMPLE 7-17 (substr FUNCTION)
Consider the following statements:
string sentence;
string str;
sentence = "It is cloudy and warm.";

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

502 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

Next, we show the effect of the substr function.
Statement
cout << sentence.substr(0, 5) << endl;
cout << sentence.substr(6, 6) << endl;
cout << sentence.substr(6, 16) << endl;
cout << sentence.substr(17, 10) << endl;
cout << sentence.substr(3, 6) << endl;
str = sentence.substr(0, 8);
str = sentence.substr(2, 10);

Effect
Outputs: It is
Outputs: cloudy
Outputs: cloudy and warm.
Outputs: warm.
Outputs: is clo

str = "It is cl"
str = " is cloudy"

The following program illustrates how to use the string function substr.
//Example: substr function
#include <iostream>
#include <string>
using namespace std;
int main()
{
string sentence;
string str;

//Line 1
//Line 2

sentence = "It is cloudy and warm.";

//Line 3

cout << "Line 4: substr(0, 5) in \""
<< sentence << "\" = \""
<< sentence.substr(0, 5) << "\"" << endl;

//Line 4

cout << "Line 5: substr(6, 6) in \""
<< sentence << "\" = \""
<< sentence.substr(6, 6) << "\"" << endl;

//Line 5

cout <<
<<
<<
<<

//Line 6

"Line 6: substr(6, 16) in \""
sentence << "\" = " << endl
"
\"" << sentence.substr(6, 16)
"\"" << endl;

cout << "Line 7: substr(17, 10) in \""
<< sentence << "\" = \""
<< sentence.substr(17, 10) << "\"" << endl; //Line 7
cout << "Line 8: substr(3, 6) in \""
<< sentence << "\" = \""
<< sentence.substr(3, 6) << "\"" << endl;

//Line 8

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

string Type |

str = sentence.substr(0, 8);
cout << "Line 10: " << "str = \"" << str
<< "\"" << endl;

//Line 9

str = sentence.substr(2, 10);
cout << "Line 12: " << "str = \"" << str
<< "\"" << endl;

//Line 11

503

//Line 10

//Line 12

return 0;
}

Sample Run:
Line 4: substr(0, 5) in "It is cloudy and warm." = "It is"
Line 5: substr(6, 6) in "It is cloudy and warm." = "cloudy"
Line 6: substr(6, 16) in "It is cloudy and warm." =
"cloudy and warm."
Line 7: substr(17, 10) in "It is cloudy and warm." = "warm."
Line 8: substr(3, 6) in "It is cloudy and warm." = "is clo"
Line 10: str = "It is cl"
Line 12: str = " is cloudy"

The output of this program is self-explanatory. The details are left as an exercise for you.

EXAMPLE 7-18 (swap FUNCTION)
The swap function is used to swap—that is, interchange—the contents of two string
variables.
Suppose you have the following statements:
string str1 = "Warm";
string str2 = "Cold";

After the following statement executes, the value of str1 is "Cold" and the value of
str2 is "Warm".
str1.swap(str2);

Additional string functions are described in Appendix F (Header File string).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

504 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

PROGRAMMING EXAMPLE:

Pig Latin Strings

In this programming example, we write a program that prompts the user to input a
string and then outputs the string in the pig Latin form. The rules for converting a
string into pig Latin form are as follows:
1. If the string begins with a vowel, add the string "-way" at the end
of the string. For example, the pig Latin form of the string "eye" is
"eye-way".
2. If the string does not begin with a vowel, first add "-" at the end of
the string. Then rotate the string one character at a time; that is,
move the first character of the string to the end of the string until the
first character of the string becomes a vowel. Then add the string
"ay" at the end. For example, the pig Latin form of the string
"There" is "ere-Thay".
3. Strings such as "by" contain no vowels. In cases like this, the letter
y can be considered a vowel. So, for this program, the vowels are
a, e, i, o, u, y, A, E, I, O, U, and Y. Therefore, the pig Latin form
of "by" is "y-bay".
4. Strings such as "1234" contain no vowels. The pig Latin form
of the string "1234" is "1234-way". That is, the pig Latin form
of a string that has no vowels in it is the string followed by the
string "-way".

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Input

Input to the program is a string.

Output

Output of the program is the string in the pig Latin form.

Suppose that str denotes a string. To convert str into pig Latin, check the first
character, str[0], of str. If str[0] is a vowel, add "-way" at the end of str—
that is, str = str + "-way".
Suppose that the first character of str, str[0], is not a vowel. First, add "-" at the
end of the string. Then, remove the first character of str from str and put it at the
end of str. Now, the second character of str becomes the first character of str.
This process of checking the first character of str and moving it to the end of str if
the first character of str is not a vowel is repeated until either the first character of
str is a vowel or all the characters of str are processed, in which case str does not
contain any vowels.
In this program, we write a function isVowel to determine whether a character is a
vowel, a function rotate to move the first character of str to the end of str, and

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Pig Latin Strings |

505

a function pigLatinString to find the pig Latin form of str. The previous
discussion translates into the following algorithm:
1. Get str.
2. Find the pig Latin form of str by using the function pigLatinString.
3. Output the pig Latin form of str.
Before writing the main algorithm, each of these functions is described in detail.
Function This function takes a character as a parameter and returns true if the character is
isVowel a vowel and false otherwise. The definition of the function isVowel is:
bool isVowel(char ch)
{
switch (ch)
{
case 'A':
case 'E':
case 'I':
case 'O':
case 'U':
case 'Y':
case 'a':
case 'e':
case 'i':
case 'o':
case 'u':
case 'y':
return true;
default:
return false;
}
}

Function This function takes a string as a parameter, removes the first character of the string,
rotate and places it at the end of the string. This is done by extracting the substring, starting
at position 1 (which is the second character) until the end of the string, and then

adding the first character of the string. The new string is returned as the value of this
function. Essentially, the definition of the function rotate is:
string rotate(string pStr)
{
string::size_type len = pStr.length();
string rStr;
rStr = pStr.substr(1, len - 1) + pStr[0];
return rStr;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

506 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

Function This function takes a string, pStr, as a parameter and returns the pig Latin form
pigLatinString of pStr. Suppose pStr denotes the string to be converted to its pig Latin form.
There are three possible cases: pStr[0] is a vowel, pStr contains a vowel and the
first character of pStr is not a vowel, or pStr contains no vowels. Suppose that
pStr[0] is not a vowel. Move the first character of pStr to the end of pStr. This
process is repeated until either the first character of pStr has become a vowel or all
the characters of pStr are checked, in which case pStr does not contain any vowels.

This discussion translates into the following algorithm:
1. If pStr[0] is a vowel, add "-way" at the end of pStr.
2. Suppose pStr[0] is not a vowel.
3. Move the first character of pStr to the end of pStr. The second
character of pStr becomes the first character of pStr. Now pStr may
or may not contain a vowel. We use a bool variable, foundVowel,
which is set to true if pStr contains a vowel and false otherwise.
a. Suppose that len denotes the length of pStr.
b. Initialize foundVowel to false.
c. If pStr[0] is not a vowel, move pStr[0] to the end of pStr
by calling the function rotate.
d. Repeat Step b until either the first character of pStr becomes a
vowel or all the characters of pStr have been checked.
4. Convert pStr into the pig Latin form.
5. Return pStr.
The definition of the function pigLatinString is:
string pigLatinString(string pStr)
{
string::size_type len;
bool foundVowel;
string::size_type counter;
if (isVowel(pStr [0]))
pStr = pStr + "-way";
else
{
pStr = pStr + '-';
pStr = rotate(pStr);
len = pStr.length();
foundVowel = false;

//Step 1
//Step 2
//Step 3
//Step 3.a
//Step 3.b

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Pig Latin Strings |

for (counter = 1; counter < len - 1;
counter++)
if (isVowel(pStr[0]))
{
foundVowel = true;
break;
}
else
pStr = rotate(pStr);

507

//Step 3.d

//Step 3.c

if (!foundVowel)
//Step 4
pStr = pStr.substr(1, len) + "-way";
else
pStr = pStr + "ay";
}
return pStr;

//Step 5

}
MAIN
ALGORITHM

1. Get the string.
2. Call the function pigLatinString to find the pig Latin form of
the string.
3. Output the pig Latin form of the string.
PROGRAM LISTING
//*************************************************************
// Author: D.S. Malik
//
// Program: Pig Latin Strings
// This program reads a string and outputs the pig Latin form
// of the string.
//*************************************************************
#include <iostream>
#include <string>
using namespace std;
bool isVowel(char ch);
string rotate(string pStr);
string pigLatinString(string pStr);
int main()
{
string str;
cout << "Enter a string: ";
cin >> str;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

508 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

cout << endl;
cout << "The pig Latin form of " << str << " is: "
<< pigLatinString(str) << endl;
return 0;
}
//Place the definitions of the functions isVowel, rotate, and
//pigLatinString and as described previously here.

Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1:
Enter a string: eye
The pig Latin form of eye is: eye-way

Sample Run 2:
Enter a string: There
The pig Latin form of There is: ere-Thay

Sample Run 3:
Enter a string: why
The pig Latin form of why is: y-whay

Sample Run 4:
Enter a string: 123456
The pig Latin form of 123456 is: 123456-way

QUICK REVIEW
1.
2.
3.

An enumeration type is a set of ordered values.
C++’s reserved word enum is used to create an enumeration type.
The syntax of enum is:
enum typeName {value1, value2,...};

4.

in which value1, value2,. . . are identifiers, and value1 < value2 < . . ..
No arithmetic operations are allowed on the enumeration type.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

5.
6.
7.
8.
9.
10.
11.
12.
13.
14.
15.

16.
17.

18.
19.
20.
21.

22.

509

Relational operators can be used with enum values.
Enumeration type values cannot be input or output directly.
Enumeration types can be passed as parameters to functions either by value
or by reference.
A function can return a value of the enumeration type.
An anonymous type is one in which a variable’s values are specified without
any type name.
C++’s reserved word typedef is used to create synonyms or aliases to
previously defined data types.
Anonymous types cannot be passed as parameters to functions.
The namespace mechanism is a feature of ANSI/ISO Standard C++.
A namespace member is usually a named constant, variable, function, or
another namespace.
The scope of a namespace member is local to the namespace.
One way to access a namespace member outside the namespace is to
precede the namespace member name with the namespace name and
scope resolution operator.
In C++, namespace is a reserved word.
To use the namespace mechanism, the program must include the ANSI/
ISO Standard C++ header files—that is, the header files without the
extension h.
The using statement simplifies the accessing of namespace members.
In C++, using is a reserved word.
The keyword namespace must appear in the using statement.
When accessing a namespace member without the using statement, the
namespace name and the scope resolution operator must precede the
name of the namespace member.
To use an identifier declared in the standard header files without the
namespace name, after including all the necessary header files, the following statement must appear in the program:
using namespace std;

23.
24.
25.

26.
27.

A string is a sequence of zero or more characters.
Strings in C++ are enclosed in double quotation marks.
To use the type string, the program must include the header file
string. The other header files used in the program should be ANSI/
ISO Standard C++ style header files.
The assignment operator can be used with the string type.
The operator + can be used to concatenate two values of the type string.
For the operator + to work with the string data type, one of the operands
of + must be a string variable.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

510 |

28.

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

Relational operators, discussed in Chapter 4, can be applied to the string
type.
In a string, the position of the first character is 0, the position of the second
character is 1, and so on.
The length of a string is the number of characters in the string.
In C++, [] is called the array subscript operator.
To access an individual character within a string, use the array subscript
operator together with the position of the character.
The string type contains functions such as at, append, clear, compare,
erase, find, find_first_of, find_first_not_of, insert, length,
replace, size, substr, and swap to manipulate strings. These functions
are described in Table 7-1.

29.
30.
31.
32.
33.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false. (1)
a.

The following is a valid C++ enumeration type: (1)
enum romanNumerals {I, V, X, L, C, D, M};

b.

Given the declaration:
enum cars {FORD, GM, TOYOTA, HONDA};
cars domesticCars = FORD;

the statement:
domesticCars = domesticCars + 1;

c.
d.

e.

f.
g.

sets the value of domesticCars to GM. (1, 2)
The values in the domain of an enumeration type are called enumerators. (1)
The only arithmetic operations allowed on the enumeration type are
increment and decrement. (2)
You can input the value of an enumeration type directly from a standard
input device. (4)
A function can return a value of an enumeration type. (6)
The following are legal C++ statements in the same block of a C++
program: (1)
enum mathStudent {BILL, JOHN, LISA, RON, CINDY, SHELLY};
enum historyStudent {AMANDA, BOB, JACK, TOM, SUSAN};

h.

The following statement creates an anonymous type: (8)
enum {A, B, C, D, F} studentGrade;

i.

You can use the namespace mechanism with header files with the
extension h. (10)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

j.

k.

|

511

Suppose str = "ABCD";. After the statement str[1] = 'a';, the value
of str is "aBCD". (11)
Suppose str = "abcd". After the statement:
str = str + "ABCD";

2.

the value of str is "ABCD". (11)
Write C++ statements that do the following: (1, 2, 3, 4, 5)
Define an enum type, birdType, with the values PEACOCK, SPARROW,
CANARY, PARROT, PENGUIN, OSTRICH, EAGLE, CARDINAL, and
HUMMINGBIRD.
b. Declare a variable bird of the type birdType.
c. Assign CANARY to the variable bird.
d. Advance bird to the next value in the list.
e. Decrement bird to the previous value in the list.
f. Output the value of the variable bird.
g. Input value in the variable bird.
Given:
a.

3.

enum currencyType {DOLLAR, POUND, FRANK, LIRA, MARK};
currencyType currency;

which of the following statements are valid? (1, 2, 3, 4, 5)

4.

a.

currency = DOLLAR;

b.

cin >> currency;

c.

currency = static_cast<currencyType>(currency + 1);

d.

for (currency = DOLLAR; currency <= MARK; currency++)
cout << "*";

Consider the following declaration:
enum fruitType {ORANGE, APPLE, BANANA, GRAPE, STRAWBERRY, MANGO, GUAVA,
PINEAPPLE, KIWI};
fruitType fruit;

Answer the following questions. (1, 2, 3, 5)
a.
b.

What is the value of static_cast<int>(STRAWBERRY)?
What is the value, if any, of the following expression?
static_cast<fruitType>(static_cast<int>(MANGO) - 2)

c.

What is the value, if any, of the following expression?
static_cast<fruitType>(static_cast<int>(GRAPE) + 2)

d.
e.

What is the value, if any, of the expression: BANANA <= KIWI
What is the output, if any, of the following code?
for (fruit = BANANA; fruit < PINEAPPLE; fruit++)
cout << static_cast<int>(fruit) << ", ";
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

512 |

5.

6.

7.
8.

9.

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

Suppose that the enum birdType is as defined in Exercise 2. Write
a C++ function that can be used to input value in a variable of type
birdType. (7)
Suppose that the enum birdType is as defined in Exercise 2. Write a C++
function that can be used to ouput the value of a variable of type
birdType. (7)
What are some of the drawbacks of an anonymous type? (8)
Define an enumeration type triangleType with values EQUILATERAL,
RIGHT, ISOSCELES, and SCALENE. Also declare the variable triangle of
type triangleType while defining this type. (7)
What is wrong with the following program? (10)
#include <iostream>

//Line 1

namespace std;

//Line 2

int main()
{
cout << "*$*" << endl;

//Line 3
//Line 4
//Line 5

return 0;
}
10.

//Line 6
//Line 7

What is wrong with the following program? (10)
#include <iostream.h>

//Line 1

int main()
//Line 2
{
//Line 3
int num;
//Line 4
std::cin >> num;
//Line 5
std::cout << "num = " << num << endl; //Line 6
return 0;
//Line 7
}
//Line 8
11.

What is wrong with the following program? (10)
#include <iostream>

//Line 1

using namespace sdt;

//Line 2

int main()
{
int x;

//Line 3
//Line 4
//Line 5

}

std::cin >> x;
cout << "x = " << x << endl;

//Line 6
//Line 7

return 0;

//Line 8
//Line 9

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

12.

14.

513

What is wrong with the following program? (10)
#include <iostream>

//Line 1

namespace mySpace
{
const double RATE = 15.35;
int a;
}

//Line
//Line
//Line
//Line
//Line

using namespace std;

//Line 7

int main()
{
int b;

//Line 8
//Line 9
//Line 10

2
3
4
5
6

cin >> b;
a = b;
cout << RATE << " " << a + 2 << " " << b
<< endl;

//Line 11
//Line 12

return 0;

//Line 14
//Line 15

}
13.

|

//Line 13

What is wrong with the following program? (10)
#include <iostream>

//Line 1

namespace aaa
{
const int X = 0;
double y;
}

//Line 2

using namespace std;

//Line 5

int main()
{
y = 34.50;
cout << "X = " << X << ", y = " << y
<< endl;
return 0;
}

//Line 6

//Line 3
//Line 4

//Line 7
//Line 8
//Line 9

What is wrong with the following program? (10)
#include <iostream>
#include <cMath>

//Line 1
//Line 2

using name std;

//Line 3

int main()
{
std::cout << sqrt (14.56) << endl;
return 0;
}

//Line
//Line
//Line
//Line
//Line

4
5
6
7
8

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

514 |

15.

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

Consider the following C++ code:
string str1;
string str2;
char ch;
int index;
cin >> str1;
cin >> str2;
cin >> index;
ch = str1[index];
str1[index] = str2[index];
str2[index] = ch;
cout << str1 << " " << str2 << endl;

Answer the following questions: (11)
a.
b.
c.
16.

What is the output if the input is Hello There 2?
What is the output if the input is Diamond Gold 0?
What is the output if the input is C++ Java 1?

Suppose that you have the following statements:
string str1, str2;
cin >> str1 >> str2;
if (str1 == str2)
cout << str1 + '!' << endl;
else if (str1 > str2)
cout << str1 + " > " + str2 << endl;
else
cout << str1 + " < " + str2 << endl;

Answer the following questions: (11)
a.
b.
c.
17.

What is the output if the input is Programming Project?
What is the output if the input is Summer Trip?
What is the output if the input is Winter Cold?

What is the output of the following program? (11)
#include <iostream>
#include <string>
using namespace std;
int main()
{
string str = "Regular exercise can reduce health insurance cost.";
string str1;
string str2 = "low fat diet";
string newStr;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

515

string::size_type index;
index = str.find("can");
str1 = str.substr(0, index - 1);
cout << str1 << endl;
newStr = str1 + " and " + str2;
cout << newStr << endl;
cout << newStr.length() << endl;
cout << str1.find("ex") << endl;
cout << str2.find('d') << endl;
index = str.find("health");
newStr = str.substr(index, 17);
cout << newStr << endl;
cout << newStr.substr(7, 14) << endl;
index = str.find("cost");
cout << str.replace(index, 4, "$$$$") << endl;
str = "$ocial Nedia!!";
cout << str << endl;
cout << str.length() << endl;
str [0] = 'S';
index = str.find('N');
str [index ] = 'M';
cout << str << endl;
return 0;
}
18.

Consider the following statement:
string str = "Now is the time for the party!";

What is the output of the following statements? (Assume that all parts are
independent of each other.) (11)
a.

cout << str.size() << endl;

b.

cout << str.substr(7, 8) << endl;

c.

string::size_type ind = str.find('f');
string s = str.substr(ind + 4, 9);
cout << s << endl;

d.

cout << str.insert(11, "best ") << endl;

e.

str.erase(16, 14);
str.insert(16, "to study for the exam?");
cout << str << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

516 |

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

PROGRAMMING EXERCISES
1.

2.

3.

4.

5.

Define an enumeration type, triangleType, that has the values
scalene, isosceles, equilateral, and noTriangle.
b. Write a function, triangleShape, that takes as parameters three numbers, each of which represents the length of a side of the triangle. The
function should return the shape of the triangle. (Note: In a triangle, the sum
of the lengths of any two sides is greater than the length of the third side.)
c. Write a program that prompts the user to input the length of the sides of
a triangle and outputs the shape of the triangle.
Redo Programming Exercise 14 of Chapter 4 (cell phone company) so that
all of the named constants are defined in a namespace.
The Programming Example: Pig Latin Strings converts a string into the pig
Latin form, but it processes only one word. Rewrite the program so that it
can be used to process a text of an unspecified length. If a word ends with a
punctuation mark, in the pig Latin form, put the punctuation at the end of
the string. For example, the pig Latin form of Hello! is ello-Hay!.
Assume that the text contains the following punctuation marks: , (comma),
. (period), ? (question mark), ; (semicolon), and : (colon). (Your program
may store the output in a file.)
Write a program that prompts the user to input a string. The program then uses
the function substr to remove all the vowels from the string. For example, if
str = "There", then after removing all the vowels, str = "Thr". After
removing all the vowels, output the string. Your program must contain a
function to remove all the vowels and a function to determine whether a
character is a vowel.
Write a program that can be used to calculate the federal tax. The tax is
calculated as follows: For single people, the standard exemption is $4,000; for
married people, the standard exemption is $7,000. A person can also put up
to 6% of his or her gross income in a pension plan. The tax rates are as
follows: If the taxable income is:
a.

•
•

Between $0 and $15,000, the tax rate is 15%.
Between $15,001 and $40,000, the tax is $2,250 plus 25% of the taxable
income over $15,000.
• Over $40,000, the tax is $8,460 plus 35% of the taxable income over
$40,000.
Prompt the user to enter the following information:
•
•

Marital status
If the marital status is ‘‘married,’’ ask for the number of children under
the age of 14

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

517

•

Gross salary (If the marital status is ‘‘married’’ and both spouses have
income, enter the combined salary.)
• Percentage of gross income contributed to a pension fund
Your program must consist of at least the following functions:
a.
b.

6.

Function getData: This function asks the user to enter the relevant data.
Function taxAmount: This function computes and returns the tax owed.

To calculate the taxable income, subtract the sum of the standard exemption,
the amount contributed to a pension plan, and the personal exemption,
which is $1,500 per person. (Note that if a married couple has two children
under the age of 14, then the personal exemption is $1,500 * 4 = $6,000.)
Write a program that uses a random number generator to generate a two
digit positive integer and allows the user to perform one or more of the
following operations:
a.
b.
c.
d.
e.

f.

Double the number.
Reverse the digits of the number.
Raise the number to the power of 2, 3, or 4.
Sum the digits of the number.
If the number is a two digit number, then raise the first digit to the
power of the second digit.
If the number is a three digit number and the last digit is less than or
equal to 4, then raise the first two digits to the power of the last digit.

After performing an operation if the number is less than 10, add 10 to the
number. Also, after each operation determine if the number is prime.

7.

Each successive operation should be performed on the number generated by
the last operation. Your program should not contain any global variables and
each of these operations must be implemented by a separate function. Also,
your program should be menu driven.
(Fraction calculator) Write a program that lets the user perform arithmetic
operations on fractions. Fractions are of the form a/b, in which a and b are integers
and b 6¼ 0. Your program must be menu driven, allowing the user to select the
operation (+, -, *, or /) and input the numerator and denominator of each fraction.
Furthermore, your program must consist of at least the following functions:
a.

b.

Function menu: This function informs the user about the program’s
purpose, explains how to enter data, and allows the user to select the
operation.
Function addFractions: This function takes as input four integers
representing the numerators and denominators of two fractions, adds the
fractions, and returns the numerator and denominator of the result.
(Notice that this function has a total of six parameters.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

7

518 |

c.

d.

e.

Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type

Function subtractFractions: This function takes as input four
integers representing the numerators and denominators of two fractions,
subtracts the fractions, and returns the numerator and denominator of the
result. (Notice that this function has a total of six parameters.)
Function multiplyFractions: This function takes as input four
integers representing the numerators and denominators of two fractions,
multiplies the fractions, and returns the numerators and denominators of
the result. (Notice that this function has a total of six parameters.)
Function divideFractions: This function takes as input four integers
representing the numerators and denominators of two fractions, divides
the fractions, and returns the numerator and denominator of the result.
(Notice that this function has a total of six parameters.)
Some sample outputs are:
3 / 4 + 2 / 5 = 23 / 20
2 / 3 * 3 / 5 = 6 / 15

8.

9.

10.

Your answer need not be in the lowest terms.
Write a program that reads in a line consisting of a student’s name, Social
Security number, user ID, and password. The program outputs the string in
which all the digits of the Social Security number and all the characters in
the password are replaced by x. (The Social Security number is in the form
000-00-0000, and the user ID and the password do not contain any
spaces.) Your program should not use the operator [] to access a string
element. Use the appropriate functions described in Table 7-1.
You are given a file consisting of students’ names in the following form:
lastName, firstName middleName. (Note that a student may not have a
middle name.) Write a program that converts each name to the following
form: firstName middleName lastName. Your program must read each
student’s entire name in a variable and must consist of a function that takes as
input a string, consists of a student’s name, and returns the string consisting of
the altered name. Use the string function find to find the index of ,; the
function length to find the length of the string; and the function substr
to extract the firstName, middleName, and lastName.
An oil slick occurs when an underwater refinery pipe ruptures, pumping oil
into the water. The spilled oil sits on top of the water and causes a natural
disaster. For simplicity, suppose that the oil sits on top of the water in the
form of a circle. Write a program that prompts the user to enter the rate at
which the ruptured pipe pumps oil (in gallons) per minute, the thickness of
the oil on top of the water, and the number of days for which the area is
covered by the spilled oil. The program outputs the spilled area (in kilometers)
and the volume of oil (in gallons) on top of the water after each day.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

CHAPTER

ª HunThomas/Shutterstock.com

A RRAYS

AND

S TRINGS

I N T H I S C H A P T E R , YO U W I L L :

1.

Learn the reasons for arrays

2.

Explore how to declare and manipulate data into arrays

3.

Understand the meaning of ‘‘array index out of bounds’’

4.

Learn how to declare and initialize arrays

5.

Become familiar with the restrictions on array processing

6.

Discover how to pass an array as a parameter to a function

7.

Learn how to search an array

8.

Learn how to sort an array

9.

Become aware of auto declarations

10.

Learn about range-based for loops

11.

Learn about C-strings

12.

Examine the use of string functions to process C-strings

13.

Discover how to input data into—and output data from—a C-string

14.

Learn about parallel arrays

15.

Discover how to manipulate data in a two-dimensional array

16.

Learn about multidimensional arrays

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

520 |

Chapter 8: Arrays and Strings

In previous chapters, you worked with simple data types. In Chapter 2, you learned that C++
data types fall into three categories: simple, structured, and pointers. One of these categories is
the structured data type. This chapter and the next few chapters focus on structured data types.
Recall that a data type is called simple if variables of that type can store only one value at a
time. In contrast, in a structured data type, each data item is a collection of other data items.
Simple data types are building blocks of structured data types. The first structured data type that
we will discuss is an array. In Chapters 9 and 10, we will discuss other structured data types.
Before formally defining an array, let us consider the following problem. We want to write a
C++ program that reads five numbers, finds their sum, and prints the numbers in reverse order.
In Chapter 5, you learned how to read numbers, print them, and find the sum and
average. Suppose that you are given five test scores and you are asked to write a program
that finds the average test score and output all the test scores that are less than the average
test score. (For simplicity, we are considering only five test scores. After introducing
arrays, we will show how to efficiently process any number of test scores.)
//Program to find the average test score and output the average
//test score and all the test scores that are less than
//the average test score.
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
int test0, test1, test2, test3, test4;
double average;
cout << fixed << showpoint << setprecision(2);
cout << "Enter five test scores: ";
cin >> test0 >> test1 >> test2 >> test3 >> test4;
cout << endl;
average = (test0 + test1 + test2 + test3 + test4) / 5.0;
cout << "The average test score = " << average << endl;
if (test0 < average)
cout << test0 << " is less than the average test score." << endl;
if (test1 < average)
cout << test1 << " is less than the average test score." << endl;
if (test2 < average)
cout << test2 << " is less than the average test score." << endl;
if (test3 < average)
cout << test3 << " is less than the average test score." << endl;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arrays

|

521

if (test4 < average)
cout << test4 << " is less than the average test score." << endl;
return 0;
}

Sample Run: In this sample run, the user input is shaded.
Enter five test scores: 85 62 94 56 71
The average test score = 73.60
62 is less than the average test score.
56 is less than the average test score.
71 is less than the average test score.

This program works fine. However, if you need to read and process 100 test scores, you
would have to declare 100 variables and write many cin, cout, and if statements. Thus,
for large amounts of data, this type of program is not efficient.
Note the following in the previous program:
1. Five variables must be declared because test scores less than the average
test scores need to be printed.
2. All test scores are of the same data type, int.
3. The way in which these variables are declared indicates that the variables
to store these numbers all have the same name—except the last character, which is a number.
4. All the if statements are similar, except the name of the variables to
store the test scores.
Now, (1) tells you that you have to declare five variables. Next, (3) and (4) tell you that it
would be convenient if you could somehow put the last character, which is a number,
into a counter variable and use one for loop to count from 0 to 4 for reading and
another for loop to process the if statements. Finally, because all variables are of the
same type, you should be able to specify how many variables must be declared—and their
data type—with a simpler statement than a brute force set of variable declarations.
The data structure that lets you do all of these things in C++ is called an array.

Arrays
An array is a collection of a fixed number of components (also called elements) all of the same
data type and in contiguous (that is, adjacent) memory space. A one-dimensional array is an
array in which the components are arranged in a list form. This section discusses only onedimensional arrays. Arrays of two dimensions or more are discussed later in this chapter.
The general form for declaring a one-dimensional array is:
dataType arrayName[intExp];

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

522 |

Chapter 8: Arrays and Strings

in which intExp specifies the number of components in the array and can be any
constant expression that evaluates to a positive integer.

EXAMPLE 8-1
The statement:
int num[5];

declares an array num of five components. Each component is of type int. The component names
are num[0], num[1], num[2], num[3], and num[4]. Figure 8-1 illustrates the array num.

num[0]
num[1]
num[2]
num[3]
num[4]

FIGURE 8-1

Array num

To save space, we also draw an array, as shown in Figure 8-2(a) or 8-2(b).

num[0] num[1] num[2] num[3] num[4]
num

(a)
[0]

[1]

[2]

[3]

[4]

num

(b)

FIGURE 8-2

Array num

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arrays

|

523

Accessing Array Components
The general form (syntax) used for accessing an array component is:
arrayName[indexExp]

in which indexExp, called the index, is any expression whose value is a nonnegative
integer. The index value specifies the position of the component in the array.
In C++, [] is an operator called the array subscripting operator. Moreover, in C++,
the array index starts at 0.
Consider the following statement:
int list[10];

This statement declares an array list of 10 components. The components are
list[0], list[1], . . ., list[9]. In other words, we have declared 10 variables
(see Figure 8-3).

list[0] list[1] list[2] list[3] list[4] list[5] list[6] list[7] list[8] list[9]

list

8

FIGURE 8-3

Array list

The assignment statement:
list[5] = 34;

stores 34 in list[5], which is the sixth component of the array list (see Figure 8-4).

list[0] list[1] list[2] list[3] list[4] list[5] list[6] list[7] list[8] list[9]

34

list

FIGURE 8-4

Array list after execution of the statement list[5]= 34;

Suppose i is an int variable. Then, the assignment statement:
list[3] = 63;

is equivalent to the assignment statements:
i = 3;
list[i] = 63;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

524 |

Chapter 8: Arrays and Strings

Next, consider the following statements:
list[3] = 10;
list[6] = 35;
list[5] = list[3] + list[6];

The first statement stores 10 in list[3], the second statement stores 35 in list[6],
and the third statement adds the contents of list[3] and list[6] and stores the result
in list[5] (see Figure 8-5).

list[0] list[1] list[2] list[3] list[4] list[5] list[6] list[7] list[8] list[9]

list

10

45

35

Array list after execution of the statements list[3]= 10;, list[6]= 35;, and
list[5] = list[3] + list[6];
FIGURE 8-5

It follows that array components are individually separate variables that can be used just as
any other variable, and that list[0] is the name of an individual variable within the array.
Now, If i is 4, then the assignment statement:
list[2 * i - 3] = 58;

stores 58 in list[5] because 2 * i - 3 evaluates to 5. The index expression is evaluated
first, giving the position of the component in the array.
EXAMPLE 8-2
You can also declare arrays as follows:
const int ARRAY_SIZE = 10;
int list[ARRAY_SIZE];

That is, you can first declare a named constant and then use the value of the named
constant to declare an array and specify its size.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arrays

|

525

When you declare an array, its size must be specified. For example, you cannot do the
following:

int arraySize;

//Line 1

cout << "Enter the size of the array: "; //Line 2
cin >> arraySize;
//Line 3
cout << endl;
//Line 4
int list[arraySize];

//Line 5; not allowed

The statement in Line 2 asks the user to enter the size of the array when the program
executes. The statement in Line 3 inputs the size of the array into arraySize. When the
compiler compiles Line 1, the value of the variable arraySize is unknown. Thus, when
the compiler compiles Line 5, the size of the array is unknown and the compiler will not
know how much memory space to allocate for the array. In Chapter 12, you will learn how to
specify the size of an array during program execution and then declare an array of that size
using pointers. Arrays that are created by using pointers during program execution are
called dynamic arrays. For now, whenever you declare an array, its size must be known.

Processing One-Dimensional Arrays
Some of the basic operations performed on a one-dimensional array are initializing,
inputting data, outputting data stored in an array, and finding the largest and/or smallest
element. Moreover, if the data is numeric, some other basic operations are finding the
sum and average of the elements of the array. Each of these operations requires the
ability to step through the elements of the array. This is easily accomplished using a loop.
For example, suppose that we have the following statements:
int list[100];
int i;

//list is an array of size 100

The following for loop steps through each element of the array list, starting at the first
element of list:
for (i = 0; i < 100; i++)
//process list[i]

//Line 1
//Line 2

If processing the list requires inputting data into list, the statement in Line 2 takes the
form of an input statement, such as the cin statement. For example, the following
statements read 100 numbers from the keyboard and store the numbers in list:
for (i = 0; i < 100; i++)
cin >> list[i];

//Line 1
//Line 2

Similarly, if processing list requires outputting the data, then the statement in Line 2
takes the form of an output statement. For example, the following statements output the
numbers stored in list.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

526 |

Chapter 8: Arrays and Strings

for (i = 0; i < 100; i++)
cout << list[i] << " ";
cout << endl;

//Line 1
//Line 2

Example 8-3 further illustrates how to process one-dimensional arrays.
EXAMPLE 8-3
This example shows how loops are used to process arrays. The following declaration is
used throughout this example:
double sales[10];
int index;
double largestSale, sum, average;

The first statement declares an array sales of 10 components, with each component
being of type double. The meaning of the other statements is clear.
a.

Initializing an array: The following loop initializes every component of the array sales to 0.0.
for (index = 0; index < 10; index++)
sales[index] = 0.0;

b. Reading data into an array: The following loop inputs the data
into the array sales. For simplicity, we assume that the data is
entered from the keyboard.
for (index = 0; index < 10; index++)
cin >> sales[index];

c. Printing an array: The following loop outputs the array sales.
For simplicity, we assume that the output goes to the screen.
for (index = 0; index < 10; index++)
cout << sales[index] << " ";

d. Finding the sum and average of an array: Because the array
sales, as its name implies, represents certain sales data, it is natural to find
the total sale and average sale amounts. The following C++ code finds the
sum of the elements of the array sales and the average sale amount:
sum = 0;
for (index = 0; index < 10; index++)
sum = sum + sales[index];
average = sum / 10;

e. Largest element in the array: We now discuss the algorithm to
find the first occurrence of the largest element in an array—that is, the
first array component with the largest value. However, in general, the
user is more interested in determining the location of the largest

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arrays

|

527

element in the array. Of course, if you know the location (that is, the
index of the largest element in the array), you can easily determine the
value of the largest element in the array. So let us describe the algorithm to determine the index of the first occurrence of the largest
element in an array—in particular, the index of the largest sale amount
in the array sales. We will use the index of the first occurrence of the
largest element in the array to find the largest sale.
We assume that maxIndex will contain the index of the first occurence of the largest element in the array sales. The general algorithm
is straightforward. Initially, we assume that the first element in the list is
the largest element, so maxIndex is initialized to 0. We then compare
the element pointed to by maxIndex with every subsequent element
in the list. Whenever we find an element in the array larger than the
element pointed to by maxIndex, we update maxIndex so that it
points to the new larger element. The algorithm is as follows:
maxIndex = 0;
for (index = 1; index < 10; index++)
if (sales[maxIndex] < sales[index])
maxIndex = index;
largestSale = sales[maxIndex];

Let us demonstrate how this algorithm works with an example. Suppose the array sales
is as given in Figure 8-6.

sales

FIGURE 8-6

[0]

[1]

[2]

[3]

[4]

[5]

[6]

[7]

[8]

[9]

12.50

8.35

19.60

25.00

14.00

39.43

35.90

98.23

66.65

35.64

Array sales

Here, we determine the largest element in the array sales. Before the for loop begins,
maxIndex is initialized to 0, and the for loop initializes index to 1. In the following,
we show the values of maxIndex, index, and certain array elements during each
iteration of the for loop.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

528 |

Chapter 8: Arrays and Strings

index

maxIndex

sales
[maxIndex]

sales
[index]

sales[maxIndex] <
sales[index]

1
2

0
0

12.50
12.50

8.35
19.60

3

2

19.60

25.00

4
5

3
3

25.00
25.00

14.00
39.43

6
7

5
5

39.43
39.43

35.90
98.23

8
9

7
7

98.23
98.23

66.65
35.64

12.50 < 8.35 is false
12.50 < 19.60 is true;
maxIndex = 2
19.60 < 25.00 is true;
maxIndex = 3
25.00 < 14.00 is false
25.00 < 39.43 is true;
maxIndex = 5
39.43 < 35.90 is false
39.43 < 98.23 is true;
maxIndex = 7
98.23 < 66.65 is false
98.23 < 35.64 is false

After the for loop executes, maxIndex = 7, giving the index of the largest element in
the array sales. Thus, largestSale = sales[maxIndex] = 98.23.

You can write an algorithm to find the smallest element in the array that is similar to the
algorithm for finding the largest element in an array. (See Programming Exercise 2 at the
end of this chapter.)

Now that we know how to declare and process arrays, let us rewrite the program that we
discussed in the beginning of this chapter. Recall that this program reads five test scores, finds
the average test score, and outputs all the test scores that are less than the average test score.
EXAMPLE 8-4
//Program to find the average test score and output the average
//test score and all the test scores that are less than the
//average test score.
#include <iostream>
#include <iomanip>
using namespace std;
int main()
{
int test[5];
int sum = 0;
double average;
int index;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arrays

|

529

cout << fixed << showpoint << setprecision(2);
cout << "Enter five test scores: ";
for (index = 0; index < 5; index++)
{
cin >> test[index];
sum = sum + test[index];
}
cout << endl;
average = sum / 5.0;
cout << "The average test score = " << average << endl;
for (index = 0; index < 5; index++)
if (test[index] < average)
cout << test[index]
<< " is less than the average test score." << endl;
return 0;
}

Sample Run: In this sample run, the user input is shaded.
Enter five test scores: 85 62 94 56 71
The average test score = 73.60
62 is less than the average test score.
56 is less than the average test score.
71 is less than the average test score.

Array Index Out of Bounds
Consider the following declaration:
double num[10];
int i;

The component num[i] is valid, that is, i is a valid index if i = 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9.
The index—say, index—of an array is in bounds if index is between 0 and ARRAY_
SIZE  1, that is, 0 <= index <= ARRAY_SIZE  1. If index is negative or index is
greater than ARRAY_SIZE  1, then we say that the index is out of bounds.
Unfortunately, C++ does not check whether the index value is within range—that is,
between 0 and ARRAY_SIZE  1. If the index goes out of bounds and the program
tries to access the component specified by the index, then whatever memory location is
indicated by the index that location is accessed. This situation can result in altering or
accessing the data of a memory location that you never intended to modify or access, or
in trying to access protected memory that causes the program to instantly halt.
Consequently, several strange things can happen if the index goes out of bounds during
execution. It is solely the programmer’s responsibility to make sure that the index is
within bounds.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

530 |

Chapter 8: Arrays and Strings

Consider the following statement:
int list[10];

A loop such as the following can set the index of list out of bounds:
for (int i = 0; i <= 10; i++)
list[i] = 0;

When i becomes 10, the loop test condition i <= 10 evaluates to true and the body of the
loop executes, which results in storing 0 in list[10]. Logically, list[10] does not exist.
On some new compilers, if an array index goes out of bounds in a progam, it is possible
that the program terminates with an error message. For example, see the programs
Example_ArrayIndexOutOfBoundsA.cpp and
Example_ArrayIndexOutOfBoundsB.cpp at the Web site accompanying this book.

Array Initialization during Declaration
Like any other simple variable, an array can be initialized while it is being declared. For
example, the following C++ statement declares an array, sales, of five components and
initializes these components.
double sales[5] = {12.25, 32.50, 16.90, 23, 45.68};

The values are placed between curly braces and separated by commas—here,
sales[0] = 12.25, sales[1] = 32.50, sales[2] = 16.90, sales[3] = 23.00,
and sales[4] = 45.68.
When initializing arrays as they are declared, it is not necessary to specify the size of the array.
The size is determined by the number of initial values in the braces. However, you must include
the brackets following the array name. The previous statement is, therefore, equivalent to:
double sales[] = {12.25, 32.50, 16.90, 23, 45.68};

Although it is not necessary to specify the size of the array if it is initialized during
declaration, it is a good practice to do so.

Partial Initialization of Arrays during Declaration
When you declare and initialize an array simultaneously, you do not need to initialize all
components of the array. This procedure is called partial initialization of an array
during declaration. However, if you partially initialize an array during declaration, you
must exercise some caution. The following examples help to explain what happens when
you declare and partially initialize an array.
The statement:
int list[10] = {0};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arrays

|

531

declares list to be an array of 10 components and initializes all of the components to 0.
The statement:
int list[10] = {8, 5, 12};

declares list to be an array of 10 components and initializes list[0] to 8, list[1]
to 5, list[2] to 12, and all other components to 0. Thus, if all of the values are not
specified in the initialization statement, the array components for which the values are not
specified are initialized to 0. Note that, here, the size of the array in the declaration
statement does matter. For example, the statement:
int list[] = {5, 6, 3};

declares list to be an array of three components and initializes list[0] to 5,
list[1] to 6, and list[2] to 3. In contrast, the statement:
int list[25] = {4, 7};

declares list to be an array of 25 components. The first two components are initialized
to 4 and 7, respectively, and all other components are initialized to 0.
Suppose that you have the following statement: int x[5] = {};. Then some compilers
may initialize each element of the array x to 0.
When you partially initialize an array, then all of the elements that follow the last
uninitialized element must be uninitialized. Therefore, the following statement will result
in a syntax error:
int list[10] = {2, 5, 6, , 8}; //illegal

In this initialization, because the fourth element is uninitialized, all elements that follow
the fourth element must be left unintialized.

Some Restrictions on Array Processing
Consider the following statements:
int myList[5] = {0, 4, 8, 12, 16};
int yourList[5]; //Line 2

//Line 1

The statement in Line 1 declares and initializes the array myList, and the statement in Line 2
declares the array yourList. Note that these arrays are of the same type and have the same
number of components. Suppose that you want to copy the elements of myList into the
corresponding elements of yourList. The following statement is illegal:
yourList = myList;

//illegal

In fact, this statement will generate a syntax error. C++ does not allow aggregate
operations on an array. An aggregate operation on an array is any operation that
manipulates the entire array as a single unit.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

532 |

Chapter 8: Arrays and Strings

To copy one array into another array, you must copy it component-wise—that is, one
component at a time. For example, the following statements copy myList into yourList.
yourList[0]
yourList[1]
yourList[2]
yourList[3]
yourList[4]

=
=
=
=
=

myList[0];
myList[1];
myList[2];
myList[3];
myList[4];

This can be accomplished more efficiently using a loop, such as the following:
for (int index = 0; index < 5; index++)
yourList[index] = myList[index];

Next, suppose that you want to read data into the array yourList. The following
statement is illegal and, in fact, would generate a syntax error:
cin >> yourList; //illegal

To read data into yourList, you must read one component at a time, using a loop such
as the following:
for (int index = 0; index < 5; index++)
cin >> yourList[index];

Similarly, determining whether two arrays have the same elements and printing the
contents of an array must be done component-wise. Note that the following statements
are legal in the sense that they do not generate a syntax error; however, they do not give
the desired results.
cout << yourList;
if (myList <= yourList)
.
.
.

We will comment on these statements in the section Base Address of an Array and Array
in Computer Memory later in this chapter.

Arrays as Parameters to Functions
Now that you have seen how to work with arrays, a question naturally arises: How are
arrays passed as parameters to functions?
By reference only: In C++, arrays are passed by reference only.

Because arrays are passed by reference only, you do not use the symbol & when declaring
an array as a formal parameter.
When declaring a one-dimensional array as a formal parameter, the size of the array is
usually omitted. If you specify the size of a one-dimensional array when it is declared as a
formal parameter, the size is ignored by the compiler.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arrays

|

533

EXAMPLE 8-5
Consider the following function:
void funcArrayAsParam(int listOne[], double listTwo[])
{
.
.
.
}

The function funcArrayAsParam has two formal parameters: (1) listOne, a onedimensional array of type int (that is, the component type is int) and (2) listTwo, a onedimensional array of type double. In this declaration, the size of both arrays is unspecified.
Sometimes, the number of elements in the array might be less than the size of the
array. For example, the number of elements in an array storing student data might
increase or decrease as students drop or add courses. In such situations, we want to
process only the components of the array that hold actual data. To write a function to
process such arrays, in addition to declaring an array as a formal parameter, we declare
another formal parameter specifying the number of elements in the array, as in the
following function:
void initialize(int list[], int listSize)
{
int count;
for (count = 0; count < listSize; count++)
list[count] = 0;
}

The first parameter of the function initialize is an int array of any size. When the
function initialize is called, the size of the actual array is passed as the second
parameter of the function initialize.

Constant Arrays as Formal Parameters
Recall that when a formal parameter is a reference parameter, then whenever the formal
parameter changes, the actual parameter changes as well. However, even though an array
is always passed by reference, you can still prevent the function from changing the actual
parameter. You do so by using the reserved word const in the declaration of the formal
parameter. Consider the following function:
void example(int x[], const int y[], int sizeX, int sizeY)
{
.
.
.
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

534 |

Chapter 8: Arrays and Strings

Here, the function example can modify the array x, but not the array y. Any attempt to
change y results in a compile-time error. It is a good programming practice to declare an
array to be constant as a formal parameter if you do not want the function to modify the
array.
EXAMPLE 8-6
This example shows how to write functions for array processing and how to declare an
array as a formal parameter.
//Function to initialize an int array to 0.
//The array to be initialized and its size are passed
//as parameters. The parameter listSize specifies the
//number of elements to be initialized.
void initializeArray(int list[], int listSize)
{
int index;
for (index = 0; index < listSize; index++)
list[index] = 0;
}
//Function to read and store the data into an int array.
//The array to store the data and its size are passed as
//parameters. The parameter listSize specifies the number
//of elements to be read.
void fillArray(int list[], int listSize)
{
int index;
for (index = 0; index < listSize; index++)
cin >> list[index];
}
//Function to print the elements of an int array.
//The array to be printed and the number of elements
//are passed as parameters. The parameter listSize
//specifies the number of elements to be printed.
void printArray(const int list[], int listSize)
{
int index;
for (index = 0; index < listSize; index++)
cout << list[index] << " ";
}
//Function to find and return the sum of the
//elements of an int array. The parameter listSize
//specifies the number of elements to be added.
int sumArray(const int list[], int listSize)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arrays

|

535

{
int index;
int sum = 0;
for (index = 0; index < listSize; index++)
sum = sum + list[index];
return sum;
}
//Function to find and return the index of the first
//largest element in an int array. The parameter listSize
//specifies the number of elements in the array.
int indexLargestElement(const int list[], int listSize)
{
int index;
int maxIndex = 0; //assume the first element is the largest
for (index = 1; index < listSize; index++)
if (list[maxIndex] < list[index])
maxIndex = index;
return maxIndex;
}
//Function to copy some or all of the elements of one array
//into another array. Starting at the position specified
//by src, the elements of list1 are copied into list2
//starting at the position specified by tar. The parameter
//numOfElements specifies the number of elements of list1 to
//be copied into list2. Starting at the position specified
//by tar, the list2 must have enough components to copy the
//elements of list1. The following call copies all of the
//elements of list1 into the corresponding positions in
//list2: copyArray(list1, 0, list2, 0, numOfElements);
void copyArray(int list1[], int src, int list2[],
int tar, int numOfElements)
{
for (int index = src; index < src + numOfElements; index++)
{
list2[index] = list1[tar];
tar++;
}
}

Base Address of an Array and Array in Computer Memory
The base address of an array is the address (that is, the memory location) of the first array
component. For example, if list is a one-dimensional array, then the base address of
list is the address of the component list[0].

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

536 |

Chapter 8: Arrays and Strings

Consider the following statements:
int myList[5];

//Line 1

This statement declares myList to be an array of five components of type int. The
components are myList[0], myList[1], myList[2], myList[3], and myList[4].
The computer allocates five memory spaces, each large enough to store an int value, for
these components. Moreover, the five memory spaces are contiguous.
The base address of the array myList is the address of the component myList[0].
Suppose that the base address of the array myList is 1000. Then, the address of the
component myList[0] is 1000. Typically, the memory allocated for an int variable is
four bytes. Recall from Chapter 1 that main memory is an ordered sequence of cells, and
each cell has a unique address. Typically, each cell is one byte. Therefore, to store a value
into myList[0], starting at the address 1000, the next four bytes are allocated for
myList[0]. It follows that the starting address of myList[1] is 1004, the starting
address of myList[2] is 1008, and so on (see Figure 8-7).

Memory
addresses

myList [0]

.
.
.

myList [1]
myList [2]
myList [3]
myList [4]
.
.
.

FIGURE 8-7

1000
1001
1002
1003
1004
1005
1006
1007
1008
1009
1010
1011
1012
1013
1014
1015
1016
1017
1018
1019

Address of
myList [0]
Address of
myList [1]
Address of
myList [2]
Address of
myList [3]
Address of
myList [4]

Array myList and the addresses of its components

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arrays

|

537

Now myList is the name of an array. There is also a memory space associated with the
identifier myList, and the base address of the array is stored in that memory space.
Consider the following statement:
cout << myList << endl;

//Line 2

Earlier, we said that this statement will not give the desired result. That is, this statement
will not output the values of the components of myList. In fact, the statement outputs the
value stored in myList, which is the base address of the array. This is why the statement
will not generate a syntax error.
Suppose that you also have the following statement:
int yourList[5];

Then, in the statement:
if (myList <= yourList)
.
.
.

//Line 3

the expression myList <= yourList evaluates to true if the base address of the array
myList is less than the base address of the array yourList; and evaluates to false
otherwise. It does not determine whether the elements of myList are less than or equal to
the corresponding elements of yourList.
The Web site accompanying this book contains the program
BaseAddressOfAnArray.cpp, which clarifies statements such as those in
Lines 2 and 3.

You might be wondering why the base address of an array is so important. The reason
is that when you declare an array, the only things about the array that the computer
remembers are the name of the array, its base address, the data type of each component, and (possibly) the number of components. Using the base address of the array,
the index of an array component, and the size of each component in bytes, the
computer calculates the address of a particular component. For example, suppose
you want to access the value of myList[3]. Now, the base address of myList is
1000. Each component of myList is of type int, so it uses four bytes to store a
value, and the index of the desired component is 3. To access the value of
myList[3], the computer calculates the address 1000 + 4 * 3 = 1000 + 12 =
1012. That is, this is the starting address of myList[3]. So, starting at 1012, the
computer accesses the next four bytes: 1012, 1013, 1014, and 1015.
When you pass an array as a parameter, the base address of the actual array is passed to the
formal parameter. For example, suppose that you have the following function:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

538 |

Chapter 8: Arrays and Strings

void arrayAsParameter(int list[], int size)
{
.
.
.
list[2] = 28;

//Line 4

.
.
.
}

Also, suppose that you have the following call to this function:
arrayAsParameter(myList, 5);

//Line 5

In this statement, the base address of myList is passed to the formal parameter list.
Therefore, the base address of list is 1000. The definition of the function contains
the statement list[2] = 28;. This statement stores 28 into list[2]. To access
list[2], the computer calculates the address as follows: 1000 + 4 * 2 = 1008. So,
starting at the address 1008, the computer accesses the next four bytes and stores 28.
Note that, in fact, 1008 is the address of myList[2] (see Figure 8-7). It follows that
during the execution of the statement in Line 5, the statement in Line 4 stores the value
28 into myList[2]. It also follows that during the execution of the function call
statement in Line 5, list[index] and myList[index] refer to the same memory
space, where 0 <= index and index < 5.
If C++ allowed arrays to be passed by value, the computer would have to allocate memory
for the components of the formal parameter and copy the contents of the actual array into
the corresponding formal parameter when the function is called. If the array size was
large, this process would waste memory as well as the computer time needed for copying
the data. That is why in C++ arrays are always passed by reference.

Functions Cannot Return a Value of the Type Array
C++ does not allow functions to return a value of the type array. Note that the functions
sumArray and indexLargestElement described earlier return values of type int.

EXAMPLE 8-7
Suppose that the distance traveled by an object at time t = a1 is d1 and at time t = a2 is d2,
where a1 < a2. Then the average speed of the object from time a1 to a2, that is, over the
interval [a1, a2] is (d2d1)/(a2a1). Suppose that the distance traveled by an object at
certain times is given by the following table:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arrays

|

Time

0

10

20

30

40

50

Distance traveled

0

18

27

38

52

64

539

Then the average speed over the interval [0, 10] is (180)/(100) = 1.8, over the
interval [10, 20] is (27 18)/(20  10) = 0.9, and so on.
The following program takes as input the distance traveled by an object at time 0, 10, 20, 30,
40, and 50. The program then outputs the average speed over the intervals [10 * i, 10 * (i + 1)],
where i = 0, 1, 2, 3, and 4. The program also outputs the maximum and minimum average
speed over these intervals. Programming Exercise 17, at the end of this chapter, asks you to
modify this program so that the distance traveled by an object recorded, but not necessarily
after every 10 time units.
//Given the distance traveled by an object at every 10 units
//of time, this program determines the average speed of the object
//at each 10 unit interval of the time.
#include <iostream>
#include <iomanip>
using namespace std;
const int SIZE = 6;
void getData(double list [], int length);
void averageSpeedOverTimeInterval(double list [], int length,
double avgSpeed []);
double maxAvgSpeed(double avgSpeed [], int length);
double minAvgSpeed(double avgSpeed [], int length);
void print(double list [], int length, double avgSpeed []);
int main()
{
double distanceTraveled [SIZE];
double averageSpeed [SIZE];
cout << fixed << showpoint << setprecision(2);
getData(distanceTraveled, SIZE);
averageSpeedOverTimeInterval(distanceTraveled, SIZE, averageSpeed);
print(distanceTraveled, SIZE, averageSpeed);
cout << "Maximum average speed: "
<< maxAvgSpeed(averageSpeed, SIZE) << endl;
cout << "Minimum average speed: "
<< minAvgSpeed(averageSpeed, SIZE) << endl;
return 0;
}
void getData(double list [], int length)
{
cout << "Enter the total distance traveled after "
<< "every 10 units of time." << endl;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

540 |

Chapter 8: Arrays and Strings

for (int index = 0; index < length; index++)
{
cout << "Enter total distance traveled at time "
<< index * 10 << " units: ";
cin >> list [index];
cout << endl;
}
}
void averageSpeedOverTimeInterval(double list [], int length,
double avgSpeed [])
{
for (int index = 0; index < length - 1; index++)
avgSpeed [index] = (list [index + 1] - list [index]) / 10;
}
double maxAvgSpeed(double avgSpeed [], int length)
{
double max = avgSpeed [0];
for (int index = 1; index < length - 1; index++)
if (avgSpeed [index] > max)
max = avgSpeed [index];
return max;
}
double minAvgSpeed(double avgSpeed [], int length)
{
double min = avgSpeed [0];
for (int index = 1; index < length - 1; index++)
if (avgSpeed [index] < min)
min = avgSpeed [index];
return min;
}
void print(double list [], int length, double avgSpeed [])
{
cout << setw(7) << "Time " << setw(20) << "Distance Traveled
<< setw(10) << "Average Speed / Time Interval" << endl;

"

cout << setw(5) << 0
<< setw(14) << list [0] << setw(6) << " "
<< setw(10) << 0 << " [0, 0] " << endl;
for (int index = 1; index < length; index++)
cout << setw(5) << index * 10
<< setw(14) << list [index] << setw(6) << " "
<< setw(10) << avgSpeed [index - 1]
<< " [" << (index - 1) * 10 << ", "
<< index * 10 << "]" << endl;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Arrays

|

541

Sample Run: In this sample run, the user input is shaded.
Enter the total distance traveled after every 10 units of time.
Enter total distance traveled at time 0 units: 0
Enter total distance traveled at time 10 units: 25
Enter total distance traveled at time 20 units: 38
Enter total distance traveled at time 30 units: 52
Enter total distance traveled at time 40 units: 60
Enter total distance traveled at time 50 units: 72
Time Distance Traveled Average Speed / Time Interval
0
0.00
0 [0, 0]
10
25.00
2.50 [0, 10]
20
38.00
1.30 [10, 20]
30
52.00
1.40 [20, 30]
40
60.00
0.80 [30, 40]
50
72.00
1.20 [40, 50]
Maximum average speed: 2.50
Minimum average speed: 0.80

The output of this program is straightforward. We leave the details as an exercise.

Integral Data Type and Array Indices
The sections ‘‘Enumeration Type’’ and ‘‘typedef Statement’’ from Chapter 7 are
required to understand this section.

Other than integers, C++ allows any integral type to be used as an array index. This
feature can greatly enhance a program’s readability. Consider the following statements:
enum paintType {GREEN, RED, BLUE, BROWN, WHITE, ORANGE, YELLOW};
double paintSale[7];
paintType paint;

The following loop initializes each component of the array paintSale to 0:
for (paint = GREEN; paint <= YELLOW;
paint = static_cast<paintType>(paint + 1))
paintSale[paint] = 0.0;

The following statement updates the sale amount of RED paint:
paintSale[RED] = paintSale[RED] + 75.69;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

542 |

Chapter 8: Arrays and Strings

As you can see, the above code is much easier to follow than the code that used integers for the
index. For this reason, you should use the enumeration type for the array index or other
integral data types wherever possible. Note that when using the enumeration type for array
indices, use the default values of the identifiers in the enumeration type. That is, the value of
the first identifier must be 0, and so on. (Recall from Chapter 7 that the default values of
identifiers in an enumeration type start at 0; however, the identifiers can be set to other values.)

Other Ways to Declare Arrays
Suppose that a class has 20 students and you need to keep track of their scores. Because
the number of students can change from semester to semester, instead of specifying the
size of the array while declaring it, you can declare the array as follows:
const int NO_OF_STUDENTS = 20;
int testScores[NO_OF_STUDENTS];

Other forms used to declare arrays are:
const int SIZE = 50;
typedef double list[SIZE];

//Line 1
//Line 2

list yourList;
list myList;

//Line 3
//Line 4

The statement in Line 2 defines a data type list, which is an array of 50 components of type
double. The statements in Lines 3 and 4 declare two variables, yourList and myList. Both
are arrays of 50 components of type double. Of course, these statements are equivalent to:
double yourList[50];
double myList[50];

Searching an Array for a Specific Item
Searching a list for a given item is one of the most common operations performed on a
list. The search algorithm we describe is called the sequential search or linear search.
As the name implies, you search the array sequentially, starting from the first array
element. You compare searchItem with the elements in the array (the list) and continue
the search until either you find the item or no more data is left in the list to compare
with searchItem.
Consider the list of seven elements shown in Figure 8-8.

[0] [1] [2] [3] [4] [5] [6]
list 35

FIGURE 8-8

12

27

18

45

16

38

List of seven elements

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Searching an Array for a Specific Item |

543

Suppose that you want to determine whether 27 is in the list. A sequential search works
as follows: First, you compare 27 with list[0], that is, compare 27 with 35. Because
list[0] 6¼ 27, you then compare 27 with list[1], that is, with 12, the second item in
the list. Because list[1] 6¼ 27, you compare 27 with the next element in the list, that is,
compare 27 with list[2]. Because list[2] = 27, the search stops. This search is successful.
Let us now search for 10. As before, the search starts at the first element in the list, that is,
at list[0]. Proceeding as before, we see that, this time, the search item, which is 10, is
compared with every item in the list. Eventually, no more data is left in the list to
compare with the search item. This is an unsuccessful search.
It now follows that, as soon as you find an element in the list that is equal to the search
item, you must stop the search and report success. (In this case, you usually also report the
location in the list where the search item was found.) Otherwise, after the search item is
unsuccessfully compared with every element in the list, you must stop the search and
report failure.
Suppose that the name of the array containing the list elements is list. The previous
discussion translates into the following algorithm for the sequential search:
found is set to false
loc = 0;
while (loc < listLength and not found)
if (list[loc] is equal to searchItem)
found is set to true
else
increment loc
if (found)
return loc;
else
return -1;

The following function performs a sequential search on a list. To be specific, and for
illustration purposes, we assume that the list elements are of type int.
int seqSearch(const int list[], int listLength, int searchItem)
{
int loc;
bool found = false;
loc = 0;
while (loc < listLength && !found)
if (list[loc] == searchItem)
found = true;
else
loc++;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

544 |

Chapter 8: Arrays and Strings

if (found)
return loc;
else
return -1;
}

If the function seqSearch returns a value greater than or equal to 0, it is a successful
search; otherwise, it is an unsuccessful search.
As you can see from this code, you start the search by comparing searchItem with the
first element in the list. If searchItem is equal to the first element in the list, you
exit the loop; otherwise, loc is incremented by 1 to point to the next element in the
list. You then compare searchItem with the next element in the list, and so on.
EXAMPLE 8-8
// This program illustrates how to use a sequential search in a
// program.
#include <iostream>

//Line 1

using namespace std;

//Line 2

const int ARRAY_SIZE = 10;

//Line 3

int seqSearch(const int list[], int listLength,
int searchItem);

//Line 4

int main()
{
int intList[ARRAY_SIZE];
int number;

//Line
//Line
//Line
//Line

5
6
7
8

cout << "Line 9: Enter " << ARRAY_SIZE
<< " integers." << endl;

//Line 9

for (int index = 0; index < ARRAY_SIZE; index++)
cin >> intList[index];

//Line 10
//Line 11

cout << endl;

//Line 12

cout << "Line 13: Enter the number to be "
<< "searched: ";
cin >> number;
cout << endl;

//Line 13
//Line 14
//Line 15

int pos = seqSearch(intList, ARRAY_SIZE, number);

//Line 16

if (pos != -1)
cout <<"Line 18: " << number
<< " is found at index " << pos
<< endl;

//Line 17
//Line 18

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Searching an Array for a Specific Item |

else
cout << "Line 20: " << number
<< " is not in the list." << endl;

545

//Line 19
//Line 20
//Line 21
//Line 22

return 0;
}
//Place the definition of the function seqSearch
//given previously here.

Sample Run 1: In this sample run, the user input is shaded.
Line 9: Enter 10 integers.
2 56 34 25 73 46 89 10 5 16
Line 13: Enter the number to be searched: 25
Line 18: 25 is found at index 3

Sample Run 2:
Line 9: Enter 10 integers.
2 56 34 25 73 46 89 10 5 16
Line 13: Enter the number to be searched: 38
Line 20: 38 is not in the list.

8

Sorting
The previous section discussed a searching algorithm. In this section, we discuss how to
sort an array using the algorithm, called selection sort. Additional searching and
sorting algorithms are discussed in Chapter 16.
As the name implies, in the selection sort algorithm, we rearrange the list by selecting an
element in the list and moving it to its proper position. This algorithm finds the location
of the smallest element in the unsorted portion of the list and moves it to the top of the
unsorted portion of the list. The first time, we locate the smallest item in the entire list.
The second time, we locate the smallest item in the list starting from the second element
in the list, and so on.

[0] [1] [2] [3] [4] [5] [6] [7]
list

FIGURE 8-9

16

30

24

7

62

45

5

55

List of eight elements

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

546 |

Chapter 8: Arrays and Strings

Suppose you have the list shown in Figure 8-9.

list
[0]

16

16

5

[1]

30

30

30

[2]
unsorted [3]
list
[4]

24

24

7

7

62

62

62

[5]

45

45

45

[6]

5

5

16

[7]

55

55

55

(b)

(c)

smallest

(a)

FIGURE 8-10

24
swap

7

unsorted
list

Elements of list during the first iteration

Figure 8-10 shows the elements of list in the first iteration.
Initially, the entire list is unsorted. So, we find the smallest item in the list. The smallest
item is at position 6, as shown in Figure 8-10(a). Because this is the smallest item, it must
be moved to position 0. So, we swap 16 (that is, list[0]) with 5 (that is, list[6]), as
shown in Figure 8-10(b). After swapping these elements, the resulting list is as shown in
Figure 8-10(c).

list
[0]

5

5

[1] 30

30

[2] 24
[3]

7
swap

24

7

30

62

62

45

45

[6] 16

16

16

[7] 55

55

55

(b)

(c)

unsorted
[4] 62
list
[5] 45

(a)

FIGURE 8-11

24

7

5

smallest

unsorted
list

Elements of list during the second iteration

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Searching an Array for a Specific Item |

547

Figure 8-11 shows the elements of list during the second iteration.
Now the unsorted list is list[1]...list[7]. So, we find the smallest element in the
unsorted list. The smallest element is at position 3, as shown in Figure 8-11(a). Because the
smallest element in the unsorted list is at position 3, it must be moved to position 1. So, we
swap 7 (that is, list[3]) with 30 (that is, list[1]), as shown in Figure 8-11(b). After
swapping list[1] with list[3], the resulting list is as shown in Figure 8-11(c).
Now, the unsorted list is list[2]...list[7]. So, we repeat the preceding process of
finding the (position of the) smallest element in the unsorted portion of the list and
moving it to the beginning of the unsorted portion of the list. Selection sort thus involves
the following steps.
In the unsorted portion of the list:
a. Find the location of the smallest element.
b. Move the smallest element to the beginning of the unsorted list.
Initially, the entire list (that is, list[0]...list[length - 1]) is the unsorted list. After
executing Steps a and b once, the unsorted list is list[1]... list[length - 1]. After
executing Steps a and b a second time, the unsorted list is list[2]...list[length - 1],
and so on. In this way, we can keep track of the unsorted portion of the list and repeat Steps a
and b with the help of a for loop, as shown in the following pseudocode:
for (index = 0; index < length - 1; index++)
{
a. Find the location, smallestIndex, of the smallest element in
list[index]...list[length - 1].
b. Swap the smallest element with list[index]. That is, swap
list[smallestIndex] with list[index].
}

The first time through the loop, we locate the smallest element in list[0]...
list[length - 1] and swap the smallest element with list[0]. The second time
through the loop, we locate the smallest element in list[1]...list[length - 1] and
swap the smallest element with list[1], and so on.
Step a is similar to the algorithm for finding the index of the largest item in the list, as
discussed earlier in this chapter. (Also see Programming Exercise 2 at the end of this chapter.)
Here, we find the index of the smallest item in the list. The general form of Step a is:
smallestIndex = index;

//assume first element is the smallest

for (location = index + 1; location < length; location++)
if (list[location] < list[smallestIndex])
smallestIndex = location; //current element in the list
//is smaller than the smallest so
//far, so update smallestIndex

Step b swaps the contents of list[smallestIndex] with list[index]. The following
statements accomplish this task:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

548 |

Chapter 8: Arrays and Strings

temp = list[smallestIndex];
list[smallestIndex] = list[index];
list[index] = temp;

It follows that to swap the values, three item assignments are needed. The following
function, selectionSort, implements the selection sort algorithm:
void selectionSort(int list[], int length)
{
int index;
int smallestIndex;
int location;
int temp;
for (index = 0; index < length - 1; index++)
{
//Step a
smallestIndex = index;
for (location = index + 1; location < length; location++)
if (list[location] < list[smallestIndex])
smallestIndex = location;
//Step b
temp = list[smallestIndex];
list[smallestIndex] = list[index];
list[index] = temp;
}
}

The program in Example 8-9 illustrates how to use the selection sort algorithm in a program.
EXAMPLE 8-9
//Selection sort
#include <iostream>
using namespace std;
void selectionSort(int list[],

int length);

int main()
{
int list[]= {2, 56, 34, 25, 73, 46, 89, 10, 5, 16};
int i;

//Line 1
//Line 2

selectionSort(list, 10);

//Line 3

cout << "After sorting, the list elements are:"
<< endl;

//Line 4

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Auto Declaration and Range-Based For Loops |

for (i = 0; i < 10; i++)
cout << list[i] << " ";

//Line 5
//Line 6

cout << endl;

//Line 7

return 0;

//Line 8

549

}
//Place the definition of the function selectionSort given
//previously here.

Sample Run:
After sorting, the list elements are:
2 5 10 16 25 34 46 56 73 89

The statement in Line 1 declares and initializes list to be an array of 10 components of
type int. The statement in Line 3 uses the function selectionSort to sort list.
Notice that both list and its length (the number of elements in it, which is 10) are
passed as parameters to the function selectionSort. The for loop in Lines 5 and 6
outputs the elements of list.
To illustrate the selection sort algorithm in this program, we declared and initialized the array
list. However, you can also prompt the user to input the data during program execution.

8
nðn  1Þ
2

key comparisons and 3(n  1) item
For a list of length n, selection sort makes exactly
assignments. Therefore, if n = 1000, then to sort the list, selection sort makes about 500,000
key comparisons and about 3000 item assignments. The next section presents the insertion
sort algorithm that reduces the number of comparisons.

Auto Declaration and Range-Based For Loops
C++11 introduces auto declaration of elements, which allows a programmer to declare
and initialize a variable without specifying its type. For example, the following statement
declares the variable num and stores 15 in it:
auto num = 15;

Because the initializer, which is 15, is an int value, the type of num will be int.
One way to process the elements of an array one-by-one, starting at the first element, is
to use an index variable, initialized to 0, and a loop. For example, to process the elements
of an array, list, you can use a for loop such as the following:
for (int index = 0; index < length; index++)
//process list[index]

This chapter uses these types of loops to process the elements of an array. C++11
provides a special type of for loop to process the elements of an array. The syntax to
use this for loop to process the elements of an array is:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

550 |

Chapter 8: Arrays and Strings

for (dataType identifier : arrayName)
statements

where identifier is a variable and the data type of identifier is the same as the data
type of the array elements. This form of the for loop is called a range-based for loop.
For example, suppose you have the following declarations:
double list[25];
double sum;

The following code finds the sum of the elements of list:
sum = 0;

//Line 1

for (double num : list)
sum = sum + num;

//Line 2
//Line 3

The for statement in Line 2 is read as ‘‘for each num in list.’’ The variable num is
initialized to list[0]. In the next iteration, the value of num is list[1], and so on. It
follows that the variable num is assigned the contents of each array element, not its index
value, and that the loop by default starts at 0 and traverses the entire array.
You can also use auto declaration in a range-based loop to process the elements of an
array. For example, using the range-based for loop, the for loop to find the largest
element in the array list can be written as:
for (auto num : list)
{
if (max < num)
max = num;
}

Suppose that list is declared as a formal parameter to a function to process an array. To
be specific, consider the following declaration:
void doSomething(int list[])
{
//code to process list
}

Then in the definition of the function doSomething, a range-based for loop cannot be
applied to list. Recall that in C++, arrays as parameters are passed by reference. Therefore, when the function doSomething is called, list gets the base address of the actual
parameters, that is, the base address of the actual parameter is copied into the memory space
list. So a formal parameter list is, in fact, not an array, it is a variable to store the address
of a memory location, so it has no first (that is, list[0]) and last elements.

C-Strings (Character Arrays)
Until now, we have avoided discussing character arrays for a simple reason: Character arrays
are of special interest, and you process them differently than you process other arrays. C++
provides many (predefined) functions that you can use with character arrays.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

C-Strings (Character Arrays)

|

551

Character array: An array whose components are of type char.

Recall that the most widely used character sets are ASCII and EBCDIC. The first character
in the ASCII character set is the null character, which is nonprintable. Also, recall that in
C++, the null character is represented as '\0', a backslash followed by a zero.
The statement:
ch = '\0';

stores the null character in ch, wherein ch is a char variable.
As you will see, the null character plays an important role in processing character arrays.
Because the collating sequence of the null character is 0, the null character is less than any
other character in the char data set.
The most commonly used term for character arrays is C-strings. However, there is a subtle
difference between character arrays and C-strings. Recall that a string is a sequence of zero or
more characters, and strings are enclosed in double quotation marks. In C++, C-strings are
null terminated; that is, the last character in a C-string is always the null character. A character
array might not contain the null character, but the last character in a C-string is always the
null character. As you will see, the null character should not appear anywhere in the C-string
except the last position. Also, C-strings are stored in (one-dimensional) character arrays.
The following are examples of C-strings:
"John L. Johnson"
"Hello there."

From the definition of C-strings, it is clear that there is a difference between 'A' and
"A". The first one is character A; the second is C-string A. Because C-strings are null
terminated, "A" represents two characters: 'A' and '\0'. Similarly, the C-string
"Hello" represents six characters: 'H', 'e', 'l', 'l', 'o', and '\0'. To store
'A', we need only one memory cell of type char; to store "A", we need two memory
cells of type char—one for 'A' and one for '\0'. Similarly, to store the C-string
"Hello" in computer memory, we need six memory cells of type char.
Consider the following statement:
char name[16];

This statement declares an array name of 16 components of type char. Because C-strings
are null terminated and name has 16 components, the largest string that can be stored in
name is of length 15, to leave room for the terminating '\0'. If you store a C-string of
length 10 in name, the first 11 components of name are used and the last 5 are left unused.
The statement:
char name[16] = {'J', 'o', 'h', 'n', '\0'};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

552 |

Chapter 8: Arrays and Strings

declares an array name containing 16 components of type char and stores the C-string
"John" in it. During char array variable declaration, C++ also allows the C-string notation
to be used in the initialization statement. The above statement is, therefore, equivalent to:
char name[16] = "John";

//Line A

Recall that the size of an array can be omitted if the array is initialized during the
declaration.
The statement:
char name[] = "John";

//Line B

declares a C-string variable name of a length large enough—in this case, 5—and stores
"John" in it. There is a difference between the last two statements: Both statements store
"John" in name, but the size of name in the statement in Line A is 16, and the size of
name in the statement in Line B is 5.
Most rules that apply to other arrays also apply to character arrays. Consider the following
statement:
char studentName[26];

Suppose you want to store "Lisa L. Johnson" in studentName. Because aggregate
operations, such as assignment and comparison, are not allowed on arrays, the following
statement is not legal:
studentName = "Lisa L. Johnson"; //illegal

C++ provides a set of functions that can be used for C-string manipulation. The header
file cstring defines these functions. We often use three of these functions: strcpy
(string copy, to copy a C-string into a C-string variable—that is, assignment); strcmp
(string comparison, to compare C-strings); and strlen (string length, to find the length
of a C-string). Table 8-1 summarizes these functions.
TABLE 8-1

strcpy, strcmp, and strlen Functions

Function

Effect
Copies the string s2 into the string variable s1

strcpy(s1, s2)

The length of s1 should be at least as large as s2
Returns a value < 0 if s1 is less than s2

strcmp(s1, s2)

Returns 0 if s1 and s2 are the same
Returns a value > 0 if s1 is greater than s2

strlen(s)

Returns the length of the string s, excluding the null

character

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

C-Strings (Character Arrays)

|

553

To use these functions, the program must include the header file cstring via the
include statement. That is, the following statement must be included in the program:
#include <cstring>

String Comparison
In C++, C-strings are compared character by character using the system’s collating
sequence. Let us assume that you use the ASCII character set.
1. The C-string "Air" is less than the C-string "Boat" because the first
character of "Air" is less than the first character of "Boat".
2. The C-string "Air" is less than the C-string "An" because the first
characters of both strings are the same, but the second character 'i'
of "Air" is less than the second character 'n' of "An".
3. The C-string "Bill" is less than the C-string "Billy" because the first
four characters of "Bill" and "Billy" are the same, but the fifth
character of "Bill", which is '\0' (the null character), is less than the
fifth character of "Billy", which is 'y'. (Recall that C-strings in C++
are null terminated.)
4. The C-string "Hello" is less than "hello" because the first character
'H' of the C-string "Hello" is less than the first character 'h' of the
C-string "hello".
As you can see, the function strcmp compares its first C-string argument with its second
C-string argument character by character.
EXAMPLE 8-10
Suppose you have the following statements:
char studentName[21];
char myname[16];
char yourname[16];

The following statements show how string functions work:
Statement
strcpy(myname, "John Robinson");

Effect
myname = "John Robinson"

strlen("John Robinson");

Returns 13, the length of the string

"John Robinson"
int len;
len = strlen("Sunny Day");

Stores 9 into len

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

554 |

Chapter 8: Arrays and Strings

strcpy(yourname, "Lisa Miller");
strcpy(studentName, yourname);

yourname = "Lisa Miller"
studentName = "Lisa Miller"

strcmp("Bill", "Lisa");

Returns a value < 0

strcpy(yourname, "Kathy Brown");
strcpy(myname, "Mark G. Clark");
strcmp(myname, yourname);

yourname = "Kathy Brown"
myname = "Mark G. Clark"
Returns a value > 0

In this chapter, we defined a C-string to be a sequence of zero or more characters.
C-strings are enclosed in double quotation marks. We also said that C-strings are null
terminated, so the C-string "Hello" has six characters even though only five are
enclosed in double quotation marks. Therefore, to store the C-string "Hello" in
computer memory, you must use a character array of size 6. The length of a C-string is the
number of actual characters enclosed in double quotation marks; for example, the length
of the C-string "Hello" is 5. Thus, in a logical sense, a C-string is a sequence of zero or
more characters, but in the physical sense (that is, to store the C-string in computer
memory), a C-string has at least one character. Because the length of the C-string is the
actual number of characters enclosed in double quotation marks, we defined a C-string to
be a sequence of zero or more characters. However, you must remember that the null
character stored in computer memory at the end of the C-string plays a key role when we
compare C-strings, especially C-strings such as "Bill" and "Billy".

Reading and Writing Strings
As mentioned earlier, most rules that apply to arrays apply to C-strings as well. Aggregate
operations, such as assignment and comparison, are not allowed on arrays. Even the input/
output of arrays is done component-wise. However, the one place where C++ allows
aggregate operations on arrays is the input and output of C-strings (that is, character arrays).
We will use the following declaration for our discussion:
char name[31];

String Input
Because aggregate operations are allowed for C-string input, the statement:
cin >> name;

stores the next input C-string into name. The length of the input C-string must be less
than or equal to 30. If the length of the input string is 4, the computer stores the four
characters that are input and the null character '\0'. If the length of the input C-string is
more than 30, then because there is no check on the array index bounds, the computer
continues storing the string in whatever memory cells follow name. This process can
cause serious problems, because data in the adjacent memory cells will be corrupted.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

C-Strings (Character Arrays)

|

555

When you input a C-string using an input device, such as the keyboard, you do not include
the double quotes around it unless the double quotes are part of the string. For example,
the C-string "Hello" is entered as Hello.

Recall that the extraction operator, >>, skips all leading whitespace characters and stops reading
data into the current variable as soon as it finds the first whitespace character or invalid data. As a
result, C-strings that contain blanks cannot be read using the extraction operator, >>. For
example, if a first name and last name are separated by blanks, they cannot be read into name.
How do you input C-strings with blanks into a character array? Once again, the function get
comes to our rescue. Recall that the function get is used to read character data. Until now,
the form of the function get that you have used (Chapter 3) read only a single character.
However, the function get can also be used to read strings. To read C-strings, you use the
form of the function get that has two parameters. The first parameter is a C-string variable;
the second parameter specifies how many characters to read into the string variable.
To read C-strings, the general form (syntax) of the get function, together with an input
stream variable such as cin, is:
cin.get(str, m + 1);

This statement stores the next m characters, or all characters until the newline character
'\n' is found, into str. The newline character is not stored in str. If the input C-string
has fewer than m characters, then the reading stops at the newline character.
Consider the following statements:
char str[31];
cin.get(str, 31);

If the input is:
William T. Johnson

then "William T. Johnson" is stored in str. Suppose that the input is:
Hello there. My name is Mickey Blair.

which is a string of length 37. Because str can store, at most, 30 characters, the C-string
"Hello there. My name is Mickey" is stored in str.
Now, suppose that we have the statements:
char str1[26];
char str2[26];
char discard;

and the two lines of input:
Summer is warm.
Winter will be cold.

Further, suppose that we want to store the first C-string in str1 and the second C-string in
str2. Both str1 and str2 can store C-strings that are up to 25 characters in length. Because

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

556 |

Chapter 8: Arrays and Strings

the number of characters in the first line is 15, the reading stops at '\n'. Now the newline
character remains in the input buffer and must be manually discarded. Therefore, you must read
and discard the newline character at the end of the first line to store the second line into str2.
The following sequence of statements stores the first line into str1 and the second line into
str2:
cin.get(str1, 26);
cin.get(discard);
cin.get(str2, 26);

To read and store a line of input, including whitespace characters, you can also use the
stream function getline. Suppose that you have the following declaration:
char textLine[100];

The following statement will read and store the next 99 characters, or until the newline
character, into textLine. The null character will be automatically appended as the last
character of textLine.
cin.getline(textLine, 100);

String Output
The output of C-strings is another place where aggregate operations on arrays are allowed.
You can output C-strings by using an output stream variable, such as cout, together with
the insertion operator, <<. For example, the statement:
cout << name;

outputs the contents of name on the screen. The insertion operator, <<, continues to write
the contents of name until it finds the null character. Thus, if the length of name is 4, the
above statement outputs only four characters. If name does not contain the null character,
then you will see strange output because the insertion operator continues to output data
from memory adjacent to name until a '\0' is found. For example, see the output of the
following program. (Note that on your computer, you may get a different output.)
#include <iostream>
using namespace std;
int main()
{
char name[5] = {'a', 'b', 'c', 'd', 'e'};
int x = 50;
int y = -30;
cout << name << endl;
return 0;
}

Output:
abcde

@·I

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

C-Strings (Character Arrays)

|

557

Specifying Input/Output Files at Execution Time
In Chapter 3, you learned how to read data from a file. In subsequent chapters, the name of
the input file was included in the open statement. By doing so, the program always received
data from the same input file. In real-world applications, the data may actually be collected at
several locations and stored in separate files. Also, for comparison purposes, someone might
want to process each file separately and then store the output in separate files. To accomplish
this task efficiently, the user would prefer to specify the name of the input and/or output file
at execution time rather than in the programming code. C++ allows the user to do so.
Consider the following statements:
ifstream infile;
ofstream outfile;
char fileName[51];

//assume that the file name is at most
//50 characters long

The following statements prompt and allow the user to specify the input and output files
at execution time:
cout << "Enter the input file name: ";
cin >> fileName;
//open the input file
infile.open(fileName);
.
.
.
cout << "Enter the output file name: ";
cin >> fileName;
outfile.open(fileName);

//open the output file

The Programming Example: Code Detection, given later in this chapter, further illustrates how to specify the names of input and output files during program execution.

string Type and Input/Output Files
In Chapter 7, we discussed the data type string. We now want to point out that values (that
is, strings) of type string are not null terminated. Variables of type string can also be used
to read and store the names of input/output files. However, the argument to the function
open must be a null-terminated string—that is, a C-string. Therefore, if we use a variable of
type string to read the name of an input/output file and then use this variable to open a file,
the value of the variable must (first) be converted to a C-string (that is, a null-terminated string).
The header file string contains the function c_str, which converts a value of type string
to a null-terminated character array (that is, C-string). The syntax to use the function c_str is:
strVar.c_str()

in which strVar is a variable of type string.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

558 |

Chapter 8: Arrays and Strings

The following statements illustrate how to use variables of type string to read the
names of the input/output files during program execution and open those files:
ifstream infile;
string fileName;
cout << "Enter the input file name: ";
cin >> fileName;
infile.open(fileName.c_str());

//open the input file

Of course, you must also include the header file string in the program. The output file
has similar conventions.

Parallel Arrays
Two (or more) arrays are called parallel if their corresponding components hold related
information.
Suppose you need to keep track of students’ course grades, together with their ID numbers, so
that their grades can be posted at the end of the semester. Further, suppose that there is a
maximum of 50 students in a class and their IDs are 5 digits long. Because there may be 50
students, you need 50 variables to store the students’ IDs and 50 variables to store their grades.
You can declare two arrays: studentId of type int and courseGrade of type char. Each
array has 50 components. Furthermore, studentId[0] and courseGrade[0] will store
the ID and course grade of the first student, studentId[1] and courseGrade[1] will
store the ID and course grade of the second student, and so on.
The statements:
int studentId[50];
char courseGrade[50];

declare these two arrays.
Suppose you need to input data into these arrays, and the data is provided in a file in the
following form:
studentId courseGrade

For example, a sample data set is:
23456
86723
22356
92733
11892
.
.
.

A
B
C
B
D

Suppose that the input file is opened using the ifstream variable infile. Because the
size of each array is 50, a maximum of 50 elements can be stored into each array.
Moreover, it is possible that there may be fewer than 50 students in the class. Therefore,

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Two- and Multidimensional Arrays

|

559

while reading the data, we also count the number of students and ensure that the array
indices do not go out of bounds. The following loop reads the data into the parallel arrays
studentId and courseGrade:
int noOfStudents = 0;
infile >> studentId[noOfStudents] >> courseGrade[noOfStudents];
while (infile && noOfStudents < 50)
{
noOfStudents++;
infile >> studentId[noOfStudents]
>> courseGrade[noOfStudents];
}

Note that, in general, when swapping values in one array, the corresponding values in
parallel arrays must also be swapped.

Two- and Multidimensional Arrays
The remainder of this chapter discusses two-dimensional arrays and ways to work with
multidimensional arrays.
In the previous section, you learned how to use one-dimensional arrays to manipulate
data. If the data is provided in a list form, you can use one-dimensional arrays.
However, sometimes data is provided in a table form. For example, suppose that you
want to track the number of cars in a particular color that are in stock at a local
dealership. The dealership sells six types of cars in five different colors. Figure 8-12
shows sample data.

[RED]

[BROWN]

[BLACK]

[WHITE]

[GRAY]

[GM]

10

7

12

10

4

[FORD]

18

11

15

17

10

[TOYOTA]

12

10

9

5

12

[BMW]

16

6

13

8

3

[NISSAN]

10

7

12

6

4

[VOLVO]

9

4

7

12

11

inStock

FIGURE 8-12

Table inStock

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

560 |

Chapter 8: Arrays and Strings

You can see that the data is in a table format. The table has 30 entries, and every entry is
an integer. Because the table entries are all of the same type, you can declare a onedimensional array of 30 components of type int. The first five components of the onedimensional array can store the data of the first row of the table, the next five
components of the one-dimensional array can store the data of the second row of the
table, and so on. In other words, you can simulate the data given in a table format in a
one-dimensional array.
If you do so, the algorithms to manipulate the data in the one-dimensional array
will be somewhat complicated, because you must know where one row ends and
another begins. You must also correctly compute the index of a particular element.
C++ simplifies the processing of manipulating data in a table form with the use
of two-dimensional arrays. This section first discusses how to declare twodimensional arrays and then looks at ways to manipulate data in a two-dimensional
array.
Two-dimensional array: A collection of a fixed number of components arranged in rows
and columns (that is, in two dimensions), wherein all components are of the same type.

The syntax for declaring a two-dimensional array is:
dataType

arrayName[intExp1][intExp2];

wherein intExp1 and intExp2 are constant expressions yielding positive integer values.
The two expressions, intExp1 and intExp2, specify the number of rows and the
number of columns, respectively, in the array.
The statement:
double sales[10][5];

declares a two-dimensional array sales of 10 rows and 5 columns, in which
every component is of type double. As in the case of a one-dimensional array,
the rows are numbered 0. . .9 and the columns are numbered 0. . .4 (see
Figure 8-13).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Two- and Multidimensional Arrays

sales

[0]

[1]

[2]

[3]

|

561

[4]

[0]
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]

FIGURE 8-13

Two-dimensional array sales

Accessing Array Components
To access the components of a two-dimensional array, you need a pair of indices: one for
the row position (which occurs first) and one for the column position (which occurs
second).
The syntax to access a component of a two-dimensional array is:
arrayName[indexExp1][indexExp2]

wherein indexExp1 and indexExp2 are expressions yielding nonnegative integer
values. indexExp1 specifies the row position; indexExp2 specifies the column
position.
The statement:
sales[5][3] = 25.75;

stores 25.75 into row number 5 and column number 3 (that is, the sixth row and the
fourth column) of the array sales (see Figure 8-14).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

562 |

Chapter 8: Arrays and Strings

sales

[0]

[1]

[2]

[0]
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]

FIGURE 8-14

[3]

[4]

sales [5] [3]

25.75

sales[5][3]

Suppose that:
int i = 5;
int j = 3;

Then, the previous statement:
sales[5][3] = 25.75;

is equivalent to:
sales[i][j] = 25.75;

So the indices can also be variables.

Two-Dimensional Array Initialization during Declaration
Like one-dimensional arrays, two-dimensional arrays can be initialized when they are declared.
The following example helps illustrate this concept. Consider the following statement:
int board[4][3] = {{2, 3, 1},
{15, 25, 13},
{20, 4, 7},
{11, 18, 14}};

This statement declares board to be a two-dimensional array of four rows and three
columns. The elements of the first row are 2, 3, and 1; the elements of the second row are 15,
25, and 13; the elements of the third row are 20, 4, and 7; and the elements of the fourth row
are 11, 18, and 14, respectively. Figure 8-15 shows the array board.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Two- and Multidimensional Arrays

board
[0]
[1]
[2]
[3]

FIGURE 8-15

[0]

[1]

[2]

2
15
20
11

3
25
4
18

1
13
7
14

|

563

Two-dimensional array board

To initialize a two-dimensional array when it is declared:
1. The elements of each row are all enclosed within one set of curly braces
and separated by commas.
2. The set of all rows is enclosed within curly braces.
3. For number arrays, if all components of a row are not specified, the
unspecified components are initialized to 0. In this case, at least one of
the values must be given to initialize all the components of a row.

Two-Dimensional Arrays and Enumeration Types
The section ‘‘Enumeration Type’’ in Chapter 7 is required to understand this section.

You can also use the enumeration type for array indices. Consider the following statements:
const int NUMBER_OF_ROWS = 6;
const int NUMBER_OF_COLUMNS = 5;
enum carType {GM, FORD, TOYOTA, BMW, NISSAN, VOLVO};
enum colorType {RED, BROWN, BLACK, WHITE, GRAY};
int inStock[NUMBER_OF_ROWS][NUMBER_OF_COLUMNS];

These statements define the carType and colorType enumeration types and define
inStock as a two-dimensional array of six rows and five columns. Suppose that each
row in inStock corresponds to a car type, and each column in inStock corresponds to
a color type. That is, the first row corresponds to the car type GM, the second row
corresponds to the car type FORD, and so on. Similarly, the first column corresponds to
the color type RED, the second column corresponds to the color type BROWN, and so on.
Suppose further that each entry in inStock represents the number of cars of a particular
type and color (see Figure 8-16).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

564 |

Chapter 8: Arrays and Strings

inStock

[RED]

[BROWN]

[BLACK]

[WHITE]

[GRAY]

[GM]
[FORD]
[TOYOTA]
[BMW]
[NISSAN]
[VOLVO]

FIGURE 8-16

Two-dimensional array inStock

The statement:
inStock[1][3] = 15;

is equivalent to the following statement (see Figure 8-17):
inStock[FORD][WHITE] = 15;

inStock [FORD] [WHITE]
inStock

[RED]

[BROWN]

[BLACK]

[WHITE]

[GRAY]

[GM]
[FORD]

15

[TOYOTA]
[BMW]
[NISSAN]
[VOLVO]

FIGURE 8-17

inStock[FORD][WHITE]

The second statement easily conveys the message—that is, set the number of WHITE
FORD cars to 15. This example illustrates that enumeration types can be used effectively
to make the program readable and easy to manage.
PROCESSING TWO-DIMENSIONAL ARRAYS
A two-dimensional array can be processed in three ways:

1. Process a single element.
2. Process the entire array.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Two- and Multidimensional Arrays

|

565

3. Process a particular row of the array, called row processing.
4. Process a particular column of the array, called column processing.
Processing a single element is like processing a single variable. Initializing and printing the
array are examples of processing the entire two-dimensional array. Finding the largest
element in a row (column) or finding the sum of a row (column) are examples of row
(column) processing. We will use the following declaration for our discussion:
const int NUMBER_OF_ROWS = 7;
//This can be set to any number.
const int NUMBER_OF_COLUMNS = 6; //This can be set to any number.
int
int
int
int
int
int

matrix[NUMBER_OF_ROWS][NUMBER_OF_COLUMNS];
row;
col;
sum;
largest;
temp;

Figure 8-18 shows the array matrix.

matrix

[0]

[1]

[2]

[3]

[4]

[5]

[0]
[1]
[2]
[3]
[4]
[5]
[6]

FIGURE 8-18

Two-dimensional array matrix

All of the components of a two-dimensional array, whether rows or columns, are
identical in type. If a row is looked at by itself, it can be seen to be just a one-dimensional
array. A column seen by itself is also a one-dimensional array. Therefore, when processing a particular row or column of a two-dimensional array, we use algorithms similar to
those that process one-dimensional arrays. We further explain this concept with the help of
the two-dimensional array matrix, as declared previously.
Suppose that we want to process row number 5 of matrix (that is, the sixth row of
matrix). The elements of row number 5 of matrix are:
matrix[5][0], matrix[5][1], matrix[5][2], matrix[5][3], matrix[5][4],
matrix[5][5]

We see that in these components, the first index (the row position) is fixed at 5. The
second index (the column position) ranges from 0 to 5. Therefore, we can use the
following for loop to process row number 5:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

566 |

Chapter 8: Arrays and Strings

for (col = 0; col < NUMBER_OF_COLUMNS; col++)
process matrix[5][col]

Clearly, this for loop is equivalent to the following for loop:
row = 5;
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
process matrix[row][col]

Similarly, suppose that we want to process column number 2 of matrix, that is, the third
column of matrix. The elements of this column are:
matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2], matrix[4][2],
matrix[5][2], matrix[6][2]

Here, the second index (that is, the column position) is fixed at 2. The first index (that is,
the row position) ranges from 0 to 6. In this case, we can use the following for loop to
process column 2 of matrix:
for (row = 0; row < NUMBER_OF_ROWS; row++)
process matrix[row][2]

Clearly, this for loop is equivalent to the following for loop:
col = 2;
for (row = 0; row < NUMBER_OF_ROWS; row++)
process matrix[row][col]

Next, we discuss specific processing algorithms.

Initialization
Suppose that you want to initialize row number 4, that is, the fifth row, to 0. As
explained earlier, the following for loop does this:
row = 4;
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
matrix[row][col] = 0;

If you want to initialize the entire matrix to 0, you can also put the first index, that is,
the row position, in a loop. By using the following nested for loops, we can initialize
each component of matrix to 0:
for (row = 0; row < NUMBER_OF_ROWS; row++)
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
matrix[row][col] = 0;

Print
By using a nested for loop, you can output the elements of matrix. The following
nested for loops print the elements of matrix, one row per line:
for (row = 0; row < NUMBER_OF_ROWS; row++)
{

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Two- and Multidimensional Arrays

|

567

for (col = 0; col < NUMBER_OF_COLUMNS; col++)
cout << setw(5) << matrix[row][col] << " ";
cout << endl;
}

Input
The following for loop inputs the data into row number 4, that is, the fifth row of matrix:
row = 4;
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
cin >> matrix[row][col];

As before, by putting the row number in a loop, you can input data into each component
of matrix. The following for loop inputs data into each component of matrix:
for (row = 0; row < NUMBER_OF_ROWS; row++)
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
cin >> matrix[row][col];

Sum by Row
The following for loop finds the sum of row number 4 of matrix; that is, it adds the
components of row number 4:
sum = 0;
row = 4;
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
sum = sum + matrix[row][col];

Once again, by putting the row number in a loop, we can find the sum of each row
separately. The following is the C++ code to find the sum of each individual row:
//Sum of each individual row
for (row = 0; row < NUMBER_OF_ROWS; row++)
{
sum = 0;
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
sum = sum + matrix[row][col];
cout << "Sum of row " << row + 1 << " = " << sum << endl;
}

Sum by Column
As in the case of sum by row, the following nested for loop finds the sum of each
individual column:
//Sum of each individual column
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
{
sum = 0;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

568 |

Chapter 8: Arrays and Strings

for (row = 0; row < NUMBER_OF_ROWS; row++)
sum = sum + matrix[row][col];
cout << "Sum of column " << col + 1 << " = " << sum
<< endl;
}

Largest Element in Each Row and Each Column
As stated earlier, two other operations on a two-dimensional array are finding the largest
element in each row and each column and finding the sum of both diagonals. Next, we
give the C++ code to perform these operations.
The following for loop determines the largest element in row number 4:
row = 4;
largest = matrix[row][0]; //Assume that the first element of
//the row is the largest.
for (col = 1; col < NUMBER_OF_COLUMNS; col++)
if (matrix[row][col] > largest)
largest = matrix[row][col];

The following C++ code determines the largest element in each row and each column:
//Largest element in each row
for (row = 0; row < NUMBER_OF_ROWS; row++)
{
largest = matrix[row][0]; //Assume that the first element
//of the row is the largest.
for (col = 1; col < NUMBER_OF_COLUMNS; col++)
if (matrix[row][col] > largest)
largest = matrix[row][col];
cout << "The largest element in row " << row + 1 << " = "
<< largest << endl;
}
//Largest element in each column
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
{
largest = matrix[0][col]; //Assume that the first element
//of the column is the largest.
for (row = 1; row < NUMBER_OF_ROWS; row++)
if (matrix[row][col] > largest)
largest = matrix[row][col];
cout << "The largest element in column " << col + 1
<< " = " << largest << endl;
}

Passing Two-Dimensional Arrays as Parameters to Functions
Two-dimensional arrays can be passed as parameters to a function, and they are passed by
reference. The base address (that is, the address of the first component of the actual
parameter) is passed to the formal parameter. If matrix is the name of a two-dimensional
array, then matrix[0][0] is the first component of matrix.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Two- and Multidimensional Arrays

|

569

When storing a two-dimensional array in the computer’s memory, C++ uses the row
order form. That is, the first row is stored first, followed by the second row, followed by
the third row, and so on.
In the case of a one-dimensional array, when declaring it as a formal parameter, we
usually omit the size of the array. Because C++ stores two-dimensional arrays in row
order form, to compute the address of a component correctly, the compiler must know
where one row ends and the next row begins. Thus, when declaring a two-dimensional
array as a formal parameter, you can omit the size of the first dimension, but not the
second; that is, you must specify the number of columns.
Suppose we have the following declaration:
const int NUMBER_OF_ROWS = 6;
const int NUMBER_OF_COLUMNS = 5;

Consider the following definition of the function printMatrix:
void printMatrix(int matrix[][NUMBER_OF_COLUMNS],
int noOfRows)
{
int row, col;
for (row = 0; row < noOfRows; row++)
{
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
cout << setw(5) << matrix[row][col] << " ";
cout << endl;
}
}

This function takes as a parameter a two-dimensional array of an unspecified number of
rows and five columns, and outputs the content of the two-dimensional array. During
the function call, the number of columns of the actual parameter must match the number
of columns of the formal parameter.
Similarly, the following function outputs the sum of the elements of each row of a twodimensional array whose elements are of type int:
void sumRows(int matrix[][NUMBER_OF_COLUMNS], int noOfRows)
{
int row, col;
int sum;
//Sum of each individual row
for (row = 0; row < noOfRows; row++)
{
sum = 0;
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
sum = sum + matrix[row][col];
cout << "Sum of row " << (row + 1) << " = " << sum
<< endl;
}
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

570 |

Chapter 8: Arrays and Strings

The following function determines the largest element in each row:
void largestInRows(int matrix[][NUMBER_OF_COLUMNS],
int noOfRows)
{
int row, col;
int largest;
//Largest element in each row
for (row = 0; row < noOfRows; row++)
{
largest = matrix[row][0]; //Assume that the first element
//of the row is the largest.
for (col = 1; col < NUMBER_OF_COLUMNS; col++)
if (largest < matrix[row][col])
largest = matrix[row][col];
cout << "The largest element of row " << (row + 1)
<< " = " << largest << endl;
}
}

Likewise, you can write a function to find the sum of the elements of each column, read
the data into a two-dimensional array, find the largest and/or smallest element in each
row or column, and so on.
Example 8-11 shows how the functions printMatrix, sumRows, and largestInRows
are used in a program.
EXAMPLE 8-11
The following program illustrates how two-dimensional arrays are passed as parameters to
functions.
// Two-dimensional arrays as parameters to functions.
#include <iostream>
#include <iomanip>
using namespace std;
const int NUMBER_OF_ROWS = 6;
const int NUMBER_OF_COLUMNS = 5;
void printMatrix(int matrix[][NUMBER_OF_COLUMNS],
int NUMBER_OF_ROWS);
void sumRows(int matrix[][NUMBER_OF_COLUMNS],
int NUMBER_OF_ROWS);
void largestInRows(int matrix[][NUMBER_OF_COLUMNS],
int NUMBER_OF_ROWS);
int main()
{

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Two- and Multidimensional Arrays

int board[NUMBER_OF_ROWS][NUMBER_OF_COLUMNS]
= {{23, 5, 6, 15, 18},
{4, 16, 24, 67, 10},
{12, 54, 23, 76, 11},
{1, 12, 34, 22, 8},
{81, 54, 32, 67, 33},
{12, 34, 76, 78, 9}};

//Line 1

printMatrix(board, NUMBER_OF_ROWS);
cout << endl;
sumRows(board, NUMBER_OF_ROWS);
cout << endl;
largestInRows(board, NUMBER_OF_ROWS);

//Line
//Line
//Line
//Line
//Line

|

571

2
3
4
5
6

return 0;
}
//Place the definitions of the functions printMatrix,
//sumRows, and largestInRows as described previously here.

Sample Run:
23
4
12
1
81
12

5
16
54
12
54
34

Sum
Sum
Sum
Sum
Sum
Sum

of
of
of
of
of
of

row
row
row
row
row
row

The
The
The
The
The
The

largest
largest
largest
largest
largest
largest

6
24
23
34
32
76

1
2
3
4
5
6

=
=
=
=
=
=

15
67
76
22
67
78

18
10
11
8
33
9

8

67
121
176
77
267
209

element
element
element
element
element
element

in
in
in
in
in
in

row
row
row
row
row
row

1
2
3
4
5
6

=
=
=
=
=
=

23
67
76
34
81
78

In this program, the statement in Line 1 declares and initializes board to be a twodimensional array of six rows and five columns. The statement in Line 2 uses the
function printMatrix to output the elements of board (see the first six lines of the
Sample Run). The statement in Line 4 uses the function sumRows to calculate and print
the sum of each row. The statement in Line 6 uses the function largestInRows to find
and print the largest element in each row.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

572 |

Chapter 8: Arrays and Strings

Arrays of Strings
Suppose that you need to perform an operation, such as alphabetizing a list of names. Because
every name is a string, a convenient way to store the list of names is to use an array. Strings in
C++ can be manipulated using either the data type string or character arrays (C-strings). Also,
on some compilers, the data type string may not be available in Standard C++ (that is, nonANSI/ISO Standard C++). This section illustrates both ways to manipulate a list of strings.

Arrays of Strings and the string Type
Processing a list of strings using the data type string is straightforward. Suppose that the
list consists of a maximum of 100 names. You can declare an array of 100 components of
type string as follows:
string list[100];

Basic operations, such as assignment, comparison, and input/output, can be performed on
values of the string type. Therefore, the data in list can be processed just like any
one-dimensional array discussed in the first part of this chapter.

Arrays of Strings and C-Strings (Character Arrays)
Suppose that the largest string (for example, name) in your list is 15 characters long and
your list has 100 strings. You can declare a two-dimensional array of characters of
100 rows and 16 columns as follows (see Figure 8-19):
char list[100][16];

list
list[0]
list[1]
list[2]
list[3]
...
list[40]
list[41]
...
list[98]
list[99]

FIGURE 8-19

Array list of strings

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Two- and Multidimensional Arrays

|

573

Now list[j] for each j, 0 <= j <= 99, is a string of at most 15 characters in length.
The following statement stores "Snow White" in list[1] (see Figure 8-20):
strcpy(list[1], "Snow White");

list
list[0]
list[1] S n o w
list[2]
list[3]

W h i

t e \0

...
list[40]
list[41]
...
list[98]
list[99]

FIGURE 8-20

Array list, showing list[1]

Suppose that you want to read and store data in list and that there is one entry per line.
The following for loop accomplishes this task:
for (j = 0; j < 100; j++)
cin.get(list[j], 16);

The following for loop outputs the string in each row:
for (j = 0; j < 100; j++)
cout << list[j] << endl;

You can also use other string functions (such as strcmp and strlen) and for loops to
manipulate list.
The data type string has operations such as assignment, concatenation, and relational
operations defined for it. If you use Standard C++ header files and the data type string
is available on your compiler, we recommend that you use the data type string to
manipulate lists of strings.

Another Way to Declare a Two-Dimensional Array
This section may be skipped without any loss of continuity.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

574 |

Chapter 8: Arrays and Strings

If you know the size of the tables with which the program will be working, then you can
use typedef to first define a two-dimensional array data type and then declare variables
of that type.
For example, consider the following:
const int NUMBER_OF_ROWS = 20;
const int NUMBER_OF_COLUMNS = 10;
typedef int tableType[NUMBER_OF_ROWS][NUMBER_OF_COLUMNS];

The previous statement defines a two-dimensional array data type tableType. Now we
can declare variables of this type. So:
tableType matrix;

declares a two-dimensional array matrix of 20 rows and 10 columns.
You can also use this data type when declaring formal parameters, as shown in the
following code:
void initialize(tableType table)
{
int row;
int col;
for (row = 0; row < NUMBER_OF_ROWS; row++)
for (col = 0; col < NUMBER_OF_COLUMNS; col++)
table[row][col] = 0;
}

This function takes as an argument any variable of type tableType, which is a twodimensional array containing 20 rows and 10 columns, and initializes the array to 0.
By first defining a data type, you do not need to keep checking the exact number of
columns when you declare a two-dimensional array as a variable or formal parameter, or
when you pass an array as a parameter during a function call.

Multidimensional Arrays
In this chapter, we defined an array as a collection of a fixed number of elements (called
components) of the same type. A one-dimensional array is an array in which the
elements are arranged in a list form; in a two-dimensional array, the elements are
arranged in a table form. We can also define three-dimensional or larger arrays. In
C++, there is no limit, except the limit of the memory space, on the dimension of
arrays. Following is the general definition of an array.
n-dimensional array: A collection of a fixed number of components arranged in n

dimensions (n >¼ 1).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Two- and Multidimensional Arrays

|

575

The general syntax for declaring an n-dimensional array is:
dataType arrayName[intExp1][intExp2] ... [intExpn];

where intExp1, intExp2, . . . , and intExpn are constant expressions yielding
positive integer values.
The syntax to access a component of an n-dimensional array is:
arrayName[indexExp1][indexExp2] ... [indexExpn]

where indexExp1,indexExp2, . . ., and indexExpn are expressions yielding
nonnegative integer values. indexExpi gives the position of the array component
in the ith dimension.
For example, the statement:
double carDealers[10][5][7];

declares carDealers to be a three-dimensional array. The size of the first dimension is 10, the size of the second dimension is 5, and the size of the third
dimension is 7. The first dimension ranges from 0 to 9, the second dimension
ranges from 0 to 4, and the third dimension ranges from 0 to 6. The base address
of the array carDealers is the address of the first array component—that is, the
address of carDealers[0][0][0]. The total number of components in the array
carDealers is 10 * 5 * 7 = 350.
The statement:
carDealers[5][3][2] = 15564.75;

sets the value of carDealers[5][3][2] to 15564.75.
You can use loops to process multidimensional arrays. For example, the nested for
loops:
for (i = 0; i < 10; i++)
for (j = 0; j < 5; j++)
for (k = 0; k < 7; k++)
carDealers[i][j][k] = 0.0;

initialize the entire array to 0.0.
When declaring a multidimensional array as a formal parameter in a function, you can
omit the size of the first dimension but not the other dimensions. As parameters, multidimensional arrays are passed by reference only, and a function cannot return a value of
the array type. There is no check to determine whether the array indices are within
bounds, so it is often advisable to include some form of ‘‘index-in-range’’ checking.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

576 |

Chapter 8: Arrays and Strings

PROGRAMMING EXAMPLE:

Code Detection

When a message is transmitted in secret code over a transmission channel, it is
usually sent as a sequence of bits, that is, 0s and 1s. Due to noise in the
transmission channel, the transmitted message may become corrupted. That is,
the message received at the destination is not the same as the message transmitted;
some of the bits may have been changed. There are several techniques to check
the validity of the transmitted message at the destination. One technique is to
transmit the same message twice. At the destination, both copies of the message are
compared bit by bit. If the corresponding bits are the same, the message received is
error-free.
Let’s write a program to check whether the message received at the destination is
error-free. For simplicity, assume that the secret code representing the message is a
sequence of digits (0 to 9) and the maximum length of the message is 250 digits.
Also, the first number in the message is the length of the message. For example, if the
secret code is:
7 9 2 7 8 3 5 6

then the actual message is 7 digits long.
The above message is transmitted as:
7 9 2 7 8 3 5 6 7 9 2 7 8 3 5 6
Input

A file containing the secret code and its copy

Output

The secret code, its copy, and a message—if the received code is error-free—in
the following form:

Code Digit
Code Digit Copy
9
9
2
2
7
7
8
8
3
3
5
5
6
6
Message transmitted OK.
PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Because we have to compare the corresponding digits of the secret code and its copy, we
first read the secret code and store it in an array. Then we read the first digit of the copy
and compare it with the first digit of the secret code, and so on. If any of the
corresponding digits are not the same, we indicate this fact by printing a message next
to the digits. Because the maximum length of the message is 250, we use an array of size
250. The first number in both the secret code and the copy of the secret code indicates
the length of the code. This discussion translates into the following algorithm:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Code Detection

|

577

1.
2.
3.
4.

Open the input and output files.
If the input file does not exist, exit the program.
Read the length of the secret code.
If the length of the secret code is greater than 250, terminate the
program because the maximum length of the code in this program is 250.
5. Read and store the secret code into an array.
6. Read the length of the copy.
7. If the length of the secret code and its copy are the same, compare
the codes and output an appropriate message. Otherwise, print an
error message.

To simplify the function main, let us write a function, readCode, to read the secret
code and another function, compareCode, to compare the codes.
readCode This function first reads the length of the secret code. If the length of the
secret code is greater than 250, a bool variable lenCodeOk, which is a
reference parameter, is set to false and the function terminates. The value of
lenCodeOk is passed to the calling function to indicate whether the secret code
was read successfully. If the length of the code is less than 250, the readCode

function reads and stores the secret code into an array. Because the input is stored
into a file and the file was opened in the function main, the input stream variable
corresponding to the input file must be passed as a parameter to this function.
Furthermore, after reading the length of the secret code and the code itself, the
readCode function must pass these values to the function main. Therefore, this
function has four parameters: an input file stream variable, an array to store the
secret code, the length of the code, and the bool parameter lenCodeOk. The
definition of the function readCode is as follows:
void readCode(ifstream& infile, int list[], int& length,
bool& lenCodeOk)
{
int count;
lenCodeOk = true;
infile >> length;

//get the length of the secret code

if (length > MAX_CODE_SIZE)
{
lenCodeOk = false;
return;
}
//Get the secret code.
for (count = 0; count < length; count++)
infile >> list[count];
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

578 |

Chapter 8: Arrays and Strings

compareCode This function compares the secret code with its copy. Therefore, it must have access

to the array containing the secret code and the length of the secret code. The copy of
the secret code and its length are stored in the input file. Thus, the input stream
variable corresponding to the input file must be passed as a parameter to this function.
Also, the compareCode function compares the secret code with the copy and prints
an appropriate message. Because the output will be stored in a file, the output stream
variable corresponding to the output file must also be passed as a parameter to this
function. Therefore, the function has four parameters: an input file stream variable,
an output file stream variable, the array containing the secret code, and the length of
the secret code. This discussion translates into the following algorithm for the
function compareCode:
a.
b.
c.
d.

Declare the variables.
Set a bool variable codeOk to true.
Read the length of the copy of the secret code.
If the length of the secret code and its copy are not the same, output
an appropriate error message and terminate the function.
e. For each digit in the input file:
e.1. Read the next digit of the copy of the secret code.
e.2. Output the corresponding digits from the secret code and its copy.
e.3. If the corresponding digits are not the same, output an error
message and set the bool variable codeOk to false.
f. If the bool variable codeOk is true
Output a message indicating that the secret code was transmitted
correctly.
else
Output an error message.
Following this algorithm, the definition of the function compareCode is:
void compareCode(ifstream& infile, ofstream& outfile,
const int list[], int length)
{
//Step a
int length2;
int digit;
bool codeOk;
int count;
codeOk = true;

//Step b

infile >> length2;

//Step c

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Code Detection

if (length != length2)
{
cout << "The original code and its copy "
<< "are not of the same length."
<< endl;
return;
}
outfile << "Code Digit
<< endl;

|

579

//Step d

Code Digit Copy"

for (count = 0; count < length; count++)
{
infile >> digit;
outfile << setw(5) << list[count]
<< setw(17) << digit;

//Step e
//Step e.1
//Step e.2

if (digit != list[count])
//Step e.3
{
outfile << " code digits are not the same"
<< endl;
codeOk = false;
}
else
outfile << endl;
}
if (codeOk)
outfile <<
<<
else
outfile <<
<<

//Step f
"Message transmitted OK."
endl;
"Error in transmission. "
"Retransmit!!" << endl;

}

The following is the algorithm for the function main:
Main
Algorithm

1.
2.
3.
4.

Declare the variables.
Open the files.
Call the function readCode to read the secret code.
if (length of the secret code <= 250)
Call the function compareCode to compare the codes.
else

Output an appropriate error message.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

580 |

Chapter 8: Arrays and Strings

COMPLETE PROGRAM LISTING
//************************************************************
// Author: D.S. Malik
//
// Program: Check Code
// This program determines whether a code is transmitted
// correctly.
//************************************************************
#include <iostream>
#include <fstream>
#include <iomanip>
using namespace std;
const int MAX_CODE_SIZE = 250;
void readCode(ifstream& infile, int list[],
int& length, bool& lenCodeOk);
void compareCode(ifstream& infile, ofstream& outfile,
const int list[], int length);
int main()
{
//Step 1
int codeArray[MAX_CODE_SIZE]; //array to store the secret
//code
int codeLength;
//variable to store the
//length of the secret code
bool lengthCodeOk; //variable to indicate if the length
//of the secret code is less than or
//equal to 250
ifstream incode;
ofstream outcode;

//input file stream variable
//output file stream variable

char inputFile[51]; //variable to store the name of the
//input file
char outputFile[51];
//variable to store the name of
//the output file
cout << "Enter the input file name: ";
cin >> inputFile;
cout << endl;
//Step 2
incode.open(inputFile);
if (!incode)
{
cout << "Cannot open the input file." << endl;
return 1;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Code Detection

|

581

cout << "Enter the output file name: ";
cin >> outputFile;
cout << endl;
outcode.open(outputFile);
readCode(incode, codeArray, codeLength,
lengthCodeOk);
if (lengthCodeOk)
compareCode(incode, outcode, codeArray,
codeLength);
else
cout << "Length of the secret code "
<< "must be <= " << MAX_CODE_SIZE
<< endl;

//Step 3
//Step 4

//Step 5

incode.close();
outcode.close();
return 0;
}
//Place the definitions of the functions readCode and
//compareCode, as described previously, here.

Sample Run: In this sample run, the user input is shaded.
Enter the input file name: Ch8_SecretCodeData.txt
Enter the output file name: Ch8_SecretCodeOut.txt

Input File Data: (Ch8_SecretCodeData.txt)
7927835679278356

Output File Data: (Ch8_SecretCodeOut.txt)
Code Digit
Code Digit Copy
9
9
2
2
7
7
8
8
3
3
5
5
6
6
Message transmitted OK.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

582 |

Chapter 8: Arrays and Strings

PROGRAMMING EXAMPLE:

Text Processing

(Line and letter count) Let us now write a program that reads a given text, outputs
the text as is, and also prints the number of lines and the number of times each letter
appears in the text. An uppercase letter and a lowercase letter are treated as being the
same; that is, they are tallied together.

Watch
the Video

Because there are 26 letters, we use an array of 26 components to perform the letter
count. We also need a variable to store the line count.
The text is stored in a file, which we will call textin.txt. The output will be
stored in a file, which we will call textout.out.

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Input

A file containing the text to be processed.

Output

A file containing the text, number of lines, and the number of times a
letter appears in the text.

Based on the desired output, it is clear that we must output the text as is. That is, if the
text contains any whitespace characters, they must be output as well. Furthermore, we
must count the number of lines in the text. Therefore, we must know where the line
ends, which means that we must trap the newline character. This requirement suggests
that we cannot use the extraction operator to process the input file. Because we also
need to perform the letter count, we use the get function to read the text.
Let us first describe the variables that are necessary to develop the program. This will
simplify the discussion that follows.

Variables We need to store the line count and the letter count. Therefore, we need a variable

to store the line count and 26 variables to perform the letter count. We will use an
array of 26 components to perform the letter count. We also need a variable to read
and store each character in turn, because the input file is to be read character by
character. Because data is to be read from an input file and output is to be saved in a
file, we need an input stream variable to open the input file and an output stream
variable to open the output file. These statements indicate that the function main
needs (at least) the following variables:
int lineCount;
int letterCount[26];
char ch;
ifstream infile;
ofstream outfile;

//variable to store the line count
//array to store the letter count
//variable to store a character
//input file stream variable
//output file stream variable

In this declaration, letterCount[0] stores the A count, letterCount[1]
stores the B count, and so on. Clearly, the variable lineCount and the array
letterCount must be initialized to 0.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Text Processing |

583

The algorithm for the program is:
1.
2.
3.
4.

Declare the variables.
Open the input and output files.
Initialize the variables.
While there is more data in the input file:
4.1. For each character in a line:
4.1.1. Read and write the character.
4.1.2. Increment the appropriate letter count.
4.2. Increment the line count.
5. Output the line count and letter counts.
6. Close the files.
To simplify the function main, we divide it into four functions:
•
•
•
•

Function
Function
Function
Function

initialize
copyText
characterCount
writeTotal

The following sections describe each of these functions in detail. Then, with the help
of these functions, we describe the algorithm for the function main.
initialize This function initializes the variable lineCount and the array letterCount to 0. It,
therefore, has two parameters: one corresponding to the variable lineCount and one
corresponding to the array letterCount. Clearly, the parameter corresponding to
lineCount must be a reference parameter. The definition of this function is:
void initialize(int& lc, int list[])
{
int j;
lc = 0;
for (j = 0; j < 26; j++)
list[j] = 0;
} //end initialize

copyText This function reads a line and outputs the line. After reading a character, it calls the
function characterCount to update the letter count. Clearly, this function has
four parameters: an input file stream variable, an output file stream variable, a char

variable, and the array to update the letter count.
Note that the copyText function does not perform the letter count, but we still pass the
array letterCount to it. We take this step because this function calls the function
characterCount, which needs the array letterCount to update the appropriate

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

584 |

Chapter 8: Arrays and Strings

letter count. Therefore, we must pass the array letterCount to the copyText
function so that it can pass the array to the function characterCount.
void copyText(ifstream& intext, ofstream& outtext, char& ch,
int list[])
{
while (ch != '\n')
//process the entire line
{
outtext << ch;
//output the character
characterCount(ch, list);
//call the function
//character count
intext.get(ch);
//read the next character
}
outtext << ch;
//output the newline character
} //end copyText

characterCount This function increments the letter count. To increment the appropriate letter count,
it must know what the letter is. Therefore, the characterCount function has two
parameters: a char variable and the array to update the letter count. In pseudocode,

this function is:
a. Convert the letter to uppercase.
b. Find the index of the array corresponding to this letter.
c. If the index is valid, increment the appropriate count. At this
step, we must ensure that the character is a letter. We are
counting only letters, so other characters—such as commas,
hyphens, and periods—are ignored.
Following this algorithm, the definition of this function is:
void characterCount(char ch, int list[])
{
int index;
ch = toupper(ch);

//Step a

index = static_cast<int>(ch)
- static_cast<int>('A');

//Step b

if (0 <= index && index < 26)
list[index]++;
} //end characterCount

//Step c

writeTotal This function outputs the line count and the letter count. It has three parameters: the

output file stream variable, the line count, and the array to output the letter count.
The definition of this function is:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Text Porcessing |

585

void writeTotal(ofstream& outtext, int lc, int list[])
{
int index;
outtext << endl << endl;
outtext << "The number of lines = " << lc << endl;
for (index = 0; index < 26; index++)
outtext << static_cast<char>(index
+ static_cast<int>('A'))
<< " count = " << list[index] << endl;
} //end writeTotal

We now describe the algorithm for the function main.
MAIN
ALGORITHM

1.
2.
3.
4.
5.

Declare the variables.
Open the input file.
If the input file does not exist, exit the program.
Open the output file.
Initialize the variables, such as lineCount and the array
letterCount.
6. Read the first character.
7. While (not end of input file):
7.1. Process the next line; call the function copyText.
7.2.

Increment the line count. (Increment the variable lineCount.)

7.3. Read the next character.
8. Output the line count and letter counts. Call the function
writeTotal.
9. Close the files.
COMPLETE PROGRAM LISTING
//*************************************************************
// Author: D.S. Malik
//
// Program: Line and Letter Count
// This programs reads a text, outputs the text as is, and also
// prints the number of lines and the number of times each
// letter appears in the text. An uppercase letter and a
// lowercase letter are treated as being the same; that is,
// they are tallied together.
//*************************************************************

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

586 |

Chapter 8: Arrays and Strings

#include <iostream>
#include <fstream>
#include <cctype>
using namespace std;
void initialize(int& lc, int list[]);
void copyText(ifstream& intext, ofstream& outtext, char& ch,
int list[]);
void characterCount(char ch, int list[]);
void writeTotal(ofstream& outtext, int lc, int list[]);
int main()
{
//Step 1; Declare variables
int lineCount;
int letterCount[26];
char ch;
ifstream infile;
ofstream outfile;
infile.open("textin.txt");

//Step 2

if (!infile)
{
cout << "Cannot open the input file."
<< endl;
return 1;
}

//Step 3

outfile.open("textout.out");

//Step 4

initialize(lineCount, letterCount);

//Step 5

infile.get(ch);

//Step 6

while (infile)
//Step 7
{
copyText(infile, outfile, ch, letterCount); //Step 7.1
lineCount++;
//Step 7.2
infile.get(ch);
//Step 7.3
}
writeTotal(outfile, lineCount, letterCount);

//Step 8

infile.close();
outfile.close();

//Step 9
//Step 9

return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Text Porcessing |

587

void initialize(int& lc, int list[])
{
int j;
lc = 0;
for (j = 0; j < 26; j++)
list[j] = 0;
} //end initialize
void copyText(ifstream& intext, ofstream& outtext, char& ch,
int list[])
{
while (ch != '\n')
//process the entire line
{
outtext << ch;

//output the character
//call the function
//character count
//read the next character

characterCount(ch, list);
intext.get(ch);
}
outtext << ch;
} //end copyText

//output the newline character

8

void characterCount(char ch, int list[])
{
int index;
ch = toupper(ch);

//Step a

index = static_cast<int>(ch)
- static_cast<int>('A');

//Step b

if (0 <= index & index < 26)
list[index]++;
} //end characterCount

//Step c

void writeTotal(ofstream& outtext, int lc, int list[])
{
int index;
outtext << endl << endl;
outtext << "The number of lines = " << lc << endl;
for (index = 0; index < 26; index++)
outtext << static_cast<char>(index
+ static_cast<int>('A'))
<< " count = " << list[index] << endl;
} //end writeTotal

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

588 |

Chapter 8: Arrays and Strings

Sample Run (textout.out):
Today we live in an era where information is processed almost at the
speed of light. Through computers, the technological revolution is
drastically changing the way we live and communicate with one
another. Terms such as "the Internet," which were unfamiliar just
a few years ago, are very common today. With the help of computers you
can send letters to, and receive letters from, loved ones within
seconds. You no longer need to send a résumé by mail to apply for a
job; in many cases you can simply submit your job application via
the Internet. You can watch how stocks perform in real time, and
instantly buy and sell them. Students regularly "surf" the Internet
and use computers to design their classroom projects. They also use
powerful word-processing software to complete their term papers.
Many people maintain and balance their checkbooks on computers.
The number of lines = 15
A count = 53
B count = 7
C count = 30
D count = 19
E count = 81
F count = 11
G count = 10
H count = 29
I count = 41
J count = 4
K count = 3
L count = 31
M count = 26
N count = 50
O count = 59
P count = 21
Q count = 0
R count = 45
S count = 48
T count = 62
U count = 24
V count = 7
W count = 15
X count = 0
Y count = 20
Z count = 0

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

589

QUICK REVIEW
1.
2.
3.

4.
5.
6.
7.
8.
9.
10.

11.

12.
13.
14.
15.
16.

17.
18.

19.
20.

A data type is simple if variables of that type can hold only one value at a time.
In a structured data type, each data item is a collection of other data items.
An array is a structured data type with a fixed number of components.
Every component is of the same type, and components are accessed using
their relative positions in the array.
Elements of a one-dimensional array are arranged in the form of a list.
There is no check on whether an array index is out of bounds.
In C++, an array index starts with 0.
An array index can be any expression that evaluates to a nonnegative integer.
The value of the index must always be less than the size of the array.
There are no aggregate operations on arrays, except for the input/output of
character arrays (C-strings).
Arrays can be initialized during their declaration. If there are fewer initial
values than the array size, the remaining elements are initialized to 0.
The base address of an array is the address of the first array component. For
example, if list is a one-dimensional array, the base address of list is the
address of list[0].
When declaring a one-dimensional array as a formal parameter, you usually
omit the array size. If you specify the size of a one-dimensional array in the
formal parameter declaration, the compiler will ignore the size.
In a function call statement, when passing an array as an actual parameter,
you use only its name.
As parameters to functions, arrays are passed by reference only.
Because as parameters, arrays are passed by reference only, when declaring an
array as a formal parameter, you do not use the symbol & after the data type.
A function cannot return a value of type array.
Although as parameters, arrays are passed by reference, when declaring an
array as a formal parameter, using the reserved word const before the data
type prevents the function from modifying the array.
Individual array components can be passed as parameters to functions.
The sequential search algorithm searches a list for a given item, starting with
the first element in the list. It continues to compare the search item with
the other elements in the list until either the item is found or the list has no
more elements left to be compared with the search item.
Selection sort sorts the list by finding the smallest (or equivalently largest)
element in the list and moving it to the beginning (or end) of the list.
nðn  1Þ
For a list of length n, selection sort makes exactly
key compar2
isons and 3(n1) item assignments.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

590 |

21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.

Chapter 8: Arrays and Strings

In C++, a string is any sequence of characters enclosed between double
quotation marks.
In C++, C-strings are null terminated.
In C++, the null character is represented as '\0'.
In the ASCII character set, the collating sequence of the null character is 0.
C-strings are stored in character arrays.
Character arrays can be initialized during declaration using string notation.
Input and output of C-strings is the only place where C++ allows aggregate
operations.
The header file cstring contains the specifications of the functions that
can be used for C-string manipulation.
Commonly used C-string manipulation functions include strcpy (string
copy), strcmp (string comparison), and strlen (string length).
C-strings are compared character by character.
Because C-strings are stored in arrays, individual characters in the C-string
can be accessed using the array component access notation.
Parallel arrays are used to hold related information.
In a two-dimensional array, the elements are arranged in a table form.
To access an element of a two-dimensional array, you need a pair of
indices: one for the row position and one for the column position.
In a two-dimensional array, the rows are numbered 0 to ROW_SIZE  1
and the columns are numbered 0 to COLUMN_SIZE  1.
If matrix is a two-dimensional array, then the base address of matrix is
the address of the array component matrix[0][0].
In row processing, a two-dimensional array is processed one row at a time.
In column processing, a two-dimensional array is processed one column at a time.
When declaring a two-dimensional array as a formal parameter, you can
omit the size of the first dimension but not the second.
When a two-dimensional array is passed as an actual parameter, the number
of columns of the actual and formal arrays must match.
C++ stores, in computer memory, two-dimensional arrays in a row order form.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.
b.
c.

A double type is an example of a simple data type. (1)
A one-dimensional array is an example of a structured data type. (1)
The size of an array is determined at compile time. (1, 6)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

d.

|

591

Given the declaration:
int list[10];

the statement:
list[5] = list[3] + list[2];
e.

f.

g.

h.
i.
j.

updates the content of the fifth component of the array list. (2)
If an array index goes out of bounds, the program always terminates in
an error. (3)
The only aggregate operations allowable on int arrays are the increment
and decrement operations. (5)
Arrays can be passed as parameters to a function either by value or by
reference. (6)
A function can return a value of type array. (6)
In C++, some aggregate operations are allowed for strings. (11, 12, 13)
The declaration:
char name[16] = "John K. Miller";

declares name to be an array of 15 characters because the string "John K.
Miller" has only 14 characters. (11)
k.

The declaration:
char str = "Sunny Day";

l.

2.

declares str to be a string of an unspecified length. (11)
As parameters, two-dimensional arrays are passed either by value or by
reference. (15, 16)

Consider the following declaration: (1, 2)
int accountNum[75];

In this declaration, identify the following:
a.
b.
c.
d.
e.
f.
3.

The array name.
The array size.
The data type of each array component.
The range of values for the index of the array.
The index of the first element.
The index of the last element.

Identify error(s), if any, in the following array declarations. If a statement is
incorrect, provide the correct statement. (1, 2)
a.

int primeNum[99];

b.

int testScores[0];

c.

string names[60];

d.

int list100[0..99];

e.

double[50] gpa;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

592 |

4.

Chapter 8: Arrays and Strings

f.

const double LENGTH = 26;
double list[LENGTH - 1];

g.

const long SIZE = 100;
int list[2 * SIZE];

Determine whether the following array declarations are valid. If a declaration
is invalid, explain why. (1, 2)
a.

string customers[];

b.

int numArray[50];

c.

const int SIZE = 30;
double list[20 - SIZE];

d.

int length = 50;
double list[length - 50];

e.

int ids[-30];

f.

colors [30] string;

5.

What would be a valid range for the index of an array of size 99? What is
the index of the first element? What is the index of the last element? (1, 3)

6.

Write C++ statement(s) to do the following: (1, 2)
a.
b.
c.
d.
e.

f.

g.
h.

i.

j.

7.

Declare an array alpha of 50 components of type int.
Initialize each component of alpha to -1.
Output the value of the first component of the array alpha.
Set the value of the twenty-fifth component of the array alpha to 62.
Set the value of the tenth component of alpha to three times the value
of the fiftieth component of alpha plus 10.
Use a for loop to output the value of a component of alpha if its
index is a multiple of 2 or 3.
Output the value of the last component of alpha.
Output the value of the alpha so that 15 components per line are
printed.
Use a for loop to increment every other element (the even indexed
elements).
Use a for loop to create a new array, diffAlpha, whose elements are
the differences between consecutive elements in alpha.

What is the output of the following program segment? (2)
int temp[5];
for (int i = 0; i < 5; i++)
temp[i] = static_cast<int>(pow(i, 2.0));
for (int i = 0; i < 5; i++)
cout << temp[i] << " ";
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

593

temp[4] = temp[3] * temp[2];
temp[3] = temp[4] - temp[2];
temp[0] = temp[5] / temp[1];
for (int i = 0; i < 5; i++)
cout << temp[i] << " ";
cout << endl;
8.

What is stored in list after the following C++ code executes? (2)
int list[10];
for (int i = 0; i < 5; i++)
{
list[i] = i * (i - 1);
if (i % 2 == 0)
list[i] = list[i] + i;
else if (i % 3 == 0)
list[i] = list[i] - i;
else if (i > 0)
list[i] = list[i] - list[i - 1];
}

9.

What is stored in list after the following C++ code executes? (2)
int list[8];
list[0] = 1;
list[1] = 2;
for (int i = 2; i < 8; i++)
{
list[i] = list[i - 1] * list[i - 2];
if (i > 5)
list[i] = list[i] - list[i - 1];
}

10.

What is stored in myList after the following C++ code executes? (2)
double myList[6];
myList[0] = 2.5;
for (int i = 1; i < 6; i++)
{
myList[i] = i * myList[i - 1];
if (i > 3)
myList[i] = myList[i] / 2;
}

11.

Correct the following code so that it correctly sets the value of each
element of myList to the index of the element. (2, 3)
int myList[10];
for (int i = 1; i > 10; i++)
myList[i] = i;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

594 |

12.

Chapter 8: Arrays and Strings

Correct the following code so that it correctly initializes and outputs the
elements of the array myList. (2, 3)
int myList[10];
for (int i = 1; i <= 10; i++)
cin >> myList;
for (int i = 1; i <= 10; i++)
cout << myList[i] << " ";
cout << endl;

13.

What is array index out of bounds? Does C++ check for array indices
within bounds? (3)

14.

Suppose that scores is an array of 10 components of type double, and:
scores = {2.5, 3.9, 4.8, 6.2, 6.2, 7.4, 7.9, 8.5, 8.5, 9.9}

The following is supposed to ensure that the elements of scores are in
nondecreasing order. However, there are errors in the code. Find and correct
the errors. (1, 2, 3)
for (int i = 1; i
if (scores[i]
cout << i
<< "
15.

Write C++ statements to define and initialize the following arrays. (4)
a.

b.

c.

d.

16.

<= 10; i++)
>= scores[i + 1])
<< " and " << (i + 1)
elements of scores are out of order." << endl;

Array heights of 10 components of type double. Initialize this array
to the following values: 5.2, 6.3, 5.8, 4.9, 5.2, 5.7, 6.7, 7.1, 5.10, 6.0.
Array weights of 7 components of type int. Initialize this array to the
following values: 120, 125, 137, 140, 150, 180, 210.
Array specialSymbols of type char. Initialize this array to the
following values: '$', '#', '%', '@', '&', '! ', '^'.
Array seasons of 4 components of type string. Initialize this array to
the following values: "fall", "winter", "spring", "summer".

Determine whether the following array declarations are valid. If a
declaration is valid, determine the size of the array. (4)
a.

int list[] = {18, 13, 14, 16};

b.

int x[10] = {1, 7, 5, 3, 2, 8};

c.

double y[4] = {2.0, 5.0, 8.0, 11.0, 14.0};

d.

double lengths[] = {8.2, 3.9, 6.4, 5.7, 7.3};

e.

int list[7] = {12, 13, , 14, 16, , 8};

f.

string names[8] = {"John","Lisa", "Chris", "Katie"};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

17.

|

595

Suppose that you have the following declaration:
int list[7] = {6, 10, 14, 18, 22};

18.

If this declaration is valid, what is stored in each of the eight components of list. (4)
Consider the following declaration: (2)
int list[] = {3, 8, 10, 13, 6, 11};
a.
b.

19.

Write a C++ code that will output the value stored in each component of list.
Write a C++ code that will set the values of the first five components of
list as follows: The value of the ith component is the value of the ith
component minus three times the value of the (i+1)th component.

What is the output of the following C++ code? (2)
#include <iostream>
using namespace std;
int main()
{
int beta[7] = {3, 5};
for (int i = 2;
{
beta[i] = 3
beta[i - 1]
beta[i - 2]
}

i < 7; i++)
* i + 2;
= beta[i - 1] + beta[i];
= beta[i - 2] + beta [i - 1];

for (int i = 0; i < 7; i++)
cout << beta[i] << " ";
cout << endl;
return 0;
}
20.

What is the output of the following C++ code? (2)
#include <iostream>
using namespace std;
int main()
{
int list1[5];
int list2[15];
for (int i = 0; i < 5; i++)
list1[i] = i * i - 2;
cout << "list1: ";
for (int i = 0; i < 5; i++)
cout << list1[i] << " ";
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

596 |

Chapter 8: Arrays and Strings

for (int i = 0; i < 5; i++)
{
list2[i] = list1[i] * i;
list2[i + 5] = list1[4 - i] + i;
list2[i + 10] = list2[9 - i] + list2[i];
}
cout << "list2: ";
for (int i = 0; i < 7; i++)
cout << list2[i] << " ";
cout << endl;
return 0;
}
21.

Consider the following function heading:
void tryMe(int x[], int size);

and the declarations:
int list[100];
int score[50];
double gpas[50];

Which of the following function calls is valid? (6)

22.

a.

tryMe(list, 100);

b.

tryMe(list, 75);

c.

tryMe(score, 100);

d.

tryMe(score, 49);

e.

tryMe(gpas, 50);

Suppose that you have the following function definition:
void sum(int x, int y, int& z)
{
z = x + y;
}

Consider the following declarations:
int list1[10], list2[10], list3[10];
int a, b, c;

Which of the following function calls is valid? (6)
a.

sum(a, b, c);

b.

sum(list1[0], list2[0], a);

c.

sum(list1, list2, c);

d.

for (int i = 1; i <= 10; i++)
sum(list1[i], list2[i], list3[i]);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

23.

|

597

What is the output of the following C++ code? (2)
double salary[5] = {25000, 36500, 85000, 62500, 97000};
double raise = 0.03;
cout << fixed << showpoint << setprecision(2);
for (int i = 0; i < 5; i++)
cout << (i + 1) << " " << salary[i] << " "
<< salary[i] * raise << endl;

24.

A car dealer has 10 salespersons. Each salesperson keeps track of the number of
cars sold each month and reports it to the management at the end of the month.
The management keeps the data in a file and assigns a number, 1 to 10, to each
salesperson. The following statement declares an array, cars, of 10 components
of type int to store the number of cars sold by each salesperson:
int cars[10];

Write the code to store the number of cars sold by each salesperson in the array
cars, output the total numbers of cars sold at the end of each month, and
output the salesperson number selling the maximum number of cars. (Assume
that data is in the file cars.dat, and that this file has been opened using the
ifstream variable inFile.) (2)
25.

What is the output of the following program? (2)
#include <iostream>
using namespace std;
int main()
{
int count;
int alpha[5];
alpha[0] = 5;
for (count = 1; count < 5; count++)
{
alpha[count] = 5 * count + 10;
alpha[count - 1] = alpha[count] - 4;
}
cout << "List elements: ";
for (count = 0; count < 5; count++)
cout << alpha[count] << " ";
cout << endl;
return 0;
}

26.

What is the output of the following program? (2)
#include <iostream>
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

598 |

Chapter 8: Arrays and Strings

int main()
{
int j;
int one[5];
int two[10];
for (j = 0; j < 5; j++)
one[j] = 5 * j + 3;
cout << "One contains: ";
for (j = 0; j < 5; j++)
cout << one[j] << " ";
cout << endl;
for (j = 0; j < 5; j++)
{
two[j] = 2 * one[j] - 1;
two[j + 5] = one[4 - j] + two[j];
}
cout << "Two contains: ";
for (j = 0; j < 10; j++)
cout << two[j] << " ";
cout << endl;
return 0;
}
27.

What is the output of the following C++ code? (2, 4)
const double PI = 3.14159;
double cylinderRadii[5] = {3.5, 7.2, 10.5, 9.8, 6.5};
double cylinderHeights[5] = {10.7, 6.5, 12.0, 10.5, 8.0};
double cylinderVolumes[5];
cout << fixed << showpoint << setprecision(2);
for (int i = 0; i < 5; i++)
cylinderVolumes[i] = 2 * PI * cylinderRadii[i]
* cylinderHeights[i];
for (int i = 0; i < 5; i++)
cout << (i + 1) << " " << cylinderRadii[i] << " "
<< cylinderHeights[i] << " " << cylinderVolumes[i] << endl;

28.

When an array is passed as an actual parameter to a function, what is actually
being passed? (6)

29.

In C++, as an actual parameter, can an array be passed by value? (6)

30.

Sort the following list using the selection sort algorithm as discussed in this
chapter. Show the list after each iteration of the outer for loop. (8)
6, 45, 10, 25, 58, 2, 50, 30, 86

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

31.

|

599

What is the output of the following C++ program segment? (9, 10)
int list [] = {5, 7, 6, 4, 8, 15, 32, 40};
for (auto num: list)
cout << num / 2 << " ";
cout << endl;

32.

What is the output of the following C++ program segment? (9, 10)
string names [] = {"Blair, Cindy", "Johnson, Chris", "Mann, Sheila"};
string str1, str2;
char ch = ',';
int pos, length;
for (auto &str: names)
{
pos = str.find(ch);
length = str.length();
str1 = str.substr(0, pos);
str2 = str.substr(pos + 2, length - pos - 1);
str = str2 + ' ' + str1;
}
for (auto str: names)
cout << str << endl;

33.

Consider the following function heading. (9, 10)
void modifyList(int list [], int length)

In the definition of the function modifyList, can you use a range-based for loop
to process the elements of list? Justify your answer.
34.

Given the declaration:
char string15[16];

Mark the following statements as valid or invalid. If a statement is invalid, explain why. (11)

35.

a.

strcpy(string15, "Hello there");

b.

strlen(string15);

c.

string15 = "Jacksonville";

d.

cin >> string15;

e.

cout << string15;

f.

if (string15 >= "Nice day")
cout << string15;

g.

string15[6] = 't';

Given the declaration:
char str1[15];
char str2[15] = "Good day";

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

600 |

Chapter 8: Arrays and Strings

Mark the following statements as valid or invalid. If a statement is invalid, explain
why. (11, 12)

36.

a.

str1 = str2;

b.

if (str1 == str2)
cout << " Both strings are of the same length." << endl;

c.

if (strlen(str1) >= strlen(str2))
str1 = str2;

d.

if (strcmp(str1, str2) < 0)
cout << "str1 is less that str2." << endl;

Given the declaration:
char name[8] = "Shelly";

Mark the following statements as ‘‘Yes’’ if they output Shelly. Otherwise, mark
the statement as ‘‘No’’ and explain why it does not output Shelly. (11)

37.

a.

cout << name;

b.

for (int j = 0; j < 6; j++)
cout << name[j];

c.

int j = 0;
while (name[j] != '\0')
cout << name[j++];

d.

int j = 0;
while (j < 8)
cout << name[j++];

Given the declaration: (11, 12)
char str1[21];
char str2[21];
a.
b.

c.
d.

38.

Write a C++ statement that stores "Sunny Day" in str1.
Write a C++ statement that stores the length of str1 into the int
variable length.
Write a C++ statement that copies the value of name into str2.
Write C++ code that outputs str1 if str1 is less than or equal to
str2, and otherwise outputs str2.

Assume the following declarations:
char name[21];
char yourName[21];
char studentName[31];

Mark the following statements as valid or invalid. If a statement is invalid, explain
why. (11, 12, 13)
a.

cin >> name;

b.

cout << studentName;

c.

yourName[0] = '\0';

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

d.

yourName = studentName;

e.

if (yourName == name)
studentName = name;

f.

int x = strcmp(yourName, studentName);

g.

strcpy(studentName, name);

h.

for (int j = 0; j < 21; j++)
cout << name[j];

39.

Define a two-dimensional array named temp of three rows and four columns
of type int such that the first row is initialized to 6, 8, 12, 9; the second row is
initialized to 17, 5, 10, 6; and the third row is initialized to 14, 13, 16, 20. (15)

40.

Suppose that array temp is as defined in Exercise 39. Write C++ statements
to accomplish the following: (15)
a.
b.
c.
d.

41.

|

601

Output the contents of the first row and first column element of temp.
Output the contents of the first row and last column element of temp.
Output the contents of the last row and first column element of temp.
Output the contents of the last row and last column element of temp.

Consider the following declarations: (15)
const int CAR_TYPES = 5;
const int COLOR_TYPES = 6;
double sales[CAR_TYPES][COLOR_TYPES];
a.
b.
c.
d.
e.

42.

Write C++ statements that do the following: (15)
a.
b.
c.
d.

e.
f.
43.

How many components does the array sales have?
What is the number of rows in the array sales?
What is the number of columns in the array sales?
To sum the sales by CAR_TYPES, what kind of processing is required?
To sum the sales by COLOR_TYPES, what kind of processing is required?
Declare an array alpha of 10 rows and 20 columns of type int.
Initialize the array alpha to 0.
Store 1 in the first row and 2 in the remaining rows.
Store 5 in the first column, and make sure that the value in each
subsequent column is twice the value in the previous column.
Print the array alpha one row per line.
Print the array alpha one column per line.

Consider the following declaration: (15)
int beta[3][3];

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

602 |

Chapter 8: Arrays and Strings

What is stored in beta after each of the following statements executes?

44.

a.

for (i = 0; i < 3; i++)
for (j = 0; j < 3; j++)
beta[i][j] = 0;

b.

for (i = 0; i < 3; i++)
for (j = 0; j < 3; j++)
beta[i][j] = i + j;

c.

for (i = 0; i < 3; i++)
for (j = 0; j < 3; j++)
beta[i][j] = i * j;

d.

for (i = 0; i < 3; i++)
for (j = 0; j < 3; j++)
beta[i][j] = 2 * (i + j) % 4;

e.

for (int i = 2; i >= 0; i--)
for (int j = 0; j < 3; j++)
beta[i][j] = (i * j) % 3;

Suppose that you have the following declarations: (15)
int
int
int
int
a.

b.

times[30][7];
speed[15][7];
trees[100][7];
students[50][7];

Write the definition of the function print that can be used to output
the contents of these arrays.
Write the C++ statements that calls the function print to output the
contents of the arrays times, speed, trees, and students.

PROGRAMMING EXERCISES
1.

2.

3.

4.

Write a C++ program that declares an array alpha of 50 components of type
double. Initialize the array so that the first 25 components are equal to the
square of the index variable, and the last 25 components are equal to three times
the index variable. Output the array so that 10 elements per line are printed.
Write a C++ function, smallestIndex, that takes as parameters an int
array and its size and returns the index of the first occurrence of the smallest
element in the array. Also, write a program to test your function.
Write a C++ function, lastLargestIndex, that takes as parameters an
int array and its size and returns the index of the last occurrence of the
largest element in the array. Also, write a program to test your function.
Write a program that reads a file consisting of students’ test scores in the
range 0–200. It should then determine the number of students having
scores in each of the following ranges: 0–24, 25–49, 50–74, 75–99,
100–124, 125–149, 150–174, and 175–200. Output the score ranges
and the number of students. (Run your program with the following input
data: 76, 89, 150, 135, 200, 76, 12, 100, 150, 28, 178, 189, 167, 200,
175, 150, 87, 99, 129, 149, 176, 200, 87, 35, 157, 189.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

5.

6.

|

603

Write a program that prompts the user to input a string and outputs the
string in uppercase letters. (Use a character array to store the string.)
The history teacher at your school needs help in grading a True/False test.
The students’ IDs and test answers are stored in a file. The first entry in the
file contains answers to the test in the form:
TFFTFFTTTTFFTFTFTFTT

Every other entry in the file is the student ID, followed by a blank, followed
by the student’s responses. For example, the entry:
ABC54301 TFTFTFTT TFTFTFFTTFT

7.

indicates that the student ID is ABC54301 and the answer to question 1 is True,
the answer to question 2 is False, and so on. This student did not answer question 9.
The exam has 20 questions, and the class has more than 150 students. Each correct
answer is awarded two points, each wrong answer gets one point deducted, and no
answer gets zero points. Write a program that processes the test data. The output
should be the student’s ID, followed by the answers, followed by the test score,
followed by the test grade. Assume the following grade scale: 90%–100%, A; 80%–
89.99%, B; 70%–79.99%, C; 60%–69.99%, D; and 0%–59.99%, F.
Write a program that allows the user to enter the last names of five candidates in
a local election and the number of votes received by each candidate. The
program should then output each candidate’s name, the number of votes
received, and the percentage of the total votes received by the candidate. Your
program should also output the winner of the election. A sample output is:
Candidate
Johnson
Miller
Duffy
Robinson
Ashtony
Total

Votes Received
5000
4000
6000
2500
1800
19300

% of Total Votes
25.91
20.73
31.09
12.95
9.33

The Winner of the Election is Duffy.
8.

Consider the following function main:
int main()
{
int inStock[10][4];
int alpha[20];
int beta[20];
int gamma[4] = {11, 13, 15, 17};
int delta[10] = {3, 5, 2, 6, 10, 9, 7, 11, 1, 8};
.
.
.
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

604 |

Chapter 8: Arrays and Strings

Write the definition of the function setZero that initializes any onedimensional array of type int to 0.
b. Write the definition of the function inputArray that prompts the user
to input 20 numbers and stores the numbers into alpha.
c. Write the definition of the function doubleArray that initializes the elements of beta to two times the corresponding elements in alpha. Make
sure that you prevent the function from modifying the elements of alpha.
d. Write the definition of the function copyGamma that sets the elements
of the first row of inStock to gamma and the remaining rows of
inStock to three times the previous row of inStock. Make sure that
you prevent the function from modifying the elements of gamma.
e. Write the definition of the function copyAlphaBeta that stores alpha
into the first five rows of inStock and beta into the last five rows of
inStock. Make sure that you prevent the function from modifying the
elements of alpha and beta.
f. Write the definition of the function printArray that prints any onedimensional array of type int. Print 15 elements per line.
g. Write the definition of the function setInStock that prompts the user
to input the elements for the first column of inStock. The function
should then set the elements in the remaining columns to two times the
corresponding element in the previous column, minus the corresponding element in delta.
h. Write C++ statements that call each of the functions in parts a through g.
i. Write a C++ program that tests the function main and the functions
discussed in parts a through g. (Add additional functions, such as printing
a two-dimensional array, as needed.)
Write a program that uses a two-dimensional array to store the highest and
lowest temperatures for each month of the year. The program should output
the average high, average low, and the highest and lowest temperatures for
the year. Your program must consist of the following functions:
a.

9.

a.

b.

c.

d.

e.

Function getData: This function reads and stores data in the twodimensional array.
Function averageHigh: This function calculates and returns the average high temperature for the year.
Function averageLow: This function calculates and returns the average
low temperature for the year.
Function indexHighTemp: This function returns the index of the
highest high temperature in the array.
Function indexLowTemp: This function returns the index of the lowest
low temperature in the array.
(These functions must all have the appropriate parameters.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

10.

Programming Exercise 10 in Chapter 6 asks you find the mean and standard
deviation of five numbers. Extend this programming exercise to find the
mean and standard deviation of up to 100 numbers. Suppose that the mean
(average) of n numbers x1, x2, . . ., xn is x. Then, the standard deviation of
these numbers is:
sﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
ðx1  xÞ2 þ ðx2  xÞ2 þ    þ ðxi  xÞ2 þ    þ ðxn  xÞ2
s¼
n

11.

(Adding Large Integers) In C++, the largest int value is 2147483647.
So, an integer larger than this cannot be stored and processed as an integer.
Similarly, if the sum or product of two positive integers is greater than
2147483647, the result will be incorrect. One way to store and manipulate
large integers is to store each individual digit of the number in an array.
Write a program that inputs two positive integers of, at most, 20 digits and
outputs the sum of the numbers. If the sum of the numbers has more than
20 digits, output the sum with an appropriate message. Your program must,
at least, contain a function to read and store a number into an array and
another function to output the sum of the numbers. (Hint: Read numbers as
strings and store the digits of the number in the reverse order.)
Jason, Samantha, Ravi, Sheila, and Ankit are preparing for an upcoming
marathon. Each day of the week, they run a certain number of miles and
write them into a notebook. At the end of the week, they would like to
know the number of miles run each day, the total miles for the week, and
average miles run each day. Write a program to help them analyze their
data. Your program must contain parallel arrays: an array to store the names
of the runners and a two-dimensional array of five rows and seven columns
to store the number of miles run by each runner each day. Furthermore,
your program must contain at least the following functions: a function to
read and store the runners’ names and the numbers of miles run each day; a
function to find the total miles run by each runner and the average number
of miles run each day; and a function to output the results. (You may
assume that the input data is stored in a file and each line of data is in the
following form: runnerName milesDay1 milesDay2 milesDay3
milesDay4 milesDay5 milesDay6 milesDay7.)
Write a program to calculate students’ average test scores and their grades.
You may assume the following input data:

12.

13.

|

605

Johnson 85 83 77 91 76
Aniston 80 90 95 93 48
Cooper 78 81 11 90 73
Gupta 92 83 30 69 87

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

606 |

Chapter 8: Arrays and Strings

Blair 23 45 96 38 59
Clark 60 85 45 39 67
Kennedy 77 31 52 74 83
Bronson 93 94 89 77 97
Sunny 79 85 28 93 82
Smith 85 72 49 75 63

14.

15.

Use three arrays: a one-dimensional array to store the students’ names, a
(parallel) two-dimensional array to store the test scores, and a parallel onedimensional array to store grades. Your program must contain at least the
following functions: a function to read and store data into two arrays, a
function to calculate the average test score and grade, and a function to
output the results. Have your program also output the class average.
A company hired 10 temporary workers who are paid hourly and you are
given a data file that contains the last name of the employees, the number of
hours each employee worked in a week, and the hourly pay rate of each
employee. You are asked to write a program that computes each employee’s weekly pay and the average salary of all the workers. The program then
outputs the weekly pay of each employee, the average weekly pay, and the
names of all the employees whose pay is greater than or equal to the average
pay. If the number of hours worked in a week is more than 40 hours, then
the pay rate for the hours over 40 is 1.5 times the regular hourly rate. Use
two parallel arrays: a one-dimensional array to store the names of all the
employees, and a two-dimensional array of 10 rows and 3 columns to store
the number of hours an employee worked in a week, the hourly pay rate,
and the weekly pay. Your program must contain at least the following
functions—a function to read the data from the file into the arrays, a
function to determine the weekly pay, a function to output the names of
all the employees whose pay is greater than or equal to the average weekly
pay, and a function to output each employee’s data.
Children often play a memory game in which a deck of cards containing
matching pairs is used. The cards are shuffled and placed face down on a
table. The players then take turns and select two cards at a time. If both
cards match, they are left face up; otherwise, the cards are placed face down
at the same positions. Once the players see the selected pair of cards and if
the cards do not match, then they can memorize the cards and use their
memory to select the next pair of cards. The game continues until all the
cards are face up. Write a program to play the memory game. Use a twodimensional array of 4 rows and 4 columns for a deck of 16 cards with 8
matching pairs. You can use numbers 1 to 8 to mark the cards. (If you use a
6 by 6 array, then you will need 18 matching pairs, and so on.) Use random
number generators to randomly store the pairs in the array. Use appropriate
functions in your program, and the main program should be merely a call to
functions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

16.

|

607

(Airplane Seating Assignment) Write a program that can be used to
assign seats for a commercial airplane. The airplane has 13 rows, with six
seats in each row. Rows 1 and 2 are first class, rows 3 through 7 are business
class, and rows 8 through 13 are economy class. Your program must prompt
the user to enter the following information:
a.
b.

Ticket type (first class, business class, or economy class)
Desired seat

Output the seating plan in the following form:

Row
Row
Row
Row
Row
Row
Row
Row
Row
Row
Row
Row
Row

17.

18.

1
2
3
4
5
6
7
8
9
10
11
12
13

A

B

C

D

E

F

*
*
*
X
*
*
X
*
X
*
*
*
*

*
X
*
*
X
X
*
X
*
X
*
*
*

X
*
X
X
*
*
*
*
X
*
X
X
*

*
X
X
*
X
*
*
X
X
X
*
X
*

X
*
*
X
*
*
X
X
*
X
X
*
X

X
X
X
X
*
X
X
*
X
X
*
X
*

Here, * indicates that the seat is available; X indicates that the seat is
occupied. Make this a menu-driven program; show the user’s choices and
allow the user to make the appropriate choices.
The program in Example 8-7 outputs the average speed over the intervals of
length 10. Modify the program so that the user can store the distance traveled
at the desired times, such as times 0, 10, 16, 20, 30, 38, 45. The program then
computes and outputs the average speed of the object over the successive
time intervals specified by the time when the distance was recorded. For
example, for the previous list of times, the average speed is computed over
the time intervals 0 to 16, 16 to 20, 20 to 30, 30 to 38, and 38 to 45.
A positive integer n is called prime if n > 1 and the only factors of n are 1
and n. It is known that a positive
integer n > 1 is prime if n is not divisible
pﬃﬃﬃ
by any prime integer m  n. The 1230th prime number is 10007. Let t be
an integer such that 2  t  100,000,000. Then t is prime if either t is equal
to one of the first 1230 prime numbers or t is not divisible by any of the first
1230 prime numbers. Write a program that declares an array of size 1230

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

8

608 |

19.

20.

21.

Chapter 8: Arrays and Strings

and stores the first 1230 prime numbers in this array. The program then uses
the first 1230 prime numbers to determine if a number between 2 and
100,000,000 is prime. If a number is not prime, then output at least one of
its prime factors.
A positive integer m is called composite if m = ab, where a and b are
positive integers such that a 6¼ 1 and b 6¼ 1. If m is composite, then m can
be written as a product of prime numbers. Let m be an integer such that 2
 m  100,000,000. Modify the program in Exercise 18 so that if m is not
prime, the program outputs m as a product of prime numbers.
Write a program that uses a 3  3 array and randomly place each integer
from 1 to 9 into the nine squares. The program calculates the magic number
by adding all the numbers in the array and then dividing the sum by 3. The
3  3 array is a magic square if the sum of each row, each column, and each
diagonal is equal to the magic number. Your program must contain at least
the following functions: a function, to randomly fill the array with the
numbers and a function to determine if the array is a magic square. Run
these functions for some large number of times, say 1,000, 10,000, or
1,000,000 times and see the number of times the array is a magic square.
Write a program that randomly generate a 20  20 two-dimensional array,
board, of type int. An element board[i][j] is a peak (either a maximum
or a minimum) if all its neighbors (there should be either 3, 5, or 8 neighbors
for any cell) are less than board[i][j], or greater than board[i][j]. The
program should output all elements in board, with their indices, which are
peak. It should also output if a peak is a maximum or a minimum.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

CHAPTER

ª HunThomas/Shutterstock.com

R ECORDS (structs)
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about records (structs)

2.

Examine various operations on a struct

3.

Explore ways to manipulate data using a struct

4.

Learn about the relationship between a struct and functions

5.

Examine the difference between arrays and structs

6.

Discover how arrays are used in a struct

7.

Learn how to create an array of struct items

8.

Learn how to create structs within a struct

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

610 |

Chapter 9: Records (structs)

In Chapter 8, you learned how to group values of the same type by using arrays. You also
learned how to process data stored in an array and how to perform list operations, such as
searching and sorting.
This chapter may be skipped without experiencing any discontinuation.

In this chapter, you will learn how to group related values that are of different types. C++
provides another structured data type, called a struct (some languages use the term
‘‘record’’), to group related items of different types. An array is a homogeneous data structure;
a struct is typically a heterogeneous data structure. The treatment of a struct in this chapter
is similar to the treatment of a struct in C. A struct in this chapter, therefore, is a C-like
struct. Chapter 10 introduces and discusses another structured data type, called a class.

Records (structs)
Suppose that you want to write a program to process student data. A student record
consists of, among other things, the student’s name, student ID, GPA, courses taken,
and course grades. Thus, various components are associated with a student. However,
these components are all of different types. For example, the student’s name is a string,
and the GPA is a floating-point number. Because these components are of different
types, you cannot use an array to group all of the items associated with a student. C++
provides a structured data type called struct to group items of different types.
Grouping components that are related but of different types offers several advantages.
For example, a single variable can pass all the components as parameters to a function.
struct: A collection of a fixed number of components in which the components are

accessed by name. The components may be of different types.
The components of a struct are called the members of the struct. The general syntax
of a struct in C++ is:
struct structName
{
dataType1 identifier1;
dataType2 identifier2;
.
.
.
dataTypen identifiern;
};

In C++, struct is a reserved word. The members of a struct, even though they
are enclosed in braces (that is, they form a block), are not considered to form a
compound statement. Thus, a semicolon (after the right brace) is essential to end the

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Records (structs) |

611

struct statement. A semicolon at the end of the struct definition is, therefore, a

part of the syntax.
The statement:
struct houseType
{
string style;
int numOfBedrooms;
int numOfBathrooms;
int numOfCarsGarage;
int yearBuilt;
int finishedSquareFootage;
double price;
double tax;
};

defines a struct houseType with 8 members. The member style is of type string,
the members numOfBedrooms, numOfBathrooms, numOfCarsGarage, yearBuilt, and
finishedSquareFootage are of type int, and the members price and tax are of type
double.
Like any type definition, a struct is a definition, not a declaration. That is, it defines
only a data type; no memory is allocated.
Once a data type is defined, you can declare variables of that type.
For example, the following statement defines newHouse to be a struct variable of type
houseType:
//variable declaration
houseType newHouse;

The memory allocated is large enough to store style, numOfBedrooms,
numOfBathrooms, numOfCarsGarage, yearBuilt, finishedSquareFootage,
price, and tax (see Figure 9-1).

newHouse
style
numOfBedrooms
numOfBathrooms
numOfCarsGarage
yearBuilt
finishedSquareFootage
price
tax

FIGURE 9-1

struct newHouse

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

612 |

Chapter 9: Records (structs)

You can also declare struct variables when you define the struct. For example,
consider the following statements:

struct houseType
{
string style;
int numOfBedrooms;
int numOfBathrooms;
int numOfCarsGarage;
int yearBuilt;
int finishedSquareFootage;
double price;
double tax;
} tempHouse;
These statements define the struct houseType and also declare tempHouse to be a
variable of type houseType.
Typically, in a program, a struct is defined before the definitions of all the functions in
the program, so that the struct can be used throughout the program. Therefore, if you
define a struct and also simultaneously declare a struct variable (as in the preceding
statements), then that struct variable becomes a global variable and thus can be
accessed anywhere in the program. Keeping in mind the side effects of global variables,
you should first only define a struct and then declare the struct variables.

Accessing struct Members
In arrays, you access a component by using the array name together with the relative
position (index) of the component. The array name and index are separated using square
brackets. To access a structure member (component), you use the struct variable name
together with the member name; these names are separated by a dot (period). The syntax
for accessing a struct member is:
structVariableName.memberName

The structVariableName.memberName is just like any other variable. For example,
newStudent.courseGrade is a variable of type char, newStudent.firstName is a
string variable, and so on. As a result, you can do just about anything with struct
members that you normally do with variables. You can, for example, use them in assignment statements or input/output (where permitted) statements.
In C++, the dot (.) is an operator called the member access operator.
Consider the following statements:
struct studentType
{
string firstName;
string lastName;
char courseGrade;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Records (structs) |

613

int testScore;
int programmingScore;
double GPA;
};
//variables
studentType newStudent;
studentType student;

Suppose you want to initialize the member GPA of newStudent to 0.0. The following
statement accomplishes this task:
newStudent.GPA = 0.0;

Similarly, the statements:
newStudent.firstName = "John";
newStudent.lastName = "Brown";

store "John" in the member firstName and "Brown" in the member lastName of
newStudent.
After the preceding three assignment statements execute, newStudent is as shown in
Figure 9-2.

newStudent
firstName

John

lastName

Brown

courseGrade
testScore
programmingScore
GPA

FIGURE 9-2

0.0

struct newStudent

The statement:
cin >> newStudent.firstName;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

614 |

Chapter 9: Records (structs)

reads the next string from the standard input device and stores it in:
newStudent.firstName

The statement:
cin >> newStudent.testScore >> newStudent.programmingScore;

reads two integer values from the keyboard and stores them in newStudent.testScore
and newStudent.programmingScore, respectively.
Suppose that score is a variable of type int. The statement:
score = (newStudent.testScore + newStudent.programmingScore) / 2;

assigns the average of newStudent.testScore and newStudent.programmingScore
to score.
The

following

statement

determines

the

course

grade

and

stores

it

in

newStudent.courseGrade:
if (score >= 90)
newStudent.courseGrade
else if (score >= 80)
newStudent.courseGrade
else if (score >= 70)
newStudent.courseGrade
else if (score >= 60)
newStudent.courseGrade
else
newStudent.courseGrade

= 'A';
= 'B';
= 'C';
= 'D';
= 'F';

EXAMPLE 9-1
Consider the definition of the struct houseType given in the previous section and the
following statements:
houseType ryanHouse;
houseType anitaHouse;
ryanHouse.style = "Colonial";
ryanHouse.numOfBedrooms = 3;
ryanHouse.numOfBathrooms = 2;
ryanHouse.numOfCarsGarage = 2;
ryanHouse.yearBuilt = 2005;
ryanHouse.finishedSquareFootage = 2250;
ryanHouse.price = 290000;
ryanHouse.tax = 5000.50;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Records (structs) |

615

The first two statements declare ryanHouse and anitaHouse to be variables of houseType.
The next eight statements store the string "Colonial" into ryanHouse.style, 3 into
ryanHouse.numOfBedrooms, 2 into ryanHouse.numOfBathrooms, and so on.
Next, consider the following statements:
cin >> anitaHouse.style >> anitaHouse.numOfBedrooms
>> anitaHouse.price;

If the input is:
Ranch 4 350000

then the string "Ranch" is stored into anitaHouse.style, 4 is stored into
anitaHouse.numOfBedrooms, and 350000 is stored into anitaHouse.price.

Assignment
We can assign the value of one struct variable to another struct variable of the same type
by using an assignment statement. Suppose that newStudent is as shown in Figure 9-3.

newStudent
firstName

Lisa

lastName

Robinson

courseGrade

FIGURE 9-3

A

testScore

95

programmingScore

98

GPA

3.9

struct newStudent

The statement:
student = newStudent;

copies the contents of newStudent into student. After this assignment statement
executes, the values of student are as shown in Figure 9-4.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

616 |

Chapter 9: Records (structs)

student
firstName

Lisa

lastName

Robinson

courseGrade

FIGURE 9-4

A

testScore

95

programmingScore

98

GPA

3.9

student after student = newStudent

In fact, the assignment statement:
student = newStudent;

is equivalent to the following statements:
student.firstName = newStudent.firstName;
student.lastName = newStudent.lastName;
student.courseGrade = newStudent.courseGrade;
student.testScore = newStudent.testScore;
student.programmingScore = newStudent.programmingScore;
student.GPA = newStudent.GPA;

Comparison (Relational Operators)
To compare struct variables, you compare them member-wise. As with an array, no
aggregate relational operations are performed on a struct. For example, suppose that
newStudent and student are declared as shown earlier. Furthermore, suppose that
you want to see whether student and newStudent refer to the same student. Now
newStudent and student refer to the same student if they have the same first name
and the same last name. To compare the values of student and newStudent, you must
compare them member-wise, as follows:
if (student.firstName == newStudent.firstName &&
student.lastName == newStudent.lastName)
.
.
.

Although you can use an assignment statement to copy the contents of one struct into
another struct of the same type, you cannot use relational operators on struct
variables. Therefore, the following would be illegal:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Records (structs) |

if (student == newStudent)
.
.
.

617

//illegal

Input /Output
No aggregate input/output operations are allowed on a struct variable. Data in a
struct variable must be read one member at a time. Similarly, the contents of a struct
variable must be written one member at a time.
We have seen how to read data into a struct variable. Let us now see how to output a
struct variable. The statement:
cout <<
<<
<<
<<
<<

newStudent.firstName << " " << newStudent.lastName
" " << newStudent.courseGrade
" " << newStudent.testScore
" " << newStudent.programmingScore
" " << newStudent.GPA << endl;

outputs the contents of the struct variable newStudent.

struct Variables and Functions
Recall that arrays are passed by reference only, and a function cannot return a value of
type array. However:
•
•

A struct variable can be passed as a parameter either by value or by reference, and
A function can return a value of type struct.

The following function reads and stores a student’s first name, last name, test score,
programming score, and GPA. It also determines the student’s course grade and stores it
in the member courseGrade.
void readIn(studentType& student)
{
int score;
cin >> student.firstName >> student.lastName;
cin >> student.testScore >> student.programmingScore;
cin >> student.GPA;
score = (newStudent.testScore + newStudent.programmingScore) / 2;
if (score >= 90)
student.courseGrade = 'A';
else if (score >= 80)
student.courseGrade = 'B';
else if (score >= 70)
student.courseGrade = 'C';

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

618 |

Chapter 9: Records (structs)

else if (score >= 60)
student.courseGrade = 'D';
else
student.courseGrade = 'F';
}

The statement:
readIn(newStudent);

calls the function readIn. The function readIn stores the appropriate information in
the variable newStudent.
Similarly, we can write a function that will print the contents of a struct variable. For
example, the following function outputs the contents of a struct variable of type
studentType on the screen:
void printStudent(studentType student)
{
cout << student.firstName << " " << student.lastName
<< " " << student.courseGrade
<< " " << student.testScore
<< " " << student.programmingScore
<< " " << student.GPA << endl;
}

Arrays versus structs
The previous discussion showed us that a struct and an array have similarities as well as
differences.Table 9-1 summarizes this discussion.
TABLE 9-1 Arrays vs. structs

Aggregate Operation

Array

struct

Arithmetic

No

No

Assignment

No

Yes

Input/output

No (except strings)

No

Comparison

No

No

Parameter passing

By reference only

By value or by reference

Function returning a value

No

Yes

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Records (structs) |

619

Arrays in structs
A list is a set of elements of the same type. Thus, a list has two things associated with it:
the values (that is, elements) and the length. Because the values and the length are both
related to a list, we can define a struct containing both items.
const int ARRAY_SIZE = 1000;
struct listType
{
int listElem[ARRAY_SIZE];
int listLength;
};

//array containing the list
//length of the list

The following statement declares intList to be a struct variable of type listType
(see Figure 9-5):
listType intList;

intList
listElem

listElem[0]
listElem[1]
listElem[2]
.
.
.
listElem[999]

listLength

FIGURE 9-5

struct variable intList

9

The variable intList has two members: listElem, an array of 1000 components of
type int, and listLength, of type int. Moreover, intList.listElem accesses the
member listElem, and intList.listLength accesses the member listLength.
Consider the following statements:
intList.listLength = 0;
intList.listElem[0] = 12;
intList.listLength++;
intList.listElem[1] = 37;
intList.listLength++;

//Line
//Line
//Line
//Line
//Line

1
2
3
4
5

The statement in Line 1 sets the value of the member listLength to 0. The statement
in Line 2 stores 12 in the first component of the array listElem. The statement in Line
3 increments the value of listLength by 1. The meaning of the other statements is
similar. After these statements execute, intList is as shown in Figure 9-6.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

620 |

Chapter 9: Records (structs)

intList
listElem

listElem[0]
listElem[1]
listElem[2]

12
37
.
.
.

listElem[999]
listLength

FIGURE 9-6

2

intList after the statements in Lines 1 through 5 execute

Next, we write the sequential search algorithm to determine whether a given item is in
the list. If searchItem is found in the list, then the function returns its location in the
list; otherwise, the function returns -1.
int seqSearch(const listType& list, int searchItem)
{
int loc;
bool found = false;
for (loc = 0; loc < list.listLength; loc++)
if (list.listElem[loc] == searchItem)
{
found = true;
break;
}
if (found)
return loc;
else
return -1;
}

In this function, because listLength is a member of list, we access this by
list.listLength. Similarly, we can access an element of list via
list.listElem[loc].
Notice that the formal parameter list of the function seqSearch is declared as
a constant reference parameter. This means that list receives the address of the
corresponding actual parameter, but list cannot modify the actual parameter.
Recall that when a variable is passed by value, the formal parameter copies the value of
the actual parameter. Therefore, if the formal parameter modifies the data, the modification has no effect on the data of the actual parameter.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Records (structs) |

621

Suppose that a struct has several data members requiring a large amount of memory to
store the data, and you need to pass a variable of that struct type by value. The
corresponding formal parameter then receives a copy of the data of the variable. The
compiler must then allocate memory for the formal parameter in order to copy the value
of the actual parameter. This operation might require, in addition to a large amount of
storage space, a considerable amount of computer time to copy the value of the actual
parameter into the formal parameter.
On the other hand, if a variable is passed by reference, the formal parameter receives only
the address of the actual parameter. Therefore, an efficient way to pass a variable as a
parameter is by reference. If a variable is passed by reference, then when the formal
parameter changes, the actual parameter also changes. Sometimes, however, you do not
want the function to be able to change the values of the actual parameter. In C++, you
can pass a variable by reference and still prevent the function from changing its value.
This is done by using the keyword const in the formal parameter declaration, as shown
in the definition of the function seqSearch.
Likewise, we can also rewrite the sorting, binary search, and other list-processing functions.

structs in Arrays
Suppose a company has 50 full-time employees. We need to print their monthly
paychecks and keep track of how much money has been paid to each employee in the
year-to-date. First, let’s define an employee’s record:
struct employeeType
{
string firstName;
string lastName;
int
personID;
string deptID;
double yearlySalary;
double monthlySalary;
double yearToDatePaid;
double monthlyBonus;
};

Each employee has the following members (components): first name, last name, personal
ID, department ID, yearly salary, monthly salary, year-to-date paid, and monthly bonus.
Because we have 50 employees and the data type of each employee is the same, we can
use an array of 50 components to process the employees’ data.
employeeType employees[50];

This statement declares the array employees of 50 components of type employeeType (see
Figure 9-7). Every element of employees is a struct. For example, Figure 9-7 also shows
employees[2].

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

622 |

Chapter 9: Records (structs)

employees
[0]
[1]
[2]
.
.
.
[49]

employees[2]
firstName
lastName
personID
deptID
yearlySalary
monthlySalary
yearToDatePaid
monthlyBonus

FIGURE 9-7

Array of employees

Suppose we also have the following declaration:
int

counter;

Further, suppose that every employee’s initial data—first name, last name, personal ID,
department ID, and yearly salary—are provided in a file. For our discussion, we
assume that each employee’s data is stored in a file, say, employee.dat. The following
C++ code loads the data into the employees’ array. We assume that, initially,
yearToDatePaid is 0 and that the monthly bonus is determined each month based
on performance.
ifstream infile; //input stream variable
//assume that the file employee.dat has been opened
for (counter = 0; counter < 50; counter++)
{
infile >> employees[counter].firstName
>> employees[counter].lastName
>> employees[counter].personID
>> employees[counter].deptID
>> employees[counter].yearlySalary;
employees[counter].monthlySalary =
employees[counter].yearlySalary / 12;
employees[counter].yearToDatePaid = 0.0;
employees[counter].monthlyBonus = 0.0;
}

Suppose that for a given month, the monthly bonuses are already stored in each employee’s
record, and we need to calculate the monthly paycheck and update the yearToDatePaid
amount. The following loop computes and prints the employee’s paycheck for the month:
double payCheck; //variable to calculate the paycheck
for (counter = 0; counter < 50; counter++)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Records (structs) |

623

{
cout << employees[counter].firstName << " "
<< employees[counter].lastName << " ";
payCheck = employees[counter].monthlySalary +
employees[counter].monthlyBonus;
employees[counter].yearToDatePaid =
employees[counter].yearToDatePaid +
payCheck;
cout << setprecision(2) << payCheck << endl;
}

structs within a struct
You have seen how the struct and array data structures can be combined to organize
information. You also saw examples wherein a member of a struct is an array, and the
array type is a struct. In this section, you will learn about situations for which it is
beneficial to organize data in a struct by using another struct.
Let us consider the following employee record:
struct employeeType
{
string firstname;
string middlename;
string lastname;
string empID;
string address1;
string address2;
string city;
string state;
string zip;
int hiremonth;
int hireday;
int hireyear;
int quitmonth;
int quitday;
int quityear;
string phone;
string cellphone;
string fax;
string pager;
string email;
string deptID;
double salary;
};

As you can see, a lot of information is packed into one struct. This struct has 22
members. Some members of this struct will be accessed more frequently than others,
and some members are more closely related than others. Moreover, some members will

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

624 |

Chapter 9: Records (structs)

have the same underlying structure. For example, the hire date and the quit date are of
the data type int. Let us reorganize this struct as follows:
struct nameType
{
string first;
string middle;
string last;
};
struct addressType
{
string address1;
string address2;
string city;
string state;
string zip;
};
struct dateType
{
int month;
int day;
int year;
};
struct contactType
{
string phone;
string cellphone;
string fax;
string pager;
string email;
};

We have separated the employee’s name, address, and contact type into subcategories.
Furthermore, we have defined a struct dateType. Let us rebuild the employee’s
record as follows:
struct employeeType
{
nameType name;
string empID;
addressType address;
dateType hireDate;
dateType quitDate;
contactType contact;
string deptID;
double salary;
};

The information in this employee’s struct is easier to manage than the previous one.
Some of this struct can be reused to build another struct. For example, suppose that
you want to define a customer’s record. Every customer has a first name, last name, and
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Records (structs) |

625

middle name, as well as an address and a way to be contacted. You can, therefore, quickly
put together a customer’s record by using the structs nameType, addressType,
contactType, and the members specific to the customer.
Next, let us declare a variable of type employeeType and discuss how to access its members.
Consider the following statement:
employeeType newEmployee;

This statement declares newEmployee to be a struct variable of type employeeType
(see Figure 9-8).

newEmployee
first
middle
last

name

empID
address

address 1
address 2
city
state
zip

hireDate

month
day
year

quitDate

month
day
year

contact

phone
cellphone
fax
pager
email

deptID
salary

FIGURE 9-8

struct variable newEmployee

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

626 |

Chapter 9: Records (structs)

The statement:
newEmployee.salary = 45678.00;

sets the salary of newEmployee to 45678.00. The statements:
newEmployee.name.first = "Mary";
newEmployee.name.middle = "Beth";
newEmployee.name.last = "Simmons";

set the first, middle, and last name of newEmployee to "Mary", "Beth", and
"Simmons", respectively. Note that newEmployee has a member called name. We
access this member via newEmployee.name. Note also that newEmployee.name is a
struct and has three members. We apply the member access criteria to access the
member first of the struct newEmployee.name. So, newEmployee.name.first
is the member where we store the first name.
The statement:
cin >> newEmployee.name.first;

reads and stores a string into newEmployee.name.first. The statement:
newEmployee.salary = newEmployee.salary * 1.05;

updates the salary of newEmployee.
The following statement declares employees to be an array of 100 components,
wherein each component is of type employeeType:
employeeType employees[100];

The for loop:
for (int j = 0; j < 100; j++)
cin >> employees[j].name.first >> employees[j].name.middle
>> employees[j].name.last;

reads and stores the names of 100 employees in the array employees. Because employees
is an array, to access a component, we use the index. For example, employees[50] is the
51st component of the array employees (recall that an array index starts with 0). Because
employees[50] is a struct, we apply the member access criteria to select a particular
member.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Sales Data Analysis

PROGRAMMING EXAMPLE:

|

627

Sales Data Analysis

A company has six salespeople. Every month, they go on road trips to sell the
company’s product. At the end of each month, the total sales for each salesperson,
together with that salesperson’s ID and the month, is recorded in a file. At the end of
each year, the manager of the company wants to see this report in this following
tabular format:
-----------

Annual Sales Report -----------

ID

QT1

QT2

12345
32214
23422
57373
35864
54654

1892.00
343.00
1395.00
893.00
2882.00
893.00

0.00
892.00
1901.00
892.00
1221.00
0.00

Total

8298.00

4906.00

QT3

QT4

Total

494.00
9023.00
0.00
8834.00
0.00
392.00

322.00
0.00
0.00
0.00
1223.00
3420.00

2708.00
10258.00
3296.00
10619.00
5326.00
4705.00

18743.00

4965.00

Max Sale by SalesPerson: ID = 57373, Amount = $10619.00
Max Sale by Quarter: Quarter = 3, Amount = $18743.00

In this report, QT1 stands for quarter 1 (months 1 to 3), QT2 for quarter 2 (months 4
to 6), QT3 for quarter 3 (months 7 to 9), and QT4 for quarter 4 (months 10 to 12).
The salespeople’s IDs are stored in one file; the sales data is stored in another file. The
sales data is in the following form:
salesPersonID
.
.
.

month

saleAmount

Furthermore, the sales data is in no particular order; it is not ordered by ID.
A sample sales data is:
12345
32214
23422
57373
.
.
.

1
1
3
2

893
343
903
893

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

628 |

Chapter 9: Records (structs)

Let us write a program that produces the output in the specified format.

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Input

One file containing each salesperson’s ID and a second file containing
the sales data.

Output

A file containing the annual sales report in the above format.

Based on the problem’s requirements, it is clear that the main components for each
salesperson are the salesperson’s ID, quarterly sales amount, and total annual sales
amount. Because the components are of different types, we can group them with the
help of a struct, defined as follows:
struct salesPersonRec
{
string ID;
//salesperson's ID
double saleByQuarter[4];
//array to store the total
//sales for each quarter
double totalSale;
//salesperson's yearly sales amount
};

Because there are six salespeople, we use an array of six components, wherein each
component is of type salesPersonRec, defined as follows:
salesPersonRec salesPersonList[NO_OF_SALES_PERSON];

wherein the value of NO_OF_SALES_PERSON is 6.
Because the program requires us to find the company’s total sales for each quarter, we
need an array of four components to store the data. Note that this data will be used to
determine the quarter in which the maximum sales were made. Therefore, the
program also needs the following array:
double totalSaleByQuarter[4];

Recall

that in C++, the array index starts with 0. Therefore,
totalSaleByQuarter[0] stores data for quarter 1, totalSaleByQuarter[1]
stores data for quarter 2, and so on.
We will refer to these variables throughout the discussion.
The array salesPersonList is as shown in Figure 9-9.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Sales Data Analysis

salesPersonList

ID

saleByQuarter

|

629

totalSale

salesPersonList[0]
salesPersonList[1]
salesPersonList[2]
salesPersonList[3]
salesPersonList[4]
salesPersonList[5]

FIGURE 9-9

Array salesPersonList

The first step of the program is to read the salespeople’s IDs into the array
salesPersonList and initialize the quarterly sales and total sales for each salesperson
to 0. After this step, the array salesPersonList is as shown in Figure 9-10.
salesPersonList

FIGURE 9-10

saleByQuarter

ID

totalSale

salesPersonList[0]

12345

0.0

0.0

0.0

0.0

0.0

salesPersonList[1]

32214

0.0

0.0

0.0

0.0

0.0

salesPersonList[2]

23422

0.0

0.0

0.0

0.0

0.0

salesPersonList[3]

57373

0.0

0.0

0.0

0.0

0.0

salesPersonList[4]

35864

0.0

0.0

0.0

0.0

0.0

salesPersonList[5]

54654

0.0

0.0

0.0

0.0

0.0

Array salesPersonList after initialization

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

630 |

Chapter 9: Records (structs)

The next step is to process the sales data. Processing the sales data is quite straightforward. For each entry in the file containing the sales data:
1. Read the salesperson’s ID, month, and sale amount for the month.
2. Search the array salesPersonList to locate the component
corresponding to this salesperson.
3. Determine the quarter corresponding to the month.
4. Update the sales for the quarter by adding the sale amount for the month.
Once the sales data file is processed:
1. Calculate the total sales by salesperson.
2. Calculate the total sales by quarter.
3. Print the report.
This discussion translates into the following algorithm:
1.
2.
3.
4.
5.
6.
7.

Initialize the array salesPersonList.
Process the sales data.
Calculate the total sales by quarter.
Calculate the total sales by salesperson.
Print the report.
Calculate and print the maximum sales by salesperson.
Calculate and print the maximum sales by quarter.

To reduce the complexity of the main program, let us write a separate function for
each of these seven steps.
Function This function reads the salesperson’s ID from the input file and stores the salesperson’s ID
initialize in the array salesPersonList. It also initializes the quarterly sales amount and the
total sales amount for each salesperson to 0. The definition of this function is:
void initialize(ifstream& indata, salesPersonRec list[],
int listSize)
{
int index;
int quarter;
for (index = 0; index < listSize; index++)
{
indata >> list[index].ID; //get salesperson's ID
for (quarter = 0; quarter < 4; quarter++)
list[index].saleByQuarter[quarter] = 0.0;
list[index].totalSale = 0.0;
}
} //end initialize

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Sales Data Analysis

|

631

Function This function reads the sales data from the input file and stores the appropriate
getData information in the array salesPersonList. The algorithm for this function is:

1. Read the salesperson’s ID, month, and sales amount for the month.
2. Search the array salesPersonList to locate the component
corresponding to the salesperson. (Because the salespeople’s IDs
are not sorted, we will use a sequential search to search the array.)
3. Determine the quarter corresponding to the month.
4. Update the sales for the quarter by adding the sales amount for the
month.
Suppose that the entry read is:
57373 2 350

Here, the salesperson’s ID is 57373, the month is 2, and the sale amount is 350.
Suppose that the array salesPersonList is as shown in Figure 9-11.

salesPersonList

saleByQuarter

ID

totalSale

salesPersonList[0]

12345

150.80

0.0

0.0

654.92

0.0

salesPersonList[1]

32214

0.0

439.90

0.0

0.0

0.0

salesPersonList[2]

23422

0.0

0.0

0.0

564.76

0.0

salesPersonList[3]

57373

354.80

0.0

0.0

0.0

0.0

salesPersonList[4]

35864

0.0

0.0

763.90

0.0

0.0

salesPersonList[5]

54654

783.45

0.0

0.0

563.80

0.0

FIGURE 9-11

Array salesPersonList

Now, ID 57373 corresponds to the array component salesPersonList[3], and
month 2 corresponds to quarter 1. Therefore, you add 350 to 354.80 to get the
new amount, 704.80. After processing this entry, the array salesPersonList is
as shown in Figure 9-12.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

632 |

Chapter 9: Records (structs)

ID = 57373
month = 2
salesPersonList

FIGURE 9-12

saleByQuarter

ID

totalSale

salesPersonList[0]

12345

150.80

0.0

0.0

654.92

0.0

salesPersonList[1]

32214

0.0

439.90

0.0

0.0

0.0

salesPersonList[2]

23422

0.0

0.0

0.0

564.76

0.0

salesPersonList[3]

57373

704.80

0.0

0.0

0.0

0.0

salesPersonList[4]

35864

0.0

0.0

763.90

0.0

0.0

salesPersonList[5]

54654

783.45

0.0

0.0

563.80

0.0

Array salesPersonList after processing entry 57373 2 350

The definition of the function getData is:
void getData(ifstream& infile, salesPersonRec list[],
int listSize)
{
int index;
int quarter;
string sID;
int month;
double amount;
infile >> sID;

//get salesperson's ID

while (infile)
{
infile >> month >> amount;

//get the sale month and
//the sale amount

for (index = 0; index < listSize; index++)
if (sID == list[index].ID)
break;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Sales Data Analysis

|

633

if (1 <= month && month <= 3)
quarter = 0;
else if (4 <= month && month <= 6)
quarter = 1;
else if (7 <= month && month <= 9)
quarter = 2;
else
quarter = 3;
if (index < listSize)
list[index].saleByQuarter[quarter] += amount;
else
cout << "Invalid salesperson's ID." << endl;
infile >> sID;
} //end while
} //end getData

Function This function finds the company’s total sales for each quarter. To find the total sales for
saleByQuarter each quarter, we add the sales amount of each salesperson for that quarter. Clearly, this
function must have access to the array salesPersonList and the array
totalSaleByQuarter. This function also needs to know the number of rows in

each array. Thus, this function has three parameters. The definition of this function is:
void saleByQuarter(salesPersonRec list[], int listSize,
double totalByQuarter[])
{
int quarter;
int index;
for (quarter = 0; quarter < 4; quarter++)
totalByQuarter[quarter] = 0.0;
for (quarter = 0; quarter < 4; quarter++)
for (index = 0; index < listSize; index++)
totalByQuarter[quarter] +=
list[index].saleByQuarter[quarter];
} //end saleByQuarter

Function This function finds each salesperson’s yearly sales amount. To find an employee’s yearly
totalSaleBy sales amount, we add that employee’s sales amount for the four quarters. Clearly, this
Person function must have access to the array salesPersonList. This function also needs to

know the size of the array. Thus, this function has two parameters.
The definition of this function is:
void totalSaleByPerson(salesPersonRec list[], int listSize)
{
int index;
int quarter;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

634 |

Chapter 9: Records (structs)

for (index = 0; index < listSize; index++)
for (quarter = 0; quarter < 4; quarter++)
list[index].totalSale +=
list[index].saleByQuarter[quarter];
} //end totalSaleByPerson

Function This function prints the annual report in the specified format. The algorithm in
printReport pseudocode is:

1. Print the heading—that is, the first three lines of output.
2. Print the data for each salesperson.
3. Print the last line of the table.
Note that the next two functions will produce the final two lines of output.
Clearly, the printReport function must have access to the array salesPersonList
and the array totalSaleByQuarter. Also, because the output will be stored in a file, this
function must have access to the ofstream variable associated with the output file. Thus,
this function has four parameters: a parameter corresponding to the array
salesPersonList, a parameter corresponding to the array totalSaleByQuarter, a
parameter specifying the size of the array, and a parameter corresponding to the ofstream
variable. The definition of this function is:
void printReport(ofstream& outfile, salesPersonRec list[],
int listSize, double saleByQuarter[])
{
int index;
int quarter;
outfile <<
<<
outfile <<
outfile <<
<<
outfile <<
<<

"––––––––––– Annual Sales Report –––––––––"
"––––" << endl;
endl;
" ID
QT1
QT2
QT3
"
"QT4
Total" << endl;
"_____________________________________________"
"_________________" << endl;

for (index = 0; index < listSize; index++)
{
outfile << list[index].ID << "
";
for (quarter = 0; quarter < 4; quarter++)
outfile << setw(10)
<< list[index].saleByQuarter[quarter];
outfile << setw(10) << list[index].totalSale << endl;
}
outfile << "Total

";

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Sales Data Analysis

|

635

for (quarter = 0; quarter < 4; quarter++)
outfile << setw(10)<< saleByQuarter[quarter];
outfile << endl << endl;
} //end printReport

Function This function prints the name of the salesperson who produces the maximum sales
maxSaleBy amount. To identify this salesperson, we look at the sales total for each salesperson
Person and find the largest sales amount. Because each employee’s sales total is maintained
in the array salesPersonList, this function must have access to the array
salesPersonList. Also, because the output will be stored in a file, this function
must have access to the ofstream variable associated with the output file.

Therefore, this function has three parameters: a parameter corresponding to the
array salesPersonList, a parameter specifying the size of this array, and a
parameter corresponding to the output file.
The algorithm to find the largest sales amount is similar to the algorithm to find the
largest element in an array (discussed in Chapter 8). The definition of this function is:
void maxSaleByPerson(ofstream& outData, salesPersonRec list[],
int listSize)
{
int maxIndex = 0;
int index;
for (index = 1; index < listSize; index++)
if (list[maxIndex].totalSale < list[index].totalSale)
maxIndex = index;
outData << "Max Sale by SalesPerson: ID = "
<< list[maxIndex].ID
<< ", Amount = $" << list[maxIndex].totalSale
<< endl;
} //end maxSaleByPerson

Function This function prints the quarter in which the maximum sales were made. To identify
maxSaleBy this quarter, we look at the total sales for each quarter and find the largest sales amount.
Quarter Because the sales total for each quarter is in the array totalSaleByQuarter, this
function must have access to the array totalSaleByQuarter. Also, because the
output will be stored in a file, this function must have access to the ofstream variable

associated with the output file. Therefore, this function has two parameters: a parameter corresponding to the array totalSaleByQuarter and a parameter corresponding to the output file.
The algorithm to find the largest sales amount is the same as the algorithm to find the
largest element in an array (discussed in Chapter 8). The definition of this function is:
void maxSaleByQuarter(ofstream& outData,
double saleByQuarter[])

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

636 |

Chapter 9: Records (structs)

{
int quarter;
int maxIndex = 0;
for (quarter = 0; quarter < 4; quarter++)
if (saleByQuarter[maxIndex] < saleByQuarter[quarter])
maxIndex = quarter;
outData << "Max Sale by Quarter: Quarter = "
<< maxIndex + 1
<< ", Amount = $" << saleByQuarter[maxIndex]
<< endl;
} //end maxSaleByQuarter

To make the program more flexible, we will prompt the user to specify the input and
output files during its execution.
We are now ready to write the algorithm for the function main.
Main
Algorithm

1. Declare the variables.
2. Prompt the user to enter the name of the file containing the
salesperson’s ID data.
3. Read the name of the input file.
4. Open the input file.
5. If the input file does not exist, exit the program.
6. Initialize the array salesPersonList. Call the function
initialize.
7. Close the input file containing the salesperson’s ID data and clear
the input stream.
8. Prompt the user to enter the name of the file containing the sales
data.
9. Read the name of the input file.
10. Open the input file.
11. If the input file does not exist, exit the program.
12. Prompt the user to enter the name of the output file.
13. Read the name of the output file.
14. Open the output file.
15. To output floating-point numbers in a fixed decimal format with
the decimal point and trailing zeroes, set the manipulators fixed
and showpoint. Also, to output floating-point numbers to two
decimal places, set the precision to two decimal places.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Sales Data Analysis

16.
17.
18.
19.
20.
21.
22.

|

637

Process the sales data. Call the function getData.
Calculate the total sales by quarter. Call the function saleByQuarter.
Calculate the total sales for each salesperson. Call the function
totalSaleByPerson.
Print the report in a tabular format. Call the function printReport.
Find and print the salesperson who produces the maximum sales
for the year. Call the function maxSaleByPerson.
Find and print the quarter that produces the maximum sales for the
year. Call the function maxSaleByQuarter.
Close the files.

PROGRAM LISTING
//*************************************************************
// Author: D.S. Malik
//
// Program: Sales Data Analysis
// This program processes sales data for a company. For each
// salesperson, it outputs the ID, the total sales by each
// quarter, and the total sales for the year. It also outputs
// the salesperson's ID generating the maximum sale for the
// year and the sales amount. The quarter generating the
// maximum sale and the sales amount is also output.
//*************************************************************
#include
#include
#include
#include

<iostream>
<fstream>
<iomanip>
<string>

using namespace std;
const int NO_OF_SALES_PERSON = 6;
struct salesPersonRec
{
string ID;
//salesperson's ID
double saleByQuarter[4]; //array to store the total
//sales for each quarter
double totalSale;
//salesperson's yearly sales amount
};
void initialize(ifstream& indata, salesPersonRec list[],
int listSize);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

638 |

Chapter 9: Records (structs)

void getData(ifstream& infile, salesPersonRec list[],
int listSize);
void saleByQuarter(salesPersonRec list[], int listSize,
double totalByQuarter[]);
void totalSaleByPerson(salesPersonRec list[], int listSize);
void printReport(ofstream& outfile, salesPersonRec list[],
int listSize, double saleByQuarter[]);
void maxSaleByPerson(ofstream& outData, salesPersonRec list[],
int listSize);
void maxSaleByQuarter(ofstream& outData, double saleByQuarter[]);
int main()
{
//Step 1
ifstream infile;
ofstream outfile;
string inputFile;
string outputFile;

//input file stream variable
//output file stream variable
//variable to hold the input file name
//variable to hold the output file name

double totalSaleByQuarter[4];

//array to hold the
//sale by quarter

salesPersonRec salesPersonList[NO_OF_SALES_PERSON]; //array
//to hold the salesperson's data
cout << "Enter the salesPerson ID file name: "; //Step 2
cin >> inputFile;
//Step 3
cout << endl;
infile.open(inputFile.c_str());

//Step 4

if (!infile)
{
cout << "Cannot open the input file."
<< endl;
return 1;
}

//Step 5

initialize(infile, salesPersonList,
NO_OF_SALES_PERSON);

//Step 6

infile.close();
infile.clear();

//Step 7
//Step 7

cout << "Enter the sales data file name: ";
cin >> inputFile;
cout << endl;

//Step 8
//Step 9

infile.open(inputFile.c_str());

//Step 10

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Sales Data Analysis

if (!infile)
{
cout << "Cannot open the input file."
<< endl;
return 1;
}

//Step 11

cout << "Enter the output file name: ";
cin >> outputFile;
cout << endl;

//Step 12
//Step 13

outfile.open(outputFile.c_str());
outfile << fixed << showpoint
<< setprecision(2);

//Step 14

getData(infile, salesPersonList,
NO_OF_SALES_PERSON);
saleByQuarter(salesPersonList,
NO_OF_SALES_PERSON,
totalSaleByQuarter);
totalSaleByPerson(salesPersonList,
NO_OF_SALES_PERSON);

639

//Step 15
//Step 16
//Step 17
//Step 18

printReport(outfile, salesPersonList,
NO_OF_SALES_PERSON,
totalSaleByQuarter);
maxSaleByPerson(outfile, salesPersonList,
NO_OF_SALES_PERSON);
maxSaleByQuarter(outfile, totalSaleByQuarter);

//Step 20
//Step 21

infile.close();
outfile.close();

//Step 22
//Step 22

return

|

//Step 19

0;

}
//Place the definitions of the functions initialize,
//getData, saleByQuarter, totalSaleByPerson,
//printReport, maxSaleByPerson, and maxSaleByQuarter here.

Sample Run: In this sample run, the user input is shaded.
Enter the salesPerson ID file name: Ch9_SalesManID.txt
Enter the sales data file name: Ch9_SalesData.txt
Enter the output file name: Ch9_SalesDataAnalysis.txt

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

640 |

Chapter 9: Records (structs)

Input File: Salespeople’s IDs
12345
32214
23422
57373
35864
54654

Input File: Salespeople’s Data
12345
32214
23422
57373
35864
54654
12345
32214
23422
23422
57373
35864
54654
12345
35864
54654
12345
32214
23422
23422
57373
35864

1 893
1 343
3 903
2 893
5 329
9 392
2 999
4 892
4 895
2 492
6 892
10 1223
11 3420
12 322
5 892
3 893
8 494
8 9023
6 223
4 783
8 8834
3 2882

Sample Run:
–––––––––––– Annual Sales Report ––––––––––––
ID

QT1

12345
32214
23422
57373
35864
54654
Total

1892.00
343.00
1395.00
893.00
2882.00
893.00
8298.00

QT2
0.00
892.00
1901.00
892.00
1221.00
0.00
4906.00

QT3

QT4

Total

494.00
9023.00
0.00
8834.00
0.00
392.00
18743.00

322.00
0.00
0.00
0.00
1223.00
3420.00
4965.00

2708.00
10258.00
3296.00
10619.00
5326.00
4705.00

Max Sale by SalesPerson: ID = 57373, Amount = $10619.00
Max Sale by Quarter: Quarter = 3, Amount = $18743.00

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

641

QUICK REVIEW
1.
2.
3.

A struct is a collection of a fixed number of components.
Components of a struct can be of different types.
The syntax to define a struct is:
struct structName
{
dataType1 identifier1;
dataType2 identifier2;
.
.
.
dataTypen identifiern;
};

4.
5.
6.
7.
8.
9.

10.
11.
12.
13.
14.

In C++, struct is a reserved word.
In C++, struct is a definition; no memory is allocated. Memory is
allocated for the struct variables only when you declare them.
Components of a struct are called members of the struct.
Components of a struct are accessed by name.
In C++, the dot (.) operator is called the member access operator.
Members of a struct are accessed by using the dot (.) operator. For
example, if employeeType is a struct, employee is a variable of type
employeeType, and name is a member of employee, then the expression
employee.name accesses the member name. That is, employee.name is
a variable and can be manipulated like other variables.
The only built-in operations on a struct are the assignment and member
access operations.
Neither arithmetic nor relational operations are allowed on struct(s).
As a parameter to a function, a struct can be passed either by value or by
reference.
A function can return a value of type struct.
A struct can be a member of another struct.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.
b.
c.

All members of a struct must be of different types. (1)
A struct is a definition, not a declaration. (1)
A struct variable must be declared after the struct definition. (1)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

642 |

Chapter 9: Records (structs)

A struct member is accessed by using the operator :. (2)
The only allowable operations on a struct are assignment and member
selection. (2)
f.
Because a struct has a finite number of components, relational operations are allowed on a struct. (2)
g. Some aggregate input/output operations are allowed on a struct
variable. (2)
h. A struct variable can be passed as a parameter either by value or by
reference. (4)
i.
A function cannot return a value of the type struct. (4)
j.
An array can be a member of a struct. (6, 7)
k. A member of a struct can be another struct. (8)
Define a struct, carType, to store the following data about a car: Manufacturer (string), model (string), model type (string), color (string),
number of doors (int), miles per gallon in city (int), miles per gallon on
highway (int), year when the car was built (int), and the price (double). (1)
Assume the definition of Exercise 2. Declare a carType variable and write
C++ statements to store the following information: Manufacturer—GMT,
model—Cyclone, type—sedan, color—blue, number of doors—4, miles
per gallon in city—28, miles per gallon on highway—32, year when the car
was built—2006, and the price—25000.00. (2)
Define a struct, fruitType, to store the following data about a fruit: Fruit name
(string), color (string), fat (int), sugar (int), and carbohydrate (int). (1)
Assume the definition of Exercise 4. Declare a variable of type fruitType
to store the following data: Fruit name—banana, color—yellow, fat—1,
sugar—15, carbohydrate—22. (2)
Consider the declaration of the struct houseType given in this chapter.
Write C++ statements to do the following: (2, 3)
d.
e.

2.

3.

4.

5.

6.

Declare variables oldHouse and newHouse of type houseType.
b. Store the following information into oldHouse: Style—Two-story,
number of bedrooms—5, number of bathrooms—3, number of cars
garage—4, year built—1975, finished square footage—3500, price—
675000, and tax—12500.
c. Copy the values of the components of oldHouse into the corresponding
components of newHouse.
Consider the declaration of the struct houseType given in this chapter.
Suppose firstHouse and secondHouse are variables of houseType.
Write C++ statement(s) to compare the style and price of firstHouse
and secondHouse. Output true if the corresponding values are the same;
false otherwise. (2, 3)
a.

7.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

8.

9.

10.

|

643

Write a C++ function, getHouseInput to read and store data into a
variable of houseType. (4)
b. Write a C++ function, printHouseInfo to output data stored
into a variable of houseType. Use appropriate labels to identify each
component. (4)
Which aggregrate operations allowed on struct variables are not allowed
on an array variable? (5)
Consider the following statements:
a.

struct nameType
{
string first;
string last;
};

struct courseType
{
string name;
int callNum;
int credits;
char grade;
};

struct studentType
{
nameType name;
double gpa;
courseType course;
};

studentType student;
studentType classList[100];
courseType course;
nameType name;

Mark the following statements as valid or invalid. If a statement is invalid, explain why.
(2, 3, 6, 7, 8)

11.

a.

student.course.callNum = "CSC230";

b.

cin >> student.name;

c.

classList[0] = name;

d.

classList[1].gpa = 3.45;

e.

name = classList[15].name;

f.

student.name = name;

g.

cout << classList[10] << endl;

h.

for (int j = 0; j < 100; j++)
classList[j].name = name;

i.

classList.course.credits = 3;

j.

course = studentType.course;

Assume the declarations of Exercise 10. Write C++ statements to store the
following information in student: (2, 3, 6, 7, 8)
name: Linda Brown
gpa: 3.78
course name: Calculus
course call number: 23827
course credits: 4
course grade: A

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

644 |

12.

Chapter 9: Records (structs)

Assume the declarations of Exercise 10. Write C++ statements that do the
following: (2, 3, 6, 7, 8)
a.

Store the following information in course:

name: Programming I
callNum: 13452
credits: 3
grade: ""

In the array classList, initialize each gpa to 0.0.
Copy the information of the thirty-first component of the array
classList into student.
d. Update the gpa of the tenth student in the array classList by adding
0.75 to its previous value.
Consider the following statements (nameType is as defined in Exercise 10):
b.
c.

13.

struct employeeType
{
nameType name;
int performanceRating;
int pID;
string dept;
double salary;
};
employeeType employees[100];
employeeType newEmployee;

Mark the following statements as valid or invalid. If a statement is invalid, explain
why. (2, 3, 6, 7, 8)

14.

a.

newEmployee.name = "John Smith";

b.

cout << newEmployee.name;

c.

employees[35] = newEmployee;

d.

if (employees[45].pID == 555334444)
employees[45].performanceRating = 1;

e.

employees.salary = 0;

Assume the declarations of Exercises 10 and 13. Write C++ statements that
do the following: (2, 3, 6, 7, 8)
a.

Store the following information in newEmployee:
name: Mickey Doe
pID: 111111111
performanceRating: 2
dept: ACCT
salary: 34567.78

b.

In the array employees, initialize each performanceRating to 0.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

645

Copy the information of the 20th component of the array employees
into newEmployee.
d. Update the salary of the 50th employee in the array employees by
adding 5735.87 to its previous value.
Assume that you have the following definition of a struct:
c.

15.

struct partsType
{
string partName;
int partNum;
double price;
int quantitiesInStock;
};

16.

Declare an array, inventory, of 100 components of type partsType. (7)
Assume the definition of Exercise 15. (7)
Write a C++ code to initialize each component of inventory as
follows: partName to null string, partNum to -1, price to 0.0, and
quantitiesInStock to 0.
b. Write a C++ code that uses a loop to output the data stored in
inventory. Assume that the variable length indicates the number
of elements in inventory.
Assume the definition and declaration of Exercise 15. Write the definition
of a void function that can be used to input data in a variable of type
partsType. Also write a C++ code that uses your function to input data in
inventory. (4, 7)
Suppose that you have the following definitions: (8)
a.

17.

18.

struct timeType
{
int hr;
double min;
int sec;
};
a.
b.

c.

d.

e.

struct tourType
{
string cityName;
int distance;
timeType travelTime;
};

Declare the variable destination of type tourType.
Write C++ statements to store the following data in destination:
cityName—Chicago, distance—550 miles, travelTime—9 hours
and 30 minutes.
Write the definition of a function to output the data stored in a variable
of type tourType.
Write the definition of a value-returning function that inputs data into
a variable of type tourType.
Write the definition of a void function with a reference parameter of
type tourType to input data in a variable of type tourType.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

646 |

Chapter 9: Records (structs)

PROGRAMMING EXERCISES
1.

2.

Assume the definition of Exercise 4, which defines the struct fruitType.
Write a program that declares a variable of type fruitType, prompts the
user to input data about a fruit, and outputs the fruit data.
Write a program that reads students’ names followed by their test scores. The
program should output each student’s name followed by the test scores and
the relevant grade. It should also find and print the highest test score and the
name of the students having the highest test score.
Student data should be stored in a struct variable of type studentType,
which has four components: studentFName and studentLName of type
string, testScore of type int (testScore is between 0 and 100), and
grade of type char. Suppose that the class has 20 students. Use an array of 20
components of type studentType.
Your program must contain at least the following functions:
A function to read the students’ data into the array.
b. A function to assign the relevant grade to each student.
c. A function to find the highest test score.
d. A function to print the names of the students having the highest test
score.
Your program must output each student’s name in this form: last name
followed by a comma, followed by a space, followed by the first name; the
name must be left justified. Moreover, other than declaring the variables and
opening the input and output files, the function main should only be a
collection of function calls.
a.

3.

4.

Define a struct, menuItemType, with two components: menuItem of
type string and menuPrice of type double.
Write a program to help a local restaurant automate its breakfast billing
system. The program should do the following:
a.
b.
c.

Show the customer the different breakfast items offered by the restaurant.
Allow the customer to select more than one item from the menu.
Calculate and print the bill.
Assume that the restaurant offers the following breakfast items (the price
of each item is shown to the right of the item):
Plain Egg
Bacon and Egg
Muffin
French Toast
Fruit Basket
Cereal
Coffee
Tea

$1.45
$2.45
$0.99
$1.99
$2.49
$0.69
$0.50
$0.75

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

647

Use an array, menuList, of the struct menuItemType, as defined in
Programming Exercise 3. Your program must contain at least the
following functions:
•

Function getData: This function loads the data into the array
menuList.
• Function showMenu: This function shows the different items
offered by the restaurant and tells the user how to select the items.
• Function printCheck: This function calculates and prints the check.
(Note that the billing amount should include a 5% tax.)
A sample output is:
Welcome to Johnny's Restaurant
Bacon and Egg
$2.45
Muffin
$0.99
Coffee
$0.50
Tax
$0.20
Amount Due
$4.14

5.

Format your output with two decimal places. The name of each item in the
output must be left justified. You may assume that the user selects only one
item of a particular type.
Redo Exercise 4 so that the customer can select multiple items of a particular
type. A sample output in this case is:
Welcome to Johnny's Restaurant
1 Bacon and Egg
$2.45
2 Muffin
$1.98
1 Coffee
$0.50
Tax
$0.25
Amount Due
$5.18

6.

Write a program whose main function is merely a collection of variable
declarations and function calls. This program reads a text and outputs the
letters, together with their counts, as explained below in the function
printResult. (There can be no global variables! All information must be
passed in and out of the functions. Use a structure to store the information.)
Your program must consist of at least the following functions:
•

Function openFile: Opens the input and output files. You must pass the
file streams as parameters (by reference, of course). If the file does not
exist, the program should print an appropriate message and exit. The
program must ask the user for the names of the input and output files.
• Function count: Counts every occurrence of capital letters A-Z and
small letters a-z in the text file opened in the function openFile. This
information must go into an array of structures. The array must be passed
as a parameter, and the file identifier must also be passed as a parameter.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

9

648 |

Chapter 9: Records (structs)

•

7.

Function printResult: Prints the number of capital letters and small
letters, as well as the percentage of capital letters for every letter A-Z and
the percentage of small letters for every letter a-z. The percentages
should look like this: ‘‘25%’’. This information must come from an array
of structures, and this array must be passed as a parameter.
Write a program that declares a struct to store the data of a football player
(player’s name, player’s position, number of touchdowns, number of catches,
number of passing yards, number of receiving yards, and the number of
rushing yards). Declare an array of 10 components to store the data of 10
football players. Your program must contain a function to input data and a
function to output data. Add functions to search the array to find the index
of a specific player, and update the data of a player. (You may assume that
input data is stored in a file.) Before the program terminates, give the user the
option to save data in a file. Your program should be menu driven, giving
the user various choices.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

10
CHAPTER

ª HunThomas/Shutterstock.com

CLASSES AND DATA
ABSTRACTION
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about classes

2.

Learn about private, protected, and public members of a class

3.

Explore how classes are implemented

4.

Become aware of accessor and mutator functions

5.

Examine constructors and destructors

6.

Learn about the abstract data type (ADT)

7.

Explore how classes are used to implement ADTs

8.

Become aware of the differences between a struct and a class

9.

Learn about information hiding

10.

Explore how information hiding is implemented in C++

11.

Learn about the static members of a class

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

650 |

Chapter 10: Classes and Data Abstraction

In Chapter 9, you learned how to group data items that are of different types by using a
struct. The definition of a struct given in Chapter 9 is similar to the definition of a
C-struct. However, the members of a C++ struct can be data items as well as functions.
C++ provides another structured data type, called a class, which is specifically designed to
group data and functions. This chapter first introduces classes and explains how to use them
and then discusses the similarities and differences between a struct and a class.
Chapter 9 is not a prerequisite for this chapter. In fact, a struct and a class have similar
capabilities, as discussed in the section ‘‘A struct versus a class’’ in this chapter.

Classes
Chapter 1 introduced the problem-solving methodology called object-oriented design
(OOD). In OOD, the first step is to identify the components, called objects. An object
combines data and the operations on that data in a single unit. In C++, the mechanism
that allows you to combine data and the operations on that data in a single unit is called a
class. Now that you know how to store and manipulate data in computer memory and
how to construct your own functions, you are ready to learn how objects are constructed.
This and subsequent chapters develop and implement programs using OOD. This chapter
first explains how to define a class and use it in a program.
A class is a collection of a fixed number of components. The components of a class are
called the members of the class.
The general syntax for defining a class is:
class classIdentifier
{
classMembersList
};

in which classMembersList consists of variable declarations and/or functions. That is, a
member of a class can be either a variable (to store data) or a function (to manipulate data).
For example, the following statements define the class courseType, with variables and
functions, to implement the basic properties of a course.
class courseType
{
public:
void setCourseInfo(string cName, string cNo, int credits);
void print() const;
int getCredits();
string getCourseNumber();
string getCourseName();

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

651

private:
string courseName;
string courseNo;
int courseCredits;
};

Let us note the following:
•

If a member of a class is a variable, you declare it just like any other
variable. Also, in the definition of the class, you cannot initialize a
variable when you declare it.
• If a member of a class is a function, you typically use the function
prototype to declare that member.
• If a member of a class is a function, it can (directly) access any member of the
class—member variables and member functions. That is, when you write
the definition of a member function, you can directly access any member
variable of the class without passing it as a parameter. The only condition is
that you must declare an identifier before you can use it.
In C++, class is a reserved word, and it defines only a data type; no memory is
allocated. It announces the declaration of a class. Moreover, note the semicolon (;) after
the right brace. The semicolon is part of the syntax. A missing semicolon, therefore, will
result in a syntax error.
The members of a class are classified into three categories: private, public, and
protected. This chapter mainly discusses the first two types, private and public.
In C++, private, protected, and public are reserved words and are called member
access specifiers.
Following are some facts about public and private members of a class:
•
•

By default, all members of a class are private.
If a member of a class is private, you cannot access it directly from
outside of the class. (Example 10-1 illustrates this concept.)
• A public member is accessible outside of the class. (Example 10-1
illustrates this concept.)
• To make a member of a class public, you use the member access
specifier public with a colon, :.
Suppose that we want to define a class to implement the time of day in a program.
Because a clock gives the time of day, let us call this class clockType. Furthermore, to
represent time in computer memory, we use three int variables: one to represent the
hours, one to represent the minutes, and one to represent the seconds.
Suppose these three variables are:
int hr;
int min;
int sec;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

652 |

Chapter 10: Classes and Data Abstraction

We also want to perform the following operations on the time:
1.
2.
3.
4.
5.
6.
7.

Set the time.
Retrieve the time.
Print the time.
Increment the time by one second.
Increment the time by one minute.
Increment the time by one hour.
Compare the two times for equality.

To implement these seven operations, we will write seven functions—setTime, getTime,
printTime, incrementSeconds, incrementMinutes, incrementHours, and
equalTime.
From this discussion, it is clear that the class clockType has 10 members: three
member variables and seven member functions.
Some members of the class clockType will be private; others will be public.
Deciding which member to make public and which to make private depends on the
nature of the member. The general rule is that any member that needs to be directly
accessed outside of the class is declared public; any member that should not be accessed
directly by the user should be declared private. For example, the user should be able to
set the time and print the time. Therefore, the members that set the time and print the
time should be declared public.
Similarly, the members to increment the time and compare the time for equality should be
declared public. On the other hand, to prevent the direct manipulation of the member
variables hr, min, and sec, we will declare them private. Furthermore, note that if the
user has direct access to the member variables, member functions such as setTime are not
needed. The second part of this chapter (beginning with the section ‘‘Information Hiding’’)
explains why some members need to be public and others should be private.
The following statements define the class clockType:
class clockType
{
public:
void setTime(int, int, int);
void getTime(int&, int&, int&) const;
void printTime() const;
void incrementSeconds();
void incrementMinutes();
void incrementHours();
bool equalTime(const clockType&) const;
private:
int hr;
int min;
int sec;
};
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

653

In this definition:
•

•

•

•

•

The class clockType has seven member functions: setTime,
getTime, printTime, incrementSeconds, incrementMinutes,
incrementHours, and equalTime. It has three member variables: hr,
min, and sec.
The three member variables—hr, min, and sec—are private to the
class and cannot be accessed outside of the class. (Example 10-1 illustrates
this concept.)
The seven member functions—setTime, getTime, printTime,
incrementSeconds, incrementMinutes, incrementHours, and
equalTime—are public and can be directly accessed outside the class.
They can also directly access the member variables (hr, min, and sec).
In other words, when we write the definitions of these functions, we do
not pass these member variables as parameters to the member functions.
In the function equalTime, the formal parameter is a constant
reference parameter. That is, in a call to the function equalTime,
the formal parameter receives the address of the actual parameter, but
the formal parameter cannot modify the value of the actual parameter.
You could have declared the formal parameter as a value parameter,
but that would require the formal parameter to copy the value of the
actual parameter, which could result in poor performance. (See the
section ‘‘Reference Parameters and Class Objects (Variables)’’ in this
chapter for an explanation.)
The word const at the end of the member functions getTime,
printTime, and equalTime specifies that these functions cannot
modify the member variables of a variable of type clockType.
The private and public members can appear in any order. If you want, you
can declare the private members first and then declare the public ones. The
section ‘‘Order of public and private Members of a Class’’ in this chapter
discusses this issue.

In the definition of the class clockType, all member variables are private
and all member functions are public. However, a member function can also be
private. For example, if a member function is used only to implement other
member functions of the class and the user does not need to access this
function, you make it private. Similarly, a member variable of a class can also
be public.

Note that we have not yet written the definitions of the member functions of the class.
You will learn how to write them shortly.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

654 |

Chapter 10: Classes and Data Abstraction

The function setTime sets the three member variables—hr, min, and sec—to a given
value. The given values are passed as parameters to the function setTime. The function
printTime prints the time, that is, the values of hr, min, and sec. The function
incrementSeconds increments the time by one second, the function incrementMinutes increments the time by one minute, the function incrementHours increments
the time by one hour, and the function equalTime compares two times for equality.
Note that the function equalTime has only one parameter, although you need two
things to make a comparison. We will explain this point with the help of an example in
the section ‘‘Implementation of Member Functions,’’ later in this chapter.

Unified Modeling Language Class Diagrams
A class and its members can be described graphically using a notation known as the
Unified Modeling Language (UML) notation. For example, Figure 10-1 shows the
UML class diagram of the class clockType.

clockType
-hr: int
-min: int
-sec: int
+setTime(int, int, int): void
+getTime(int&, int&, int&) const: void
+printTime() const: void
+incrementSeconds(): int
+incrementMinutes(): int
+incrementHours(): int
+equalTime(const clockType&) const: bool

FIGURE 10-1

UML class diagram of the class clockType

The top box contains the name of the class. The middle box contains the member variables
and their data types. The last box contains the member function name, parameter list, and the
return type of the function. A + (plus) sign in front of a member name indicates that this
member is a public member; a - (minus) sign indicates that this is a private member. The
symbol # before the member name indicates that the member is a protected member.

Variable (Object) Declaration
Once a class is defined, you can declare variables of that type. In C++ terminology, a class
variable is called a class object or class instance. To help you become familiar with this
terminology, from now on we will use the term class object, or simply object, for a class
variable.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

655

The syntax for declaring a class object is the same as that for declaring any other variable.
The following statements declare two objects of type clockType:
clockType myClock;
clockType yourClock;

Each object has 10 members: seven member functions and three member variables. Each
object has separate memory allocated for hr, min, and sec.
In actuality, memory is allocated only for the member variables of each class object. The
C++ compiler generates only one physical copy of a member function of a class, and each
class object executes the same copy of the member function. Therefore, whenever we
draw the figure of a class object, we will show only the member variables. As an example,
Figure 10-2 shows the objects myClock and yourClock with values in their member
variables.

myClock

FIGURE 10-2

hr

8

min
sec

yourClock

hr

12

12

min

35

30

sec

45

Objects myClock and yourClock

Accessing Class Members
Once an object of a class is declared, it can access the members of the class. The general
syntax for an object to access a member of a class is:
classObjectName.memberName

The class members that a class object can access depend on where the object is declared.
•

If the object is declared in the definition of a member function of the
class, then the object can access both the public and private members.
(We will elaborate on this when we write the definition of the member
function equalTime of the class clockType in the section ‘‘Implementation of Member Functions,’’ later in this chapter.)
• If the object is declared elsewhere (for example, in a user’s program),
then the object can access only the public members of the class.
Recall that in C++, the dot, . (period), is an operator called the member access operator.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

656 |

Chapter 10: Classes and Data Abstraction

Example 10-1 illustrates how to access the members of a class.
EXAMPLE 10-1
Suppose we have the following declaration (say, in a user’s program):
clockType myClock;
clockType yourClock;

Consider the following statements:
myClock.setTime(5, 2, 30);
myClock.printTime();
yourClock.setTime(x, y, z);

//assume x, y, and z are
//variables of type int
if (myClock.equalTime(yourClock))
.
.
.

These statements are legal; that is, they are syntactically correct.
In the first statement, myClock.setTime(5, 2, 30);, the member function
setTime is executed. The values 5, 2, and 30 are passed as parameters to the
function setTime, and the function uses these values to set the values of the three
member variables hr, min, and sec of myClock to 5, 2, and 30, respectively.
Similarly, the second statement executes the member function printTime and
outputs the contents of the three member variables of myClock. In the third
statement, the values of the variables x, y, and z are used to set the values of the
three member variables of yourClock.
In the fourth statement, the member function equalTime executes and compares
the three member variables of myClock to the corresponding member variables of
yourClock. Because in this statement equalTime is a member of the object
myClock, it has direct access to the three member variables of myClock. So it
needs one more object, which in this case is yourClock, to compare. In essence,
equalTime needs two objects to compare. The object to which it is dotted, myClock,
is one and the argument, yourClock, is the other. This explains why the function
equalTime has only one parameter.
The objects myClock and yourClock can access only public members of the class
clockType. Thus, the following statements are illegal because hr and min are declared
as private members of the class clockType and, therefore, cannot be accessed by the
objects myClock and yourClock:
myClock.hr = 10;
myClock.min = yourClock.min;

//illegal
//illegal

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

657

Built-in Operations on Classes
Most of C++’s built-in operations do not apply to classes. You cannot use arithmetic
operators to perform arithmetic operations on class objects (unless they are overloaded;
see Chapter 13). For example, you cannot use the operator + to add two class objects
of, say, type clockType. Also, you cannot use relational operators to compare two
class objects for equality (unless they are overloaded; see Chapter 13).
The two built-in operations that are valid for class objects are member access (.) and
assignment (=). You have seen how to access an individual member of a class by using the
name of the class object, then a dot, and then the member name. (For example, if
myClock is a clockType object, in the statement myClock.incrementSeconds();,
myClock accesses the member incrementSeconds.)
We now show how an assignment statement works with the help of an example.

Assignment Operator and Classes
Suppose that myClock and yourClock are clockType objects, as defined previously.
Furthermore, suppose that the values of myClock and yourClock are as shown in
Figure 10-3(a).

myClock

yourClock

myClock

yourClock

hr

2

hr

14

hr

14

hr

14

min

26

min

39

min

39

min

39

sec

47

sec

28

sec

28

sec

28

(a) myClock and yourClock before
executing myClock = yourClock;

FIGURE 10-3

(b) myClock and yourClock after
executing myClock = yourClock;

myClock and yourClock before and after executing the statement myClock =
yourClock;

The statement:
myClock = yourClock;

//Line 1

copies the value of yourClock into myClock. That is,
•
•
•

the value of yourClock.hr is copied into myClock.hr,
the value of yourClock.min is copied into myClock.min, and
the value of yourClock.sec is copied into myClock.sec.

In other words, the values of the three member variables of yourClock are copied into
the corresponding member variables of myClock. Therefore, an assignment statement

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

658 |

Chapter 10: Classes and Data Abstraction

performs a member-wise copy. After the statement in Line 1 executes, the values of
myClock and yourClock are as shown in Figure 10-3(b).

Class Scope
A class object can be either automatic (that is, created each time the control reaches
its declaration and destroyed when the control exits the surrounding block) or static
(that is, created once, when the control reaches its declaration, and destroyed when the
program terminates). Also, you can declare an array of class objects. A class object
has the same scope as other variables. A member of a class has the same scope as a
member of a struct. That is, a member of a class is local to the class. You access
a class member outside of the class by using the class object name and the
member access operator (.).

Functions and Classes
The following rules describe the relationship between functions and classes:
•

Class objects can be passed as parameters to functions and returned as
function values.
• As parameters to functions, class objects can be passed either by value or
by reference.
• If a class object is passed by value, the contents of the member variables of
the actual parameter are copied into the corresponding member variables
of the formal parameter.

Reference Parameters and Class Objects (Variables)
Recall that when a variable is passed by value, the formal parameter copies the value of
the actual parameter. That is, memory space to copy the value of the actual parameter is
allocated for the formal parameter. As a parameter, a class object can be passed by value.
Suppose that a class has several member variables requiring a large amount of memory to store
data, and you need to pass a variable by value. The corresponding formal parameter then
receives a copy of the data of the variable. That is, the compiler must allocate memory for the
formal parameter, so as to copy the value of the member variables of the actual parameter.
This operation might require, in addition to a large amount of storage space, a considerable
amount of computer time to copy the value of the actual parameter into the formal parameter.
On the other hand, if a variable is passed by reference, the formal parameter receives only the
address of the actual parameter. Therefore, an efficient way to pass a variable as a parameter is
by reference. If a variable is passed by reference, then when the formal parameter changes, the
actual parameter also changes. Sometimes, however, you do not want the function to be able
to change the values of the member variables. In C++, you can pass a variable by reference
and still prevent the function from changing its value by using the keyword const in the
formal parameter declaration. As an example, consider the following function definition:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

659

void testTime(const clockType& otherClock)
{
clockType dClock;
.
.
.
}

The function testTime contains a reference parameter, otherClock. The parameter
otherClock is declared using the keyword const. Thus, in a call to the function
testTime, the formal parameter otherClock receives the address of the actual parameter, but otherClock cannot modify the contents of the actual parameter. For example,
after the following statement executes, the value of myClock will not be altered:
testTime(myClock);

In fact, if the function testTime attempts to modify otherClock, the compiler will
generate syntax errors.
Generally, if you want to declare a class object as a value parameter, you declare it as a
reference parameter using the keyword const, as described previously.
Recall that if a formal parameter is a value parameter, within the function definition,
you can change the value of the formal parameter. That is, you can use an assignment
statement to change the value of the formal parameter (which, of course, would have
no effect on the actual parameter). However, if a formal parameter is a constant
reference parameter, you cannot use an assignment statement to change its value
within the function, nor can you use any other function to change its value. Therefore,
within the definition of the function testTime, you cannot alter the value of
otherClock. For example, the following would be illegal in the definition of the
function testTime:
otherClock.setTime(5, 34, 56); //illegal
otherClock = dClock;
//illegal

Implementation of Member Functions
When we defined the class clockType, we included only the function prototype
for the member functions. For these functions to work properly, we must write the
related algorithms. One way to implement these functions is to provide the function
definition rather than the function prototype in the class itself. Unfortunately, the
class definition would then be very long and difficult to comprehend. Another reason
for providing function prototypes instead of function definitions relates to information hiding; that is, we want to hide the details of the operations on the data. We
will discuss this issue later in this chapter, in the section ‘‘Information Hiding.’’

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

660 |

Chapter 10: Classes and Data Abstraction

Next, let us write the definitions of the member functions of the class clockType.
That is, we will write the definitions of the functions setTime, getTime, printTime,
incrementSeconds, equalTime, and so on. Because the identifiers setTime,
printTime, and so forth are local to the class, we cannot reference them (directly)
outside of the class. In order to reference these identifiers, we use the scope resolution
operator, :: (double colon). In the function definition’s heading, the name of
the function is the name of the class, followed by the scope resolution operator,
followed by the function name. For example, the definition of the function setTime
is as follows:
void clockType::setTime(int hours, int minutes, int seconds)
{
if (0 <= hours && hours < 24)
hr = hours;
else
hr = 0;
if (0 <= minutes && minutes < 60)
min = minutes;
else
min = 0;
if (0 <= seconds && seconds < 60)
sec = seconds;
else
sec = 0;
}

Note that the definition of the function setTime checks for the valid values of hours,
minutes, and seconds. If these values are out of range, the member variables hr, min,
and sec are initialized to 0. Let us now explain how the member function setTime
works when accessed by an object of type clockType.
The member function setTime is a void function and has three parameters.
Therefore:
•
•

A call to this function is a stand-alone statement.
We must use three parameters in a call to this function.

Furthermore, recall that because setTime is a member of the class clockType, it can
directly access the member variables hr, min, and sec, as shown in the definition of
setTime.
Suppose that myClock is an object of type clockType (as declared previously). The
object myClock has three member variables, as shown in Figure 10-4(a).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

FIGURE 10-4

myClock

myClock

hr

hr

3

min

min

48

sec

sec

52

(a) myClock before executing

(b) myClock after executing

myClock.setTime(3, 48, 52);

myClock.setTime(3, 48, 52);

|

661

myClock before and after executing the statement myClock.setTime(3, 48, 52);

Consider the following statement:
myClock.setTime(3, 48, 52);

Now the function setTime is called with parameters 3, 48, and 52. So the values of the
formal parameters hours, minutes, and seconds of the function setTime are 3, 48, and
52, respectively. Next, in the statement myClock.setTime(3, 48, 52);, setTime is
accessed by the object myClock. Therefore, the three variables—hr, min, and
sec—referred to in the body of the function setTime are the three member variables of
myClock. When the body of the function setTime executes, the value of hours is copied
into myClock.hr, the value of minutes is copied into myClock.min, and the value of
seconds is copied into myClock.sec. In essence, the values, 3, 48, and 52, which are
passed as parameters in the preceding statement, are assigned to the three member variables
of myClock by the function setTime (see the body of the function setTime). After the
previous statement executes, the object myClock is as shown in Figure 10-4(b).
Next, let us give the definitions of the other member functions of the class clockType.
The definitions of these functions are simple and easy to follow:
void clockType::getTime(int& hours, int& minutes,
int& seconds) const
{
hours = hr;
minutes = min;
seconds = sec;
}
void clockType::printTime() const
{
if (hr < 10)
cout << "0";
cout << hr << ":";
if (min < 10)
cout << "0";
cout << min << ":";

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

662 |

Chapter 10: Classes and Data Abstraction

if (sec < 10)
cout << "0";
cout << sec;
}
void clockType::incrementHours()
{
hr++;
if (hr > 23)
hr = 0;
}
void clockType::incrementMinutes()
{
min++;
if (min > 59)
{
min = 0;
incrementHours(); //increment hours
}
}
void clockType::incrementSeconds()
{
sec++;
if (sec > 59)
{
sec = 0;
incrementMinutes(); //increment minutes
}
}

From the definitions of the functions incrementMinutes and incrementSeconds,
it is clear that a member function of a class can call other member functions of the
class.
The function equalTime has the following definition:
bool clockType::equalTime(const clockType& otherClock) const
{
return (hr == otherClock.hr
&& min == otherClock.min
&& sec == otherClock.sec);
}

Let us see how the member function equalTime works.
Suppose that myClock and yourClock are objects of type clockType, as declared
previously. Further suppose that we have myClock and yourClock, as shown in
Figure 10-5.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

myClock

FIGURE 10-5

hr

yourClock

14

hr

14

min

8

min

25

sec

25

sec

54

|

663

Objects myClock and yourClock

Consider the following statement:
if (myClock.equalTime(yourClock))
.
.
.

In the expression:
myClock.equalTime(yourClock)

the object myClock accesses the member function equalTime. Because otherClock
is a reference parameter, the address of the actual parameter yourClock is passed to the
formal parameter otherClock, as shown in Figure 10-6.

myClock

hr

14

min

8

sec

25

yourClock
equalTime

hr

14

min

25

sec

54

otherClock

FIGURE 10-6

Object myClock and parameter otherClock

The member variables hr, min, and sec of otherClock have the values 14, 25, and
54, respectively. In other words, when the body of the function equalTime executes,
the value of otherClock.hr is 14, the value of otherClock.min is 25, and the value
of otherClock.sec is 54. The function equalTime is a member of myClock. When
the function equalTime executes, the variables hr, min, and sec in the body of the
function equalTime are the member variables of the object myClock. Therefore, the
member hr of myClock is compared with otherClock.hr, the member min of
myClock is compared with otherClock.min, and the member sec of myClock is
compared with otherClock.sec.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

664 |

Chapter 10: Classes and Data Abstraction

Once again, from the definition of the function equalTime, it is clear why it has only
one parameter.
Let us again take a look at the definition of the function equalTime. Notice that within
the definition of this function, the object otherClock accesses the member variables hr,
min, and sec. However, these member variables are private. So is there any violation?
The answer is no. The function equalTime is a member of the class clockType, and
hr, min, and sec are the member variables. Moreover, otherClock is an object of type
clockType. Therefore, the object otherClock can access its private member variables within the definition of the function equalTime.
The same is true for any member function of a class. In general, when you write the
definition of a member function, say, dummyFunction, of a class, say, dummyClass,
and the function uses an object, dummyObject of the class dummyClass, then within
the definition of dummyFunction, the object dummyObject can access its private
member variables (in fact, any private member of the class).
Once a class is properly defined and implemented, it can be used in a program. A program
or software that uses and manipulates the objects of a class is called a client of that class.
When you declare objects of the class clockType, every object has its own copy of
the member variables hr, min, and sec. In object-oriented terminology, variables such
as hr, min, and sec are called instance variables of the class because every object
instance has its own copy of the data.

Accessor and Mutator Functions
Let us look at the member functions of the class clockType. The function setTime
sets the values of the member variables to the values specified by the user. In other
words, it alters or modifies the values of the member variables. Similarly, the functions
incrementSeconds, incrementMinutes, and incrementHours also modify the
member variables. On the other hand, functions such as getTime, printTime, and
equalTime only access the values of the member variables. They do not modify the
member variables. We can, therefore, categorize the member functions of the class
clockType into two categories: member functions that modify the member variables
and member functions that only access, but do not modify, the member variables.
This is typically true for any class. That is, every class has member functions that only
access but do not modify the member variables, called accessor functions, and member
functions that modify the member variables, called mutator functions.
Accessor function: A member function of a class that only accesses (that is, does not
modify) the value(s) of the member variable(s).
Mutator function: A member function of a class that modifies the value(s) of the member

variable(s).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

665

Because an accessor function only accesses the values of the member variables, as a
safeguard, we typically include the reserved word const at the end of the headings of
these functions. Moreover, a constant member function of a class cannot modify the
member variables of that class. For example, see the headings of the member functions
getTime, printTime, and equalTime of the class clockType.
A member function of a class is called a constant function if its heading contains the reserved
word const at the end. For example, the member functions getTime, printTime, and
equalTime of the class clockType are constant functions. A constant member function
of a class cannot modify the member variables of that class, so these are accessor functions.
One thing that should be remembered about constant member functions is that a constant
member function of a class can only call other constant member functions of that class.
Therefore, you should be careful when you make a member function constant.
Example 10-2 shows how to use the class clockType in a program. Note that we
have combined the definition of the class, the definition of the member functions, and the
main function to create a complete program. Later in this chapter, you will learn how to
separate the definition of the class clockType, the definitions of the member functions, and the main program, using three files.
EXAMPLE 10-2
//The program listing of the program that defines
//and uses the class clockType
#include <iostream>
using namespace std;
class clockType
{
public:
void setTime(int, int, int);
void getTime(int&, int&, int&) const;
void printTime() const;
void incrementSeconds();
void incrementMinutes();
void incrementHours();
bool equalTime(const clockType&) const;
private:
int hr;
int min;
int sec;
};
int main()
{
clockType myClock;
clockType yourClock;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

666 |

Chapter 10: Classes and Data Abstraction

int hours;
int minutes;
int seconds;
//Set the time of myClock
myClock.setTime(5, 4, 30);

//Line 1

cout << "Line 2: myClock: ";
myClock.printTime(); //print the time of myClock
cout << endl;

//Line 2
Line 3
//Line 4

cout << "Line 5: yourClock: ";
//Line 5
yourClock.printTime(); //print the time of yourClock Line 6
cout << endl;
//Line 7
//Set the time of yourClock
yourClock.setTime(5, 45, 16);

//Line 8

cout << "Line 9: After setting, yourClock: ";
//Line 9
yourClock.printTime(); //print the time of yourClock Line 10
cout << endl;
//Line 11
//Compare myClock and yourClock
if (myClock.equalTime(yourClock))
//Line
cout << "Line 13: Both times are equal."
<< endl;
//Line
else
//Line
cout << "Line 15: The two times are not equal."
<< endl;
//Line
cout << "Line 16: Enter the hours, minutes, and "
<< "seconds: ";
cin >> hours >> minutes >> seconds;
cout << endl;

12
13
14
15

//Line 16
//Line 17
//Line 18

//Set the time of myClock using the value of the
//variables hours, minutes, and seconds
myClock.setTime(hours, minutes, seconds);
//Line 19
cout << "Line 20: New myClock: ";
//Line 20
myClock.printTime();
//print the time of myClock
Line 21
cout << endl;
//Line 22
//Increment the time of myClock by one second
myClock.incrementSeconds();

//Line 23

cout << "Line 24: After incrementing myClock by "
<< "one second, myClock: ";
//Line 24
myClock.printTime();
//print the time of myClock
Line 25
cout << endl;
//Line 26

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

667

//Retrieve the hours, minutes, and seconds of the
//object myClock
myClock.getTime(hours, minutes, seconds);
//Line 27
//Output the value of
cout << "Line 28: hours =
<< ", minutes = " <<
<< ", seconds = " <<

hours, minutes, and seconds
" << hours
minutes
seconds << endl;
//Line 28

return 0;
}//end main
void clockType::setTime(int hours, int minutes, int seconds)
{
if (0 <= hours && hours < 24)
hr = hours;
else
hr = 0;
if (0 <= minutes && minutes < 60)
min = minutes;
else
min = 0;
if (0 <= seconds && seconds < 60)
sec = seconds;
else
sec = 0;
}
//Place the definitions of the remaining functions, getTime,
//incrementHours, incrementMinutes, incrementSeconds, printTime,
//and equalTime, of the class clockType, as described
//previously here.

Sample Run: In this sample run, the user input is shaded.
Line
Line
Line
Line
Line

2: myClock: 05:04:30
5: yourClock: 0-858993460:0-858993460:0-858993460
9: After setting, yourClock: 05:45:16
15: The two times are not equal.
16: Enter the hours, minutes, and seconds: 5 23 59

Line 20: New myClock: 05:23:59
Line 24: After incrementing myClock by one second, myClock: 05:24:00
Line 28: hours = 5, minutes = 24, seconds = 0

The value of yourClock, as printed in the second line of the output (Line 5), is
machine dependent you might get different values.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

668 |

Chapter 10: Classes and Data Abstraction

Order of public and private Members of a Class
C++ has no fixed order in which you declare public and private members; you can
declare them in any order. The only thing you need to remember is that, by default, all
members of a class are private. You must use the member access specifier public to
make a member available for public access. Member access remains as set for all declared
members until explicitly reset, so public sets all members public until explicitly
changed to private. Therefore, if you decide to declare the private members after
the public members (as is done in the case of clockType), you must use the member
access specifier private to begin the declaration of the private members.
We can declare the class clockType in one of three ways, as shown in Examples 10-3
through 10-5.
EXAMPLE 10-3
This declaration is the same as before. For the sake of completeness, we include the class
definition:
class clockType
{
public:
void setTime(int, int, int);
void getTime(int&, int&, int&) const;
void printTime() const;
void incrementSeconds();
void incrementMinutes();
void incrementHours();
bool equalTime(const clockType&) const;
private:
int hr;
int min;
int sec;
};

EXAMPLE 10-4
class clockType
{
private:
int hr;
int min;
int sec;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

public:
void
void
void
void
void
void
bool
};

|

669

setTime(int, int, int);
getTime(int&, int&, int&) const;
printTime() const;
incrementSeconds();
incrementMinutes();
incrementHours();
equalTime(const clockType&) const;

EXAMPLE 10-5
class clockType
{
int hr;
int min;
int sec;
public:
void
void
void
void
void
void
bool
};

setTime(int, int, int);
getTime(int&, int&, int&) const;
printTime() const;
incrementSeconds();
incrementMinutes();
incrementHours();
equalTime(const clockType&) const;

In Example 10-5, because the identifiers hr, min, and sec do not follow any member
access specifier, they are by default private.
It is a common practice to list all of the public members first and then the private
members. This way, you can focus your attention on the public members.

Constructors
In the program in Example 10-2, when we printed the value of yourClock without
calling the function setTime, the output was some strange numbers (see the output of
Line 5 in the sample run). This is due to the fact that C++ does not automatically initialize
the variables. Because the private members of a class cannot be accessed outside of the
class (in our case, the member variables), if the user forgets to initialize these variables by
calling the function setTime, the program will produce erroneous results.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

670 |

Chapter 10: Classes and Data Abstraction

To guarantee that the member variables of a class are initialized, you use constructors.
There are two types of constructors: with parameters and without parameters. The
constructor without parameters is called the default constructor.
Constructors have the following properties:
•
•
•
•

•

•

The name of a constructor is the same as the name of the class.
A constructor is a function and it has no type. That is, it is neither a
value-returning function nor a void function.
A class can have more than one constructor. However, all constructors of
a class have the same name.
If a class has more than one constructor, the constructors must have
different formal parameter lists. That is, either they have a different
number of formal parameters or, if the number of formal parameters is
the same, then the data type of the formal parameters, in the order you
list, must differ in at least one position. In other words, like function
overloading, a constructor’s name is overloaded.
Constructors execute automatically when a class object is declared and
enters its scope. Because they have no types, they cannot be called like
other functions.
Which constructor executes depends on the types of values passed to the
class object when the class object is declared.

Let us extend the definition of the class clockType by including two constructors:
class clockType
{
public:
void setTime(int, int, int);
void getTime(int&, int&, int&) const;
void printTime() const;
void incrementSeconds();
void incrementMinutes();
void incrementHours();
bool equalTime(const clockType&) const;
clockType(int, int, int); //constructor with parameters
clockType(); //default constructor
private:
int hr;
int min;
int sec;
};

This definition of the class clockType includes two constructors: one with three
parameters and one without any parameters. Let us now write the definitions of these
constructors:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

671

clockType::clockType(int hours, int minutes, int seconds)
{
if (0 <= hours && hours < 24)
hr = hours;
else
hr = 0;
if (0 <= minutes && minutes < 60)
min = minutes;
else
min = 0;
if (0 <= seconds && seconds < 60)
sec = seconds;
else
sec = 0;
}
clockType::clockType()
{
hr = 0;
min = 0;
sec = 0;
}

//default constructor

From the definitions of these constructors, it follows that the default constructor sets the
three member variables—hr, min, and sec—to 0. Also, the constructor with parameters
sets the member variables to whatever values are assigned to the formal parameters.
Moreover, we can write the definition of the constructor with parameters by calling
the function setTime, as follows:
clockType::clockType(int hours, int minutes, int seconds)
{
setTime(hours, minutes, seconds);
}

Invoking a Constructor
Recall that when a class object is declared, a constructor is automatically executed.
Because a class might have more than one constructor, including the default constructor,
next we discuss how to invoke a specific constructor.

Invoking the Default Constructor
Suppose that a class contains the default constructor. The syntax to invoke the default
constructor is:
className classObjectName;

For example, the statement:
clockType yourClock;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

672 |

Chapter 10: Classes and Data Abstraction

declares yourClock to be an object of type clockType. In this case, the default
constructor executes because no arguments are included in the declaration and the
member variables of yourClock are initialized to 0.
If you declare an object and want the default constructor to be executed, the empty
parentheses after the object name are not required in the object declaration statement. In
fact, if you accidentally include the empty parentheses, the compiler generates a syntax
error message. For example, the following statement to declare the object yourClock
is illegal:

clockType yourClock();

//illegal object declaration

Invoking a Constructor with Parameters
Suppose a class contains constructors with parameters. The syntax to invoke a constructor
with a parameter is:
className classObjectName(argument1, argument2, ...);

in which argument1, argument2, and so on are either a variable or an expression.
Note the following:
•

The number of arguments and their type should match the formal
parameters (in the order given) of one of the constructors.
• If the type of the arguments does not match the formal parameters of any
constructor (in the order given), C++ uses type conversion and looks for
the best match. For example, an integer value might be converted to a
floating-point value with a zero decimal part. Any ambiguity will result
in a compile-time error.
Consider the statement:
clockType myClock(5, 12, 40);

This statement declares an object myClock of type clockType. Here, we are passing
three values of type int, which matches the type of the formal parameters of the
constructor with a parameter. Therefore, the constructor with parameters of the class
clockType executes, and the three member variables of the object myClock are set to
5, 12, and 40.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

673

Example 10-6 further illustrates how constructors are executed.
EXAMPLE 10-6
Consider the following class definition:
class inventory
{
public:
inventory();
inventory(string);
inventory(string, int, double);
inventory(string, int, double, int);

//Line
//Line
//Line
//Line

1
2
3
4

//Add additional functions
private:
string name;
int itemNum;
double price;
int unitsInStock;
};

This class has four constructors and four member variables. Suppose that the definitions of
the constructors are as follows:
inventory::inventory() //default constructor
{
name = "";
itemNum = -1;
price = 0.0;
unitsInStock = 0;
}
inventory::inventory(string n)
{
name = n;
itemNum = -1;
price = 0.0;
unitsInStock = 0;
}
inventory::inventory(string n, int iNum, double cost)
{
name = n;
itemNum = iNum;
price = cost;
unitsInStock = 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

674 |

Chapter 10: Classes and Data Abstraction

inventory::inventory(string n, int iNum, double cost, int inStock)
{
name = n;
itemNum = iNum;
price = cost;
unitsInStock = inStock;
}

Consider the following declarations:
inventory
inventory
inventory
inventory

item1;
item2("Dryer");
item3("Washer", 2345, 278.95);
item4("Toaster", 8231, 34.49, 200);

For item1, the default constructor in Line 1 executes because no value is passed to this
variable. For item2, the constructor in Line 2 executes because only one parameter,
which is of type string, is passed, and it matches with the constructor in Line 2. For
item3, the constructor in Line 3 executes because three parameters are passed to item3,
and they match with the constructor in Line 3. Similarly, for item4, the constructor in
Line 4 executes (see Figure 10-7).

item1

item2
name

name

itemNum

-1

itemNum

-1

price

0.0

price

0.0

unitsInStock

0

unitsInStock

0

item4

item3
name
itemNum
price
unitsInStock

FIGURE 10-7

Dryer

Washer
2345
278.95
0

name

Toaster

itemNum

8231

price

34.49

unitsInStock

200

Effect of constructors on objects

If the values passed to a class object do not match the parameters of any constructor and
if no type conversion is possible, a compile-time error will be generated.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

675

Constructors and Default Parameters
A constructor can also have default parameters. In such cases, the rules for declaring
formal parameters are the same as those for declaring default formal parameters in a
function. Moreover, actual parameters to a constructor with default parameters are
passed according to the rules for functions with default parameters. (Chapter 6 discusses
functions with default parameters.) Using the rules for defining default parameters, in the
definition of the class clockType, you can replace both constructors
clockType(int, int, int);
clockType();

using the following statement. (Recall that in the function prototype, the name of a
formal parameter is optional.)
clockType clockType(int = 0, int = 0, int = 0);

//Line 1

In the implementation file, the definition of this constructor is the same as the definition
of the constructor with parameters.
If you replace the constructors of the class clockType with the constructor in Line 1
(the constructor with the default parameters), then you can declare clockType objects
with zero, one, two, or three arguments, as follows:
clockType
clockType
clockType
clockType

clock1;
clock2(5);
clock3(12, 30);
clock4(7, 34, 18);

//Line
//Line
//Line
//Line

2
3
4
5

The member variables of clock1 are initialized to 0. The member variable hr of clock2
is initialized to 5, and the member variables min and sec of clock2 are initialized to 0.
The member variable hr of clock3 is initialized to 12, the member variable min of
clock3 is initialized to 30, and the member variable sec of clock3 is initialized to 0.
The member variable hr of clock4 is initialized to 7, the member variable min of
clock4 is initialized to 34, and the member variable sec of clock4 is initialized to 18.
Using these conventions, we can say that a constructor that has no parameters, or has all
default parameters, is called the default constructor.

Classes and Constructors: A Precaution
As discussed in the preceding section, constructors provide guaranteed initialization of the
object’s member variables. Typically, the default constructor is used to initialize the member
variables to some default values, and this constructor has no parameters. A constructor with
parameters is used to initialize the member variables to some specific values.
We have seen that if a class has no constructor(s), then the object created is uninitialized
because C++ does not automatically initialize variables when they are declared. In reality, if
a class has no constructor(s), then C++ automatically provides the default constructor.
However, this default constructor does not initialize the object being declared.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

676 |

Chapter 10: Classes and Data Abstraction

The important things to remember about classes and constructors are the following:
•

If a class has no constructor(s), C++ automatically provides the default
constructor. However, the object declared is still uninitialized.
• On the other hand, suppose a class, say, dummyClass, includes constructor(s) with parameter(s) and does not include the default constructor. In
this case, C++ does not provide the default constructor for the class
dummyClass. Therefore, when an object of the class dummyClass is
declared, we must include the appropriate arguments in its declaration.
The following code further explains this. Consider the definition of the following class:
class dummyClass
{
public:
void print() const;
dummyClass(int dX, int dY);
private:
int x;
int y;
};

The class dummyClass has a constructor with parameters. It does not have a default
constructor written for it and C++ will not provide one automatically because at least
one constructor has been written for it. Given this definition of the class dummyClass,
the following object declaration is legal:
dummyClass myObject(10, 25);

//object declaration is legal

However, because the class dummyClass does not contain the default constructor, the
following declaration is incorrect and would generate a syntax error:
dummyClass dummyObject;

//incorrect object declaration

Therefore, to avoid such pitfalls, if a class has constructor(s), the class should also include
the default constructor.

In-line initialization of Data Members and the Default Constructor
C++11 standard allows the initialization of data members when they are declared in a
class. For example, the definition of the class clockType can also be written as follows:
class clockType
{
public:
void setTime(int, int, int);
void getTime(int&, int&, int&) const;
void printTime() const;
void incrementSeconds();
void incrementMinutes();

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

677

void incrementHours();
bool equalTime(const clockType&) const;
clockType(int, int, int); //constructor with parameters
private:
int hr = 0;
int min = 0;
int sec = 0;
};

In this class definition, the data members hr, min, and sec are declared as well as
initialized. This is called in-line initialization of the data members and in many situations eliminates the declaration of the default constructor. When an object of the class
clockType is declared without parameters, then the object is initialized using the
in-line initialized values. If an object is declared with parameters, then the default
values are overridden by the constructor with the parameters. For example, consider the
following statements:
clockType myTime;
clockType yourTime(3, 40, 18);

The hr, min, and sec of myTime are each set to 0, while the hr, min, and sec of
yourTime are set to 3, 40, and 18, respectively.
At the time of the writing of this book, the compiler that we used to create and test code
had not implemented this feature of C++11. Therefore, we will continue to include the
default constructor in the definition of a class.

Arrays of Class Objects (Variables) and Constructors
If a class has constructors and you declare an array of that class’s objects, the class should
have the default constructor. The default constructor is typically used to initialize each
(array) class object.
For example, if you declare an array of 100 class objects, then it is impractical (if not
impossible) to specify different constructors for each component. (We will further clarify
this at the end of this section.)
Suppose that you have 100 employees who are paid on an hourly basis, and you need to keep
track of their arrival and departure times. You can declare two arrays—arrivalTimeEmp
and departureTimeEmp—of 100 components each, wherein each component is an object
of type clockType.
Consider the following statement:
clockType arrivalTimeEmp[100];

//Line 1

The statement in Line 1 creates the array of objects arrivalTimeEmp[0],
arrivalTimeEmp[1], . . ., arrivalTimeEmp[99], as shown in Figure 10-8.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

678 |

Chapter 10: Classes and Data Abstraction

arrivalTimeEmp
arrivalTimeEmp[0]
arrivalTimeEmp[1]

arrivalTimeEmp[49]

arrivalTimeEmp[49]

arrivalTimeEmp[98]
arrivalTimeEmp[99]

FIGURE 10-8

hr

0

min

0

sec

0

Array arrivalTimeEmp

You can now use the functions of the class clockType to manipulate the time for
each employee. For example, the following statement sets the arrival time, that is, hr,
min, and sec, of the 50th employee to 8, 5, and 10, respectively (see Figure 10-9).
arrivalTimeEmp[49].setTime(8, 5, 10);

//Line 2

arrivalTimeEmp
arrivalTimeEmp[0]
arrivalTimeEmp[1]

arrivalTimeEmp[49]

arrivalTimeEmp[49]

arrivalTimeEmp[98]
arrivalTimeEmp[99]

FIGURE 10-9

hr

8

min

5

sec

10

Array arrivalTimeEmp after setting the time of employee 49

To output the arrival time of each employee, you can use a loop, such as the following:
for (int j = 0; j < 100; j++)
{
cout << "Employee " << (j + 1)
<< " arrival time: ";
arrivalTimeEmp[j].printTime();
cout << endl;
}

//Line 3

//Line 4

The statement in Line 4 outputs the arrival time of an employee in the form
hr:min:sec.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes

|

679

To keep track of the departure time of each employee, you can use the array
departureTimeEmp.
Similarly, you can use arrays to manage a list of names or other objects.
Before leaving our discussion of arrays of class objects, we would like to point out the
following: The beginning of this section stated that if you declare an array of class objects
and the class has constructor(s), then the class should have the default constructor. The
compiler uses the default constructor to initialize the array of objects. If the array size is
large, then it is impractical to specify a different constructor with parameters for each object.
For a small-sized array, we can manage to specify a different constructor with parameters.
For example, the following statement declares clocks to be an array of two components. The member variables of the first component are initialized to 8, 35, and 42,
respectively. The member variables of the second component are initialized to 6, 52, and
39, respectively.

clockType clocks[2] = {clockType(8, 35, 42), clockType(6, 52, 39)};
In fact, the expression clockType(8, 35, 42) creates an anonymous object of the
class clockType; initializes its member variables to 8, 35, and 42, respectively;
and then uses a member-wise copy to initialize the object clock[0].
Consider the following statement, which creates the object myClock and initializes its
member variables to 10, 45, and 38, respectively. This is how we have been creating and
initializing objects. In fact, the statement:

clockType myClock(10, 45, 38);
is equivalent to the statement:

clockType myClock = clockType(10, 45, 38);
However, the first statement is more efficient. It does not first require that an anonymous
object be created and then member-wise copied in order to initialize myClock.
The main point that we are stressing here, and that we discussed in the preceding section,
is the following: To avoid any pitfalls, if a class has constructor(s), it should also have the
default constructor.

Destructors
Like constructors, destructors are also functions. Moreover, like constructors, a destructor
does not have a type. That is, it is neither a value-returning function nor a void function.
However, a class can have only one destructor, and the destructor has no parameters. The
name of a destructor is the tilde character (~), followed by the name of the class. For
example, the name of the destructor for the class clockType is:
~clockType();

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

680 |

Chapter 10: Classes and Data Abstraction

The destructor automatically executes when the class object goes out of scope. The use of
destructors is discussed in subsequent chapters.

Data Abstraction, Classes, and Abstract
Data Types
For the car that we drive, most of us want to know how to start the car and drive it.
Most people are not concerned with the complexity of how the engine works. By
separating the design details of a car’s engine from its use, the manufacturer helps the
driver focus on how to drive the car. Our daily life has other similar examples. For
the most part, we are concerned only with how to use certain items, rather than with
how they work.
Separating the design details (that is, how the car’s engine works) from its use is
called abstraction. In other words, abstraction focuses on what the engine does and
not on how it works. Thus, abstraction is the process of separating the logical
properties from the implementation details. Driving the car is a logical property;
the construction of the engine constitutes the implementation details. We have an
abstract view of what the engine does but are not interested in the engine’s actual
implementation.
Abstraction can also be applied to data. Earlier sections of this chapter defined a data type
clockType. The data type clockType has three member variables and the following
basic operations:
1.
2.
3.
4.
5.
6.
7.

Set the time.
Return the time.
Print the time.
Increment the time by one second.
Increment the time by one minute.
Increment the time by one hour.
Compare two times to see whether they are equal.

The actual implementation of the operations, that is, the definitions of the member
functions of the class clockType, was postponed.
Data abstraction is defined as a process of separating the logical properties of the data from
its implementation. The definition of clockType and its basic operations are the logical
properties; the storing of clockType objects in the computer and the algorithms to
perform these operations are the implementation details of clockType.
Abstract data type (ADT): A data type that separates the logical properties from the

implementation details.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Data Abstraction, Classes, and Abstract Data Types |

681

Like any other data type such as int, an ADT has three things associated with it: the
name of the ADT, called the type name; the set of values belonging to the ADT, called
the domain; and the set of operations on the data. (For example, for the data type int,
the type name is int, the domain is the set of integers between -2147483648 and
2147483647 (inclusive), and the operations on int type are +, -, *, /, and %. ) Following
these conventions, we can define the clockType ADT as follows:
dataTypeName
clockType
domain
Each clockType value is a time of day in the form of hours,
minutes, and seconds.
operations
Set the time.
Return the time.
Print the time.
Increment the time by one second.
Increment the time by one minute.
Increment the time by one hour.
Compare the two times to see whether they are equal.

EXAMPLE 10-7
A list is defined as a set of values of the same type. Because all values in a list are of the
same type, a convenient way to represent and process a list is to use an array. You can
define a list as an ADT as follows:
dataTypeName
listType
domain
Every listType value is an array of, say, 1000 numbers
operations
Check to see whether the list is empty.
Check to see whether the list is full.
Search the list for a given item.
Delete an item from the list.
Insert an item in the list.
Sort the list.
Destroy the list.
Print the list.

The next obvious question is how to implement an ADT in a program. To implement an
ADT, you must represent the data and write algorithms to perform the operations.
The previous section used classes to group data and functions together. Furthermore, our
definition of a class consisted only of the specifications of the operations; functions to
implement the operations were written separately. Thus, we see that classes are a convenient
way to implement an ADT. In fact, in C++, classes were specifically designed to handle ADTs.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

682 |

Chapter 10: Classes and Data Abstraction

Next, we define the class listType to implement a list as an ADT. Typically in a list,
not only do we store the elements, but we also keep track of the number of elements in
the list. Therefore, our class listType has two member variables: one to store the
elements and another to keep track of the number of elements in the list. The following
class, listType, defines the list as an ADT.
class listType
{
public:
bool isEmptyList() const;
bool isFullList() const;
int search(int searchItem) const;
void insert(int newElement);
void remove(int removeElement);
void destroyList();
void printList() const;
listType(); //constructor
private:
int list[1000];
int length;
};

Figure 10-10 shows the UML class diagram of the class listType.

listType
-list: int
-length: int
+isEmptyList() const: bool
+isFullList() const: bool
+search(int) const: int
+insert(int): void
+remove(int): void
+destroyList(): void
+printList(): const: void
+listType()

FIGURE 10-10

UML class diagram of the class listType

A struct Versus a class
Chapter 9 defined a struct as a fixed collection of components, wherein the components can be of different types. This definition of components in a struct included only
member variables. However, a C++ struct is very similar to a C++ class. As with a

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Information Hiding |

683

class, members of a struct can also be functions, including constructors and a
destructor. The only difference between a struct and a class is that, by default, all
members of a struct are public, and all members of a class are private. You can
use the member access specifier private in a struct to make a member private.

In C, the definition of a struct is similar to the definition of a struct in C++, as given
in Chapter 9. Because C++ evolved from C, the standard C-structs are perfectly
acceptable in C++. However, the definition of a struct in C++ was expanded to
include member functions and constructors and destructors. In the future, because a
class is a syntactically separate entity, specially designed to handle an ADT, the
definition of a class may evolve in a completely different way than the definition of a
C-like struct.
Both C++ classes and structs have the same capabilities. However, most programmers
restrict their use of structures to adhere to their C-like structure form and thus do not use
them to include member functions. In other words, if all of the member variables of a
class are public and the class has no member functions, you typically use a struct to
group these member variables. This is, in fact, how it is done in this book.

Information Hiding
The previous section defined the class clockType to implement the time in a
program. We then wrote a program that used the class clockType. In fact, we
combined the class clockType with the function definitions to implement the
operations and the function main so as to complete the program. That is, the specification and implementation details of the class clockType were directly incorporated
into the program.
Is it a good practice to include the specification and implementation details of a class in
the program? Definitely not. There are several reasons for not doing so. Suppose the
definition of the class and the definitions of the member functions are directly included in
the user’s program. The user then has direct access to the definition of the class and the
definitions of the member functions. Therefore, the user can modify the operations in
any way the user pleases. The user can also modify the member variables of an object in
any way the user pleases. Thus, in this sense, the private member variables of an object
are no longer private to the object.
If several programmers use the same object in a project and if they have direct access to
the internal parts of the object, there is no guarantee that every programmer will use the
same object in exactly the same way. Thus, we must hide the implementation details. The
user should know only what the object does, not how it does it. Hiding the implementation details frees the user from having to fit this extra piece of code in the program. Also,
by hiding the details, we can ensure that an object will be used in exactly the same way
throughout the project. Furthermore, once an object has been written, debugged, and
tested properly, it becomes (and remains) error-free.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

684 |

Chapter 10: Classes and Data Abstraction

This section discusses how to hide the implementation details of an object. For illustration
purposes, we will use the class clockType.
To implement clockType in a program, the user must declare objects of type
clockType and know which operations are allowed and what the operations do.
So, the user must have access to the specification details. Because the user is not
concerned with the implementation details, we must put those details in a separate file
called an implementation file. Also, because the specification details can be too long,
we must free the user from having to include them directly in the program. However, the
user must be able to look at the specification details so that he or she can correctly call the
functions, and so forth. We must, therefore, put the specification details in a separate file.
The file that contains the specification details is called the header file (or interface file).
The implementation file contains the definitions of the functions to implement the
operations of an object. This file contains, among other things (such as the preprocessor
directives), the C++ statements. Because a C++ program can have only one function,
main, the implementation file does not contain the function main. Only the user
program contains the function main. Because the implementation file does not contain
the function main, we cannot produce the executable code from this file. In fact, we
produce what is called the object code from the implementation file. The user then links
the object code produced by the implementation file with the object code of the program
that uses the class to create the final executable code.
Finally, the header file has an extension h, whereas the implementation file has an extension
cpp. Suppose that the specification details of the class clockType are in a file called
clockType. The complete name of this file should then be clockType.h. If the
implementation details of the class clockType are in a file—say, clockTypeImp—the
name of this file must be clockTypeImp.cpp.
The file clockTypeImp.cpp contains only the definitions of the functions, not
the definition of the class. Thus, to resolve the problem of an undeclared identifier
(such as the function names and variable names), we include the header file
clockType.h in the file clockTypeImp.cpp with the help of the include
statement. The following include statement is required by any program that uses
the class clockType, as well as by the implementation file that defines the
operations for the class clockType:
#include "clockType.h"

Note that the header file clockType.h is enclosed in double quotation marks, not
angular brackets. The header file clockType.h is called the user-defined header file.
Typically, all user-defined header files are enclosed in double quotation marks, whereas
the system-provided header files (such as iostream) are enclosed between angular
brackets. Also, note that the preceding include statement assumes that the header file
clockType.h is in the same directory as the .cpp file (user program).
The implementation contains the definitions of the functions, and these definitions are
hidden from the user because the user is typically provided only the object code.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Information Hiding |

685

However, the user of the class should be aware of what a particular function does and
how to use it. Therefore, in the specification file with the function prototypes, we
include comments that briefly describe the function and specify any preconditions and/
or postconditions.
Precondition: A statement specifying the condition(s) that must be true before the
function is called.
Postcondition: A statement specifying what is true after the function call is completed.

Following are the specification and implementation files for the class clockType:
//clockType.h, the specification file for the class clockType
class clockType
{
public:
void setTime(int hours, int minutes, int seconds);
//Function to set the time.
//The time is set according to the parameters.
//Postcondition: hr = hours; min = minutes;
//
sec = seconds;
//
The function checks whether the
//
values of hours, minutes, and seconds
//
are valid. If a value is invalid, the
//
default value 0 is assigned.
void getTime(int& hours, int& minutes, int& seconds) const;
//Function to return the time.
//Postcondition: hours = hr; minutes = min;
//
seconds = sec;
void printTime() const;
//Function to print the time.
//Postcondition: The time is printed in the form
//
hh:mm:ss.
void incrementSeconds();
//Function to increment the time by one second.
//Postcondition: The time is incremented by one second.
//
If the before-increment time is
//
23:59:59, the time is reset to 00:00:00.
void incrementMinutes();
//Function to increment the time by one minute.
//Postcondition: The time is incremented by one minute.
//
If the before-increment time is
//
23:59:53, the time is reset to 00:00:53.
void incrementHours();
//Function to increment the time by one hour.
//Postcondition: The time is incremented by one hour.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

686 |

Chapter 10: Classes and Data Abstraction

//
//

If the before-increment time is
23:45:53, the time is reset to 00:45:53.

bool equalTime(const clockType& otherClock) const;
//Function to compare the two times.
//Postcondition: Returns true if this time is equal to
//
otherClock; otherwise, returns false.
clockType(int hours, int minutes, int seconds);
//Constructor with parameters.
//The time is set according to the parameters.
//Postcondition: hr = hours; min = minutes;
//
sec = seconds;
//
The constructor checks whether the
//
values of hours, minutes, and seconds
//
are valid. If a value is invalid, the
//
default value 0 is assigned.
clockType();
//Default constructor
//The time is set to 00:00:00.
//Postcondition: hr = 0; min = 0; sec = 0;
private:
int hr; //variable to store the hours
int min; //variable to store the minutes
int sec; //variable to store the seconds
};
//clockTypeImp.cpp, the implementation file
#include
#include

<iostream>
"clockType.h"

using namespace std;
.
.
.
//Place the definitions of the member functions of the class
//clockType here.
.
.
.

Next, we describe the user file containing the program that uses the class clockType.
//The user program that uses the class clockType
#include
#include

<iostream>
"clockType.h"

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Executable Code

|

687

using namespace std;
.
.
.
//Place the definitions of the function main and the other
//user-defined functions here
.
.
.
To save space, we have not provided the complete details of the implementation file and
the file that contains the user program. However, you can find these files and the
specification (header) file at the Web site accompanying this book.

Executable Code
The previous section discussed how to hide the implementation details of a class. To use
an object in a program, during execution, the program must be able to access the
implementation details of the object (that is, the algorithms to implement the operations
on the object). This section discusses how a client’s program obtains access to the
implementation details of an object. For illustration purposes, we will use the class
clockType.
As explained previously, to use the class clockType, the program must include the
header file clockType.h via the include statement. For example, the following
program segment includes the header file clockType.h:
//Program testClockClass.cpp
#include "clockType.h"
.
.
.
int main()
{
.
.
.
}

The program testClockClass.cpp must include only the header file, not the implementation file. To create the executable code to run the program testClockClass.cpp,
the following steps are required:
1. We separately compile the file clockTypeImp.cpp and create the
object code file clockTypeImp.obj. The object code file contains
the machine language code, but the code is not in an executable form.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

688 |

Chapter 10: Classes and Data Abstraction

Suppose that the command cc invokes the C++ compiler or linker, or
both, on the computer’s system command line. The command:
cc -c clockTypeImp.cpp

creates the object code file clockTypeImp.obj.
2. To create the executable code for the source code file testClock
Class.cpp, we compile the source code file testClockClass.cpp,
create the object code file testClockClass.obj, and then link the files
testClockClass.obj and clockTypeImp.obj to create the executable file testClockClass.exe. The following command on the system
command line creates the executable file testClockClass.exe:
cc testClockClass.cpp clockTypeImp.obj
1.

To create the object code file for any source code file, we use the command line
option -c on the system command line. For example, to create the
object code file for the source code file, called exercise.cpp, we
use the following command on the system command line:

cc -c exercise.cpp
2.

To link more than one object code file with a source code file, we list all of the object
code files on the system command line. For example, to link A.obj and
B.obj with the source code file test.cpp, we use the command:

cc test.cpp A.obj B.obj
3.

If a source code file is modified, it must be recompiled.

4.

If modifications in one source file affect other files, the other files must be
recompiled and relinked.

5.

The user must have access to the header file and the object code file. Access to
the header file is needed to see what the objects do and how to use
them. Access to the object code file is needed so that the user can link
the program with the object code to produce an executable code. The
user does not need access to the source code file containing the
implementation details.

As stated in Chapter 1, IDEs Visual C++ 2012 Express, Visual Studio 2012, and C++
Builder put the editor, compiler, and linker all into one package. With one command,
the program is compiled and linked with the other necessary files. These systems also
manage multiple-file programs in the form of a project. Thus, a project consists of several
files, called the project files. These systems usually have a command, called build,
rebuild, or make. (Check your system’s documentation.) When the build, rebuild, or
make command is applied to a project, the system automatically compiles and links all of
the files required to create the executable code. When one or more files in the project
change, you can use these commands to recompile and relink the files.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More Examples of Classes

|

689

More Examples of Classes
In this section, we give various examples of classes and how to use them in a program.
EXAMPLE 10-8
The following statements define the class circleType to implement the basic properties of a circle:
class circleType
{
public:
void setRadius(double r);
//Function to set the radius.
//Postcondition: if (r >= 0) radius = r;
//
otherwise radius = 0;
double getRadius();
//Function to return the radius.
//Postcondition: The value of radius is returned.
double area();
//Function to return the area of a circle.
//Postcondition: Area is calculated and returned.
double circumference();
//Function to return the circumference of a circle.
//Postcondition: Circumference is calculated and returned.
circleType(double r = 0);
//Constructor with a default parameter.
//Radius is set according to the parameter.
//The default value of the radius is 0.0;
//Postcondition: radius = r;
private:
double radius;
};

The definitions of the member functions are as follows:
void circleType::setRadius(double r)
{
if (r >= 0)
radius = r;
else
radius = 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

690 |

Chapter 10: Classes and Data Abstraction

double circleType::getRadius()
{
return radius;
}
double circleType::area()
{
return 3.1416 * radius * radius;
}
double circleType::circumference()
{
return 2 * 3.1416 * radius;
}
circleType::circleType(double r)
{
setRadius(r);
}

The following illustrates how to use the class circleType in a program:
//The user program that uses the class circleType
#include <iostream>
#include <iomanip>
#include "circleType.h"
using namespace std;
int main()
{
circleType circle1(8);
circleType circle2;

//Line
//Line
//Line
//Line

1
2
3
4

double radius;

//Line 5

cout << fixed << showpoint << setprecision(2);

//Line 6

cout <<
<<
<<
<<
<<

"Line 7: circle1 - "
"radius: " << circle1.getRadius()
", area: " << circle1.area()
", circumference: " << circle1.circumference()
endl;
//Line 7

cout <<
<<
<<
<<
<<

"Line 8: circle2 - "
"radius: " << circle2.getRadius()
", area: " << circle2.area()
", circumference: " << circle2.circumference()
endl << endl;
//Line 8

cout << "Line 9: Enter the radius of a circle: ";
cin >> radius;
cout << endl;

//Line 9
//Line 10
//Line 11

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More Examples of Classes

circle2.setRadius(radius);

|

691

//Line 12

cout << "Line 13: After setting the radius." << endl; //Line 13
cout << "Line 14: circle2 - "
<< "radius: " << circle2.getRadius()
<< ", area: " << circle2.area()
<< ", circumference: " << circle2.circumference()
<< endl;
//Line 14
return 0;
}//end main

//Line 15
//Line 16

Sample Run: In this sample run, the user input is shaded.
Line 7: circle1 - radius: 8.00, area: 201.06, circumference: 50.27
Line 8: circle2 - radius: 0.00, area: 0.00, circumference: 0.00
Line 9: Enter the radius of a circle: 5.5
Line 13: After setting the radius.
Line 14: circle2 - radius: 5.50, area: 95.03, circumference: 34.56

The preceding program works as follows. The statements in Lines 3 and 4 create the
objects circle1 and circle2. The radius of circle1 is set to 8; and the radius of
circle2 is set to 0 by using the default value by the constructor. The statements in Lines
7 and 8 output the data of circle1 and circle2. The statements in Lines 9 and 10
prompt the user to enter the radius of a circle and store the radius in the variable radius.
The statement in Line 12 uses the member function setRadius and the value of radius
to set the radius of circle2. The statement in Line 14 ouputs the (new) data of circle2.

EXAMPLE 10-9
In Example 6-4, in Chapter 6, the function rollDice rolls a pair of dice until the sum of
the numbers rolled is a given number and returns the number of times the dice are rolled
to get the desired sum. In fact, we can design a class that implements the basic properties
of a die. Consider the definition of the following class die.
class die
{
public:
die();
//Default constructor
//Sets the default number rolled by a die to 1
void roll();
//Function to roll a die.
//This function uses a random number generator to randomly
//generate a number between 1 and 6, and stores the number
//in the instance variable num.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

692 |

Chapter 10: Classes and Data Abstraction

int getNum() const;
//Function to return the number on the top face of the die.
//Returns the value of the instance variable num.
private
int num;
};

The definitions of the member functions are given next.
die::die()
{
num = 1;
srand(time(0));
}
void die::roll()
{
num = rand() % 6 + 1;
}
int die::getNum() const
{
return num;
}

The following program shows how to use the class die in a program:
//The user program that uses the class die
#include <iostream>
#include "die.h"
using namespace std;
int main()
{
die die1;
die die2;

//Line
//Line
//Line
//Line

1
2
3
4

cout << "Line 5: die1: " << die1.getNum() << endl;
cout << "Line 6: die2: " << die2.getNum() << endl;

//Line 5
//Line 6

die1.roll();
cout << "Line 8: After rolling die1: "
<< die1.getNum() << endl;

//Line 7
//Line 8
//Line 9

die2.roll();
cout << "Line 10: After rolling die2: "
<< die2.getNum() << endl;

//Line 10

cout << "Line 11: The sum of the numbers rolled"
<< " by the dice is: "
<< die1.getNum() + die2.getNum() << endl;

//Line 11

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More Examples of Classes

die1.roll();
die2.roll();

|

693

//Line 12
//Line 13

cout << "Line 14: After again rolling, the sum of "
<< "the numbers rolled is: "
<< die1.getNum() + die2.getNum() << endl;
//Line 14
return 0;
}//end main

//Line 15
//Line 16

Sample Run:
Line
Line
Line
Line
Line
Line

5: die1: 1
6: die2: 1
8: After rolling die1: 2
10: After rolling die2: 6
11: The sum of the numbers rolled by the dice is: 8
14: After again rolling, the sum of the numbers rolled is: 5

The preceding program works as follows. The statements in Lines 3 and 4 create the objects
die1 and die2, and using the default constructor set both dice to 1. The statements in
Lines 5 and 6 output the number of both dice. The statement in Line 7 rolls die1 and the
statement in Line 8 outputs the number rolled. Similarly, the statement in Line 9 rolls die2
and the statement in Line 10 outputs the number rolled. The statement in Line 11 outputs
the sum of the numbers rolled by die1 and die2. The statements in Lines 12 and 13 again
rolls both dice and the statement in Line 14 outputs the sum of the numbers rolled.
The class personType that is designed in Example 10-10 is very useful; we will use
this class in subsequent chapters.
EXAMPLE 10-10
The most common attributes of a person are the person’s first and last name. The typical
operations on a person’s name are to set the name and print the name. The following
statements define a class with these properties.
#include <string >
using namespace std;
class personType
{
public:
void print() const;
//Function to output the first name and last name
//in the form firstName lastName.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

694 |

Chapter 10: Classes and Data Abstraction

void setName(string first, string last);
//Function to set firstName and lastName according
//to the parameters.
//Postcondition: firstName = first; lastName = last;
string getFirstName() const;
//Function to return the first name.
//Postcondition: The value of firstName is returned.
string getLastName() const;
//Function to return the last name.
//Postcondition: The value of lastName is returned.
personType(string first = "", string last = "");
//Constructor
//Sets firstName and lastName according to the parameters.
//The default values of the parameters are null strings.
//Postcondition: firstName = first; lastName = last;
private:
string firstName; //variable to store the first name
string lastName; //variable to store the last name
};

Figure 10-11 shows the UML class diagram of the class personType.

personType
-firstName: string
-lastName: string
+print(): void
+setName(string, string): void
+getFirstName() const: string
+getLastName() const: string
+personType(string = "", string = "")

FIGURE 10-11

UML class diagram of the class personType

We now give the definitions of the member functions of the class personType.
void personType::print() const
{
cout << firstName << " " << lastName;
}
void personType::setName(string first, string last)
{
firstName = first;
lastName = last;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More Examples of Classes

|

695

string personType::getFirstName() const
{
return firstName;
}
string personType::getLastName() const
{
return lastName;
}
//constructor
personType::personType(string first, string last)
{
firstName = first;
lastName = last;
}

EXAMPLE 10-11
In this example, we design and implement a class to manipulate an integer. Consider the
integer 90237104628012645. Some of the operations that can be performed on this
integer are: count the number of even digits, odd digits, and zeros; find the sum of the
digits; reverse the digits; split the number in the block of three-digit numbers; and find
the sum of these numbers. The following class defines some of these operations.
class integerManipulation
{
public:
void setNum(long long n);
//Function to set num.
//Postcondition: num = n;
long long getNum();
//Function to return num.
//Postcondition: The value of num is returned.
void reverseNum();
//Function to reverse the digits of num.
//Postcondition: revNum is set to num with digits in
//
the reverse order.
void classifyDigits();
//Function to count the even, odd, and zero digits of num.
//Postcondition: evensCount = the number of even digits in num.
//
oddsCount = the number of odd digits in num.
//
zerosCount = the number of zeros in num.
int getEvensCount();
//Function to return the number of even digits in num.
//Postcondition: The value of evensCount is returned.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

696 |

Chapter 10: Classes and Data Abstraction

int getOddsCount();
//Function to return the number of odd digits in num.
//Postcondition: The value of oddsCount is returned.
int getZerosCount();
//Function to return the number of zeros in num.
//Postcondition: The value of zerosCount is returned.
int sumDigits();
//Function to return the sum of the digits of num.
//Postcondition: The sum of the digits is returned.
integerManipulation(long long n = 0);
//Constructor with a default parameter.
//The instance variable num is set according to the parameter,
//and other instance variables are set to zero.
//The default value of num is 0;
//Postcondition: num = n; revNum = 0; evensCount = 0;
//
oddsCount = 0; zerosCount = 0;
private:
long long num;
long long revNum;
int evensCount;
int oddsCount;
int zerosCount;
};

The definition of some of the member functions are:
void integerManipulation::setNum(long long n)
{
num = n;
}
long long integerManipulation::getNum()
{
return num;
}
void integerManipulation::reverseNum()
{
cout << "See Programming Exercise 6 in Chapter 6." << endl;
}
void integerManipulation::classifyDigits()
{
long long temp;
temp = abs(num);
int digit;
while (temp != 0)
{
digit = temp - (temp / 10 ) * 10;
temp = temp / 10;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More Examples of Classes

|

697

if (digit % 2 == 0)
{
evensCount++;
if (digit == 0)
zerosCount++;
}
else
oddsCount++;
}
}
int integerManipulation::getEvensCount()
{
return evensCount;
}
int integerManipulation::getOddsCount()
{
return oddsCount;
}
int integerManipulation::getZerosCount()
{
return zerosCount;
}
int integerManipulation::sumDigits()
{
cout << "See Programming Exercise 1 in Chapter 5." << endl;
return 0;
}
integerManipulation::integerManipulation(long long n)
{
num = n;
revNum = 0;
evensCount = 0;
oddsCount = 0;
zerosCount = 0;
}

The following program shows how to use this class in a program.
//The user program that uses the class integerManipulation
#include <iostream>
#include "integerManipulation.h"
using namespace std;
int main()
{
integerManipulation number;
long long num;

//Line 1
//Line 2
//Line 3
//Line 4

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

698 |

Chapter 10: Classes and Data Abstraction

cout << "Enter an integer: ";
cin >> num;
cout << endl;

//Line 5
//Line 6
//Line 7

number.setNum(num);

//Line 8

number.classifyDigits();

//Line 9

cout <<
<<
<<
<<
<<
<<
<<

//Line 10

number.getNum() << "- - - - - -" << endl
"The number of even digits: "
number.getEvensCount() << endl
"The number of zeros: "
number.getZerosCount() << endl
"The number of odd digits: "
number.getOddsCount() << endl;

return 0;
}//end main

//Line 11
//Line 12

Sample Run: In this sample run, the user input is shaded.
Enter an integer: 90237104628012645
90237104628012645- - - - - The number of even digits: 11
The number of zeros: 3
The number of odd digits: 6

Programming Exercise 21, at the end of this chapter, asks you to write the definition of
the functions of the class integerManipulation that are not given.

Static Members of a Class
This section may be skipped without any loss of continuation.

In Chapter 6, we described two types of variables: automatic and static. Recall that if
a local variable of a function is static, it exists between function calls. Similar to static
variables, a class can have static members, functions, or variables. Let us note the
following about the static members of a class:
•

If a function of a class is static, in the class definition it is declared using
the keyword static in its heading.
• If a member variable of a class is static, it is declared using the keyword
static, as discussed in Chapter 6 and also illustrated in Example 10-12.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Static Members of a Class |

•

699

A public static member, function, or variable of a class can be
accessed using the class name and the scope resolution operator.

Example 10-12 clarifies the effect of the keyword static.
EXAMPLE 10-12
Consider the following definition of the class illustrate:
class illustrate
{
public:
static int count;

//public static variable

void print() const;
//Function to output x, y, and count.
void setX(int a);
//Function to set x.
//Postcondition: x = a;
static void incrementY();
//static function
//Function to increment y by 1.
//Postcondition: y = y + 1
illustrate(int a = 0);
//constructor
//Postcondition: x = a;
//
If no value is specified for a, x = 0;
private:
int x;
static int y;
};

//private static variable

Suppose that the static member variables and the definitions of the member functions
of the class illustrate are as follows. (These statements are all placed in the
implementation file. Also, notice that all static member variables are initialized, as
shown below.)
int illustrate::count = 0;
int illustrate::y = 0;
void illustrate::print() const
{
cout << "x = " << x << ", y = " << y
<< ", count = " << count << endl;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

700 |

Chapter 10: Classes and Data Abstraction

void illustrate::setX(int a)
{
x = a;
}
void illustrate::incrementY()
{
y++;
}
illustrate::illustrate(int a)
{
x = a;
}

Because the function incrementY is static and public, the following statement is
legal:
illustrate::incrementY();

Similarly, because the member variable count is static and public, the following
statement is legal:
illustrate::count++;

Next, we elaborate on static member variables a bit more. Suppose that you have a
class, say, myClass, with member variables (static as well as non-static ). When
you create objects of type myClass, only non-static member variables of the class
myClass become the member variables of each object. For each static member
variable of a class, C++ allocates only one memory space. All myClass objects refer to
the same memory space. In fact, static member variables of a class exist even when no
object of that class type exists. You can access the public static member variables
outside of the class, as explained earlier in this section.
Next, we explain how memory space is allocated for static and non-static member
variables of a class.
Suppose that you have the class illustrate, as given in Example 10-12. Memory
space then exists for the static member variables y and count.
Consider the following statements:
illustrate illusObject1(3);
illustrate illusObject2(5);

//Line 1
//Line 2

The statements in Lines 1 and 2 declare illusObject1 and illusObject2 to be
illustrate type objects (see Figure 10-12).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Static Members of a Class |

701

y 0
count 0
illusObject1

illusObject2
x

FIGURE 10-12

3

x

5

illusObject1 and illusObject2

Now, consider the following statements:
illustrate::incrementY();
illustrate::count++;

After these statements execute, the objects and static members are as shown in Figure 10-13.

y 1
count 1
illusObject1

FIGURE 10-13

x

3

illusObject2

x

5

illusObject1 and illusObject2 after the statements illustrate::
incrementY(); and illustrate::count++; execute

The output of the statement:
illusObject1.print();

is:
x = 3, y = 1, count = 1

Similarly, the output of the statement:
illusObject2.print();

is:
x = 5, y = 1, count = 1

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

702 |

Chapter 10: Classes and Data Abstraction

Note that the function print outputs each instance’s individual value for x along with
the common static variable values for y and count. Now consider the statement:
illustrate::count++;

After this statement executes, the objects and static members are as shown in
Figure 10-14.

y 1
count 2
illusObject1

FIGURE 10-14

x

3

illusObject2

x

5

illusObject1 and illusObject2 after the statement illustrate::
count++; executes

The output of the statements:
illusObject1.print();
illusObject2.print();

is:
x = 3, y = 1, count = 2
x = 5, y = 1, count = 2

Note that the function print output the same incremented value of count for both
illusObject1 and illusObject2.
The program in Example 10-13 further illustrates how static members of a class work.
EXAMPLE 10-13
#include <iostream>
#include "illustrate.h"
using namespace std;
int main()
{
illustrate illusObject1(3);
illustrate illusObject2(5);

//Line 1
//Line 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Static Members of a Class |

illustrate::incrementY();
illustrate::count++;
illusObject1.print();
illusObject2.print();
cout << "Line 7: ***Increment y using "
<< "illusObject1***" << endl;

//Line
//Line
//Line
//Line

illusObject1.incrementY();
illusObject1.setX(8);
illusObject1.print();
illusObject2.print();

//Line
//Line
//Line
//Line

cout << "Line 12: ***Increment y using "
<< "illusObject2***" << endl;

//Line 12

illusObject2.incrementY();
illusObject2.setX(23);
illusObject1.print();
illusObject2.print();

//Line
//Line
//Line
//Line

703

3
4
5
6

//Line 7
8
9
10
11

13
14
15
16

return 0;
}

Sample Run:
x = 3, y = 1, count = 1
x = 5, y = 1, count = 1
Line 7: ***Increment y using illusObject1***
x = 8, y = 2, count = 1
x = 5, y = 2, count = 1
Line 12: ***Increment y using illusObject2***
x = 8, y = 3, count = 1
x = 23, y = 3, count = 1

The preceding program works as follows. The static member variables y and count
are initialized to 0. The statement in Line 1 declares illusObject1 to be an object of
the class illustrate and initializes its member variable x to 3. The statement in
Line 2 declares illusObject2 to be an object of the class illustrate and
initializes its member variable x to 5.
The statement in Line 3 uses the name of the class illustrate and the function
incrementY to increment y. Now, count is a public static member of the
class illustrate. So the statement in Line 4 uses the name of the class
illustrate to directly access count and increments it by 1. The statements in Lines
5 and 6 output the data stored in the objects illusObject1 and illusObject2. Notice
that the value of y for both objects is the same. Similarly, the value of count for both objects
is the same.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

704 |

Chapter 10: Classes and Data Abstraction

The statement in Line 7 is an output statement. The statement in Line 8 uses the object
illusObject1 and the function incrementY to increment y. The statement in Line 9
sets the value of the member variable x of illusObject1 to 8. Lines 10 and 11 output
the data stored in the objects illusObject1 and illusObject2. Notice that the
value of y for both objects is the same. Similarly, the value of count for both objects is
the same. Moreover, notice that the statement in Line 9 changes only the value of the
member variable x of illusObject1 because x is not a static member of the class
illustrate.
The statement in Line 13 uses the object illusObject2 and the function
incrementY to increment y. The statement in Line 14 sets the value of the member
variable x of illusObject2 to 23. Lines 15 and 16 output the data stored in the
objects illusObject1 and illusObject2. Notice that the value of y for both
objects is the same. Similarly, the value of count for both objects is the same. Moreover, notice that the statement in Line 14 changes only the value of the member
variable x of illusObject2, because x is not a static member of the class
illustrate.

Here are some additional comments on static members of a class. As you have seen in
this section, a static member function of a class does not need any object to be
invoked. It can be called using the name of the class and the scope resolution operator, as
illustrated. Therefore, a static member function cannot use anything that depends on
a calling object. In other words, in the definition of a static member function, you
cannot use a non-static member variable or a non-static function unless there is
an object declared locally that accesses the non-static member variable or the nonstatic member function.

Let us again consider the class illustrate, as defined in Example 10-12. This class
contains both static and non-static member variables. When we declare objects of
this class, each object has its own copy of the member variable x, which is non-static,
and all objects share the member variables y and count, which are static. Earlier in
this chapter, we defined the terminology instance variables of a class using the class
clockType. However, at that point, we did not discuss static member variables of a
class. A class can have static as well as non-static member variables. We can,
therefore, make the general statement that non-static member variables of a class are
called the instance variables of the class.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Juice Machine |

PROGRAMMING EXAMPLE:

Watch
the Video

705

Juice Machine

A common place to buy juice is from a machine. A new juice machine has been
purchased for the gym, but it is not working properly. The machine sells the following
types of juices: orange, apple, mango, and strawberry–banana. You have been asked to
write a program for this juice machine so that it can be put into operation.
The program should do the following:
1.
2.
3.
4.
5.

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Input

Show the customer the different products sold by the juice machine.
Let the customer make the selection.
Show the customer the cost of the item selected.
Accept money from the customer.
Release the item.
The item selection and the cost of the item.

Output

The selected item.

A juice machine has two main components: a built-in cash register and several
dispensers to hold and release the products.

Cash Register Let us first discuss the properties of a cash register. The register has some cash on

hand, it accepts the amount from the customer, and if the amount deposited is more
than the cost of the item, then—if possible—it returns the change. For simplicity, we
assume that the user deposits the money greater than or equal to the cost of the
product. The cash register should also be able to show to the juice machine’s owner
the amount of money in the register at any given time. The following class defines
the properties of a cash register:
class cashRegister
{
public:
int getCurrentBalance() const;
//Function to show the current amount in the cash
//register.
//Postcondition: The value of cashOnHand is returned.
void acceptAmount(int amountIn);
//Function to receive the amount deposited by
//the customer and update the amount in the register.
//Postcondition: cashOnHand = cashOnHand + amountIn;
cashRegister(int cashIn = 500);
//Constructor
//Sets the cash in the register to a specific amount.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

706 |

Chapter 10: Classes and Data Abstraction

//Postcondition:
//
//
//
private:
int cashOnHand;

cashOnHand = cashIn;
If no value is specified when the
object is declared, the default value
assigned to cashOnHand is 500.

//variable to store the cash
//in the register

};

Figure 10-15 shows the UML class diagram of the class cashRegister.

cashRegister
–cashOnHand: int
+getCurrentBalance() const: int
+acceptAmount(int): void
+cashRegister(int = 500)

FIGURE 10-15

UML class diagram of the class cashRegister

Next, we give the definitions of the functions to implement the operations of the
class cashRegister. The definitions of these functions are very simple and easy to

follow.
The function getCurrentBalance shows the current amount in the cash register. It
returns the value of the private member variable cashOnHand. So its definition is:
int cashRegister::getCurrentBalance() const
{
return cashOnHand;
}

The function acceptAmount accepts the amount of money deposited by the customer.
It updates the cash in the register by adding the amount deposited by the customer to the
previous amount in the cash register. Essentially, the definition of this function is:
void cashRegister::acceptAmount(int amountIn)
{
cashOnHand = cashOnHand + amountIn;
}

In the definition of the class cashRegister, the constructor is declared with a
default value. Therefore, if the user does not specify any value when the object is
declared, the default value is used to initialize the member variable cashOnHand. Recall
that because we have specified the default value for the constructor’s parameter in the

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Juice Machine |

707

definition of the class, in the heading of the definition of the constructor, we do not
specify the default value. The definition of the constructor is as follows:
cashRegister::cashRegister(int cashIn)
{
if (cashIn >= 0)
cashOnHand = cashIn;
else
cashOnHand = 500;
}

Note that the definition of the constructor checks for valid values of the parameter
cashIn. If the value of cashIn is less than 0, the value assigned to the member
variable cashOnHand is 500.
Dispenser The dispenser releases the selected item if it is not empty. It should show the number

of items in the dispenser and the cost of the item. The following class defines the
properties of a dispenser. Let us call this class dispenserType:
class dispenserType
{
public:
int getNoOfItems() const;
//Function to show the number of items in the machine.
//Postcondition: The value of numberOfItems is returned.
int getCost() const;
//Function to show the cost of the item.
//Postcondition: The value of cost is returned.
void makeSale();
//Function to reduce the number of items by 1.
//Postcondition: numberOfItems--;
dispenserType(int setNoOfItems = 50, int setCost = 50);
//Constructor
//Sets the cost and number of items in the dispenser
//to the values specified by the user.
//Postcondition: numberOfItems = setNoOfItems;
//
cost = setCost;
//
If no value is specified for a
//
parameter, then its default value is
//
assigned to the corresponding member
//
variable.
private:
int numberOfItems;
int cost;

//variable to store the number of
//items in the dispenser
//variable to store the cost of an item

};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

708 |

Chapter 10: Classes and Data Abstraction

Figure 10-16 shows the UML class diagram of the class dispenserType.

dispenserType
–numberOfItems: int
–cost: int
+getNoOfItems() const: int
+getCost(): const: int
+makeSale(): void
+dispenserType(int = 50, int = 50)

FIGURE 10-16

UML class diagram of the class dispenserType

Because the juice machine sells four types of items, we shall declare four objects of
type dispenserType. For example, the statement:
dispenserType apple(100, 65);

declares apple to be an object of type dispenserType, sets the number of apple
juice bottles in the dispenser to 100, and sets the cost of each apple juice bottle to 65
cents (see Figure 10-17).

apple

numberOfItems 100
cost

FIGURE 10-17

65

Object apple

Next, we discuss the definitions of the functions to implement the operations of the
class dispenserType.
The function getNoOfItems returns the number of items of a particular product.
Because the number of items currently in the dispenser is stored in the private
member variable numberOfItems, the function returns the value of
numberOfItems. The definition of this function is:
int dispenserType::getNoOfItems() const
{
return numberOfItems;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Juice Machine |

709

The function getCost returns the cost of a product. Because the cost of a product is
stored in the private member variable cost, the function returns the value of
cost. The definition of this function is:
int dispenserType::getCost() const
{
return cost;
}

When a product is sold, the number of items in that dispenser is reduced by 1. Therefore, the function makeSale reduces the number of items in the dispenser by 1. That is,
it decrements the value of the private member variable numberOfItems by 1. The
definition of this function is:
void dispenserType::makeSale()
{
numberOfItems--;
}

The definition of the constructor checks for valid values of the parameters. If these
values are less than 0, the default values are assigned to the member variables. The
definition of the constructor is:
//constructor
dispenserType::dispenserType(int setNoOfItems, int setCost)
{
if (setNoOfItems >= 0)
numberOfItems = setNoOfItems;
else
numberOfItems = 50;
if (setCost >= 0)
cost = setCost;
else
cost = 50;
}
MAIN
PROGRAM

When the program executes, it must do the following:
1. Show the different products sold by the juice machine.
2. Show how to select a particular product.
3. Show how to terminate the program.
Furthermore, these instructions must be displayed after processing each selection (except
exiting the program) so that the user need not remember what to do if he or she wants to
buy two or more items. Once the user has made the appropriate selection, the juice
machine must act accordingly. If the user has opted to buy a product and that product is
available, the juice machine should show the cost of the product and ask the user to
deposit the money. If the amount deposited is at least the cost of the item, the juice
machine should sell the item and display an appropriate message.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

710 |

Chapter 10: Classes and Data Abstraction

This discussion translates into the following algorithm:
1. Show the selection menu to the customer.
2. Get the selection.
3. If the selection is valid and the dispenser corresponding to the
selection is not empty, sell the product.
We divide this program into three functions: showSelection, sellProduct, and main.
showSelection This function displays the information necessary to help the user select and buy a
product. This definition of the function showSelection is:
void showSelection()
{
cout << "*** Welcome to Shelly's Juice Shop ***" << endl;
cout << "To select an item, enter " << endl;
cout << "1 for orange juice (50 cents)" << endl;
cout << "2 for apple juice (65 cents)" << endl;
cout << "3 for mango juice (80 cents)" << endl;
cout << "4 for strawberry banana juice (85 cents)" << endl;
cout << "9 to exit" << endl;
}//end showSelection

sellProduct This function attempts to sell the product selected by the customer. Therefore, it must

have access to the dispenser holding the product. The first thing that this function does is
check whether the dispenser holding the product is empty. If the dispenser is empty, the
function informs the customer that this product is sold out. If the dispenser is not empty,
it tells the user to deposit the necessary amount to buy the product.
If the user does not deposit enough money to buy the product, sellProduct tells the
user how much additional money must be deposited. If the user fails to deposit enough
money in two tries to buy the product, the function simply returns the money.
(Programming Exercise 13, at the end of this chapter, asks you to revise
the definition of the function sellProduct so that it keeps asking the user to
enter the additional amount as long as the user has not entered enough money to
buy the product.) If the amount deposited by the user is sufficient, it accepts the
money and sells the product. Selling the product means to decrement the number
of items in the dispenser by 1 and to update the money in the cash register by
adding the cost of the product. (Because this program does not return the extra
money deposited by the customer, the cash register is updated by adding the
money entered by the user.)
From this discussion, it is clear that the function sellProduct must have access to
the dispenser holding the product (to decrement the number of items in the dispenser
by 1 and to show the cost of the item) as well as the cash register (to update the cash).
Therefore, this function has two parameters: one corresponding to the dispenser and
the other corresponding to the cash register. Furthermore, both parameters must be
referenced.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Juice Machine |

711

In pseudocode, the algorithm for this function is:
1. If the dispenser is not empty,
a. Show and prompt the customer to enter the cost of the item.
b. Get the amount entered by the customer.
c. If the amount entered by the customer is less than the cost of the
product,
i. Show and prompt the customer to enter the additional amount.
ii. Calculate the total amount entered by the customer.
d. If the amount entered by the customer is at least the cost of the
product,
i.

Update the amount in the cash register by adding the
amount entered by the user.
ii. Sell the product—that is, decrement the number of items
in the dispenser by 1.
iii. Display an appropriate message.
e. If the amount entered by the user is less than the cost of the
item, return the amount.
2. If the dispenser is empty, tell the user that this product is sold out.
This definition of the function sellProduct is:
void sellProduct(dispenserType& product,
cashRegister& pCounter)
{
int amount; //variable to hold the amount entered
int amount2; //variable to hold the extra amount needed
if (product.getNoOfItems() > 0) //if the dispenser is not
//empty
{
cout << "Please deposit " << product.getCost()
<< " cents" << endl;
cin >> amount;
if (amount < product.getCost())
{
cout << "Please deposit another "
<< product.getCost()- amount
<< " cents" << endl;
cin >> amount2;
amount = amount + amount2;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

712 |

Chapter 10: Classes and Data Abstraction

if (amount >= product.getCost())
{
pCounter.acceptAmount(amount);
product.makeSale();
cout << "Collect your item at the bottom and "
<< "enjoy." << endl;
}
else
cout << "The amount is not enough. "
<< "Collect what you deposited." << endl;
cout << "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*"
<< endl << endl;
}
else
cout << "Sorry, this item is sold out." << endl;
}//end sellProduct

Now that we have described the functions showSelection and sellProduct, the
function main is described next.
main The algorithm for the function main is as follows:

1. Create the cash register—that is, declare an object of type
cashRegister.
2. Create four dispensers—that is, declare four objects of type
dispenserType and initialize these objects. For example, the statement:
dispenserType orange(100, 50);

3.
4.
5.
6.

creates a dispenser object, orange, to hold the juice. The number of items in
the dispenser is 100, and the cost of an item is 50 cents.
Declare additional variables as necessary.
Show the selection; call the function showSelection.
Get the selection.
While not done (a selection of 9 exits the program),
a. Sell the product; call the function sellProduct.
b. Show the selection; call the function showSelection.
c. Get the selection.

The definition of the function main is as follows:
int main()
{
cashRegister counter;
dispenserType orange(100, 50);
dispenserType apple(100, 65);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Juice Machine |

713

dispenserType mango(75, 80);
dispenserType strawberryBanana(100, 85);
int choice;

//variable to hold the selection

showSelection();
cin >> choice;
while (choice != 9)
{
switch (choice)
{
case 1:
sellProduct(orange, counter);
break;
case 2:
sellProduct(apple, counter);
break;
case 3:
sellProduct(mango, counter);
break;
case 4:
sellProduct(strawberryBanana, counter);
break;
default :
cout << "Invalid selection." << endl;
}//end switch
showSelection();
cin >> choice;
}//end while
return 0;
}//end main

COMPLETE PROGRAM LISTING

In the previous sections, we designed the classes to implement cash registers and
dispensers to implement a juice machine. In this section, for the sake of completeness,
we give complete definitions of the classes, the implementation file, and the user
program to implement a juice machine.
//************************************************************
// Author: D.S. Malik
//
// class cashRegister
// This class specifies the members to implement a cash
// register.
//************************************************************

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

714 |

Chapter 10: Classes and Data Abstraction

class cashRegister
{
public:
int getCurrentBalance() const;
//Function to show the current amount in the cash
//register.
//Postcondition: The value of cashOnHand is returned.
void acceptAmount(int amountIn);
//Function to receive the amount deposited by
//the customer and update the amount in the register.
//Postcondition: cashOnHand = cashOnHand + amountIn;
cashRegister(int cashIn = 500);
//Constructor
//Sets the cash in the register to a specific amount.
//Postcondition: cashOnHand = cashIn;
//
If no value is specified when the
//
object is declared, the default value
//
assigned to cashOnHand is 500.
private:
int cashOnHand;

//variable to store the cash
//in the register

};
//************************************************************
// Author: D.S. Malik
//
// class dispenserType
// This class specifies the members to implement a dispenser.
//************************************************************
class dispenserType
{
public:
int getNoOfItems() const;
//Function to show the number of items in the machine.
//Postcondition: The value of numberOfItems is returned.
int getCost() const;
//Function to show the cost of the item.
//Postcondition: The value of cost is returned.
void makeSale();
//Function to reduce the number of items by 1.
//Postcondition: numberOfItems--;
dispenserType(int setNoOfItems = 50, int setCost = 50);
//Constructor
//Sets the cost and number of items in the dispenser
//to the values specified by the user.
//Postcondition: numberOfItems = setNoOfItems;
//
cost = setCost;
//
If no value is specified for a
//
parameter, then its default value is
//
assigned to the corresponding member
//
variable.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Juice Machine |

715

private:
int numberOfItems;
int cost;

//variable to store the number of
//items in the dispenser
//variable to store the cost of an item

};
//**********************************************************
// Author: D.S. Malik
//
// Implementation file juiceMachineImp.cpp
// This file contains the definitions of the functions to
// implement the operations of the classes cashRegister and
// dispenserType.
//**********************************************************
#include <iostream>
#include "juiceMachine.h"
using namespace std;
int cashRegister::getCurrentBalance() const
{
return cashOnHand;
}
void cashRegister::acceptAmount(int amountIn)
{
cashOnHand = cashOnHand + amountIn;
}
cashRegister::cashRegister(int cashIn)
{
if (cashIn >= 0)
cashOnHand = cashIn;
else
cashOnHand = 500;
}
int dispenserType::getNoOfItems() const
{
return numberOfItems;
}
int dispenserType::getCost() const
{
return cost;
}
void dispenserType::makeSale()
{
numberOfItems- -;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

716 |

Chapter 10: Classes and Data Abstraction

dispenserType::dispenserType(int setNoOfItems, int setCost)
{
if (setNoOfItems >= 0)
numberOfItems = setNoOfItems;
else
numberOfItems = 50;
if (setCost >= 0)
cost = setCost;
else
cost = 50;
}

Main //*****************************************************
Program // Author: D.S. Malik
//
// This program uses the classes cashRegister and
// dispenserType to implement a juice machine.
// ****************************************************
#include <iostream>
#include "juiceMachine.h"
using namespace std;
void showSelection();
void sellProduct(dispenserType& product,
cashRegister& pCounter);
int main()
{
cashRegister counter;
dispenserType orange(100, 50);
dispenserType apple(100, 65);
dispenserType mango(75, 80);
dispenserType strawberryBanana(100, 85);
int choice;

//variable to hold the selection

showSelection();
cin >> choice;
while (choice != 9)
{
switch (choice)
{
case 1:
sellProduct(orange, counter);
break;
case 2:
sellProduct(apple, counter);
break;
case 3:
sellProduct(mango, counter);
break;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Juice Machine |

717

case 4:
sellProduct(strawberryBanana, counter);
break;
default:
cout << "Invalid selection." << endl;
}//end switch
showSelection();
cin >> choice;
}//end while
return 0;
}//end main
void showSelection()
{
cout << "*** Welcome to Shelly's Juice Shop ***" << endl;
cout << "To select an item, enter " << endl;
cout << "1 for orange juice (50 cents)" << endl;
cout << "2 for apple juice (65 cents)" << endl;
cout << "3 for mango juice (80 cents)" << endl;
cout << "4 for strawberry banana juice (85 cents)" << endl;
cout << "9 to exit" << endl;
}//end showSelection
void sellProduct(dispenserType& product,
cashRegister& pCounter)
{
int amount; //variable to hold the amount entered
int amount2; //variable to hold the extra amount needed
if (product.getNoOfItems() > 0) //if the dispenser is not
//empty
{
cout << "Please deposit " << product.getCost()
<< " cents" << endl;
cin >> amount;
if (amount < product.getCost())
{
cout << "Please deposit another "
<< product.getCost()- amount
<< " cents" << endl;
cin >> amount2;
amount = amount + amount2;
}
if (amount >= product.getCost())
{
pCounter.acceptAmount(amount);
product.makeSale();
cout << "Collect your item at the bottom and "
<< "enjoy." << endl;
}
else
cout << "The amount is not enough. "
<< "Collect what you deposited." << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

718 |

Chapter 10: Classes and Data Abstraction

cout << "*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*"
<< endl << endl;
}
else
cout << "Sorry, this item is sold out." << endl;
}//end sellProduct

Sample Run: In this sample run, the user input is shaded.
*** Welcome to Shelly's Juice Shop ***
To select an item, enter
1 for orange juice (50 cents)
2 for apple juice (65 cents)
3 for mango juice (80 cents)
4 for strawberry banana juice (85 cents)
9 to exit
1
Please deposit 50 cents
50
Collect your item at the bottom and enjoy.
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
*** Welcome to Shelly's Juice Shop ***
To select an item, enter
1 for orange juice (50 cents)
2 for apple juice (65 cents)
3 for mango juice (80 cents)
4 for strawberry banana juice (85 cents)
9 to exit
9

We placed the definitions of the classes cashRegister and
dispenserType in the same header file juiceMachine.h. However, you
can also place the definitions of these classes in separate header files and include
those header files in the files that use these classes, such as the implementation
file of these classes and the file that contains the main program. Similarly, you
can also create separate implementation files for these classes. The Web site
accompanying this book contains these header and implementation files.

QUICK REVIEW
1.
2.
3.
4.
5.

A class is a collection of a fixed number of components.
Components of a class are called the members of the class.
Members of a class are accessed by name.
In C++, class is a reserved word.
Members of a class are classified into one of three categories: private,
protected, and public.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

6.
7.
8.
9.
10.
11.
12.
13.
14.
15.

16.

17.
18.
19.
20.
21.
22.
23.
24.
25.
26.

719

The private members of a class are not directly accessible outside of
the class.
The public members of a class are directly accessible outside of the class.
By default, all members of a class are private.
The public members are declared using the member access specifier
public and the colon, :.
The private members are declared using the member access specifier
private and the colon, :.
A member of a class can be a function or a variable.
If any member of a class is a function, you usually use the function
prototype to declare it.
If any member of a class is a variable, it is declared like any other variable.
In the definition of a class, you cannot initialize a variable when you declare it.
A member function of a class is called a constant function if its heading
contains the reserved word const at the end. Moreover, a constant member
function of a class cannot modify the member variables of the class.
In the Unified Modeling Language (UML) diagram of a class, the top
box contains the name of the class. The middle box contains the
member variables and their data types. The last box contains the member
function name, parameter list, and the return type of the function.
A + (plus) sign in front of a member indicates that this member is a
public member. A - (minus) sign preceding a member indicates that
this is a private member. The symbol # before the member name
indicates that the member is a protected member.
In C++, a class is a definition. No memory is allocated for the class
itself; memory is allocated for the class variables when you declare them.
In C++, class variables are called class objects or class instances or,
simply, objects.
A class member is accessed using the class variable name, followed by
the dot operator (.), followed by the member name.
The only built-in operations on classes are the assignment and member selection.
As parameters to functions, classes can be passed either by value or by reference.
A function can return a value of type class. For example, a function can
return a value of clockType.
Any program (or software) that uses a class is called a client of the class.
A member function of a class that modifies the value(s) of the member
variable(s) is called a mutator function.
A member function of a class that only accesses (that is, does not modify)
the value(s) of the member variable(s) is called an accessor function.
A constant member function of a class can only call the other constant
member functions of the class.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

720 |

27.
28.
29.
30.
31.
32.
33.
34.
35.

36.
37.
38.
39.
40.
41.
42.
43.
44.

Chapter 10: Classes and Data Abstraction

Constructors guarantee that the member variables are initialized when an
object is declared.
The name of a constructor is the same as the name of the class.
A class can have more than one constructor.
A constructor without parameters is called the default constructor.
Constructors automatically execute when a class object enters its scope.
Destructors automatically execute when a class object goes out of scope.
A class can have only one destructor, and the destructor has no
parameters.
The name of a destructor is the tilde (~), followed by the class name
(no spaces in between).
Constructors and destructors are functions without any type; that is, they
are neither value-returning nor void. As a result, they cannot be called like
other functions.
A data type that separates the logical properties from the implementation
details is called an abstract data type (ADT).
Classes were specifically designed in C++ to handle ADTs.
To implement an ADT, you must represent the data and write related
algorithms to implement the operations.
A precondition is a statement specifying the condition(s) that must be true
before the function is called.
A postcondition is a statement specifying what is true after the function call
is completed.
A public static member, function or variable, of a class can be
accessed using the class name and the scope resolution operator, ::.
For each static variable of a class, C++ allocates only one memory
space. All objects of the class refer to the same memory space.
static member variables of a class exist even when no object of the
class type exists.
Non-static member variables of a class are called the instance variables
of the class.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.
b.
c.

The member variables of a class must be of the same type. (1)
The member functions of a class must be public. (2)
A class can have more than one constructor. (5)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

d.
e.
2.

Find the syntax errors in the following class definition. (1, 2, 5)
1
2
3
4
5
6
7
8
9
10
11

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7
8
9
10

Find the syntax errors in the following class definition. (1, 2, 5)
class secret
{
public:
set (int x, int y);
get (int& x, int& y);
int multiply();
void print() const;
secret(int = 0, int = 0) const;
private:
int num1;
int num2;
};

5.

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

Find the syntax errors in the following class definition. (1, 2, 5)
class temp
{
public:
bool isEqual();
print() const;
void temp(int = 0, int = 0);
private:
int first;
int second;
};

4.

721

A class can have more than one destructor. (5)
Both constructors and destructors can have parameters. (5)

class mystery
{
public;
void print() const;
void setXY(double, double);
int add();
double mystery();
private:
double x;
double y;
};
3.

|

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7
8
9
10
11
12

Find the syntax errors in the following class definition. (1, 2, 5)
class discover()
{
public:
void set(string, int, int);
void print() const;
discover();
discover(string, int, int);
bool discover(string, int, int);

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7
8

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

722 |

Chapter 10: Classes and Data Abstraction

private;
string type;
int l;
int w;
}
6.

//Line
//Line
//Line
//Line
//Line

9
10
11
12
13

Consider the following declarations: (1, 2, 5, 7)
class bagType
{
public:
void set(string, double, double, double, double);
void print() const;
string getStyle() const;
double getPrice() const;
void get(double, double, double, double);
bagType();
bagType(string, double, double, double, double);
private:
string style;
double l;
double w;
double h;
double price;
};
bagType newBag;
a.
b.
c.
d.
e.

7.

//variable declaration

How many members does class bagType have?
How many private members does class bagType have?
How many constructors does class bagType have?
How many constant functions does class bagType have?
Which constructor is used to initialize the object newBag?

Assume the definition of class bagType as given in Exercise 6. Answer the
following questions: (1, 2, 3, 5, 7)
a.

b.

c.

d.
e.

Write the definition of the member function set so that private
members are set according to the parameters.
Write the definition of the member function print that prints the
values of the data members.
Write the definition of the default constructor of the class bagType so
that the private member variables are initialized to "", 0.0, 0.0, 0.0,
0.0, respectively.
Write a C++ statement that prints the value of the object newBag.
Write a C++ statement that declares the object tempBag of type
bagType, and initializes the member variables of tempBag to
"backPack", 15, 8, 20, and 49.99, respectively.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

8.

void setData(string, int, double);
void print() const;
void updateSalary(double x);
int getNumOfServiceYears() const;
double getSalary() const;
private:
string name;
int numOfServiceYears;
double salary;
};
a.

b.

c.

d.

10.

723

Consider the definition of the following class: (1, 2, 3, 5, 7)
class employee
{
public:
employee();
employee(string, int, double);
employee(int, double);
employee(string);

9.

|

//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7

//Line
//Line
//Line
//Line
//Line

8
9
10
11
12

//Line
//Line
//Line
//Line
//Line

13
14
15
16
17

Give the line number containing the constructor that is executed in each of
the following declarations:
i.

employee tempEmployee;

ii.

employee newEmployee("Harry Miller", 0, 25000);

iii.

employee oldEmployee("Bill Dunbar", 15, 55000);

Write the definition of the constructor in Line 4 so that the instance
variables are initialized to "", 0, and 0.0, respectively.
Write the definition of the constructor in Line 5 so that the instance
variables are initialized according to the parameters.
Write the definition of the constructor in Line 6 so that the instance
variable name is initialized to the empty string and the remaining
instance variables are initialized according to the parameters.

Consider the definition of the class employee as given in Exercise 8. Which
function members are accessors and which are mutators? (4)
Consider the definition of the class employee as given in Exercise 8. Answer the
following questions: (1, 2, 3, 5)
a.

b.

c.

d.

Write the definition of the function setData so that the instance
variables are set according to the parameters.
Write the definition of the function print to output the values of the
instance variables.
Write the definition of the function updateSalary to update the value
of the instance variable salary by adding the value of the parameter.
Write the definition of the function getNumOfServiceYears to
return the value of the instance variable numOfServiceYears.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

724 |

e.

f.
11.

Chapter 10: Classes and Data Abstraction

Write the definition of the function getSalary to return the value of
the instance variable salary.
Write a program to test the class employee.

Consider the following declarations: (1, 2, 3, 5, 7)
class houseType
{
public:
void set(string, int, int, int, int, int, double, double);
void print() const;
void setStyle(string);
string getStyle() const;
void setNumOfBedrooms(int);
int getNumOfBedrooms() const;
void setNumOfBathrooms(int);
int getNumOfBathrooms() const;
void setNumOfCarsGarage(int);
int getNumOfCarsGarage() const;
void setYearBuilt(int);
int getYearBuilt() const;
void setFinishedSquareFootage(int);
int getFinishedSquareFootage() const;
void setPrice(double);
double getPrice() const;
void setTax(double);
double getTax() const;
houseType(string = "", int = 0, int = 0, int = 0, int = 0,
int = 0, double = 0, double = 0);
private:
string style;
int numOfBedrooms;
int numOfBathrooms;
int numOfCarsGarage;
int yearBuilt;
int finishedSquareFootage;
double price;
double tax;
};
houseType newHouse;
a.
b.
c.
d.

How
How
How
How

many
many
many
many

//variable declaration

members does class houseType have?
private members does class houseType have?

constructors does class houseType have?
constant functions does class houseType have?

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

12.

725

Assume the definition of class houseType as given in Exercise 11.
Answer the following questions? (1, 2, 3, 4, 5)
a.

b.

c.

d.
e.

f.
13.

|

Write the definition of the member function set so that private
members are set according to the parameters.
Write the definition of the member function print that prints the
values of the data members.
Write the definition of the constructor of the class houseType so that the
private member variables are initialized according to the parameters.
Write a C++ statement that prints the value of the object newHouse.
Write a C++ statement that declares an object house of type
newHouse, and initializes the member variables of house to
"Ranch", 3, 2, 2, 2005, 1300, 185000, and 3600.0, respectively.
Which function members are accessors and which are mutators?

Consider the following statements: (1, 2, 3, 5, 7)
class temporary
{
public:
void set(string, double, double);
void print();
double manipulate();
void get(string&, double&, double&);
void setDescription(string);
void setFirst(double);
void setSecond(double);
string getDescription() const;
double getFirst()const;
double getSecond()const;
temporary(string = "", double = 0.0, double = 0.0);
private:
string description;
double first;
double second;
};
a.
b.
c.

14.

How many members does class temporary have?
How many private members does class temporary have?
How many constructors does class temporary have? Can this constructor be used to initialize an object without specifying any parameters?
If yes, then illustrate with an example; otherwise, explain why it cannot
be used to initialize an object witout specifying any parameters.

Assume the definition of class temporary as given in Exercise 13.
Answer the following questions: (1, 2, 3, 5)
a.

Write the definition of the member function set so that the instance
variables are set according to the parameters.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

726 |

b.

c.

Chapter 10: Classes and Data Abstraction

Write the definition of the member function manipulate that returns a
decimal number as follows: If the value of description is "rectangle",
it returns first * second; if the value of description is "circle", it
returns the area of the circle with radius first; if the value of
description is "sphere", it returns the volume of the sphere with radius
first; if the value of description is "cylinder", it returns the volume
of the cylinder with radius first and height second; otherwise, it
returns the value -1.
Write the definition of the function print to print the values of the
instance variables and the values returned by the function manipulate.
For example, if description ¼ "rectangle", first ¼ 8.5, and
second ¼ 5, it should print:
rectangle: length = 8.50, width = 5.00, area = 42.50

d.

e.

15.

Write the definition of the constructor so that it initializes the instance
variables using the function set.
Write the definition of the remaining functions to set or retrieve the
values of the instance variables. Note that the function get returns the
values of all instance variables.

Assume the definition of class temporary as given in Exercise 13. What is the
effect of the following statements? (1, 5)
temporary
temporary
temporary
temporary

16.

object1;
object2("rectangle", 3.0, 5.0);
object3("circle", 6.5, 0.0);
object4("cylinder", 6.0, 3.5);

//Line
//Line
//Line
//Line

1
2
3
4

Assume the definition of class temporary as given in Exercise 13 and the
definitions of the member functions and the constructor as specified in
Exercise 14. What is the output of the following statements? (3, 5)
temporary
temporary
temporary
temporary

object1;
object2("rectangle", 8.5, 5);
object3("circle", 6, 0);
object4("cylinder", 6, 3.5);

cout << fixed << showpoint << setprecision(2);
object1.print();
object2.print();
object3.print();
object4.print();
object1.set("sphere", 4.5, 0);
object1.print();
17.

What are the built-in operations on classes? (3)

18.

What is the main difference between a struct and a class? (8)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

19.

|

727

Consider the definition of the following class: (1, 2, 3, 5, 7)
class testClass
{
public:
int sum();
//Returns the sum of the private member variables
void print() const;
//Prints the values of the private member variables
testClass();
//Default constructor
//Initializes the private member variables to 0
testClass(int a, int b);
//Constructors with parameters
//initializes the private member variables to the values
//specified by the parameters
//Postcondition: x = a; y = b;
private:
int x;
int y;
};
a.

b.

20.

Write the definitions of the member functions as described in the
definition of the class testClass.
Write a test program to test the various operations of the
class testClass.

Given the definition of the class clockType with constructors (as described in
this chapter), what is the output of the following C++ code? (1, 2, 3, 5)
clockType clock1;
clockType clock2(23, 13, 75);
clock1.printTime();
cout << endl;
clock2.printTime();
cout << endl;
clock1.setTime(6, 59, 39);
clock1.printTime();
cout << endl;
clock1.incrementMinutes();
clock1.printTime();
cout << endl;
clock1.setTime(0, 13, 0);
if (clock1.equalTime(clock2))
cout << "clock1 time is the same as clock2 time."
<< endl;
else
cout << "The two times are different." << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

728 |

21.

Chapter 10: Classes and Data Abstraction

Assume the definition of the class personType as given in this chapter.
(1, 3)
a.

b.

c.

Write a C++ statement that declares student to be a personType
object, and initialize its first name to "Buddy" and last name to
"Arora".
Write a C++ statement that outputs the data stored in the object
student.
Write a C++ statement that changes the first name of student to
"Susan" and the last name to "Gilbert".

22.

Explain why you would need both public and private members in a class.
(2, 9, 10)

23.

What is a constructor? Why would you include a constructor in a class? (5)

24.

Which of the following characters appears before a destructor’s name? (5)
a.

#

b.

!

c.

~

d.

$

25.

What is a destructor and what is its purpose? (5)

26.

Write the definition of a class that has the following properties: (1, 2, 3, 5)
a.
b.

c.

The name of the class is secretType.
The class secretType has four member variables: name of type
string, age and weight of type int, and height of type
double.
The class secretType has the following member functions. (Make
each accessor function constant.)
print—outputs the data stored in the member variables with the

appropriate titles
setName—function to set the name
setAge—function to set the age
setWeight—function to set the weight
setHeight—function to set the height
getName—value-returning function to return the name
getAge—value-returning function to return the age
getWeight—value-returning function to return the weight
getHeight—value-returning function to return the height

d.

constructor—with default parameters: The default value of name is
the empty string " ", and the default values of age, weight, and
height are 0.
Write the definition of the member functions of the class secretType,
as described in Part c.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

27.

|

729

Consider the following definition of the class myClass: (11)
class myClass
{
public:
void setX(int a);
//Function to set the value of x.
//Postcondition: x = a;
void printX() const;
//Function to output x.
static void printCount();
//Function to output count.
static void incrementCount();
//Function to increment count.
//Postcondition: count++;
myClass(int a = 0);
//constructor with default parameters
//Postcondition x = a;
//If no value is specified for a, x = 0;
private:
int x;
static int count;
};
a.
b.
c.
d.

e.

f.

g.

Write a C++ statement that initializes the member variable count to 0.
Write a C++ statement that increments the value of count by 1.
Write a C++ statement that outputs the value of count.
Write the definitions of the functions of the class myClass as
described in its definition.
Write a C++ statement that declares myObject1 to be a myClass
object and initializes its member variable x to 5.
Write a C++ statement that declares myObject2 to be a myClass
object and initializes its member variable x to 7.
Which of the following statements are valid? (Assume that myObject1
and myObject2 are as declared in Parts e and f.)
myObject1.printCount();
myObject1.printX();
myClass.printCount();
myClass.printX();
myClass::count++;

h.

//Line
//Line
//Line
//Line
//Line

1
2
3
4
5

Assume that myObject1 and myObject2 are as declared in Parts e and f.
What is the output of the following C++ code?
myObject1.printX();
cout << endl;
myObject1.incrementCount();
myClass::incrementCount();

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

730 |

Chapter 10: Classes and Data Abstraction

myObject1.printCount();
cout << endl;
myObject2.printCount();
cout << endl;
myObject2.printX();
cout << endl;
myObject1.setX(14);
myObject1.incrementCount();
myObject1.printX();
cout << endl;
myObject1.printCount();
cout << endl;
myObject2.printCount();
cout << endl;
28.

In Example 10-9, we designed the class die. Using this class,
declare an array named rolls of 100 components of type die. Write
C++ statements to roll each die of the array rolls, find and output the
highest number rolled and the number of times this number was rolled,
and find and output the number that is rolled the maximum number
of times together with its count. Also write a program to test your
statements. (1, 3)

PROGRAMMING EXERCISES
1.

Chapter 9 defined the struct studentType to implement the basic
properties of a student. Define the class studentType with the same
components as the struct studentType, and add member functions to
manipulate the data members. (Note that the data members of the class
studentType must be private.) Write a program to illustrate how to use
the class studentType.

2.

Write a program that uses the class houseType defined in Exercises 11 and 12.

3.

Write a program to illustrate how to use the class temporary, designed in
Exercises 13 and 14 of this chapter. Your program should not use the
statements given in Exercises 15 and 16. Also, your program must contain
statements that would ask the user to enter data of an object and use the
member function set to initialize the object.

4.

Write a program that converts a number entered in Roman numerals to a
positive integer. Your program should consist of a class, say, romanType.
An object of type romanType should do the following:
a.
b.
c.

Store the number as a Roman numeral.
Convert and store the number as a positive integer.
Print the number as a Roman numeral or positive integer as requested
by the user.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

731

The integer values of the Roman numerals are:

d.

5.

M

1000

D

500

C

100

L

50

X

10

V

5

I

1

Test your program using the following Roman numerals: MCXIV,
CCCLIX, MDCLXVI.

Design and implement a class dayType that implements the day of the
week in a program. The class dayType should store the day, such as Sun
for Sunday. The program should be able to perform the following operations
on an object of type dayType:
a.
b.
c.
d.
e.
f.

g.

Set the day.
Print the day.
Return the day.
Return the next day.
Return the previous day.
Calculate and return the day by adding certain days to the current day.
For example, if the current day is Monday and we add 4 days, the day to
be returned is Friday. Similarly, if today is Tuesday and we add 13 days,
the day to be returned is Monday.
Add the appropriate constructors.

6.

Write the definitions of the functions to implement the operations for the
class dayType as defined in Programming Exercise 5. Also, write a
program to test various operations on this class.

7.

This chapter defines the class clockType to implement time in a program. Add functions to this class so that a program that uses this class
can set only the hours, minutes, or seconds and retrieve only the hours,
minutes, or seconds. Also write a program to test your class.

8.

Enhance Programming Exercise 7 by adding functions to the class
clockType so that a program that uses this class can perform the following
operations:
a.
b.

Returns the elapsed time of the day of a clock in seconds.
Returns the remaining time of the day of a clock in seconds.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

732 |

c.

Chapter 10: Classes and Data Abstraction

Determine and output how far apart in time two clocks are? Output the
time in the form hr:min:sec.

Also write a program to test your class.
9.

Example 10-10 defined a class personType to store the name of a
person. The member functions that we included merely print the name
and set the name of a person. Redefine the class personType so that, in
addition to what the existing class does, you can:
a.
b.
c.
d.
e.

10.

a.

Set the first name only.
Set the last name only.
Store and set the middle name.
Check whether a given first name is the same as the first name of this person.
Check whether a given last name is the same as the last name of this person.
Write the definitions of the member functions to implement the operations for this class. Also, write a program to test various operations on this
class.
Some of the characteristics of a book are the title, author(s), publisher,
ISBN, price, and year of publication. Design a class bookType that
defines the book as an ADT.
Each object of the class bookType can hold the following
information about a book: title, up to four authors, publisher,
ISBN, price, and number of copies in stock. To keep track of the
number of authors, add another member variable.
ii.
Include the member functions to perform the various operations on
objects of type bookType. For example, the usual operations that
can be performed on the title are to show the title, set the title, and
check whether a title is the same as the actual title of the book.
Similarly, the typical operations that can be performed on the
number of copies in stock are to show the number of copies in
stock, set the number of copies in stock, update the number of
copies in stock, and return the number of copies in stock. Add
similar operations for the publisher, ISBN, book price, and authors.
Add the appropriate constructors and a destructor (if one is needed).
Write the definitions of the member functions of the class bookType.
Write a program that uses the class bookType and tests various
operations on the objects of the class bookType. Declare an array of
100 components of type bookType. Some of the operations that you
should perform are to search for a book by its title, search by ISBN, and
update the number of copies of a book.
i.

b.
c.

11.

In this exercise, you will design a class memberType.
a.

Each object of memberType can hold the name of a person, member
ID, number of books bought, and amount spent.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

b.

c.
d.
e.

|

733

Include the member functions to perform the various operations on the
objects of memberType—for example, modify, set, and show a person’s name. Similarly, update, modify, and show the number of books
bought and the amount spent.
Add the appropriate constructors.
Write the definitions of the member functions of memberType.
Write a program to test various operations of your class memberType.

12.

Using the classes designed in Programming Exercises 10 and 11, write a
program to simulate a bookstore. The bookstore has two types of customers:
those who are members of the bookstore and those who buy books from the
bookstore only occasionally. Each member has to pay a $10 yearly membership fee and receives a 5% discount on each book purchased.
For each member, the bookstore keeps track of the number of books
purchased and the total amount spent. For every eleventh book that a
member buys, the bookstore takes the average of the total amount of the
last 10 books purchased, applies this amount as a discount, and then resets
the total amount spent to 0.
Write a program that can process up to 1000 book titles and 500 members. Your
program should contain a menu that gives the user different choices to effectively run the program; in other words, your program should be user driven.

13.

The method sellProduct of the Juice Machine programming example
gives the user only two chances to enter enough money to buy the product.
Rewrite the definition of the method sellProduct so that it keeps prompting the user to enter more money as long as the user has not entered enough
money to buy the product. Also, write a program to test your method.

14.

Write the definition of a class, swimmingPool, to implement the properties of a swimming pool. Your class should have the instance variables to
store the length (in feet), width (in feet), depth (in feet), the rate (in gallons
per minute) at which the water is filling the pool, and the rate (in gallons per
minute) at which the water is draining from the pool. Add appropriate
constructors to initialize the instance variables. Also add member functions
to do the following: determine the amount of water needed to fill an empty
or partially filled pool, determine the time needed to completely or partially
fill or empty the pool, and add or drain water for a specific amount of time.

15.

(Tic-Tac-Toe) Write a program that allows two players to play the tic-tac-toe
game. Your program must contain the class ticTacToe to implement a
ticTacToe object. Include a 3-by-3 two-dimensional array, as a private
member variable, to create the board. If needed, include additional member
variables. Some of the operations on a ticTacToe object are printing the
current board, getting a move, checking if a move is valid, and determining the
winner after each move. Add additional operations as needed.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

734 |

16.

Chapter 10: Classes and Data Abstraction

The equation of a line in standard form is ax + by ¼ c, wherein both a and
b cannot be zero, and a, b, and c are real numbers. If b 6¼ 0, then –a/b is the
slope of the line. If a ¼ 0, then it is a horizontal line, and if b ¼ 0, then it is
a vertical line. The slope of a vertical line is undefined. Two lines are
parallel if they have the same slope or both are vertical lines. Two lines are
perpendicular if either one of the lines is horizontal and the other is vertical
or the product of their slopes is –1. Design the class lineType to store a
line. To store a line, you need to store the values of a (coefficient of x), b
(coefficient of y), and c. Your class must contain the following operations:
a.
b.

c.
d.
e.

If a line is nonvertical, then determine its slope.
Determine if two lines are equal. (Two lines a1x + b1y ¼ c1 and a2x +
b2y ¼ c2 are equal if either a1 ¼ a2, b1 ¼ b2, and c1 ¼ c2 or a1 ¼ ka2,
b1 ¼ kb2, and c1 ¼ kc2 for some real number k.)
Determine if two lines are parallel.
Determine if two lines are perpendicular.
If two lines are not parallel, then find the point of intersection.

Add appropriate constructors to initialize variables of lineType. Also write
a program to test your class.
17.

Typically, everyone saves money periodically for retirement, buying a
house, or for some other purposes. If you are saving money for retirement,
then the money you put in a retirement fund is tax sheltered and your
employer also makes some contribution into your retirement fund. In this
exercise, for simplicity, we assume that the money is put into an account that
pays a fixed interest rate, and money is deposited into the account at the end
of the specified period. Suppose that a person deposits R dollars m times a
year into an account that pays r % interest compounded m times a year for t
years.
Then ithe total accumulated at the end of t years is given by
h
R

ð1þr=mÞmt 1
r=m

. For example, suppose that you deposit $500 at the end of

each month into an account that pays 4.8% interest per year compounded
monthly for 25 years. Then the total money accumulated into the account is
500[(1 + 0.048/12)300 – 1]/(0.048/12) ¼ $289,022.42.
On the other hand, suppose that you want to accumulate S dollars in t years
and would like to know how much money, m times a year, you should
deposit into an account that pays r% interest compounded m times a year.
sðr=mÞ
.
The periodic payment is given by the formula ð1þr=mÞ
mt
1
Design a class that uses the above formulas to determine the total
accumulated into an account and the periodic deposits to accumulate a
specifc amount. Your class should have instance variables to store the
periodic deposit, the value of m, the interest rate, and the number of years

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

735

the money will be saved. Add appropriate constructors to initialize
instance variables, functions to set the values of the instance variables,
functions to retrieve the values of the instance variables, and functions to
do the necessary calculations and output results.
18.

Define the class bankAccount to implement the basic properties of a
bank account. An object of this class should store the following data:
Account holder’s name (string), account number (int), account type
(string, checking/saving), balance (double), and interest rate (double).
(Store interest rate as a decimal number.) Add appropriate member functions to manipulate an object. Use a static member in the class to
automatically assign account numbers. Also declare an array of 10 components of type bankAccount to process up to 10 customers and write a
program to illustrate how to use your class.

19.

Suppose you roll a set of n dice. Then the smallest sum is n and the largest sum
is 6n. For example, if n = 10, then the smallest sum is 6 and the largest sum
is 60. Let m be the desired sum of the numbers rolled. Then n  m  6n.
If n = 10, then 6  m  60. Write a program that uses the class die, of
Example 10-9, to roll 10 dice. (Use an array of size 10 to implement 10 dice.)
The program prompts the user to enter the desired sum and the number of
times the dice are to be rolled. The program outputs the number of times the
desired sum was rolled and the probability of rolling the desired sum. Test
run your program to roll the 10 dice 10,000, 100,000, 1,000,000,
10,000,000, and 100,000,000 times with the desired sums 6, 25, 40, and
60. How many times was the sum 6 rolled? How many times was the sum 60
rolled?

20.

Programming Exercise 19 prompted the user to input the number of times
the dice were to be rolled and the desired sum, and the program output the
number of times the desired sum occurred. Modify Programming Exercise
19 as follows: Suppose you roll 4 dice 1000 times. Store the sum of the
numbers rolled in each roll into an array, and then use this array to print a
bar graph (similar to the bar graph in the Programming Example Data
Comparison (Chapter 6)). Test run your program using 4, 5, and 6 dice
and the number of rolls 2500, 3000, and 5000. What type of curve does the
shape of your bar graph resemble?

21.

Write the definitions of the member functions of the class
integerManipulation not given in Example 10-11. Also add the following operations to this class: (1) Split the number into blocks of n-digit
numbers starting from right to left and find the sum of these n-digit
numbers. (Note the last block may not have n digits. If needed add
additional instance variables.) (2) Determine whether the number is prime.
(3) Find the prime factorization of the number.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
0

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

11
CHAPTER

ª HunThomas/Shutterstock.com

I NHERITANCE AND
COMPOSITION
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about inheritance

2.

Learn about derived and base classes

3.

Explore how to redefine the member functions of a base class

4.

Examine how the constructors of base and derived classes work

5.

Learn how the destuctors of base and derived classes work

6.

Learn how to construct the header file of a derived class

7.

Become aware of stream classes hierarchy

8.

Explore three types of inheritance: public, protected, and private

9.

Learn about composition (aggregation)

10.

Become familiar with the three basic principles of object-oriented design

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

738 |

Chapter 11: Inheritance and Composition

Chapter 10 introduced classes, abstract data types (ADT), and ways to implement ADT in
C++. By using classes, you can combine data and operations in a single unit. An object,
therefore, becomes a self-contained entity. Operations can directly access the data, but the
internal state of an object cannot be manipulated directly.
In addition to implementing ADT, classes have other features. For instance, classes can
create new classes from existing classes. This important feature encourages code reuse. In
C++, you can relate two or more classes in more than one way. Two common ways to
relate classes in a meaningful way are:
•
•

Inheritance (‘‘is-a’’ relationship)
Composition (aggregation) (‘‘has-a’’ relationship)

Inheritance
Suppose that you want to design a class, partTimeEmployee, to implement and
process the characteristics of a part-time employee. The main features associated with
a part-time employee are the name, pay rate, and number of hours worked. In
Example 10-10 (in Chapter 10), we designed a class to implement a person’s name.
Every part-time employee is a person. Therefore, rather than design the class
partTimeEmployee from scratch, we want to be able to extend the definition of
the class personType (from Example 10-10) by adding additional members (data
and/or functions).
Of course, we do not want to make the necessary changes directly to the class
personType—that is, edit the class personType and add and/or delete members.
In fact, we want to create the class partTimeEmployee without making any
physical changes to the class personType by adding only the members that are
necessary. For example, because the class personType already has members to store
the first name and last name, we will not include any such members in the class
partTimeEmployee. In fact, these member variables will be inherited from the
class personType. (We will design such a class in Example 11-3.)
In Chapter 10, we extensively studied and designed the class clockType to implement
the time of day in a program. The class clockType has three member variables to store
the hours, minutes, and seconds. Certain applications, in addition to the hours, minutes, and
seconds, might also require us to store the time zone. In this case, we would like to extend
the definition of the class clockType and create a class, extClockType, to accommodate this new information. That is, we want to derive the class extClockType by
adding a member variable—say, timeZone—and the necessary member functions to
manipulate the time (see Programming Exercise 1 at the end of this chapter). In C++, the
mechanism that allows us to accomplish this task is the principle of inheritance. Inheritance is
an ‘‘is-a’’ relationship; for instance, ‘‘every employee is a person.’’
Inheritance lets us create new classes from existing classes. The new classes that we create
from the existing classes are called the derived classes; the existing classes are called the

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

739

base classes. The derived classes inherit the properties of the base classes. So rather than
create completely new classes from scratch, we can take advantage of inheritance and
reduce software development complexity.
Each derived class, in turn, can become a base class for a future derived class. Inheritance can be either single inheritance or multiple inheritance. In single inheritance,
the derived class is derived from a single base class; in multiple inheritance, the
derived class is derived from more than one base class. This chapter concentrates on
single inheritance.
Inheritance can be viewed as a treelike, or hierarchical, structure wherein a base class is
shown with its derived classes. Consider the tree diagram shown in Figure 11-1.

shape

circle

rectangle

square

FIGURE 11-1

Inheritance hierarchy

In this diagram, shape is the base class. The classes circle and rectangle are
derived from shape, and the class square is derived from rectangle. Every
circle and every rectangle is a shape. Every square is a rectangle.
The general syntax of a derived class is:
class className: memberAccessSpecifier baseClassName
{
member list
};

in which memberAccessSpecifier is public, protected, or private. When no
memberAccessSpecifier is specified, it is assumed to be a private inheritance.
(We will discuss protected inheritance later in this chapter.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

740 |

Chapter 11: Inheritance and Composition

EXAMPLE 11-1
Suppose that we have defined a class called shape. The following statements specify that
the class circle is derived from shape, and it is a public inheritance.
class circle: public shape
{
.
.
.
};

On the other hand, consider the following definition of the class circle:
class circle: private shape
{
.
.
.
};

This is a private inheritance. In this definition, the public members of shape
become private members of the class circle. So any object of type circle
cannot directly access these members. The previous definition of circle is equivalent to:
class circle: shape
{
.
.
.
};

That is, if we do not use either the memberAccessSpecifier public or private,
the public members of a base class are inherited as private members by default.
The following facts about the base and the derived classes should be kept in mind.
1. The private members of a base class remain private to the base class;
hence, the members of the derived class cannot directly access them. In
other words, when you write the definitions of the member functions of
the derived class, even though the private members of the base class are
members of the derived class, the derived class cannot directly access them.
2. The public members of a base class can be inherited either as public
members or as private members by the derived class. That is, the
public members of the base class can become either public or
private members of the derived class. This means that what were
public members in the base class can either remain public members
or become private members in the derived class.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

741

3. The derived class can include additional members—data and/or functions.
4. The derived class can redefine the public member functions of the base
class. That is, in the derived class, you can have a member function with
the same name, number, and types of parameters as a function in the
base class, but with different code in the function body. However, this
redefinition applies only to the objects of the derived class, not to the
objects of the base class.
5. All member variables of the base class are also member variables of the
derived class. Similarly, the member functions of the base class (unless
redefined) are also member functions of the derived class. (Remember
Rule 1 when accessing a member of the base class in the derived class.)
The next sections describe two important issues related to inheritance. The first issue is the
redefinition of the member functions of the base class in the derived class. While discussing
this issue, we will also address how to access the private (data) members of the base class
in the derived class. The second key inheritance issue is related to the constructor. The
constructor of a derived class cannot directly access the private member variables of the
base class. Thus, we need to ensure that the private member variables that are inherited
from the base class are also initialized when a constructor of the derived class executes.

Redefining (Overriding) Member Functions of the Base Class
Suppose that a class derivedClass is derived from the class baseClass.
Further assume that both derivedClass and baseClass have some member
variables. It then follows that the member variables of the class derivedClass
are its own member variables, together with the member variables of baseClass.
Suppose that baseClass contains a function, print, that prints the values of the
member variables of baseClass. Now derivedClass contains member variables
in addition to the member variables inherited from baseClass. Suppose that
you want to include a function that prints the values of the member variables of
derivedClass. You can give any name to this function. However, in the class
derivedClass, you can also name this function print (the same name used by
baseClass). This is called redefining (or overriding) the member function of the
base class. Next, we illustrate how to redefine the member functions of a base class
with the help of an example.
To redefine a public member function of a base class in the derived class, the
corresponding function in the derived class must have the same name, number, and
types of parameters. In other words, the name of the function being redefined in the
derived class must have the same name and the same set of parameters. If the
corresponding functions in the base class and the derived class have the same name but
different sets of parameters, then this is function overloading in the derived class,
which is also allowed.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

742 |

Chapter 11: Inheritance and Composition

Consider the definition of the following class:
class rectangleType
{
public:
void setDimension(double l, double w);
//Function to set the length and width of the rectangle.
//Postcondition: length = l; width = w;
double getLength() const;
//Function to return the length of the rectangle.
//Postcondition: The value of length is returned.
double getWidth() const;
//Function to return the width of the rectangle.
//Postcondition: The value of width is returned.
double area() const;
//Function to return the area of the rectangle.
//Postcondition: The area of the rectangle is
//
calculated and returned.
double perimeter() const;
//Function to return the perimeter of the rectangle.
//Postcondition: The perimeter of the rectangle is
//
calculated and returned.
void print() const;
//Function to output the length and width of
//the rectangle.
rectangleType();
//Default constructor
//Postcondition: length = 0; width = 0;
rectangleType(double l, double w);
//Constructor with parameters
//Postcondition: length = l; width = w;
private:
double length;
double width;
};

Figure 11-2 shows the UML class diagram of the class rectangleType.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

743

rectangleType
–length: double
–width: double
+setDimension(double, double): void
+getLength() const: double
+getWidth() const: double
+area() const: double
+perimeter() const: double
+print() const: void
+rectangleType()
+rectangleType(double, double)

FIGURE 11-2

UML class diagram of the class rectangleType

The class rectangleType has 10 members.
Suppose that the definitions of the member functions of the class rectangleType are
as follows:
void rectangleType::setDimension(double l, double w)
{
if (l >= 0)
length = l;
else
length = 0;
if (w >= 0)
width = w;
else
width = 0;
}
double rectangleType::getLength() const
{
return length;
}
double rectangleType::getWidth() const
{
return width;
}
double rectangleType::area() const
{
return length * width;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

744 |

Chapter 11: Inheritance and Composition

double rectangleType::perimeter() const
{
return 2 * (length + width);
}
void rectangleType::print() const
{
cout << "Length = " << length
<< "; Width = " << width;
}
rectangleType::rectangleType(double l, double w)
{
setDimension(l, w);
}
rectangleType::rectangleType()
{
length = 0;
width = 0;
}

Now consider the definition of the following class boxType, derived from the
class rectangleType:
class boxType: public rectangleType
{
public:
void setDimension(double l, double w, double h);
//Function to set the length, width, and height
//of the box.
//Postcondition: length = l; width = w; height = h;
double getHeight() const;
//Function to return the height of the box.
//Postcondition: The value of height is returned.
double area() const;
//Function to return the surface area of the box.
//Postcondition: The surface area of the box is
//
calculated and returned.
double volume() const;
//Function to return the volume of the box.
//Postcondition: The volume of the box is
//
calculated and returned.
void print() const;
//Function to output the length, width, and height of a box.
boxType();
//Default constructor
//Postcondition: length = 0; width = 0; height = 0;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

745

boxType(double l, double w, double h);
//Constructor with parameters
//Postcondition: length = l; width = w; height = h;
private:
double height;
};

Figure 11-3 shows the UML class diagram of the class boxType and the inheritance
hierarchy.

boxType
–height: double
+setDimension(double, double, double): void
+getHeight() const: double
+area() const: double
+volume() const: double
+print() const: void
+boxType()
+boxType(double, double, double)

FIGURE 11-3

rectangleType

boxType

UML class diagram of the class boxType and the inheritance hierarchy

From the definition of the class boxType, it is clear that the class boxType
is derived from the class rectangleType, and it is a public inheritance. Therefore,
all public members of the class rectangleType are public members of the class
boxType. The class boxType also overrides (redefines) the functions print and
area.
In general, while writing the definitions of the member functions of a derived class to
specify a call to a public member function of the base class, we do the following:
•

If the derived class overrides a public member function of the base class,
then to specify a call to that public member function of the base class,
you use the name of the base class, followed by the scope resolution
operator, ::, followed by the function name with the appropriate parameter list. For example, to call the function area of the class
rectangleType the statement is: rectangleType::area().
• If the derived class does not override a public member function of the
base class, you may specify a call to that public member function by
using the name of the function and the appropriate parameter list. (See
the following note for member functions of the base class that are overloaded in the derived class.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

746 |

Chapter 11: Inheritance and Composition

If a derived class overloads a public member function of the base class, then while
writing the definition of a member function of the derived class, to specify a call to
that (overloaded) member function of the base class (depending on the compiler), you
might need to use the name of the base class, followed by the scope resolution
operator, ::, followed by the function name with the appropriate parameter list. See the
definition of the function setDimension (of the class boxType), given later in
this section, for an example.

Next, let us write the definition of the member function print of the class boxType.
The class boxType has three member variables: length, width, and height. The
member function print of the class boxType prints the values of these member
variables. To write the definition of the function print of the class boxType, keep in
mind the following:
•

The member variables length and width are private members of
the class rectangleType, so they cannot be directly accessed in the
class boxType. Therefore, when writing the definition of the function
print of the class boxType, we cannot access length and width
directly.
• The member variables length and width of the class rectangleType
are accessible by the class boxType only through the public member
functions of the class rectangleType. Therefore, when writing the
definition of the member function print of the class boxType, we must
call the member function print of the class rectangleType to print the
values of length and width. After printing the values of length and
width, we can directly output the value of height because it is a member of
class boxType.
To call the member function print of rectangleType in the definition of the
member function print of boxType, we must use the following statement:
rectangleType::print();

This statement ensures that we call the member function print of the base class
rectangleType, not of the class boxType.
The definition of the member function print of the class boxType is:
void boxType::print() const
{
rectangleType::print(); //to print the length and width
cout << "; Height = " << height;
}

Let us write the definitions of the remaining member functions of the class boxType.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

747

The definition of the function setDimension is:
void boxType::setDimension(double l, double w, double h)
{
rectangleType::setDimension(l, w);
if (h >= 0)
height = h;
else
height = 0;
}

Notice that in the preceding definition of the function setDimension, a call to the
member function setDimension of the class rectangleType is preceded by the
name of the class and the scope resolution operator, even though the class boxType
overloads—not overrides—the function setDimension.
The definition of the function getHeight is:
double boxType::getHeight() const
{
return height;
}

The member function area of the class boxType determines the surface area of a box.
To determine the surface area of a box, we need to access the length and width of the box, which
are declared as private members of the class rectangleType. Therefore, we use the
member functions getLength and getWidth of the class rectangleType to retrieve
the length and width, respectively. Because the class boxType does not contain any member
functions that have the names getLength or getWidth, we can call these member functions
of the class rectangleType without coupling them to the name of the base class.
double boxType::area() const
{
return 2 * (getLength() * getWidth()
+ getLength() * height
+ getWidth() * height);
}

The member function volume of the class boxType determines the volume of a box.
To determine the volume of a box, you multiply the length, width, and height of the
box or multiply the area of the base of the box by its height. Let us write the definition of
the member function volume by using the second alternative. To do this, you can use
the member function area of the class rectangleType to determine the area of the
base. Because the class boxType overrides the member function area, to specify a call
to the member function area of the class rectangleType, we use the name of the
base class and the scope resolution operator, as shown in the following definition:
double boxType::volume() const
{
return rectangleType::area() * height;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

748 |

Chapter 11: Inheritance and Composition

In the next section, we discuss how to specify a call to the constructor of the base class
when writing the definition of a constructor of the derived class.

Constructors of Derived and Base Classes
A derived class can have its own private member variables, so a derived class can
explicitly include its own constructors to initialize them. When we declare a
derived class object, this object inherits the members of the base class, but the
derived class object cannot directly access the private (data) members of the base
class. The same is true for the member functions of a derived class. That is, the
member functions of a derived class cannot directly access the private members of
the base class.
As a consequence, the constructors of a derived class can (directly) initialize only the
(public data) members inherited from the base class of the derived class. Thus, when
a derived class object is declared, it must also trigger the execution of one of the base
class’s constructors. Furthermore, this triggering of the base class’s constructor is
specified in the heading of the definition of a derived class constructor.
First, let us write the definition of the default constructor of the class boxType.
Recall that, if a class contains a default constructor and no values are specified when
the object is declared, the default constructor executes and initializes the object. Because
the class rectangleType contains the default constructor, we do not specify any
constructor of the base class when writing the definition of the default constructor of the
class boxType.
boxType::boxType()
{
height = 0.0;
}

To write the definition of class boxType constructor with parameters, we first write
the class boxType constructor heading including all of the parameters needed for both
the base class and derived class constructors; that is, all the parameters needed for both
boxType and rectangleType. Then, to trigger the execution of the base class
constructor with parameters, we add a colon (:) to the heading followed by the name
of the constructor of the base class with its parameters in the heading of the definition
of the constructor of the derived class. In effect, we ‘‘tack on’’ the base class
constructor to the derived class constructor via a colon. The derived class constructor
gets all of the parameters needed for itself and the base class constructor, then passes on
the base class parameters to its constructor.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

749

Consider the following definition of the constructor with parameters of the class boxType:
boxType::boxType(double l, double w, double h)
: rectangleType(l, w)
{
if (h >= 0)
height = h;
else
height = 0;
}

In this definition, we specify the constructor of rectangleType with two parameters.
When this constructor of boxType executes, it triggers the execution of the constructor
of the class rectangleType with two parameters of type double.
Consider the following statements:
rectangleType myRectangle(5.0, 3.0);
boxType myBox(6.0, 5.0, 4.0);

//Line 1
//Line 2

The statement in Line 1 creates the rectangleType object myRectangle. Thus, the
object myRectangle has two member variables: length and width. The statement in
Line 2 creates the boxType object myBox. Thus, the object myBox has three member
variables: length, width, and height (see Figure 11-4).

myRectangle

myBox
length

5.0

width

3.0

length

6.0

width

5.0

height

FIGURE 11-4

4.0

Objects myRectangle and myBox

Consider the following statements:
myRectangle.print();
cout << endl;
myBox.print();
cout << endl;

//Line
//Line
//Line
//Line

3
4
5
6

In the statement in Line 3, the member function print of the class rectangleType
is executed. In the statement in Line 5, the function print associated with the class
boxType is executed. Recall that, if a derived class overrides a member function of the
base class, the redefinition applies only to the objects of the derived class. Thus, the
output of the statement in Line 3 is (as defined in the class rectangleType):
Length = 5.0; Width = 3.0

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

750 |

Chapter 11: Inheritance and Composition

The output of the statement in Line 5 is (as defined in the class boxType):
Length = 6.0; Width = 5.0; Height = 4.0

When the object myBox enters its scope, the constructors of both the classes
rectangleType and boxType execute. Note that the constructors of a base class are not
inherited by a derived class. So if a base class contains private data members, only base class
constructors can construct the base class, including the base class part of a derived class. In this
case, derived class constructors can only construct the additional members specified in its
definition. This means that a call to a base class constructor must be included in the definition
of a constructor of the derived class.
When a derived class constructor executes, first a constructor of the base class executes to
initialize the data members inherited from the base class, and then the constructor of the
derived class executes to initialize the data members declared by the derived class. So first,
the constructor of the class rectangleType executes to initialize the instance variables length and width, and then the constructor of the class boxType executes to
initialize the instance variable height.
The program in Example 11-2 shows how the objects of a base class and a derived class behave.
EXAMPLE 11-2
In this example, we write a program to solve the following problems:
1. Jim’s lawn care store specializes in putting up fences around small farms
and home lawns and fertilizing the farms and lawns. For simplicity, we
assume that the yards and farms are rectangular. In order to put up the
fence, the program needs to know the perimeter and to fertilize, the
program needs to know the area. We will write a program that uses
the class rectangle to store the dimensions of a yard or a farm. The
program will also prompt the user to input the dimensions (in feet) of a
yard or farm, the cost (per foot) to put up the fence, and the cost (per
square foot) to fertilize the area. The program will then output the cost
of putting up the fence and fertilizing the area.
2. Linda’s gift store specializes in wrapping small packages. For simplicity, we
assume that a package is in the shape of a box with a specific length, width, and
height. We will write a program that uses the class boxType to store the
dimensions of a package. The program will ask the user to input the dimensions of the package and the cost (per square foot) to wrap the package. The
program will then output the cost of wrapping the package. (The program
assumes that the minimum cost of wrapping a package is $1.00.)
Consider the following C++ program:
#include
#include
#include
#include

<iostream>
<iomanip>
"rectangleType.h"
"boxType.h"

//Line
//Line
//Line
//Line

1
2
3
4

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

751

using namespace std;

//Line 5

int main()
{
rectangleType yard;
double fenceCostPerFoot;
double fertilizerCostPerSquareFoot;
double length, width;
double billingAmount;

//Line
//Line
//Line
//Line
//Line
//Line
//Line

6
7
8
9
10
11
12

cout << fixed << showpoint << setprecision(2);

//Line 13

cout << "Line 14: Enter the length and width of the "
<< "yard (in feet): ";
cin >> length >> width;
cout << endl;

//Line 14
//Line 15
//Line 16

yard.setDimension(length, width);

//Line 17

cout << "Line 18: Enter the cost of fence "
<< "(per foot): $";
cin >> fenceCostPerFoot;
cout << endl;

//Line 18
//Line 19
//Line 20

cout << "Line 21: Enter the cost of fertilizer "
<< "(per square foot): $";
cin >> fertilizerCostPerSquareFoot;
cout << endl;

//Line 21
//Line 22
//Line 23

billingAmount = yard.perimeter() * fenceCostPerFoot
+ yard.area() * fertilizerCostPerSquareFoot;

//Line 24

cout << "Line 25: Amount due: $" << billingAmount
<< endl;

//Line 25

boxType package;
double height;
double wrappingCostPerSquareFeet;

//Line 26
//Line 27
//Line 28

cout << "Line 29: Enter the length, width, and height "
<< "of the package (in feet): ";
//Line 29
cin >> length >> width >> height;
//Line 30
cout << endl;
//Line 31
package.setDimension(length, width, height);

//Line 32

cout << "Line 33: Enter the cost (25 to 50 cents) of "
<< "wrapping per square foot: ";
cin >> wrappingCostPerSquareFeet;
cout << endl;

//Line 33
//Line 34
//Line 35

billingAmount = wrappingCostPerSquareFeet
* package.area() / 100;

//Line 36

if (billingAmount < 1.00)
billingAmount = 1.00;

//Line 37
//Line 38

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

752 |

Chapter 11: Inheritance and Composition

cout << "Line 39: Amount due: $" << billingAmount
<< endl;

//Line 39

return 0;

//Line 40
//Line 41

}

Sample Run: In this sample run, the user input is shaded.
Line 14: Enter the length and width of the yard (in feet): 70 50
Line 18: Enter the cost of fence (per foot): $10.00
Line 21: Enter the cost of fertilizer (per square foot): $0.25
Line 25: Amount due: $3275.00
Line 29: Enter the length, width, and height of the package (in feet): 3 2 0.25
Line 33: Enter the cost (25 to 50 cents) of wrapping per square foot: 25
Line 39: Amount due: $3.63

The preceding program works as follows: The statements in Lines 8 to 12 and 26 to 28 declare
the variables and objects used in the program. (Note that the statement in Line 8 creates the
object yard, and the statement in Line 26 creates the object package.) The statement in
Line 14 prompts the user to input the length and width of the yard and the statement in Line
15 inputs these values in the variables length and width, respectively. The statement in
Line 17 uses the function setDimension to initialize the instance variables of the object
yard. The statements in Lines 18 to 23 prompt the user to input the cost of putting up the
fence and fertilizing the yard, and they store the values in the variables fenceCostPerFoot
and fertilizerCostPerSquareFoot. The statement in Line 24 calculates the billing
amount. Note that this statement uses the functions perimeter and area of the class
rectangleType to compute the length of the fence and the area of the yard. Then the
statement in Line 25 outputs the billing amount.
The statement in Line 29 prompts the user to input the length, width, and height of the
package and the statement in Line 30 inputs these values in the variables length, width, and
height, respectively. The statement in Line 32 uses the function setDimension to initialize
the instance variables of the object package. The statement in Line 33 prompts the user to
input the cost (per square foot) of wrapping the package and the statement in Line 34 stores
the cost in the variable wrappingCostPerSquareFeet. The statement in Line 36
calculates the billing amount. Note that this statement uses the function area of the class
boxType to compute the surface area of the package. The statement in Line 37 checks if
the value of the billing amount is less than $1.00, and the statement in Line 38 sets the value
of the billing amount to 1.00. Then the statement in Line 39 outputs the billing amount.
Note that in this program the length of the yard is 70 feet and the width is 50 feet.
So the perimeter of the yard is 2 * (70 + 50) = 240 feet, and the area of the yard is
70 * 50 = 3500 square feet. The total cost of putting up the fence and fertilizing the
yard ¼ $(240 * 10 + 3500 * 0.25) = $(2400 + 875) = $3275.00.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

753

Next, the length, width, and height of the package are 3 feet, 2 feet, and 0.25 feet. So
the surface area of the package ¼ 2 * ( 3 * 2 + 3 * 0.25 + 2 * 0.25) = 14.50 square
feet. Therefore, the cost of wrapping the package is $14.50 * 25 / 100 = $3.625 =
$3.63 (rounded to two decimal places).
Now both the classes rectangleType and boxType have the functions setDimension
and area. It follows that the program correctly calls the function setDimension of
each class to initialize the objects yard and package. Similarly, in the case of yard,
the function area of the class rectangleType is called to calculate the area of the
yard, and in the case of package, the function area of the class boxType is called
to calculate the surface area of the package.
From the output of this program, it follows that the redefinition of the functions
setDimension and area in the class boxType applies only to an object of the type
boxType.

The Web site accompanying this book contains a program in the folder
Ch11_InheritanceAndConstructors that further illustrates how to use the classes
rectangleType and boxType in a program.

(Constructors with default parameters and the inheritance hierarchy) Recall that a class can
have a constructor with default parameters. Therefore, a derived class can also have a
constructor with default parameters. For example, suppose that the definition of the
class rectangleType is as shown below. (To save space, these definitions have no
documentation.)

class rectangleType
{
public:
void setDimension(double l, double w);
double getLength() const;
double getWidth() const;
double area() const;
double perimeter()const;
void print() const;
rectangleType(double l = 0, double w = 0);
//Constructor with default parameters
private:
double length;
double width;
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

754 |

Chapter 11: Inheritance and Composition

Suppose the definition of the constructor is:

rectangleType::rectangleType(double l, double w)
{
setDimension(l, w);
}
Now suppose that the definition of the class boxType is:

class boxType: public rectangleType
{
public:
void setDimension(double l, double w, double h);
double getHeight()const;
double area() const;
double volume() const;
void print() const;
boxType(double l = 0, double w = 0, double h = 0);
//Constructor with default parameters
private:
double height;
};
You can write the definition of the constructor of the class boxType as follows:

boxType::boxType(double l, double w, double h)
: rectangleType(l, w)
{
if (h >= 0)
height = h;
else
height = 0;
}
Notice that this definition also takes care of the default constructor of the class boxType.

Suppose that a base class, baseClass, has private member variables and constructors.
Further suppose that the class derivedClass is derived from baseClass, and
derivedClass has no member variables. Therefore, the member variables of
derivedClass are the ones inherited from baseClass. A constructor cannot be called
like other functions, and the member variables of baseClass cannot be directly accessed
by the member functions of derivedClass. To guarantee the initialization of the inherited
member variables of an object of type derivedClass, even though derivedClass
has no member variables, it must have the appropriate constructors. A constructor (with
parameters) of derivedClass merely issues a call to a constructor (with parameters)
of baseClass. Therefore, when you write the definition of the constructor (with parameters)
of derivedClass, the heading of the definition of the constructor contains a call to an
appropriate constructor (with parameters) of baseClass, and the body of the constructor
is empty—that is, it contains only the opening and closing braces.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

755

EXAMPLE 11-3
Suppose that you want to define a class to group the attributes of an employee. There are
both full-time and part-time employees. Part-time employees are paid based on the number
of hours worked and an hourly rate. Suppose that you want to define a class to keep track of a
part-time employee’s information, such as name, pay rate, and hours worked. You can
then print the employee’s name together with his or her wages. Because every employee is a
person and Example 10-10 (Chapter 10) defined the class personType to store the first
name and the last name together with the necessary operations on name, we can define a
class partTimeEmployee based on the class personType. You can also redefine the
print function to print the appropriate information.
class partTimeEmployee: public personType
{
public:
void print() const;
//Function to output the first name, last name, and
//the wages.
//Postcondition: Outputs
//
firstName lastName wages are $$$$.$$
double calculatePay() const;
//Function to calculate and return the wages.
//Postcondition: Pay is calculated and returned
void setNameRateHours(string first, string last,
double rate, double hours);
//Function to set the first name, last name, payRate,
//and hoursWorked according to the parameters.
//Postcondition: firstName = first; lastName = last;
//
payRate = rate; hoursWorked = hours
partTimeEmployee(string first = "", string last = "",
double rate = 0, double hours = 0);
//Constructor with parameters
//Sets the first name, last name, payRate, and hoursWorked
//according to the parameters. If no value is specified,
//the default values are assumed.
//Postcondition: firstName = first; lastName = last;
//
payRate = rate; hoursWorked = hours
private:
double payRate;
//variable to store the pay rate
double hoursWorked; //variable to store the hours worked
};

Figure 11-5 shows the UML class diagram of the class partTimeEmployee and the
inheritance hierarchy.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

756 |

Chapter 11: Inheritance and Composition

partTimeEmployee
–payRate: double
–hoursWorked: double
+print() const: void
+calculatePay() const: double
+setNameRateHours(string, string,
double, double ): void
+partTimeEmployee(string = "", string = "",
double = 0, double = 0)

FIGURE 11-5

personType

partTimeEmployee

UML class diagram of the class partTimeEmployee and inheritance hierarchy

The definitions of the member functions of the class partTimeEmployee are as follows:
void partTimeEmployee::print() const
{
personType::print(); //print the name of the employee
cout << "'s wages are: $" << calculatePay() << endl;
}
double partTimeEmployee::calculatePay() const
{
return (payRate * hoursWorked);
}
void partTimeEmployee::setNameRateHours(string first,
string last, double rate, double hours)
{
personType::setName(first, last);
payRate = rate;
hoursWorked = hours;
}
//Constructor
partTimeEmployee::partTimeEmployee(string first, string last,
double rate, double hours)
: personType(first, last)
{
if (rate >= 0)
payRate = rate;
else
payRate = 0;
if (hours >= 0)
hoursWorked = hours;
else
hoursWorked = 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

757

Destructors in a Derived Class
Recall from Chapter 10 that a class can have a destructor. As we will see in the next
chapter, destructors are typically used to deallocate dynamic memory allocated to the
objects of a class. (A memory space that is allocated during execution time is called a
dynamic memory space. The next chapter explains how to create and work with dynamic
memory.) Suppose that a base class and its derived class have destructors. When a derived
class object goes out of scope, it automatically invokes its destructor. When the destructor
of the derived class executes, it automatically invokes the destructor of the base class.
So when writing the definition of the destructor of the derived class, an explict call to
the destructor of the base class is not needed. Furthermore, when the destructor of the
derived class executes, it executes its own code first and then calls the destructor of the
base class. For example, suppose that class three is derived from class two, class
two is derived from class one, and these classes have destructors. When an object of
class three goes out of scope, first the destructor of class three executes, then the
destructor of class two executes, and finally, the destructor of class one executes.
That is, the destructors execute in the reverse order.
HEADER FILE OF A DERIVED CLASS
The previous section explained how to derive new classes from previously defined classes.
To define new classes, you create new header files. The base classes are already defined,
and header files contain their definitions. Thus, to create new classes based on the
previously defined classes, the header files of the new classes contain commands that tell
the computer where to look for the definitions of the base classes. Recall that to include a
system-provided header file, such as iostream, in a user program, you enclose the
header file between angular brackets; to include a user-defined header file in a program,
you enclose the header file between double quotation marks.

Suppose that the definition of the class personType is placed in the header file
personType.h. To create the definition of the class partTimeEmployee, the
header file—say, partTimeEmployee.h—must contain the preprocessor directive:
#include "personType.h"

before the definition of the class partTimeEmployee. To be specific, the header file
partTimeEmployee.h is as shown below.
//Header file partTimeEmployee
#include "personType.h"
class partTimeEmployee: public personType
{
public:
void print() const;
//Function to output the first name, last name, and
//the wages.
//Postcondition: Outputs
//
firstName lastName wages are $$$$.$$
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

758 |

Chapter 11: Inheritance and Composition

double calculatePay() const;
//Function to calculate and return the wages.
//Postcondition: Pay is calculated and returned
void setNameRateHours(string first, string last,
double rate, double hours);
//Function to set the first name, last name, payRate,
//and hoursWorked according to the parameters.
//Postcondition: firstName = first; lastName = last;
//
payRate = rate; hoursWorked = hours
partTimeEmployee(string first = "", string last = "",
double rate = 0, double hours = 0);
//Constructor with parameters
//Sets the first name, last name, payRate, and hoursWorked
//according to the parameters. If no value is specified,
//the default values are assumed.
//Postcondition: firstName = first; lastName = last;
//
payRate = rate; hoursWorked = hours
private:
double payRate;
//variable to store the pay rate
double hoursWorked; //variable to store the hours worked
};

The definitions of the member functions of the class partTimeEmployee can be
placed in a separate file.

Multiple Inclusions of a Header File
The previous section discussed how to create the header file of a derived class. To
include a header file in a program, you use the preprocessor command. Recall that
before a program is compiled, the preprocessor first processes the program. Consider
the following header file:
//Header file test.h
const int ONE = 1;
const int TWO = 2;

Suppose that the header file testA.h includes the file test.h in order to use the
identifiers ONE and TWO and looks as follows:
//Header file testA.h
#include "test.h"
.
.
.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

759

Now, consider the following program code:
//Program headerTest.cpp
#include "test.h"
#include "testA.h"
.
.
.

When this program code is compiled, it is first processed by the preprocessor. The
preprocessor first includes the header file test.h and then the header file testA.h. When
the header file testA.h is included, because it contains the preprocessor directive
#include "test.h", the header file test.h is included twice in the program. The second
inclusion of the header file test.h results in compile-time errors, such as the identifier ONE
already being declared. This problem occurs because the first inclusion of the header file
test.h has already defined the variables ONE and TWO. To avoid multiple inclusion of a file
in a program, we use certain preprocessor commands in the header file. Let us first rewrite
the header file test.h using these preprocessor commands and then explain their meaning.
//Header file test.h
#ifndef H_test
#define H_test
const int ONE = 1;
const int TWO = 2;
#endif

a. #ifndef H_test means ‘‘if not defined H_test’’
b. #define H_test means ‘‘define H_test’’
c. #endif means ‘‘end if’’
Here, H_test is a preprocessor identifier.
The effect of these commands is as follows: If the identifier H_test is not defined, we
must define the identifier H_test and let the remaining statements between #define
and #endif pass through the compiler. If the header file test.h is included the second
time in the program, the statement #ifndef fails and all of the statements until #endif
are skipped. In fact, all header files are written using similar preprocessor commands.
EXAMPLE 11-4
In Chapter 10, we defined the class integerManipulation to perform various operations, such as reverse the number and count the even digits, odd digits, and zeros on an integer.
In this example, we extend this class so that a prime factorization of an integer between 2 and
27 * 1013 can be determined and printed. In order to find the prime factorization of an integer,
we create an array of the first 125,000 prime numbers and then use these prime numbers to
find the factorization (see the related Programming Exercise 19, in Chapter 8).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

760 |

Chapter 11: Inheritance and Composition

The following class extends the definition of the class integerManipulation using
public inheritance.
#ifndef primeFactorization_H
#define primeFactorization_H
#include "integerManipulation.h"
class primeFactorization: public integerManipulation
{
public:
void factorization();
//Function to output the prime factorization of num
//Postcondition: Prime factorization of num is printed;
primeFactorization(long long n = 0);
//Constructor with a default parameter.
//The instance variables of the base class are set according
//to the parameters and the array first125000Primes is
//created.
//Postcondition: num = n; revNum = 0; evenscount = 0;
//
oddsCount = 0; zerosCount = 0;
//
first125000Primes = first 125000 prime numbers.
private:
long long first125000Primes [125000];
void first125000PrimeNum(long long list [], int length);
//Function to determine and store the first 125000 prime
//integers.
//Postcondition: The first 125000 prime numbers are
//
determined and stored in the array first125000Primes;
//Add additional functions as needed.
};
#endif

In the definition of the class primeFactorization, add additional member functions as private members as needed. Next we only give the definition of the constructor
and leave the definitions of the other functions as an exercise (see Programming Exercise
14 at the end of this chapter).
primeFactorization::primeFactorization(long long n)
: integerManipulation(n)
{
first125000PrimeNum(first125000Primes, 125000);
}
void primeFactorization::factorization()
{
//See Programming Exercise 14 at the end of this chapter.
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

761

The following program uses class primeFactorization to find the prime factorization of a number. Note that this program does not check whether the user entered a valid
number. The program that you will write in Programing Exercise 14, must ensure that
the user enters a valid number.
#include <iostream>
#include "primeFactorization.h"
using namespace std;
int main()
{
primeFactorization number;
long long num;
cout << "Enter an integer between 2 and "
<< "270,000,000,000,000: ";
cin >> num;
cout << endl;
number.setNum(num);
number.factorization();
return 0;
}//end main

Sample Runs: In these sample runs, the user input is shaded.
Sample Run1:
Enter an integer between 2 and 270,000,000,000,000: 898329840343
898329840343 is not a prime number. Its factorization is:
898329840343 = 13 * 237701 * 290711

Sample Run2:
Enter an integer between 2 and 270,000,000,000,000: 24578290120000
24578290120000 is not a prime number. Its factorization is:
24578290120000 = 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5 * 5 * 5 * 614457253

Sample Run3:
Enter an integer between 2 and 270,000,000,000,000: 54149933
54149933 is a prime number. Its factorization is:
54149933 = 54149933

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

762 |

Chapter 11: Inheritance and Composition

C++ Stream Classes
Chapter 3 described in detail how to perform input/output (I/O) using standard I/O
devices and file I/O. In particular, you used the object cin, the extraction operator >>,
and functions such as get and ignore to read data from the standard input device. You
also used the object cout and the insertion operator << to send output to the standard
output device. To use cin and cout, the programs included the header file iostream,
which includes the definitions of the classes istream and ostream. Moreover, for file
I/O, the programs included the header file fstream, and they used objects of type
ifstream for file input and objects of type ofstream for file output. This section
briefly describes how stream classes are related and implemented in C++.
In C++, stream classes are implemented using the inheritance mechanism, as shown in
Figure 11-6.

ios

FIGURE 11-6

istream

ostream

ifstream

ofstream

C++ stream classes hierarchy

Figure 11-6 shows the stream classes that we have encountered in previous chapters.
From this figure, it follows that the class ios is the base class for all stream classes.
Classes istream and ostream are directly derived from the class ios. The class
ifstream is derived from the class istream, and the class ofstream is derived
from the class ostream. Moreover, using the mechanism of multiple inheritance, the
class iostream (not to be confused with the header file iostream—these are separate
things) and the class fstream are derived from the class iostream. (The classes
iostream and fstream are not discussed in this book.)
The class ios contains formatting flags and member functions to access and/or modify the
setting of these flags. To identify the I/O status, the class ios contains an integer status word.
This integer status word provides a continuous update that reports the status of the stream.
The classes istream and ostream are responsible for providing the operations for
the data transfer between memory and devices. The class istream defines the extraction operator, >>, and functions such as get and ignore. The class ostream defines
the insertion operator, <<, which is used by the object cout.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

763

The class ifstream is derived from the class istream to provide the file input
operations. Similarly, the class ofstream is derived from the class ostream to
provide the file output operations. Objects of type ifstream are used for file input;
objects of type ofstream are used for file output. The header file fstream contains the
definitions of the classes ifstream and ofstream.

Protected Members of a Class
The private members of a class are private to the class and cannot be directly accessed
outside of the class. Only member functions of that class can access the private
members. As discussed previously, the derived class cannot directly access the private
members of a base class. However, it is sometimes necessary (say, for efficiency and/or to
simplify the code) for a derived class to directly access a private member of a base class.
If you make a private member become public, then anyone can access that member.
Recall that the members of a class are classified into three categories: public, private,
and protected. A derived class can directly access the protected members of a
base class. So, for a base class to give access to a member to its derived class and still
prevent its direct access outside of the class, you must declare that member under
memberAccessSpecifier protected. Thus, the accessibility of a protected
member of a class is between public and private.
To summarize, if a member of a base class needs to be accessed by a derived class, that
member is declared under memberAccessSpecifier protected.

Inheritance as public, protected, or private
Suppose class B is derived from class A. Then, B cannot directly access the private
members of A. That is, the private members of A are hidden in B. What about the
public and protected members of A? This section gives the rules that generally apply
when accessing the members of a base class.
Consider the following statement:
class B: memberAccessSpecifier A
{
.
.
.
};

In this statement, memberAccessSpecifier is either public, protected, or private.
1. If memberAccessSpecifier is public—that is, the inheritance is
public—then:
The public members of A are public members of B. They can be
directly accessed in class B.
b. The protected members of A are protected members of B. They
can be directly accessed by the member functions (and friend
functions) of B.

a.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

764 |

Chapter 11: Inheritance and Composition

c. The private members of A are hidden in B. They cannot be
directly accessed in B. They can be accessed by the member
functions (and friend functions) of B through the public or
protected members of A.
2. If memberAccessSpecifier is protected—that is, the inheritance
is protected—then:
The public members of A are protected members of B. They can
be accessed by the member functions (and friend functions) of B.
b. The protected members of A are protected members of B. They
can be accessed by the member functions (and friend functions) of B.
c. The private members of A are hidden in B. They cannot be
directly accessed in B. They can be accessed by the member
functions (and friend functions) of B through the public or
protected members of A.
3. If memberAccessSpecifier is private—that is, the inheritance is
private—then:
a.

The public members of A are private members of B. They can
be accessed by the member functions (and friend functions) of B.
b. The protected members of A are private members of B. They can
be accessed by the member functions (and friend functions) of B.
c. The private members of A are hidden in B. They cannot be
directly accessed in B. They can be accessed by the member
functions (and friend functions) of B through the public or
protected members of A.

a.

Chapter 13 describes friend functions.

Example 11-5 illustrates how the member functions of a derived class can directly access a
protected member of the base class.
EXAMPLE 11-5

(Accessing protected Members in the Derived Class)
Consider the following definition of the class bClass:
class bClass
{
public:
void setData(double);
void setData(char, double);
void print() const;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance

|

765

bClass(char ch = '*', double u = 0.0);
protected:
char bCh;
private:
double bX;
};

The definition of the class bClass contains a protected member variable bCh of
type char and a private member variable bX of type double. It also contains an
overloaded member function setData. One version is used to set both member variables; the other version is used to set only the private member variable. The class also
has a constructor with default parameters. Suppose that the definitions of the member
functions and the constructor are as follows:
void bClass::setData(double u)
{
bX = u;
}
void bClass::setData(char ch, double u)
{
bCh = ch;
bX = u;
}
void bClass::print() const
{
cout << "Base class: bCh = " << bCh << ", bX = " << bX
<< endl;
}
bClass::bClass(char ch, double u)
{
bCh = ch;
bX = u;
}

Next, we derive a class dClass from the class bClass using public inheritance as
follows:
class dClass: public bClass
{
public:
void setData(char, double, int);
void print() const;
dClass(char ch = '*', double u = 0.0, int x = 0);
private:
int dA;
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

766 |

Chapter 11: Inheritance and Composition

The class dClass contains a private member variable dA of type int. It also
contains a constructor, a member function setData with three parameters, and the
function print.
Let us now write the definition of the function setData. Because bCh is a protected
member variable of the class bClass, it can be directly accessed in the definition of the
function setData. However, because bX is a private member variable of the class
bClass, the function setData cannot directly access it. Thus, the function setData
must set bX by using the function setData of the class bClass. The definition of the
function setData of the class dClass can be written as follows:
void dClass::setData(char ch, double v, int a)
{
bClass::setData(v);
bCh = ch; //initialize bCh using the assignment statement
dA = a;
}

Note that the definition of the function setData calls the function bClass::setData,
with one parameter to set the member variable bX, and then directly sets the value of bCh.
We now write the definition of the function print of the class dClass. Notice that in
the definition of the class bClass, the member function print is not overloaded as
the member function setData. It prints the values of both member variables, bCh and
bX. The member variable bX is a private member variable, so it cannot be directly
accessed in the class dClass. Even though bCh is a protected member variable and it
can be directly accessed in the class dClass, we must print its value using the function
print of the class bClass, because we want this function to output the values of both
bCh (which is protected) and bX (which is private and inaccessible to dClass). For
this reason, we first call the function bClass::print to output bCh and bX and then
output the value of dA. The definition of the function print is:
void dClass::print() const
{
bClass::print();
cout << "Derived class dA = " << dA << endl;
}

The definition of the constructor is:
dClass::dClass(char ch, double u, int x)
: bClass(ch, u)
{
dA = x;
}

Note that the dClass constructor has parameters for all of the values needed for both the
dClass and bClass constructors, uses one of the parameters to set its own member, and
then passes the remaining parameters onto the bClass constructor.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Composition (Aggregation) |

767

The following program illustrates how the objects of bClass and dClass work. We assume
that the definition of the class bClass is in the header file protectMembClass.h, and the
definition of the class dClass is in the header file protectMembInDerivedCl.h.
//Accessing protected members of a base class in the derived
//class.
#include <iostream>
#include "protectMembClass.h"
#include "protectMembInDerivedCl.h"
using namespace std;
int main()
{
bClass bObject;
dClass dObject;

//Line 1
//Line 2
//Line 3
//Line 4

bObject.print();
cout << endl;

cout << "*** Derived class object ***" << endl; //Line 5
dObject.setData('&', 2.5, 7);

//Line 6

dObject.print();

//Line 7

return 0;
}

Sample Run:
Base class: bCh = *, bX = 0
*** Derived class object ***
Base class: bCh = &, bX = 2.5
Derived class dA = 7

When you write the definitions of the member functions of the class dClass, the
protected member variable bCh can be accessed directly. However, dClass objects cannot
directly access bCh. That is, the following statement is illegal (it is, in fact, a syntax error):
dObject.bCh = '&';

//illegal

Composition (Aggregation)
Composition (aggregation) is another way to relate two classes. In composition (aggregation), one or more members of a class are objects of another class type. Composition is
a ‘‘has-a’’ relation; for example, ‘‘every person has a date of birth.’’
Example 10-10 in Chapter 10 defined a class called personType. The class personType
stores a person’s first and last name. Suppose we want to keep track of additional
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

768 |

Chapter 11: Inheritance and Composition

information for a person, such as a personal ID (e.g., a Social Security number)
and a date of birth. Because every person has a personal ID and a date of birth, we can
define a new class, called personalInfo, in which one of the members is an object of
type personType. We can declare additional members to store the personal ID and date
of birth for the class personalInfo.
First, we define another class, dateType, to store only a person’s date of birth.
Then, we construct the class personalInfo from the classes personType and
dateType. This way, we can demonstrate how to define a new class using two
classes.
To define the class dateType, we need three member variables—to store the
month, day number, and year. Some of the operations that need to be performed on
a date are setting the date and printing the date. The following statements define the
class dateType:
class dateType
{
public:
void setDate(int month, int day, int year);
//Function to set the date.
//The member variables dMonth, dDay, and dYear are set
//according to the parameters.
//Postcondition: dMonth = month; dDay = day;
//
dYear = year
int getDay() const;
//Function to return the day.
//Postcondition: The value of dDay is returned.
int getMonth() const;
//Function to return the month.
//Postcondition: The value of dMonth is returned.
int getYear() const;
//Function to return the year.
//Postcondition: The value of dYear is returned.
void printDate() const;
//Function to output the date in the form mm-dd-yyyy.
dateType(int month = 1, int day = 1, int year = 1900);
//Constructor to set the date
//The member variables dMonth, dDay, and dYear are set
//according to the parameters.
//Postcondition: dMonth = month; dDay = day; dYear = year;
//
If no values are specified, the default
//
values are used to initialize the member
//
variables.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Composition (Aggregation) |

769

private:
int dMonth; //variable to store the month
int dDay;
//variable to store the day
int dYear; //variable to store the year
};

Figure 11-7 shows the UML class diagram of the class dateType.

dateType
–dMonth: int
–dDay: int
–dYear: int
+setDate(int, int, int): void
+getDay() const: int
+getMonth() const: int
+getYear() const: int
+printDate() const: void
+dateType(int = 1, int = 1, int = 1900)

FIGURE 11-7

UML class diagram of the class dateType

The definitions of the member functions of the class dateType are as follows:
void dateType::setDate(int month, int day, int year)
{
dMonth = month;
dDay = day;
dYear = year;
}

The definition of the function setDate, before storing the date into the member
variables, does not check whether the date is valid. That is, it does not confirm whether
month is between 1 and 12, year is greater than 0, and day is valid (for example, for
January, day should be between 1 and 31). In Programming Exercise 2 at the end of this
chapter, you are asked to rewrite the definition of the function setDate so that the date
is validated before storing it in the member variables. The definitions of the remaining
member functions are as follows:
int dateType::getDay() const
{
return dDay;
}
int dateType::getMonth() const
{
return dMonth;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

770 |

Chapter 11: Inheritance and Composition

int dateType::getYear() const
{
return dYear;
}
void dateType::printDate() const
{
cout << dMonth << "-" << dDay << "-" << dYear;
}
//Constructor with parameters
dateType::dateType(int month, int day, int year)
{
dMonth = month;
dDay = day;
dYear = year;
}

Again, as in the case of setDate, in Programming Exercise 2, you are asked to rewrite
the definition of the constructor so that it checks for valid values of month, day, and
year before storing the date into the member variables.
Next, we give the definition of the class personalInfo:
class personalInfo
{
public:
void setpersonalInfo(string first, string last, int month,
int day, int year, int ID);
//Function to set the personal information.
//The member variables are set according to the
//parameters.
//Postcondition: firstName = first; lastName = last;
//
dMonth = month; dDay = day;
//
dYear = year; personID = ID;
void printpersonalInfo () const;
//Function to print the personal information.
personalInfo(string first = "", string last = "",
int month = 1, int day = 1, int year = 1900,
int ID = 0);
//Constructor
//The member variables are set according to the
//parameters.
//Postcondition: firstName = first; lastName = last;
//
dMonth = month; dDay = day;
//
dYear = year; personID = ID;
//
If no values are specified, the default
//
values are used to initialize the member
//
variables.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Composition (Aggregation) |

771

private:
personType name;
dateType bDay;
int personID;
};

Figure 11-8 shows the UML class diagram of the class personalInfo and composition (aggregation).

personalInfo
-name: personType
-bDay: dateType
-personID: int
setpersonalInfo(string, string, int, int,
int, int): void
printpersonalInfo () const: void
personalInfo(string = "", string = "",
int = 1, int = 1,
int = 1900, int = 0)

FIGURE 11-8

personalInfo

personType

dateType

UML class diagram of the class personalInfo and composition (aggregation)

Before we give the definition of the member functions of the class personalInfo, let
us discuss how the constructors of the objects bDay and name are invoked.
Recall that a class constructor is automatically executed when a class object enters its
scope. Suppose that we have the following statement:
personalInfo student;

When the object student enters its scope, the objects bDay and name, which are members
of student, also enter their scopes. As a result, one of their constructors is executed. We,
therefore, need to know how to pass arguments to the constructors of the member objects
(that is, bDay and name), which occurs when we give the definitions of the constructors of
the class. Recall that constructors do not have a type and so cannot be called like other
functions. The arguments to the constructor of a member object (such as bDay) are specified
in the heading part of the definition of the constructor of the class. Furthermore, member
objects of a class are constructed (that is, initialized) in the order they are declared (not in the
order they are listed in the constructor’s member initialization list) and before the containing
class objects are constructed. Another way to think of this is that all of the components that
make up the instance of personalInfo must be built before the instance itself can be
built. Thus, in our case, the object name is initialized first because it is the first member listed
(in the private section of the class personalInfo definition), then bDay (the second
member listed), and finally student (the instance of personalInfo we are declaring).
The following statements illustrate how to pass arguments to the constructors of the
member objects name and bDay:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

772 |

Chapter 11: Inheritance and Composition

personalInfo::personalInfo(string first, string last, int month,
int day, int year, int ID)
: name(first, last), bDay(month, day, year)
{
.
.
.
}

The definitions of the member functions of the class personalInfo are as follows:
void personalInfo::setpersonalInfo(string first, string last,
int month, int day, int year, int ID)
{
name.setName(first,last);
bDay.setDate(month,day,year);
personID = ID;
}
void personalInfo::printpersonalInfo() const
{
name.print();
cout << "'s date of birth is ";
bDay.printDate();
cout << endl;
cout << "and personal ID is " << personID;
}
personalInfo::personalInfo(string first, string last, int month,
int day, int year, int ID)
: name(first, last), bDay(month, day, year)
{
personID = ID;
}
In the case of inheritance, use the class name to invoke the base class’s constructor. In
the case of composition, use the member object name to invoke its own constructor.

Object-Oriented Design (OOD) and
Object-Oriented Programming (OOP)
The first 11 chapters of this book used the top-down approach to programming, also
called structured programming, to write programs. Problems were broken down into
modules, and each module solved a particular part of the problem. Data requirements
were identified, and functions were written to manipulate the data. The functions and the
data were kept separate, and the functions acted on the data in a passive way. Structured
programming, therefore, has certain limitations. In structured programming, functions are

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Object-Oriented Design (OOD) and Object-Oriented Programming (OOP)

|

773

dependent on the data, and functions are designed specifically to solve a particular
problem. It is quite difficult, if not impossible, to reuse a function written for one
program in another program. For some of these reasons, structured programming is not
very efficient for large software development.
Chapter 10 began with the introduction of classes. We learned how classes are defined
and used. Later in that chapter, we concentrated on the data requirements of a problem
and the logical operations on that data. With the help of classes, we combined, or
encapsulated, the data—and the operations on that data—in a single unit. Also, with
the help of classes, we were able to separate the data and the algorithms to manipulate that
data. However, the functions to implement the operations on the data had direct access to
the data. This chapter explains how to create new classes from existing classes through
inheritance and composition. Furthermore, an object has the capability to hide the
information details. These are some of the features of object-oriented design (OOD).
The three basic principles of OOD are as follows:
•

Encapsulation—The ability to combine data and operations on that
data in a single unit.
• Inheritance—The ability to create new objects (classes) from existing
objects (classes).
• Polymorphism—The ability to use the same expression to denote
different operations.
In OOD, a class is a fundamental entity; in structured programming, a function is a
fundamental entity. In OOD, we debug classes; in structured programming, we debug
functions. In OOD, a program is a collection of interacting objects; in structured programming, a program is a collection of interacting functions. Also, OOD encourages code reuse.
Once a class becomes error-free, it can be reused in many programs because it is a selfcontained entity. So are functions. But objects contain functions (methods) that are not
designed to solve specific programming problems. They are built as general service functions
that will be used in any program. They come with their own set of variables and don’t
require the programmer to spend time rethinking what data to put into the program solution.
They also hide the implementation details, providing greater control of variable values than
structured programs. Object-oriented programming (OOP) implements OOD.
To create objects, we must know how to represent the data and write functions to
manipulate that data. Thus, we must know everything that we have learned in Chapters 2
through 8. The first eight chapters are essential for any type of programming, whether
structured or object-oriented.
C++ supports OOP through the use of classes. We have already examined the first two features
of OOP, encapsulation and inheritance, in this chapter and Chapter 10. Chapter 13 discusses the
third feature of OOD: polymorphism. A polymorphic function or operator has many forms.
In C++, a function name and operators such as +, -, *, and / can be overloaded. An example
of function overloading occurs when the function or operator is called, and the specific
version used decided according to the arguments used. For instance, if both operands are
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

774 |

Chapter 11: Inheritance and Composition

integers, the division operator yields an integer result; otherwise, the division operator yields a
decimal result. Suppose a class has constructors. If no arguments are passed to an object when it
is declared, the default constructor is executed; otherwise, one of the constructors with
parameters is executed. However, all constructors have the same name.
C++ also provides parametric polymorphism. In parametric polymorphism, the (data)
type is left unspecified and then later instantiated. Templates (discussed in Chapter 13)
provide parametric polymorphism. Also, C++ provides virtual functions as a means to
implement polymorphism in an inheritance hierarchy, which allows the run-time selection of appropriate member functions. (Chapter 12 discusses virtual functions.)
There are several OOP languages in existence today, including Ada, Modula-2, Object Pascal,
Turbo Pascal, Eiffel, C++, Java, and Smalltalk. The earliest OOP language was Simula,
developed in 1967. The OOP terminology is influenced by the vocabulary of Smalltalk, the
OOP language largely developed at a Xerox research center during the 1970s. An OOP
language uses many ‘‘fancy’’ words, such as methods, message passing, and so forth.
OOP is a natural and intuitive way to view the programming process. When we view an
object, we immediately think of what it can do. For example, when we think about a car,
we also think about the operations on the car, such as starting the car and driving the car.
When programmers think about a list, they also think about the operations on the list,
such as searching, sorting, and inserting. OOP allows ADT to be created and used. In
C++, we implement ADT through the use of classes.
Objects are created when class variables are declared. Objects interact with each other via
function calls. Every object has an internal state and an external state. The private
members form the internal state; the public members form the external state. Only the
object can manipulate its internal state.

Identifying Classes, Objects, and Operations
In this book’s first 9 chapters, in the problem analysis phase, we analyzed the problem, identified
the data, and outlined the algorithm. To reduce the complexity of the function main, we wrote
functions to manipulate the data. In Chapter 10, we used the OOD technique and first identified
the objects that made up the overall problem. The objects were designed and implemented
independently of the main program. The hardest part in OOD is to identify the classes and objects.
In this section, we describe a common and simple technique to identify classes and objects.
We begin with a description of the problem and then identify all of the nouns and verbs. We
choose our classes from the list of nouns, and we choose our operations from the list of verbs.
For example, suppose that we want to write a program that calculates and prints the
volume and surface area of a cylinder. We can state this problem as follows:
Write a program to input the dimensions of a cylinder and calculate and print the
surface area and volume.
In this statement, the nouns are bold, and the verbs are italic. From the list of nouns—
program, dimensions, cylinder, surface area, and volume—we can easily visualize
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Grade Report

|

775

cylinder to be a class—say, cylinderType—from which we can create many cylinder
objects of various dimensions. The nouns dimensions, surface area, and volume are
characteristics of a cylinder and thus can hardly be considered classes.
After we identify a class, the next step is to determine three pieces of information:
•
•
•

Operations that an object of that class type can perform
Operations that can be performed on an object of that class type
Information that an object of that class type must maintain

From the list of verbs identified in the problem description, we choose a list of possible
operations that an object of that class can perform, or has performed, on itself. For
example, from the list of verbs for the cylinder problem description—write, input, calculate,
and print—the possible operations for a cylinder object are input, calculate, and print.
For the class cylinderType, the dimensions represent the data. The center of the base,
radius of the base, and height of the cylinder are the characteristics of the dimensions.
You can input data to the object either by a constructor or by a mutator function.
The verb calculate applies to determining the volume and the surface area. From this, you
can deduce the operations: cylinderVolume and cylinderSurfaceArea. Similarly,
the verb print applies to the display of the volume and the surface area on an output
device. In Programming Exercise 3 at the end of this chapter, you are asked to design a
class to implement the characteristics of a cylinder.
Identifying classes via the nouns and verbs from the descriptions of the problem is not the
only technique possible. There are several other OOD techniques in the literature.
However, this technique is sufficient for the programming exercises in this book.

PROGRAMMING EXAMPLE:

Grade Report

This programming example further illustrates the concepts of inheritance and composition.

Watch
the Video

The mid-semester point at your local university is approaching. The registrar’s office
wants to prepare the grade reports as soon as the students’ grades are recorded.
However, some of the students enrolled have not yet paid their tuition.
1. If a student has paid the tuition, the grades are shown on the grade
report together with the grade point average (GPA).
2. If a student has not paid the tuition, the grades are not printed. For
these students, the grade report contains a message indicating that
the grades have been held for nonpayment of the tuition. The grade
report also shows the billing amount.
The registrar’s office and the business office want your help in writing a program that
can analyze the students’ data and print the appropriate grade reports. The data is
stored in a file in the following form:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

776 |

Chapter 11: Inheritance and Composition

15000 345
studentName studentID isTuitionPaid
courseName courseNumber creditHours
courseName courseNumber creditHours
.
.
.
studentName studentID isTuitionPaid
courseName courseNumber creditHours
courseName courseNumber creditHours
.
.
.

numberOfCourses
grade
grade

numberOfCourses
grade
grade

The first line indicates the number of students enrolled and the tuition rate per credit
hour. The students’ data is given thereafter.
A sample input file is as follows:
3 345
Lisa Miller 890238 Y 4
Mathematics MTH345 4 A
Physics PHY357 3 B
ComputerSci CSC478 3 B
History HIS356 3 A
.
.
.

The first line indicates that the input file contains three students’ data, and the tuition
rate is $345 per credit hour. Next, the course data for student Lisa Miller is given:
Lisa Miller’s ID is 890238, she has paid the tuition, and she is taking four courses.
The course number for the mathematics class she is taking is MTH345, the course has
four credit hours, her mid-semester grade is A, and so on.
The desired output for each student is in the following form:
Student Name: Lisa Miller
Student ID: 890238
Number of courses enrolled: 4

Course No

Course Name

CSC478
HIS356
MTH345
PHY357

ComputerSci
History
Mathematics
Physics

Credits
3
3
4
3

Grade
B
A
A
B

Total number of credits: 13
Mid-Semester GPA: 3.54

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Grade Report

|

777

It is clear from this output that the courses must be ordered according to the course
number. To calculate the GPA, we assume that the grade A is equivalent to four
points, B is equivalent to three points, C is equivalent to two points, D is equivalent to
one point, and F is equivalent to zero points.

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Input

A file containing the data in the form given previously. For easy reference,
let us assume that the name of the input file is stData.txt.

Output

A file containing the output in the form given previously.

We must first identify the main components of the program. The university has
students, and every student takes courses. Thus, the two main components are the
student and the course.
Let us first describe the course component.

Course The main characteristics of a course are the course name, course number, and

number of credit hours.
Some of the basic operations that need to be performed on an object of the course type are:
1.
2.
3.
4.

Set the course information.
Print the course information.
Show the credit hours.
Show the course number.

The following class defines the course as an ADT:
class courseType
{
public:
void setCourseInfo(string cName, string cNo, int credits);
//Function to set the course information.
//The course information is set according to the
//parameters.
//Postcondition: courseName = cName; courseNo = cNo;
//
courseCredits = credits;
void print(ostream& outF);
//Function to print the course information.
//This function sends the course information to the
//output device specified by the parameter outF. If the
//actual parameter to this function is the object cout,
//then the output is shown on the standard output device.
//If the actual parameter is an ofstream variable, say,
//outFile, then the output goes to the file specified by
//outFile.
int getCredits();
//Function to return the credit hours.
//Postcondition: The value of courseCredits is returned.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

778 |

Chapter 11: Inheritance and Composition

string getCourseNumber();
//Function to return the course number.
//Postcondition: The value of courseNo is returned.
string getCourseName();
//Function to return the course name.
//Postcondition: The value of courseName is returned.
courseType(string cName = "", string cNo = "",
int credits = 0);
//Constructor
//The object is initialized according to the parameters.
//Postcondition: courseName = cName; courseNo = cNo;
//
courseCredits = credits;
private:
string courseName;
string courseNo;
int courseCredits;
};

//variable to store the course name
//variable to store the course number
//variable to store the credit hours

Figure 11-9 shows the UML class diagram of the class courseType.

courseType
–courseName: string
–courseNo: string
–courseCredits: int
+setCourseInfo(string, string,int): void
+print(ostream&): void
+getCredits(): int
+getCourseNumber(): string
+getCourseName(): string
+courseType(string = "", string = "", int = 0)

FIGURE 11-9

UML class diagram of the class courseType

The definitions of the functions to implement the operations of the class
courseType are quite straightforward and easy to follow.

The function setCourseInfo sets the values of the private member variables
according to the values of the parameters. Its definition is:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Grade Report

|

779

void courseType::setCourseInfo(string cName, string cNo,
int credits)
{
courseName = cName;
courseNo = cNo;
courseCredits = credits;
} //end setCourseInfo

The function print prints the course information. The parameter outF specifies the
output device. Also, we print the course name and course number left-justified rather
than right-justified (the default). Thus, we need to set the left manipulator. Before
printing the credit hours, the manipulator is set to be right-justified. The following
steps describe this function:
1.
2.
3.
4.
5.

Set the left manipulator.
Print the course number.
Print the course name.
Set the right manipulator.
Print the credit hours.

The definition of the function print is:
void courseType::print(ostream& outF)
{
outF << left;
outF << setw(8) << courseNo << "
";
outF << setw(15) << courseName;
outF << right;
outF << setw(3) << courseCredits << "
} //end print

";

//Step
//Step
//Step
//Step
//Step

1
2
3
4
5

The constructor is declared with the default values. If no values are specified when a
courseType object is declared, the constructor uses the default values to initialize
the object as follows: courseNo to blank, courseName to blank, and
courseCredits to 0. Otherwise, the values specified in the object declaration are
used to initialize the object. Its definition is:
courseType::courseType(string cName, string cNo, int credits)
{
courseName = cName;
courseNo = cNo;
courseCredits = credits;
} //end default constructor

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

780 |

Chapter 11: Inheritance and Composition

The definitions of the remaining functions are as follows:
int courseType::getCredits()
{
return courseCredits;
} //end getCredits
string courseType::getCourseNumber()
{
return courseNo;
}//end getCourseNumber
string courseType::getCourseName()
{
return courseName;
} //end getCourseName

Next, we discuss the student component.
Notice that in the definition of the class courseType, the member functions,
such as print and getCredits, are accessor functions. This class also has
other accessor functions. As noted in Chapter 10, we typically define the accessor
functions with the keyword const at the end of their headings. We leave it as
an exercise for you to redefine this class so that the accessor functions are
declared as constant functions. (See Programming Exercise 12 at the end of this
chapter.)

Student The main characteristics of a student are the student name, student ID, number of

courses in which enrolled, courses in which enrolled, and grade for each course.
Because every student has to pay tuition, we also include a member to indicate
whether the student has paid the tuition.
Every student is a person, and every student takes courses. We have already designed
a class personType to process a person’s first and last name. We have also
designed a class to process the information for a course. Thus, we see that we can
derive the class studentType to keep track of a student’s information from the
class personType, and one member of this class is of type courseType. We can
add more members as needed.
The basic operations to be performed on an object of type studentType are as
follows:
1. Set the student information.
2. Print the student information.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Grade Report

3.
4.
5.
6.

|

781

Calculate the number of credit hours taken.
Calculate the GPA.
Calculate the billing amount.
Because the grade report will print the courses in ascending order,
sort the courses according to the course number.

The following class defines studentType as an ADT. We assume that a student
takes no more than six courses per semester, so we store course information in an
array of six course objects.
class studentType: public personType
{
public:
void setInfo(string fname, string lName, int ID,
int nOfCourses, bool isTPaid,
courseType courses[], char courseGrades[]);
//Function to set the student's information.
//Postcondition: The member variables are set
//
according to the parameters.
void print(ostream& outF, double tuitionRate);
//Function to print the student's grade report.
//If the member variable isTuitionPaid is true, the grades
//are shown; otherwise, three stars are printed. If the
//actual parameter corresponding to outF is the object
//cout, then the output is shown on the standard output
//device. If the actual parameter corresponding to outF
//is an ofstream object, say outFile, then the output
//goes to the file specified by outFile.
studentType();
//Default constructor
//The member variables are initialized.
int getHoursEnrolled();
//Function to return the credit hours a student is
//enrolled in.
//Postcondition: The number of credit hours is
//
calculated and returned.
double getGpa();
//Function to return the grade point average.
//Postcondition: The gpa is calculated and returned.
double billingAmount(double tuitionRate);
//Function to return the tuition fees.
//Postcondition: The billing amount is calculated
//and returned.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

782 |

Chapter 11: Inheritance and Composition

private:
void sortCourses();
//Function to sort the courses.
//Postcondition: The array coursesEnrolled is sorted.
//
For each course, its grade is stored in
//
the array coursesGrade. Therefore, when
//
the array coursesEnrolled is sorted, the
//
corresponding entries in the array
//
coursesGrade are adjusted.
int sId;
//variable to store the student ID
int numberOfCourses; //variable to store the number
//of courses
bool isTuitionPaid; //variable to indicate whether the
//tuition is paid
courseType coursesEnrolled[6]; //array to store the courses
char coursesGrade[6];
//array to store the course grades
};

Figure 11-10 shows the UML class diagram of the class studentType together
with the inheritance and composition (aggregation) relation.

studentType
-sId: int
-numberOfCourses: int
-isTuitionPaid: bool
-coursesEnrolled[6]: courseType
-coursesGrade[6]: char
+setInfo(string, string, int, int, bool,
courseType [], char []): void
+print(ostream&, double): void
+getHoursEnrolled(): int
+getGpa(): double
+billingAmount(double): double
-sortCourses(): void
+studentType()

personType

studentType

courseType

UML class diagram of the class studentType together with inheritance and
composition (aggregation) relation

FIGURE 11-10

Before writing the definitions of the member functions of the class studentType,
we make the following note.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Grade Report

|

783

Notice that in the definition of the class studentType, the member functions,
such as print and getGpa, are accessor functions. This class also has other
accessor functions. As noted in Chapter 10, we typically define the accessor
functions with the keyword const at the end of their headings. We leave it as an
exercise for you to redefine this class so that the accessor functions are declared as
constant functions. (See Programming Exercise 12 at the end of this chapter.)

Note that the member function sortCourses to sort the array coursesEnrolled
is a private member of the class studentType. This is due to the fact that this
function is needed for internal data manipulation, and the user of the class does not
need to access this member.
Next, we discuss the definitions of the functions to implement the operations of the
class studentType.

The function setInfo first initializes the private member variables to the incoming
parameter values. This function then calls the function sortCourses to sort the array
coursesEnrolled by course number. The class studentType is derived
from the class personType, and the variables to store the first and last name are
private member variables of that class. Therefore, we call the member function
setName of the class personType to pass the appropriate variables to set the first
and last names. The definition of the function setInfo is as follows:
void studentType::setInfo(string fName, string lName, int ID,
int nOfCourses, bool isTPaid,
courseType courses[], char cGrades[])
{
int i;
setName(fName, lName);

//set the name

sId = ID;
isTuitionPaid = isTPaid;
numberOfCourses = nOfCourses;

//set the student ID
//set isTuitionPaid
//set the number of courses

//set the course information
for (i = 0; i < numberOfCourses; i++)
{
coursesEnrolled[i] = courses[i];
coursesGrade[i] = cGrades[i];
}
sortCourses();
} //end setInfo

//sort the array coursesEnrolled

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

784 |

Chapter 11: Inheritance and Composition

The default constructor initializes the private member variables to the default
values. Note that because the private member variable coursesEnrolled is an
array of type courseType, the default constructor of the class courseType
executes automatically, and the entire array is initialized.
studentType::studentType()
{
numberOfCourses = 0;
sId = 0;
isTuitionPaid = false;
for (int i = 0; i < 6; i++)
coursesGrade[i] = '*';
} //end default constructor

The function print prints the grade report. The parameter outF specifies the
output device. If the student has paid his or her tuition, the grades and the GPA are
shown. Otherwise, three stars are printed in place of each grade, the GPA is not
shown, a message indicates that the grades are being held for nonpayment of the
tuition, and the amount due is shown. This function has the following steps:
1.
2.
3.
4.

Output
Output
Output
Output

the
the
the
the

student’s name.
student’s ID.
number of courses in which the student is enrolled.
heading:

Course No Course Name

Credits

Grade

5. Print each course’s information.
For each course, print:
a. Course No, Course Name, Credits
b. if isTuitionPaid is true
Output the grade
else

Output three stars.
6. Print the total credit hours.
7. To output the GPA and billing amount in a fixed decimal format
with the decimal point and trailing zeros, set the necessary flag. Also,
set the precision to two decimal places.
8. if isTuitionPaid is true
Output the GPA
else

Output the billing amount and a message about withholding the grades.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Grade Report

|

785

The definition of the function print is as follows:
void studentType::print(ostream& outF, double tuitionRate)
{
int i;
outF << "Student Name: " << getFirstName()
<< " " << getLastName() << endl;

//Step 1

outF << "Student ID: " << sId << endl;

//Step 2

outF << "Number of courses enrolled: "
<< numberOfCourses << endl;
outF << endl;

//Step 3

outF << left;
outF << "Course No" << setw(15) << "
<< setw(8) << "Credits"
<< setw(6) << "Grade" << endl;

Course Name"

outF << right;
for (i = 0; i < numberOfCourses; i++)
{
coursesEnrolled[i].print(outF);

//Step 4
//Step 5
//Step 5a

if (isTuitionPaid)
//Step 5b
outF <<setw(4) << coursesGrade[i] << endl;
else
outF << setw(4) << "***" << endl;
}
outF << endl;
outF << "Total number of credit hours: "
<< getHoursEnrolled() << endl;

//Step 6

outF << fixed << showpoint << setprecision(2);

//Step 7

if (isTuitionPaid)
//Step 8
outF << "Mid-Semester GPA: " << getGpa()
<< endl;
else
{
outF << "*** Grades are being held for not paying "
<< "the tuition. ***" << endl;
outF << "Amount Due: $" << billingAmount(tuitionRate)
<< endl;
}
outF << "-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*"
<< "-*-*-*-*-" << endl << endl;
} //end print

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

786 |

Chapter 11: Inheritance and Composition

Let us take a look at the formal parameter of the function print. The formal
parameter outF is an object of the class ostream. We can use this function to
send the output to the standard output device, the screen, or to a file. As indicated in
the definition of the class, if the actual parameter is, say, cout, then the output is
displayed on the screen. If the actual parameter is, say, outfile, an object of the
class ofstream, then the output is sent to the device indicated by outfile.
As mentioned in the section, ‘‘C++ Stream Classes,’’ the class ofstream is
derived from the class ostream. Therefore, the class ostream is the base
class. In C++, if a formal reference parameter is of the type ostream, it can refer to
an object of the class ofstream.
In general, C++ allows a formal reference parameter of the base class type to refer to an
object of the derived class. Of course, for user-defined classes, some other things need to
be taken into account for this mechanism to work properly, which we will discuss in
Chapter 12 (in the section ‘‘Inheritance, Pointers, and Virtual Functions’’).

The function getHoursEnrolled calculates and returns the total credit hours that
a student is taking. These credit hours are needed to calculate both the GPA and the
billing amount. The total credit hours are calculated by adding the credit hours of
each course in which the student is enrolled. Because the credit hours for a course are
in the private member variable of an object of type courseType, we use the
member function getCredits of the class courseType to retrieve the credit
hours. The definition of this function is:
int studentType::getHoursEnrolled()
{
int totalCredits = 0;
int i;
for (i = 0; i < numberOfCourses; i++)
totalCredits += coursesEnrolled[i].getCredits();
return totalCredits;
} //end getHoursEnrolled

If a student has not paid the tuition, the function billingAmount calculates
and returns the amount due, based on the number of credit hours enrolled. The
definition of this function is:
double studentType::billingAmount(double tuitionRate)
{
return tuitionRate * getHoursEnrolled();
} //end billingAmount

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Grade Report

|

787

We now discuss the function getGpa. This function calculates a student’s GPA. To find
the GPA, we find the equivalent points for each grade, add the points, and then divide
the sum by the total credit hours the student is taking. The definition of this function is:
double studentType::getGpa()
{
int i;
double sum = 0.0;
for (i = 0; i < numberOfCourses; i++)
{
switch (coursesGrade[i])
{
case 'A':
sum += coursesEnrolled[i].getCredits() *
break;
case 'B':
sum += coursesEnrolled[i].getCredits() *
break;
case 'C':
sum += coursesEnrolled[i].getCredits() *
break;
case 'D':
sum += coursesEnrolled[i].getCredits() *
break;
case 'F':
break;
default:
cout << "Invalid Course Grade." << endl;
}
}

4;

3;

2;

1;

return sum / getHoursEnrolled();
} //end getGpa

The function sortCourses sorts the array coursesEnrolled by course number.
To sort the array, we use a selection sort algorithm. Because we will compare the
course numbers, which are strings and private member variables of the class
courseType, we first retrieve and store the course numbers in local variables.
void studentType::sortCourses()
{
int i, j;
int minIndex;
courseType temp;
//variable to swap the data
char tempGrade;
//variable to swap the grades
string course1;
string course2;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

788 |

Chapter 11: Inheritance and Composition

for (i = 0; i < numberOfCourses - 1; i++)
{
minIndex = i;
for (j = i + 1; j < numberOfCourses; j++)
{
//get the course numbers
course1 =
coursesEnrolled[minIndex].getCourseNumber();
course2 = coursesEnrolled[j].getCourseNumber();
if (course1 > course2)
minIndex = j;
}//end for
temp = coursesEnrolled[minIndex];
coursesEnrolled[minIndex] = coursesEnrolled[i];
coursesEnrolled[i] = temp;
tempGrade = coursesGrade[minIndex];
coursesGrade[minIndex] = coursesGrade[i];
coursesGrade[i] = tempGrade;
} //end for
} //end sortCourses
MAIN
PROGRAM

Now that we have designed the classes courseType and studentType, we will
use these classes to complete the program.
We will restrict our program to process a maximum of 10 students. Note that this
program can easily be enhanced to process any number of students.
Because the print function of the class does the necessary computations to print the
final grade report, the main program has very little work to do. (Note that because of
the definition of the print function, we have shifted the bulk of the programming
code from functions in file scope to functions in object scope.) In fact, all that is left
for the main program is to declare the objects to hold the students’ data, load the data
into these objects, and then print the grade reports. Because the input is in a file and
the output will be sent to a file, we declare stream variables to access the input and
output files. Essentially, the main algorithm for the program is:
1.
2.
3.
4.
5.
6.
7.

Declare the variables.
Open the input file.
If the input file does not exist, exit the program.
Open the output file.
Get the number of students registered and the tuition rate.
Load the students’ data.
Print the grade reports.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Grade Report

VARIABLES

|

789

This program processes a maximum of 10 students. Therefore, we must declare an
array of 10 components of type studentType to hold the students’ data. We also need
to store the number of students registered and the tuition rate. Because the data will be
read from a file and because the output is sent to a file, we need two stream variables
to access the input and output files. Thus, we need the following variables:
studentType studentList[MAX_NO_OF_STUDENTS]; //array to store
//the students' data
int noOfStudents;
double tuitionRate;

//variable to store the number of students
//variable to store the tuition rate

ifstream infile;
ofstream outfile;

//input stream variable
//output stream variable

Function This function has three parameters: a parameter to access the input file, a parameter to
getStudentData

access the array studentList, and a parameter to know the number of students
registered. In pseudocode, the definition of this function is as follows:
For each student in the university,
1. Get the first name, last name, student ID, and isPaid.
2. if isPaid is ‘Y’
set isTuitionPaid to true
else

set isTuitionPaid to false
3. Get the number of courses the student is taking.
4. For each course:
Get the course name, course number, credit hours, and grade.
Load the course information into a courseType object.
5. Load the data into a studentType object.
We need to declare several local variables to read and store the data. The definition of
the function getStudentData is:
void getStudentData(ifstream& infile,
studentType studentList[],
int numberOfStudents)
{
//local variables
string fName;
//variable to store the first name
string lName;
//variable to store the last name
int ID;
//variable to store the student ID
int noOfCourses; //variable to store the number of courses
char isPaid;
//variable to store Y/N, that is,
//is tuition paid
bool isTuitionPaid; //variable to store true/false

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

790 |

Chapter 11: Inheritance and Composition

string cName;
string cNo;
int credits;
int count;
int i;

//variable to store the course name
//variable to store the course number
//variable to store the course credit hours
//loop control variable
//loop control variable

courseType courses[6]; //array of objects to store the
//course information
char cGrades[6];
//array to hold the course grades
for (count = 0; count < numberOfStudents; count++)
{
infile >> fName >> lName >> ID >> isPaid; //Step 1
if (isPaid == 'Y')
isTuitionPaid = true;
else
isTuitionPaid = false;

//Step 2

infile >> noOfCourses;

//Step 3

for (i = 0; i < noOfCourses; i++)
//Step
{
infile >> cName >> cNo >> credits
>> cGrades[i];
//Step
courses[i].setCourseInfo(cName, cNo,
credits);
//Step
}
studentList[count].setInfo(fName, lName, ID,
noOfCourses,
isTuitionPaid,
courses, cGrades); //Step
}//end for
} //end getStudentData

4
4.a
4.b

5

Function This function prints the grade reports. For each student, it calls the function print
printGrade of the class studentType to print the grade report. The definition of the function
Reports printGradeReports is:
void printGradeReports(ofstream& outfile,
studentType studentList[],
int numberOfStudents,
double tuitionRate)
{
int count;
for (count = 0; count < numberOfStudents; count++)
studentList[count].print(outfile, tuitionRate);
} //end printGradeReports

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Grade Report

|

791

PROGRAMMING LISTING
//************************************************************
// Author: D.S. Malik
//
// class courseType
// This class specifies the members to implement a course's
// information.
//************************************************************
#ifndef H_courseType
#define H_courseType
#include <fstream>
#include <string>
using namespace std;
//The definition of the class courseType goes here.
.
.
.
#endif
//**********************************************************
// Author: D.S. Malik
//
// Implementation file courseTypeImp.cpp
// This file contains the definitions of the functions to
// implement the operations of the class courseType.
//**********************************************************
#include
#include
#include
#include
#include

<iostream>
<fstream>
<string>
<iomanip>
"courseType.h"

using namespace std;
//The definitions of the member functions of the class
//courseType go here.
.
.
.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

792 |

Chapter 11: Inheritance and Composition

//**********************************************************
// Author: D.S. Malik
//
// class personType
// This class specifies the members to implement a person's
// first name and last name.
//**********************************************************
#ifndef H_personType
#define H_personType
#include <string>
using namespace std;
//The definition of the class personType goes here.
.
.
.
#endif
//**********************************************************
// Author: D.S. Malik
//
// Implementation file personTypeImp.cpp
// This file contains the definitions of the functions to
// implement the operations of the class personType.
//**********************************************************
#include <iostream>
#include <string>
#include "personType.h"
using namespace std;
//The definitions of the member functions of the class
//personType go here.
.
.
.
//************************************************************
// Author: D.S. Malik
//
// class studentType
// This class specifies the members to implement a student's
// information.
//************************************************************

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Grade Report

|

793

#ifndef H_studentType
#define H_studentType
#include
#include
#include
#include

<fstream>
<string>
"personType.h"
"courseType.h"

using namespace std;
//The definition of the class studentType goes here.
.
.
.
#endif
//**********************************************************
// Author: D.S. Malik
//
// Implementation file studentTypeImp.cpp
// This file contains the definitions of the functions to
// implement the operations of the class studentType.
//**********************************************************
#include
#include
#include
#include
#include
#include
#include

<iostream>
<iomanip>
<fstream>
<string>
"personType.h"
"courseType.h"
"studentType.h"

using namespace std;
//The definitions of the member functions of the class
//studentType go here.
.
.
.
//************************************************************
// Author: D.S. Malik
//
// This program reads students' data from a file and outputs
// the grades. If student has not paid the tuition, the
// grades are not shown, and an appropriate message is
// output. The output is stored in a file.
//************************************************************

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

794 |

Chapter 11: Inheritance and Composition

#include
#include
#include
#include

<iostream>
<fstream>
<string>
"studentType.h"

using namespace std;
const int MAX_NO_OF_STUDENTS = 10;
void getStudentData(ifstream& infile,
studentType studentList[],
int numberOfStudents);
void printGradeReports(ofstream& outfile,
studentType studentList[],
int numberOfStudents,
double tuitionRate);
int main()
{
studentType studentList[MAX_NO_OF_STUDENTS];
int noOfStudents;
double tuitionRate;
ifstream infile;
ofstream outfile;
infile.open("stData.txt");
if (!infile)
{
cout << "The input file does not exist. "
<< "Program terminates." << endl;
return 1;
}
outfile.open("sDataOut.txt");
infile >> noOfStudents; //get the number of students
infile >> tuitionRate; //get the tuition rate
getStudentData(infile, studentList, noOfStudents);
printGradeReports(outfile, studentList,
noOfStudents, tuitionRate);
return 0;
}
//Place the definitions of the functions getStudentData and
//printGradeReports here.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Grade Report

|

795

Sample Run:
Student Name: Lisa Miller
Student ID: 890238
Number of courses enrolled: 4
Course No
CSC478
HIS356
MTH345
PHY357

Course Name
ComputerSci
History
Mathematics
Physics

Credits Grade
3
B
3
A
4
A
3
B

Total number of credit hours: 13
Mid-Semester GPA: 3.54
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*Student Name: Bill Wilton
Student ID: 798324
Number of courses enrolled: 5
Course No
BIO234
CHM256
ENG378
MTH346
PHL534

Course Name
Biology
Chemistry
English
Mathematics
Philosophy

Credits Grade
4
***
4
***
3
***
3
***
3
***

Total number of credit hours: 17
*** Grades are being held for not paying the tuition. ***
Amount Due: $5865.00
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*Student Name: Dandy Goat
Student ID: 746333
Number of courses enrolled: 6
Course No
BUS128
CHM348
CSC201
ENG328
HIS101
MTH137

Course Name
Business
Chemistry
ComputerSci
English
History
Mathematics

Credits Grade
3
C
4
B
3
B
3
B
3
A
3
A

Total number of credit hours: 19
Mid-Semester GPA: 3.16
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

796 |

Chapter 11: Inheritance and Composition

Input File:
3 345
Lisa Miller 890238 Y 4
Mathematics MTH345 4 A
Physics PHY357 3 B
ComputerSci CSC478 3 B
History HIS356 3 A
Bill Wilton 798324 N 5
English ENG378 3 B
Philosophy PHL534 3 A
Chemistry CHM256 4 C
Biology BIO234 4 A
Mathematics MTH346 3 C
Dandy Goat 746333 Y 6
History HIS101 3 A
English ENG328 3 B
Mathematics MTH137 3 A
Chemistry CHM348 4 B
ComputerSci CSC201 3 B
Business BUS128 3 C

QUICK REVIEW
1.
2.
3.
4.
5.
6.
7.
8.
9.

Inheritance and composition (aggregation) are meaningful ways to relate
two or more classes.
Inheritance is an ‘‘is-a’’ relation.
Composition (aggregation) is a ‘‘has-a’’ relation.
In a single inheritance, the derived class is derived from only one existing
class called the base class.
In a multiple inheritance, a derived class is derived from more than one base
class.
The private members of a base class are private to the base class. The
derived class cannot directly access them.
The public members of a base class can be inherited either as public or
private by the derived class.
A derived class can redefine the member functions of a base class, but this
redefinition applies only to the objects of the derived class.
A call to a base class’s constructor (with parameters) is specified in the
heading of the definition of the derived class’s constructor.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

10.

11.
12.
13.
14.
15.
16.

|

797

If in the heading of the definition of a derived class’s constructor, no call to
a constructor (with parameters) of a base class is specified, then during the
derived class’s object declaration and initialization, the default constructor
(if any) of the base class executes.
When initializing the object of a derived class, the constructor of the base
class is executed first.
Review the inheritance rules given in this chapter.
In composition (aggregation), a member of a class is an object of another class.
In composition (aggregation), a call to the constructor of the member
objects is specified in the heading of the definition of the class’s constructor.
The three basic principles of OOD are encapsulation, inheritance, and
polymorphism.
An easy way to identify classes, objects, and operations is to describe the
problem in English and then identify all of the nouns and verbs. Choose your
classes (objects) from the list of nouns and your operations from the list of verbs.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.
b.

c.

d.

e.

f.

g.

h.

In single inheritance, a base class can create only one derived class. (1)
The public members of a base class can only be inherited as public
members in the derived class. (2)
To redefine (or override) a member function of the base class in the
derived class, the corresponding member function must have the same
name, number, and type of parameters. (3)
If the derived class does not override a public member function of the
base class, you may specify a call to that public member function by
using the name of the function and the appropriate parameter list. (3)
The constructor of a derived class can specify a call to the constructor
of the base class in the heading of the function definition. (4)
The constructor of a derived class can specify a call to the constructor of
the base class using the name of the class. (4)
Suppose that x and y are classes, one of the member variables of x is an
object of type y, and both classes have constructors. The constructor of
x specifies a call to the constructor of y by using the object name
of type y. (4)
When the destructor of the derived class executes, it automatically
invokes the destructor of the base class. (5)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

798 |

Chapter 11: Inheritance and Composition

The class ios is the base class for all stream classes. (7)
In protected inheritance, the private members of the base class are
protected members of the derived class. (8)
k. In composition, one or more members of a class are objects of another
class type. (9)
Suppose vehicle is a class that defines the basic properties of a vehicle.
Draw a class hierarchy in which several classes are derived from the class
vehicle, and then other classes are derived from the classes derived from
the class vehicle. (1, 2)
Suppose that a class employeeType is derived from the class
personType (see Example 10-10, in Chapter 10). Give examples of
members—data and functions—that can be added to the class
employeeType. Also write the definition of the class employeeType
that you derived from the class personType. (2, 3, 4)
Consider the class circleType as defined in Example 10-8 (Chapter 10).
Suppose that the class sphereType is derived from the class
circleType. (2, 3, 4)
i.
j.

2.

3.

4.

Name some of the functions and/or data members that can be added to
the class sphereType.
b. Write the definition of the class sphereType.
c. Write the definitions of the member functions of the class sphereType.
Consider the following statements:
a.

5.

class personalComputers: public computers
{
...
};

In this declaration, which class is the base class and which class is the
derived class? (2)
b. What is the type of this inheritance? (2)
Consider the following statements:
a.

6.

class fruits: food
{
...
};
a.

b.

In this declaration, which class is the base class and which class is the
derived class? (2)
What is the type of this inheritance? (2)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

7.

|

799

Consider the following class definition:
class circle
{
public:
void print() const;
void setRadius(double);
void setCenter(double, double);
void getCenter(double&, double&);
double getRadius();
double area();
circle();
circle(double, double, double);
private:
double xCoordinate;
double yCoordinate;
double radius;
};

class cylinder: public circle
{
public:
void print() const;
void setHeight(double);
double getHeight();
double volume();
double area();
cylinder();
cylinder(double, double,
double, double);
private:
double height;
};

Suppose that you have the declaration:
cylinder newCylinder;
8.

9.

Determine the private members of the object newCylinder. (2)
Suppose that you have the declarations of Exercise 7. Write the definitions
of the member functions of the classes circle and cylinder. Identify
the member functions of the class cylinder that overrides the member
functions of the class circle. (2, 3, 4)
Consider the following class definition:
class temp
{
public:
void print() const;
void setDescription(string);
void setX(double);
string getDescription();
double getX();
temp();
temp(string, double);
private:
string description;
double x;
};

What is wrong with the following class definition? (2)
class derivedFromTemp public temp
{
public:
void print();
void setZ(double);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

800 |

Chapter 11: Inheritance and Composition

double getZ();
double power();
//returns x to the power of z.
private:
double z;
}
10.

Assume the definition of the class temp as given in Exercise 9. Consider
the following class definition: (2, 3, 4)
class derivedFromTemp: public temp;
{
public:
void print();
//outputs the values of all the instance variables.
void setZ(double);
//sets the value of z according to the parameter.
double getZ();
//returns the value of z.
double power() const;
//returns x to the power of z.
derivedFromTemp();
//sets the values of instance variables to "",
//0.0, and 0.0, respectively.
derivedFromTemp(string, double, double);
//sets the values of instance variables according
//to the parameters.
private:
double z;
}

Identify and correct errors, if any, in the definition of the class
derivedFromTemp. Also give a correct definition of this class.
b. After correcting errors, if any, in the definition of the class
derivedFromTemp, write the definition of the member functions of
the class derivedFromTemp.
Consider the following statements: (3)
a.

11.

class base
{
public:
void print() const;
void set(int, int);
void get(int&, int&);
base();
base(int, int);
private:
int a;
int b;
};

class derived: public base
{
public:
.
.
.
private:
int c;
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

801

Suppose that class derived overrides the function print of the
class base. What is the heading of the function print in the class
derived?
b. Suppose that the class overloads the functions set and get of the
class base. What are the headings of these functions in the class
derived?
Explain the difference between overriding and overloading a member
function of a base class in a derived class. (3)
Suppose that class three is derived from class two and class two is
derived from class one and that each class has instance variables. Suppose
that an object of class three enters its scope, so the constructors of these
classes will execute. Determine the order in which the constructors of
these classes will execute. (4)
Consider the following class definitions: (2, 8)
a.

12.

13.

14.

class smart
{
public:
void print() const;
void set(int, int);
int sum();
smart();
smart(int, int);
private:
int x;
int y;
int secret();
};

class superSmart: public smart
{
public:
void print() const;
void set(int, int, int);
int manipulate();
superSmart();
superSmart(int, int, int);
private:
int z;
};

Which private members, if any, of smart are public members of
superSmart?
b. Which members, functions, and/or data of the class smart are
directly accessible in class superSmart?
Assume the definitions of the classes smart and superSmart as given
in Exercise 14. Suppose that the following statements are in a user program
(client code):
a.

15.

smart smartObject;
superSmart superSmartObject;

Mark the following statements as valid or invalid. If a statement is invalid, explain
why. (2, 3, 4)
a.

int smart::sum()
{
return x + y + z;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

802 |

Chapter 11: Inheritance and Composition

b.

smartObject.secret();
superSmartObject.z = 0;

c.

void superSmart::set(int a, int b, int c)
{
smart::set(a, b);
z = c;
}

d.

Assume that the following statement is in a user program:
smart.print();

e.

Assume that the following statement is in a user program:
cout << superSmart.sum() << superSmart.z << endl;

16.

Assume the declaration of Exercise 14. (3, 4)
Write the definition of the default constructor of smart so that the
instance variables of smart are initialized to 0.
b. Write the definition of the default constructor of superSmart so that
the instance variables of superSmart are initialized to 0.
c. Write the definition of the member function set of smart so that the
instance variables are initialized according to the parameters.
d. Write the definition of the member function sum of the class smart
so that it returns the sum of the instance variables.
e. Write the definition of the member function manipulate of the
class superSmart so that it returns the (x + y)z, that is, return x
plus y to the power of z.
Suppose class two is derived from class one. To avoid multiple inclusion of these classes, which preprocessor directives are used in the header
files containing the definitions of these classes. Justify your answer by giving
an example. (7)
a. The class ifstream is derived from which class? (7)
b. The class ofstream is derived from which class? (7)
Explain how in a private inheritance, the members of the base class are
inherited by a derived class. (8)
Explain how in a protected inheritance, the members of the base class are
inherited by a derived class. (8)
Explain how in a public inheritance, the members of the base class are
inherited by a derived class. (8)
Explain the difference between the private and protected members of
a class. (8)
Explain the difference between the protected and public members of
a class. (8)
a.

17.

18.

19.

20.

21.

22.

23.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

24.

|

803

Consider the following class definition:
class first
{
public:
void setX();
void print() const;
protected:
int y;
void setY(int a);
private:
int x;
};

Suppose that class second is derived from class first using the
statement:
class second: private first

25.

Determine which members of class first are private, protected, and
public in class second. (8)
Assume the declaration of Exercise 24. Suppose that class third is
derived from class first using the statement:
class third: protected first

26.

Determine which members of class first are private, protected, and
public in class third. (8)
Assume the declaration of Exercise 24. Suppose that class fourth is
derived from class first using the statement:
class fourth: public first

27.

Determine which members of class first are private, protected, and
public in class fourth. (8)
Assume the declaration of Exercise 24. Suppose that class fifth is
derived from class first using the statement:
class fifth: first

28.

Determine which members of class first are private, protected, and
public in class fifth. (8)
What is wrong with the following code? (8)
class classA
{
protected:
void setX(int a);
//Postcondition: x = a;
private:
int x;
};

//Line 1
//Line 2
//Line 3
//Line 4

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

804 |

Chapter 11: Inheritance and Composition

.
.
.
int main()
{
classA aObject;
aObject.setX(4);
return 0;

//Line 5
//Line 6
//Line 7

}
29.

Consider the following code: (3, 8)
class one
{
public:
void print() const;
//Output the values of x and y
protected:
void setData(int u, int v);
//Postcondition: x = u; y = v;
private:
int x;
int y;
};
class two: public one
{
public:
void setData(int a, int b, int c);
//Postcondition: x = a; y = b; z = c;
void print() const;
//Output the values of x, y, and z
private:
int z;
};

Write the definition of the function setData of class two.
b. Write the definition of the function print of class two.
What is the output of the following C++ program? (1, 2, 3, 4, 8)
a.

30.

#include <iostream>
#include <string>
using namespace std;
class baseClass
{
public:
void print() const;
baseClass(string s = " ", int a = 0);
//Postcondition: str = s; x = a;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

805

protected:
int x;
private:
string str;
};
class derivedClass: public baseClass
{
public:
void print() const;
derivedClass(string s = "", int a = 0, int b = 0);
//Postcondition: str = s; x = a; y = b;
private:
int y;
};
int main()
{
baseClass baseObject("This is the base class", 2);
derivedClass derivedObject("DDDDDD", 3, 7);
baseObject.print();
derivedObject.print();
return 0;
}
void baseClass::print() const
{
cout << x << " " << str << endl;
}
baseClass::baseClass(string s, int a)
{
str = s;
x = a;
}
void derivedClass::print() const
{
cout << "Derived class: " << y << endl;
baseClass::print();
}
derivedClass::derivedClass(string s, int a, int b)
:baseClass("Hello Base", a + b)
{
y = b;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

806 |

Chapter 11: Inheritance and Composition

PROGRAMMING EXERCISES
1.

2.

3.

4.

In Chapter 10, the class clockType was designed to implement the time
of day in a program. Certain applications, in addition to hours, minutes, and
seconds, might require you to store the time zone. Derive the class
extClockType from the class clockType by adding a member variable
to store the time zone. Add the necessary member functions and constructors
to make the class functional. Also, write the definitions of the member
functions and the constructors. Finally, write a test program to test
your class.
In this chapter, the class dateType was designed to implement the date in
a program, but the member function setDate and the constructor do not
check whether the date is valid before storing the date in the member
variables. Rewrite the definitions of the function setDate and the constructor so that the values for the month, day, and year are checked before
storing the date into the member variables. Add a member function,
isLeapYear, to check whether a year is a leap year. Moreover, write a
test program to test your class.
Chapter 10 defined the class circleType to implement the basic properties of a circle. (Add the function print to this class to output the radius,
area, and circumference of a circle.) Now every cylinder has a base and
height, where the base is a circle. Design a class cylinderType that can
capture the properties of a cylinder and perform the usual operations on the
cylinder. Derive this class from the class circleType designed in Chapter 10. Some of the operations that can be performed on a cylinder are as
follows: calculate and print the volume, calculate and print the surface area,
set the height, set the radius of the base, and set the center of the base. Also,
write a program to test various operations on a cylinder.
Amanda and Tyler opened a business that specializes in shipping liquids, such
as milk, juice, and water, in cylinderical containers. The shipping charges
depend on the amount of the liquid in the container. (For simplicity, you
may assume that the container is filled to the top.) They also provide the
option to paint the outside of the container for a reasonable amount. Write a
program that does the following:
a.

b.
c.

d.

Prompts the user to input the dimensions (in feet) of the container
(radius of the base and the height).
Prompts the user to input the shipping cost per liter.
Prompts the user to input the paint cost per square foot. (Assume that
the entire container including the top and bottom needs to be painted.)
Separately outputs the shipping cost and the cost of painting.
Your program must use the class cylinderType (designed in
Programming Exercise 3) to store the radius of the base and the height
of the container. (Note that 1 cubic feet ¼ 28.32 liters or 1 liter ¼
0.353146667 cubic feet.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

5.

|

807

Using classes, design an online address book to keep track of the names,
addresses, phone numbers, and dates of birth of family members, close
friends, and certain business associates. Your program should be able to
handle a maximum of 500 entries.
a.

b.

c.

Define a class addressType that can store a street address, city, state,
and ZIP code. Use the appropriate functions to print and store the
address. Also, use constructors to automatically initialize the member
variables.
Define a class extPersonType using the class personType (as
defined in Example 10-10, Chapter 10), the class dateType (as designed
in this chapter’s Programming Exercise 2), and the class addressType.
Add a member variable to this class to classify the person as a family
member, friend, or business associate. Also, add a member variable to store
the phone number. Add (or override) the functions to print and store the
appropriate information. Use constructors to automatically initialize the
member variables.
Define the class addressBookType using the previously defined
classes. An object of the type addressBookType should be able to
process a maximum of 500 entries.
The program should perform the following operations:

Load the data into the address book from a disk.
ii. Sort the address book by last name.
iii.
Search for a person by last name.
iv. Print the address, phone number, and date of birth (if it exists) of a
given person.
v. Print the names of the people whose birthdays are in a given month.
vi. Print the names of all the people between two last names.
vii. Depending on the user’s request, print the names of all family
members, friends, or business associates.
In Programming Exercise 2, the class dateType was designed and implemented to keep track of a date, but it has very limited operations. Redefine
the class dateType so that it can perform the following operations on a
date, in addition to the operations already defined:
i.

6.

a.
b.
c.
d.
e.
f.

Set the month.
Set the day.
Set the year.
Return the month.
Return the day.
Return the year.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

808 |

Chapter 11: Inheritance and Composition

Test whether the year is a leap year.
Return the number of days in the month. For example, if the date is
3-12-2017, the number of days to be returned is 31 because there are
31 days in March.
i.
Return the number of days passed in the year. For example, if the date is
3-18-2017, the number of days passed in the year is 77. Note that the
number of days returned also includes the current day.
j.
Return the number of days remaining in the year. For example, if the
date is 3-18-2017, the number of days remaining in the year is 288.
k. Calculate the new date by adding a fixed number of days to the date. For
example, if the date is 3-18-2017 and the days to be added are 25, the
new date is 4-12-2017.
Write the definitions of the functions to implement the operations defined
for the class dateType in Programming Exercise 6.
The class dateType defined in Programming Exercise 6 prints the date in
numerical form. Some applications might require the date to be printed in
another form, such as March 24, 2017. Derive the class extDateType so
that the date can be printed in either form.
Add a member variable to the class extDateType so that the month can
also be stored in string form. Add a member function to output the month
in the string format, followed by the year—for example, in the form March
2017.
Write the definitions of the functions to implement the operations for the
class extDateType.
Using the classes extDateType (Programming Exercise 8) and dayType
(Chapter 10, Programming Exercise 5), design the class calendarType so
that, given the month and the year, we can print the calendar for that month.
To print a monthly calendar, you must know the first day of the month and the
number of days in that month. Thus, you must store the first day of the month,
which is of the form dayType, and the month and the year of the calendar.
Clearly, the month and the year can be stored in an object of the form
extDateType by setting the day component of the date to 1 and the month
and year as specified by the user. Thus, the class calendarType has two
member variables: an object of the type dayType and an object of the type
extDateType.
Design the class calendarType so that the program can print a calendar for
any month starting January 1, 1500. Note that the day for January 1 of the year
1500 is a Monday. To calculate the first day of a month, you can add the
appropriate days to Monday of January 1, 1500.
g.
h.

7.

8.

9.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

809

For the class calendarType, include the following operations:
a.

b.
c.
d.
e.
f.
g.
10.

a.

b.

11.

Determine the first day of the month for which the calendar will be printed.
Call this operation firstDayOfMonth.
Set the month.
Set the year.
Return the month.
Return the year.
Print the calendar for the particular month.
Add the appropriate constructors to initialize the member variables.
Write the definitions of the member functions of the class
calendarType (designed in Programming Exercise 9) to implement the operations of the class calendarType.
Write a test program to print the calendar for either a particular month
or a particular year. For example, the calendar for September 2017 is:
Sun

Mon

3
10
17
24

4
11
18
25

September 2017
Tue
Wed
Thu
5
12
19
26

6
13
20
27

7
14
21
28

Fri
1
8
15
22
29

Sat
2
9
16
23
30

In this exercise, you will design various classes and write a program to
computerize the billing system of a hospital.
a.

b.

c.

Design the class doctorType, inherited from the class
personType, defined in Chapter 10, with an additional data member
to store a doctor’s speciality. Add appropriate constructors and member functions to initialize, access, and manipulate the data members.
Design the class billType with data members to store a patient’s ID
and a patient’s hospital charges, such as pharmacy charges for medicine,
doctor’s fee, and room charges. Add appropriate constructors and
member functions to initialize, access, and manipulate the data members.
Design the class patientType, inherited from the class personType,
defined in Chapter 10, with additional data members to store a patient’s ID,
age, date of birth, attending physician’s name, the date when the patient was
admitted in the hospital, and the date when the patient was discharged from
the hospital. (Use the class dateType to store the date of birth, admit
date, discharge date, and the class doctorType to store the attending
physician’s name.) Add appropriate constructors and member functions to
initialize, access, and manipulate the data members.
Write a program to test your classes.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
1

810 |

12.

13.

14.

Chapter 11: Inheritance and Composition

In the Programming Example Grade Report, in the definitions of the
classes courseType and studentType, the accessor functions are not
made constants; that is, they are not defined with the reserved word const
at the end of their headings. Redefine these classes so that all of the accessor
functions are constant functions. Accordingly, modify the definitions of the
accessor functions and rerun the program.
a. Define the class bankAccount to store a bank customer’s account
number and balance. Suppose that account number is of type int, and
balance is of type double. Your class should, at least, provide the
following operations: set the account number, retrieve the account
number, retrieve the balance, deposit and withdraw money, and print
account information. Add appropriate constructors.
b. Every bank offers a checking account. Derive the class
checkingAccount from the class bankAccount (designed in part
(a)). This class inherits members to store the account number and the
balance from the base class. A customer with a checking account typically
receives interest, maintains a minimum balance, and pays service charges if
the balance falls below the minimum balance. Add member variables to
store this additional information. In addition to the operations inherited
from the base class, this class should provide the following operations: set
interest rate, retrieve interest rate, set minimum balance, retrieve minimum
balance, set service charges, retrieve service charges, post interest, verify if
the balance is less than the minimum balance, write a check, withdraw
(override the method of the base class), and print account information. Add
appropriate constructors.
c. Every
bank offers a savings account. Derive the class
savingsAccount from the class bankAccount (designed in part
(a)). This class inherits members to store the account number and
the balance from the base class. A customer with a savings account
typically receives interest, makes deposits, and withdraws money. In
addition to the operations inherited from the base class, this class
should provide the following operations: set interest rate, retrieve
interest rate, post interest, withdraw (override the method of the base
class), and print account information. Add appropriate constructors.
d. Write a program to test your classes designed in parts (b) and (c).
Write the definitions of the functions of the class primeFactorization
(Example 11-4) and write a program that uses this class to output the prime
factorization of an integer.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

12
CHAPTER

ª HunThomas/Shutterstock

P OINTERS , C LASSES , V IRTUAL
F UNCTIONS , A BSTRACT
C LASSES , AND L ISTS
I N T H I S C H A P T E R , YO U W I L L :
1.

Learn about the pointer data type and pointer variables

2.

Explore how to declare and manipulate pointer variables

3.

Learn about the address of the operator and the dereferencing operator

4.

Learn how pointers work with classes and structs

5.

Discover dynamic variables

6.

Explore how to use the new and delete operators to manipulate dynamic variables

7.

Learn about pointer arithmetic

8.

Learn how to work with dynamic arrays

9.

Become familiar with the limitations of range-based for loops with dynamic arrays

10.

Explore how pointers work with functions as parameters and functions as return values

11.

Become familiar with the shallow and deep copies of data

12.

Discover the peculiarities of classes with pointer member variables

13.

Learn about virtual functions

14.

Become familiar with abstract classes

15.

Learn about array-based lists and the basic operations on them

16.

Examine the relationship between the address of operator and classes

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

812 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

In Chapter 2, you learned that C++’s data types are classified into three categories:
simple, structured, and pointers. Until now, you have studied only the first two data
types. This chapter discusses the third data type called the pointer data type. You will first
learn how to declare pointer variables (or pointers, for short) and manipulate the data to
which they point. Later, you will use these concepts when you study dynamic arrays and
linked lists. Linked lists are discussed in Chapter 16.

Pointer Data Type and Pointer Variables
Chapter 2 defined a data type as a set of values together with a set of operations. Recall that
the set of values is called the domain of the data type. In addition to these two properties,
until now, all of the data types you have encountered have one more thing associated with
them: the name of the data type. For example, there is a data type called int. The set of
values belonging to this data type includes integers that range between –2147483648 and
2147483647, and the operations allowed on these values are the arithmetic operators
described in Chapter 2. To manipulate numeric integer data in the range –2147483648
to 2147483647, you can declare variables using the word int. The name of the data type
allows you to declare a variable of that type. Next, we describe the pointer data type.
The values belonging to pointer data types are the memory addresses of your computer. As
in many other languages, there is no name associated with the pointer data type in C++.
Because the domain—that is, the set of values of a pointer data type—is the addresses
(locations) in memory, a pointer variable is a variable whose content is an address, that is, a
memory location and the pointer variable is said to point to that memory location.
Pointer variable: A variable whose content is an address (that is, a memory address) and is

therefore said to point to a memory address.

Declaring Pointer Variables
As remarked previously, there is no name associated with pointer data types. Moreover,
pointer variables store memory addresses. So the obvious question is: If no name is
associated with a pointer data type, how do you declare pointer variables?
The value of a pointer variable is an address or memory space that typically contains some
data. Therefore, when you declare a pointer variable, you also specify the data type of the
value to be stored in the memory location pointed to by the pointer variable. For
example, if a pointer variable contains the address of a memory location containing an
int value, it is said to be an int pointer or a pointer (variable) of type int. As with
regular variables, pointers are bound to a data type and they can only contain the
addresses of (or point to) variables of the specific data type they were created to hold.
In C++, you declare a pointer variable by using the asterisk symbol (*) between the data
type and the variable name. The general syntax to declare a pointer variable is:
dataType *identifier;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Pointer Data Type and Pointer Variables |

813

As an example, consider the following statements:
int *p;
char *ch;

In these statements, both p and ch are pointer variables. The content of p (when properly
assigned) points to a memory location of type int, and the content of ch points to a
memory location of type char. So, p is a pointer variable of type int, and ch is a pointer
variable of type char.
Before discussing how pointers work, let us make the following observations. The
statement:
int *p;

is equivalent to the statement:
int*

p;

which is equivalent to the statement:
int * p;

Thus, the character * can appear anywhere between the data type name and the variable
name.
Now, consider the following statement:
int* p, q;

In this statement, only p is the pointer variable, not q. Here, q is an int variable. Each
variable must have its own * character placed to the left of it to make it a pointer variable.
To avoid confusion, we prefer to attach the character * to the variable name. So the
preceding statement is written as:
int *p, q;

Of course, the statement:
int *p, *q;

declares both p and q to be pointer variables of type int.
Now that you know how to declare pointers, next we will discuss how to make a pointer
point to a memory space and how to manipulate the data stored in these memory
locations.
Because the value of a pointer is a memory address, a pointer can store the address of a
memory space of the designated type. For example, if p is a pointer of type int, p can
store the address of any memory space of type int. C++ provides two operators—the
address of operator (&) and the dereferencing operator (*)—to work with pointers. The
next two sections describe these operators.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

814 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Address of Operator (&)
In C++, the ampersand, &, called the address of operator, is a unary operator that
returns the address of its operand. For example, given the statements:
int x;
int *p;

the statement:
p = &x;

assigns the address of x to p. That is, x and the value of p refer to the same memory
location.
Let’s compare names and pointers. In the following two declarations, num1 and num2 are
int variables and numptr is the name of an int pointer:
int num1, num2;
int *numptr;

The name num1 now stands in place of an int memory location and can be assigned the
value of any integer between –2147483648 and 2147483647. For example, the following
statement stores 100 in num1:
num1 = 100;

The value held at the memory location named num1 can easily be copied directly to
another integer memory location by using the assignment operator. For instance, if we
want to copy the integer 100 at the memory location num1 to the memory location
num2, we can use this statement:
num2 = num1;

The name num1 in a sense means ‘‘the value held in the memory location named num1.’’
This value is copied into the memory location named num2.
On the other hand, when we use the statement:
numptr = &num1;

we are asking the program to copy the address of the memory location of num1 to numptr,
not the integer value it is holding. The pointer numptr will not contain 100, but the actual
address num1 has been assigned by the operating system. (In a sense, since the name num1
stands for the memory address of num1’s value, and numptr contains the address of num1,
numptr is really holding the name num1. This makes numptr a reference to num1.)
Now, if we output both num1 and numptr using the statements
cout << num1 << endl;
cout << numptr << endl;

the first line will output 100 onto the screen, while the second line will output an address
usually displayed in hexadecimal digits.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Dereferencing Operator (*) |

815

In the next section, after discussing the dereference operator, we will explain how to
output the value of the memory location whose address is stored in numptr.

Dereferencing Operator (*)
Every chapter until now has used the asterisk character, *, as the binary multiplication
operator. C++ also uses * as a unary operator. When used as a unary operator, *,
commonly referred to as the dereferencing operator or indirection operator, refers
to the object to which its operand (that is, the pointer) points. For example, given the
statements:
int x = 25;
int *p;
p = &x;
//store the address of x in p

the statement:
cout << *p << endl;

prints the value stored in the memory space pointed to by p, which is the value of x. Also,
the statement:
*p = 55;

stores 55 in the memory location pointed to by p—that is, in x.

EXAMPLE 12-1
Let us consider the following statements:
int *p;
int num;

In these statements, p is a pointer variable of type int, and num is a variable of type int.
Let us assume that memory location 1200 is allocated for p, and memory location 1800 is
allocated for num. (See Figure 12-1.)

. . .

. . .
1200
p

FIGURE 12-1

. . .
1800
num

Variables p and num

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

816 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Consider the following statements:
1. num = 78;
2. p = &num;
3. *p = 24;

The following shows the values of the variables after the execution of each statement.
After
Statement
1

2

3

Values of the Variables
. . .

. . .

Explanation
78

1200
p

1800
num

. . . 1800 . . .

78

1200
p

1800
num

. . . 1800 . . .

24

1200
p

1800
num

. . .

The statement num = 78; stores

78 into num.

. . .

. . .

The statement p = &num; stores
the address of num, which is 1800,
into p.

The statement *p = 24; stores 24
into the memory location to which p
points. Because the value of p is
1800, statement 3 stores 24 into
memory location 1800. Note that the
value of num is also changed.

Let us summarize the preceding discussion.
1. A declaration such as int *p; allocates memory for p only, not for *p.
Later, you will learn how to allocate memory for *p.
2. The content of p points only to a memory location of type int.
3. &p, p, and *p all have different meanings.
4. &p means the address of p—that is, 1200 (in Figure 12-1).
5. p means the content of p, which is 1800, after the statement p = &num;
executes.
6. *p means the content of the memory location to which p points.
Note that after the statement p = &num; executes, the value
of *p is 78; after the statement *p = 24; executes, the value of
*p is 24.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Dereferencing Operator (*) |

817

EXAMPLE 12-2
Consider the following statements:
int *p;
int x;

Suppose that we have the memory allocation for p and x as shown in Figure 12-2.

. . .

. . .
1400
p

FIGURE 12-2

. . .
1750
x

Variables p and x

The values of &p, p, *p, &x, and x are as follows:
&p

1400

p

? (unknown)

*p

Does not exist
(undefined)

&x

1750

x ? (unknown)

Suppose that the following statements are executed in the order given:
x = 50;
p = &x;
*p = 38;

The values of &p, p, *p, &x, and x are shown after each of these statements executes.
After the statement x = 50; executes, the values of &p, p, *p, &x, and x are as follows:
&p

1400

p

? (unknown)

*p

Does not exist
(undefined)

&x

1750

x 50

After the statement p = &x; executes, the values of &p, p, *p, &x, and x are as follows:
&p

1400

p

1750

*p

50

&x

1750

x 50

After the statement *p = 38; executes, the values of &p, p, *p, &x, and x are as follows.
(Because *p and x refer to the same memory space, the value of x is also changed to 38.)
&p

1400

p

1750

*p

38

&x

1750

x 38

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

818 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Let us note the following:
1. p is a pointer variable.
2. The content of p points only to a memory location of type int.
3. Memory location x exists and is of type int. Therefore, the assignment
statement:
p = &x;

is legal. After this assignment statement executes, *p is valid and
meaningful.
The program in Example 12-3 further illustrates how a pointer variable works.
EXAMPLE 12-3
The following program illustrates how pointer variables work:
//Chapter 12: Example 12-3
#include <iostream>
#include <iomanip>

//Line 1
//Line 2

using namespace std;

//Line 3

const double PI = 3.1416;

//Line 4

int main()
{
double radius;
double *radiusPtr;

//Line
//Line
//Line
//Line

5
6
7
8

cout << fixed << showpoint << setprecision(2);

//Line 9

radius = 2.5;
radiusPtr = &radius;

//Line 10
//Line 11

cout << "Line 12: Radius = " << radius
<< ", area = " << PI * radius * radius << endl;

//Line 12

cout << "Line 13: Radius = " << *radiusPtr
<< ", area = "
<< PI * (*radiusPtr) * (*radiusPtr) << endl;

//Line 13

cout << "Line 14: Enter the radius: ";
cin >> *radiusPtr;
cout << endl;

//Line 14
//Line 15
//Line 16

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Dereferencing Operator (*) |

819

cout <<
<<
cout <<
<<
<<
<<

"Line 17: Radius = " << radius << ", area = "
PI * radius * radius << endl;
//Line 17
"Line 18: Radius = " << *radiusPtr
", area = "
PI * (*radiusPtr) * (*radiusPtr) << endl
endl;
//Line 18

cout <<
<<
cout <<
<<
cout <<
<<
cout <<
<<

"Line 19: Address of radiusPtr: "
&radiusPtr << endl;
"Line 20: Value stored in radiusPtr: "
radiusPtr << endl;
"Line 21: Address of radius: "
&radius << endl;
"Line 22: Value stored in radius: "
radius << endl;

return 0;
}

//Line 19
//Line 20
//Line 21
//Line 22
//Line 23
//Line 24

Sample Run: In this sample run, the user input is shaded.
Line 12: Radius = 2.50, area = 19.64
Line 13: Radius = 2.50, area = 19.64
Line 14: Enter the radius: 4.90
Line 17: Radius = 4.90, area = 75.43
Line 18: Radius = 4.90, area = 75.43
Line
Line
Line
Line

19:
20:
21:
22:

Address of radiusPtr: 0012FF50
Value stored in radiusPtr: 0012FF5C
Address of radius: 0012FF5C
Value stored in radius: 4.90

The preceding program works as follows. The statement in Line 7 declares radius to
be a variable of type double and the statement in Line 8 declares radiusPtr to be a
pointer variable of type double. The statement in Line 10 stores 2.5 in radius and
the statement in Line 11 stores the address of radius in radiusPtr. The statement in
Line 12 outputs the radius and area of the circle using the value stored in the memory
location radius. The statement in Line 13 outputs the radius and area of the circle
using the value stored in the memory location to which radiusPtr is pointing. Note
that the output of the statements in Lines 12 and 13 is the same because radiusPtr
points to radius. Next, the statement in Line 14 prompts the user to input the radius
and the statement in Line 15 stores the radius in the memory location to which
radiusPtr is pointing. Next, similar to the statements in Lines 12 and 13, the
statements in Lines 17 and 18 output the radius and area using the variables radius
and radiusPtr. The statements in Lines 19 to 22, output the address of radiusPtr,
the value stored in radiusPtr, the address of radius, and the value stored in radius.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

820 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

From the output of the statements in Lines 20 and 21, it follows that radiusPtr stores
the address of the variable radius. (Note that the address of radiusPtr, the value of
radiusPtr, and the address of radius as shown by the output of Lines 19, 20, and 21,
respectively, are machine dependent. When you run this program on your machine,
you are likely to get different values. Furthermore, the pointer values, that is, the
addresses, are printed in hexadecimal by default.)

Classes, Structs, and Pointer Variables
In the previous section, you learned how to declare and manipulate pointers of simple
data types, such as int and char. You can also declare pointers to other data types, such
as classes. You will now learn how to declare and manipulate pointers to classes and
structs. (Recall that both classes and structs have the same capabilities. The only difference
between classes and structs is that, by default, all members of a class are private, and, by
default, all members of a struct are public. Therefore, the following discussion applies
to both.)
Consider the following declaration of a struct:
struct studentType
{
char name[26];
double gpa;
int sID;
char grade;
};
studentType student;
studentType *studentPtr;

In the preceding declaration, student is an object of type studentType, and
studentPtr is a pointer variable of type studentType. The following statement stores
the address of student in studentPtr:
studentPtr = &student;

The following statement stores 3.9 in the component gpa of the object student:
(*studentPtr).gpa = 3.9;

The expression (*studentPtr).gpa is a mixture of pointer dereferencing and the class
component selection. In C++, the dot operator, ., has a higher precedence than the
dereferencing operator.
Let us elaborate on this a bit. In the expression (*studentPtr).gpa, the operator *
evaluates first, so the expression *studentPtr evaluates first. Because studentPtr is a
pointer variable of type studentType, *studentPtr refers to a memory space of type

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes, Structs, and Pointer Variables |

821

studentType, which is a struct. Therefore, (*studentPtr).gpa refers to the
component gpa of that struct.

Consider the expression *studentPtr.gpa. Let us see how this expression gets evaluated.
Because. (dot) has a higher precedence than *, the expression studentPtr.gpa evaluates
first. The expression studentPtr.gpa would result in a syntax error, as studentPtr is
not a struct variable, so it has no such component as gpa.
As you can see, in the expression (*studentPtr).gpa, the parentheses are important.
However, typos can be problematic. Therefore, to simplify the accessing of class or
struct components via a pointer, C++ provides another operator called the member
access operator arrow, ->. The operator -> consists of two consecutive symbols: a
hyphen and the ‘‘greater than’’ sign.
The syntax for accessing a class (struct) member using the operator -> is:
pointerVariableName->classMemberName

Thus, the statement:
(*studentPtr).gpa = 3.9;

is equivalent to the statement:
studentPtr->gpa = 3.9;

Accessing class (struct) components via pointers using the operator -> thus eliminates
the use of both parentheses and the dereferencing operator. Because typos are unavoidable and missing parentheses can result in either an abnormal program termination or
erroneous results, when accessing class (struct) components via pointers, this book
uses the arrow notation.
Example 12-4 illustrates how pointers work with class member functions.
EXAMPLE 12-4
Consider the following class:
class classExample
{
public:
void setX(int a);
//Function to set the value of x
//Postcondition: x = a;
void print() const;
//Function to output the value of x
private:
int x;
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

822 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

The definition of the member function is as follows:
void classExample::setX(int a)
{
x = a;
}
void classExample::print() const
{
cout << "x = " << x << endl;
}

Consider the following function main:
int main()
{
classExample *cExpPtr;
classExample cExpObject;

//Line 1
//Line 2

cExpPtr = &cExpObject;

//Line 3

cExpPtr->setX(5);
cExpPtr->print();

//Line 4
//Line 5

return 0;
}

Sample Run:
x = 5

In the function main, the statement in Line 1 declares cExpPtr to be a pointer of type
classExample, and the statement in Line 2 declares cExpObject to be an object of
type classExample. The statement in Line 3 stores the address of cExpObject into
cExpPtr (see Figure 12-3). (Note that in Figure 12-3, the arrow originates from the box
cExpPtr and points to the box cExpObject. It means that cExpPtr contains the address
of the memory location cExpObject, that is, cExpPtr points to cExpObject.)

cExpObject
cExpPtr

FIGURE 12-3

x

cExpObject and cExpPtr after the statement cExpPtr = &cExpObject;

executes

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Initializing Pointer Variables |

823

In the statement in Line 4, the pointer cExpPtr accesses the member function setX to
set the value of the member variable x (see Figure 12-4).

cExpObject
cExpPtr

FIGURE 12-4

x

5

cExpObject and cExpPtr after the statement cExpPtr->setX(5); executes

In the statement in Line 5, the pointer cExpPtr accesses the member function print to
print the value of x, as shown above.

Initializing Pointer Variables
Because C++ does not automatically initialize variables, pointer variables must be
initialized if you do not want them to point to anything. Pointer variables are
initialized using the constant value 0, called the null pointer. Thus, the statement
p = 0; stores the null pointer in p, that is, p points to nothing. Some programmers
use the named constant NULL to initialize pointer variables. The named constant
NULL is defined in the header file cstddef. The following two statements are
equivalent:
p = NULL;
p = 0;

The number 0 is the only number that can be directly assigned to a pointer variable.

Initializing Pointer Variables Using nullptr
C++11 Standard provides the null pointer nullptr to initialize pointer variables.
A pointer with the value nullptr points to nothing, and is called the null pointer.
nullptr has a special value type that can be converted to any pointer type. The
following statement declares p to be a pointer of type int and it also initializes it to
the null pointer:
int *p = nullptr;

Because the compiler that we have used to test the code has implemented this feature of
C++11 Standard, we can initialize the pointer variable using the int value 0, using
another pointer variable of the same type, or using nullptr.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

824 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Dynamic Variables
Watch
the Video

In the previous sections, you learned how to declare pointer variables, how to store the
address of a variable into a pointer variable of the same type as the variable, and how to
manipulate data using pointers. However, you learned how to use pointers to manipulate
data only into memory spaces that were created using other variables. In other words, the
pointers manipulated data into already existing memory spaces. But you could have
accessed these memory spaces through the variables that were used to create them. So
what is the benefit of using pointers? In this section, you will learn about the power
behind pointers. In particular, you will learn how to allocate and deallocate memory
during program execution using pointers.
Variables that are created during program execution are called dynamic variables. With
the help of pointers, C++ creates dynamic variables. C++ provides two operators, new
and delete, to create and destroy dynamic variables, respectively. When a program
requires a new variable, the operator new is used. When a program no longer needs a
dynamic variable, the operator delete is used.
In C++, new and delete are reserved words.

Operator new
The operator new has two forms: one to allocate a single variable and another to allocate
an array of variables. The syntax to use the operator new is:
new dataType;
new dataType[intExp];

//to allocate a single variable
//to allocate an array of variables

in which intExp is any expression evaluating to a positive integer.
The operator new allocates memory (as a variable) of the designated type and returns a
pointer to it—that is, the address of this allocated memory. Moreover, the allocated
memory is uninitialized.
Consider the following declaration:
int *p;
char *q;
int x;
The statement:
p = &x;

stores the address of x in p. However, no new memory is allocated. On the other hand,
consider the following statement:
p = new int;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Dynamic Variables |

825

This statement creates a variable during program execution somewhere in memory and
stores the address of the allocated memory in p. The allocated memory is accessed via
pointer dereferencing—namely, *p. Similarly, the statement:
q = new char[16];

creates an array of 16 components of type char and stores the base address of the array in q.
Because a dynamic variable is unnamed, it cannot be accessed directly. It is accessed indirectly
by the pointer returned by new. The following statements illustrate this concept:
int *p;
char *name;
string *str;

//p is a pointer of type int
//name is a pointer of type char
//str is a pointer of type string

p = new int;

//allocates memory of type int
//and stores the address of the
//allocated memory in p
//stores 28 in the allocated memory

*p = 28;

name = new char[5];

strcpy(name, "John");

//allocates memory for an array of
//five components of type char and
//stores the base address of the array
//in name
//stores John in name

str = new string; //allocates memory of type string
//and stores the address of the
//allocated memory in str
*str = "Sunny Day";
//stores the string "Sunny Day" in
//the memory pointed to by str

Recall that the operator new allocates memory space of a specific type and returns
the address of the allocated memory space. However, if the operator new is unable to allocate
the required memory space (for example, there is not enough memory space), then it throws a
bad_alloc exception, and if this exception is not handled, it terminates the program with
an error message. Exceptions are covered in detail in Chapter 14. This chapter also discusses
bad_alloc exception.

Operator delete
Suppose you have the following declaration:
int *p;

This statement declares p to be a pointer variable of type int. Next, consider the
following statements:
p = new int;
*p = 54;

//Line 1
//Line 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

826 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

p = new int;
*p = 73;

//Line 3
//Line 4

Figure 12-5 shows the effect of these statements.

1500
p 1500

1500
p 1500

(a) p after the execution of
p = new int;

(b) p and *p after the
execution of *p = 54;

1500

1500

54

54

1800
p 1800

(c) p after the execution of
p = new int;

FIGURE 12-5

54

1800
p 1800

73

(d) p and *p after the
execution of *p = 73;

p after the memory space it points to following the execution of various statements

(The number 1500 on top of the box indicates the address of the memory space.) The
statement in Line 1 allocates memory space of type int and stores the address of the allocated
memory space into p. Suppose that the address of allocated memory space is 1500. Then, the
value of p after the execution of this statement is 1500 (see Figure 12-5(a)). The statement in
Line 2 stores 54 into the memory space that p points to, which is 1500 (see Figure 12-5(b)).
Next, the statement in Line 3 executes, which allocates a memory space of type int
and stores the address of the allocated memory space into p. Suppose the address of
this allocated memory space is 1800. It follows that the value of p is now 1800 (see
Figure 12-5(c)). The statement in Line 4 stores 73 into the memory space that p points
to, which is 1800. In other words, after the execution of the statement in Line 4, the
value stored into memory space at location 1800 is 73 (see Figure 12-5(d)).
Now the obvious question is what happened to the memory space 1500 that p was
pointing to after execution of the statement in Line 1. After execution of the statement in
Line 3, p points to the new memory space at location 1800. The previous memory space
at location 1500 is now inaccessible. In addition, the memory space 1500 remains as
marked allocated. In other words, it cannot be freed or reallocated. This is called
memory leak. That is, there is an unused memory space that cannot be allocated.
Imagine what would happen if you executed statements, such as Line 3, a few thousand
or a few million times. There would be a good amount of memory leak. The program
might then run out of memory spaces for data manipulation, which would result in an
abnormal termination of the program.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Dynamic Variables |

827

The question at hand is how to avoid memory leak. When a dynamic variable is no longer
needed, it can be destroyed; that is, its memory can be deallocated. The C++ operator delete
is used to destroy dynamic variables. The syntax to use the operator delete has two forms:
delete pointerVariable;

//to deallocate a single
//dynamic variable
delete [] pointerVariable; //to deallocate a dynamically
//created array

Thus, given the declarations of the previous section, the statements:
delete p;
delete [] name;
delete str;

deallocate the memory spaces that the pointers p, name, and str point to.
Suppose p and name are pointer variables, as declared previously. Notice that an expression such as:
delete p;

or:
delete [] name;

only marks the memory spaces that these pointer variables point to as deallocated.
Depending on the particular operating system, after these statements execute, these
pointer variables may still contain the addresses of the deallocated memory spaces. In this
case, we say that these pointers are dangling. Therefore, if later you access the memory
spaces via these pointers without properly initializing them, depending on the particular
system, either the program will access a wrong memory space, which may result in
corrupting data now stored in those spaces, or the program may terminate with an error
message. One way to avoid this pitfall is to set these pointers to NULL after the delete
operation. Also note that for the operator delete to work properly, the pointer must
point to a valid memory space.
In Example 12-3, we used the pointer variable radiusPtr to access the memory location of
the variable radius. However, in that example, the radiusPtr pointed to an existing
memory, which was not created during program execution. In the following example, we
illustrate how to use the new and delete operators to allocate and deallocate dynamic memory.
EXAMPLE 12-5
The following program illustrates how to use the operators new and delete.
//This program illustrates how to use the operators new and delete.
#include <iostream>
#include <iomanip>

//Line 1
//Line 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

828 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

using namespace std;
const double PI = 3.1416;

//Line 3
//Line 4

int main()
{
double *radiusPtr;

//Line 5
//Line 6
//Line 7

cout << fixed << showpoint << setprecision(2);

//Line 8

radiusPtr = new double;

//Line 9

cout << "Line 10: Enter the radius: ";
cin >> *radiusPtr;
cout << endl;

//Line 10
//Line 11
//Line 12

cout << "Line 13: Radius = " << *radiusPtr
<< ", area = " << PI * (*radiusPtr) * (*radiusPtr)
<< endl << endl;
//Line 13
cout <<
<<
cout <<
<<
cout <<
<<
<<

"Line 14: Address of radiusPtr: "
&radiusPtr << endl;
"Line 15: Value stored in radiusPtr: "
radiusPtr << endl;
"Line 16: Value stored in the memory "
"location to which \n
radiusPtr "
"is pointing: " << *radiusPtr << endl;

delete radiusPtr;
cout <<
<<
<<
<<

//Line 15
//Line 16
//Line 17

"Line 18: After using the delete operator, "
"the value stored in the location\n
"
"to which radiusPtr is pointing: "
*radiusPtr << endl;
//Line 18

double *lengthPtr = new double;
radiusPtr = new double;

//Line 19
//Line 20

*radiusPtr = 5.38;

//Line 21

cout <<
<<
cout <<
<<
cout <<
<<
<<
cout <<
<<

"Line 22: Address of radiusPtr: "
&radiusPtr << endl;
"Line 23: Value stored in radiusPtr: "
radiusPtr << endl;
"Line 24: Value stored in the memory "
"location to which radiusPtr is pointing: "
*radiusPtr << endl;
"Line 25: Value stored in lengthPtr: "
lengthPtr << endl;

return 0;
}

//Line 14

//Line 22
//Line 23
//Line 24
//Line 25
//Line 26
//Line 27

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operations on Pointer Variables |

829

Sample Run: In this sample run, the user input is shaded.
Line 10: Enter the radius: 2.5
Line 13: Radius = 2.50, area = 19.64
Line 14: Address of radiusPtr: 0012FF60
Line 15: Value stored in radiusPtr: 003450A8
Line 16: Value stored in the memory location to which
radiusPtr is pointing: 2.50
Line 18: After using the delete operator, the value stored in the location
to which radiusPtr is pointing: -145681599014746290000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000.00
Line 22: Address of radiusPtr: 0012FF60
Line 23: Value stored in radiusPtr: 00345550
Line 24: Value stored in the memory location to which radiusPtr is pointing:
5.38
Line 25: Value stored in lengthPtr: 003450A8

For the most part, the preceding program is the same as the program in Example 12-3.
However, let us note the following: the statement in Line 9 allocates memory of type
double and stores the address of the allocated memory in radiusPtr. The output of the
statement in Line 15 shows that the address of the allocated memory is 003450A8. Next
the statement in Line 17 deallocates the memory space to which radiusPtr is pointing.
The statement in Line 18 outputs the value stored in the memory location to which
radiusPtr is pointing. As shown by the output of this statement, the value stored is a
strange number. This is because after the delete operation in Line 17, radiusPtr does
not point to a valid memory location. Next, the statement in Line 19 declares the pointer
variable lengthPtr, allocates memory space of type double, and stores the address of the
allocated memory space in lengthPtr. The statement in Line 20 allocates (another)
memory space of type double and stores the address of the allocated memory space in
radiusPtr, and the statement in Line 21 stores 5.38 in the allocated memory space.
The statements in Lines 22 to 25 output the addresses as shown by the output. (Note that
the addresses and the value printed by the statement in Line 18 are machine dependent.
When you run this program on your machine, you are likely to get different values.)

Operations on Pointer Variables
The operations that are allowed on pointer variables are the assignment and relational
operations and some limited arithmetic operations. The value of one pointer variable can
be assigned to another pointer variable of the same type.
For example, suppose that we have the following statements:
int *p, *q;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

830 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

The statement:
p = q;

copies the value of q into p. After this statement executes, both p and q point to the same
memory location. Any changes made to *p automatically change the value of *q, and vice versa.
Two pointer variables of the same type can be compared for equality, and so on. The
expression:
p == q

evaluates to true if p and q have the same value—that is, if they point to the same
memory location. Similarly, the expression:
p != q

evaluates to true if p and q point to different memory locations.
Integer values can be added and subtracted from a pointer variable. The value of one pointer
variable can be subtracted from another pointer variable. The arithmetic operations that are
allowed differ from the arithmetic operations on numbers. First, let us use the following
statements to explain the increment and decrement operations on pointer variables:
int *p;
double *q;
char *chPtr;
studentType *stdPtr;

//studentType is as defined before

Recall that the size of the memory allocated for an int variable is 4 bytes, a double
variable is 8 bytes, and a char variable is 1 byte. The memory allocated for a variable of
type studentType is then 40 bytes.
The statement:
p++;

or

p = p + 1;

increments the value of p by 4 bytes because p is a pointer of type int. Similarly, the
statements:
q++;
chPtr++;

increment the value of q by 8 bytes and the value of chPtr by 1 byte, respectively. The
statement:
stdPtr++;

increments the value of stdPtr by 40 bytes.
The increment operator increments the value of a pointer variable by the size of the data
type or structure to which it is pointing. Similarly, the decrement operator decrements
the value of a pointer variable by the size of the data type or structure to which it is
pointing.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Dynamic Arrays

|

831

Moreover, the statement:
p = p + 2;

increments the value of p (an int pointer) by 8 bytes.
Thus, when an integer is added to a pointer variable, the value of the pointer variable is
incremented by the integer times the size of the data type or structure to which the pointer is
pointing. Similarly, when an integer is subtracted from a pointer variable, the value of the
pointer variable is decremented by the integer times the size of the data type or structure to
which the pointer is pointing.
Pointer arithmetic can be very dangerous. Using pointer arithmetic, the program can
accidentally access the memory locations of other variables and change their content
without warning, leaving the programmer trying to find out what went wrong. If a pointer
variable tries to access either the memory spaces of other variables or an illegal memory
space, some systems might terminate the program with an appropriate error message.
Always exercise extra care when doing pointer arithmetic.

Dynamic Arrays
In Chapter 8, you learned how to declare and process arrays. The arrays discussed in
Chapter 8 are called static arrays because their size was fixed at compile time. One of the
limitations of a static array is that every time you execute the program, the size of the
array is fixed, so it might not be possible to use the same array to process different data sets
of the same type. One way to handle this limitation is to declare an array that is large
enough to process a variety of data sets. However, if the array is very big and the data set
is small, such a declaration would result in memory waste. On the other hand, it would
be helpful if, during program execution, you could prompt the user to enter the size of
the array and then create an array of the appropriate size. This approach is especially
helpful if you cannot even guess the array size. In this section, you will learn how to
create arrays during program execution and process such arrays.
An array created during the execution of a program is called a dynamic array. To create
a dynamic array, we use the second form of the new operator.
The statement:
int *p;

declares p to be a pointer variable of type int. The statement:
p = new int[10];

allocates 10 contiguous memory locations, each of type int, and stores the address of the
first memory location into p. In other words, the operator new creates an array of
10 components of type int, it returns the base address of the array, and the assignment
operator stores the base address of the array into p. Thus, the statement:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

832 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

*p = 25;

stores 25 into the first memory location, and the statements:
p++;
*p = 35;

//p points to the next array component

store 35 into the second memory location. Thus, by using the increment and decrement
operations, you can access the components of the array. Of course, after performing a few
increment operations, it is possible to lose track of the first array component. C++ allows
us to use array notation to access these memory locations. For example, the statements:
p[0] = 25;
p[1] = 35;

store 25 and 35 into the first and second array components, respectively. That is, p[0]
refers to the first array component, p[1] refers to the second array component, and so on.
In general, p[i] refers to the (i + 1)th array component. Unlike using pointer arithmetic,
after the preceding statements execute, p still points to the first array component. The
following for loop initializes each array component to 0:
for (j = 0; j < 10; j++)
p[j] = 0;

in which j is an int variable.
When the array notation is used to process the array pointed to by p, p stays fixed at
the first memory location. Moreover, p is a dynamic array created during program execution.
The statement:

int list[5];
declares list to be an array of five components of type int. Recall from Chapter 8 that
list itself is a variable, and the value stored in list is the base address of the array—
that is, the address of the first array component. Suppose the address of the first array
component is 1000. Figure 12-6 shows list and the array list.

list 1000
list[0] 1000
list[1] 1004
list[2] 1008
list[3] 1012
list[4] 1016

FIGURE 12-6

list and array list

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Dynamic Arrays

|

833

Because the value of list, which is 1000, is a memory address, list is a pointer
variable. However, the value stored in list, which is 1000, cannot be altered during
program execution. That is, the value of list is constant. Therefore, the increment and
decrement operations cannot be applied to list. In fact, any attempt to use the
increment or decrement operations on list results in a compile-time error.
Notice that here we are only saying that the value of list cannot be changed. However,
the data into the array list can be manipulated as before. For example, the statement
list[0] = 25; stores 25 into the first array component. Similarly, the statement
list[3] = 78; stores 78 into the fourth component of list (see Figure 12-7).

list 1000
list[0] 1000

25

list[1] 1004
list[2] 1008
list[3] 1012

78

list[4] 1016

FIGURE 12-7

Array list after the execution of the statements list[0] = 25; and
list[3] = 78;

If p is a pointer variable of type int, then the statement:

p = list;
copies the value of list, which is 1000, the base address of the array, into p. Unlike the
case with the name list, we are allowed to perform increment and decrement operations on the pointer p.
An array name is a constant pointer.

1
2

EXAMPLE 12-6
The following program segment illustrates how to obtain a user’s response to get the array size
and create a dynamic array during program execution. Consider the following statements:
int *intList;
int arraySize;

//Line 1
//Line 2

cout << "Enter array size: ";
cin >> arraySize;
cout << endl;

//Line 3
//Line 4
//Line 5

intList = new int[arraySize];

//Line 6

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

834 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

The statement in Line 1 declares intList to be a pointer of type int, and the statement
in Line 2 declares arraySize to be an int variable. The statement in Line 3 prompts the
user to enter the size of the array, and the statement in Line 4 inputs the array size into the
variable arraySize. The statement in Line 6 creates an array of the size specified by
arraySize, and the base address of the array is stored in intList. From this point on,
you can treat intList just like any other array. For example, you can use the array
notation to process the elements of intList and pass intList as a parameter to the
function.

Arrays and Range-Based for Loops (Revisited)
Chapter 8 introduced range-based for loops, which is a feature of C++11 Standard, and
discussed how it can be effectively used to process the elements of an array. We also
pointed out that if a formal parameter of a function is an array, a range-based for loop
cannot be used on that formal parameter. In this section, we explain why this is the case.
Consider the following statements:
int *list;

//Line 1

list = new int [5];

//Line 2

for (int i = 0; i < 5; i++)
list [i] = i * i;

//Line 3
//Line 4

for (int x: list)
cout << x << " ";

//Line 5;
//Line 6

illegal range-based for loop

The statement in Line 1 declares list to be a pointer variable of type int. During
execution, the statement in Line 2 creates an array of five components of type int and
stores the base address of the array into the pointer list. The statements in Lines 3 and 4
initialize the array to which list points. Now, the array to which list points is a
dynamic array. So at the compile time, the pointer list, even though it will contain the
base address of an array, has no first and no last elements. Therefore, in the for loop in
Line 5, x cannot be initialized to the first element of the array list. Thus, the rangebased for loop in Line 5 is illegal and will result in a syntax (compiler) error. In essence, a
range-based for loop cannot be used on dynamic arrays. The following code shows the
type of syntax errors generated by the compiler when a range-based for loop is used on a
dynamic array.
1.
2.
3.
4.
5.
6.

#include <iostream>
using namespace std;
int main()
{

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Dynamic Arrays

7.
8.
9.
10.
11.
12.
13.
14.
15.
16.
17.
18.
19. }

|

835

int *list;
list = new int [5];
for (int i = 0; i < 5; i++)
list [i] = i * i;
for (auto x : list)
cout << x << " ";
cout << endl;
return 0;

Syntax errors generated by the compiler:
Ch12_Example_RangeBased_For_Loops.cpp
c:\ch12_example_rangebased_for_loops.cpp(15): error C3312: no
callable 'begin' function found for type 'int *'
c:\ch12_example_rangebased_for_loops.cpp(15): error C3312: no
callable 'end' function found for type 'int *'
c:\ch12_example_rangebased_for_loops.cpp(15): error C2065: 'x':
undeclared identifier

Note that in the previous programming code, the numbers on the left are not part of the
code. These numbers are merely to show the line number. The syntax errors generated
by the complier shows that the syntax errors are in Line 15. This is due to the fact that the
pointer list has no first and no last elements and so the functions begin and end cannot
be called on list.
Next, consider the following function:
void testFunc(int *p; int list[])
{
}

The function testFunc has two formal parameters: p is a pointer variable of type
int, and list is an array of type int. Now p is a pointer of type int, so it can
contain the address of an int variable and the base address of an int array. Suppose
that in a call to function testFunc, p contains the base address of an array.
However, during compilation p does not have the first and the last elements, so in
the definition of the function testFunc, a range-based for loop cannot be used on
p. Next, consider the formal parameter list. Even though list is declared as an
array, it is still a pointer of type int and can only contain the base address of any
array of type int. However, during compilation list does not have the first and the
last elements, so in the definition of the function testFunc, a range-based for loop
cannot be used on list.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

836 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Functions and Pointers
A pointer variable can be passed as a parameter to a function either by value or by
reference. To declare a pointer as a value parameter in a function heading, you use the
same mechanism as you use to declare a variable. To make a formal parameter be a
reference parameter, you use & when you declare the formal parameter in the function
heading. Therefore, to declare a formal parameter as a reference pointer parameter,
between the data type name and the identifier name, you must include * to make the
identifier a pointer and & to make it a reference parameter. The obvious question is: In
what order should & and * appear between the data type name and the identifier to
declare a pointer as a reference parameter? In C++, to make a pointer a reference
parameter in a function heading, * appears before the & between the data type name
and the identifier. The following example illustrates this concept:
void pointerParameters(int* &p, double *q)
{
.
.
.
}

In the function pointerParameters, both p and q are pointers. The parameter p is a
reference parameter; the parameter q is a value parameter. Furthermore, the function
pointerParameters can change the value of *q, but not the value of q. However, the
function pointerParameters can change the value of both p and *p.

Pointers and Function Return Values
In C++, the return type of a function can be a pointer. For example, the return type of
the function:
int* testExp(...)
{
.
.
.
}

is a pointer type int.

Dynamic Two-Dimensional Arrays
The beginning of this section discussed how to create dynamic one-dimensional arrays. You
can also create dynamic multidimensional arrays. In this section, we discuss how to create
dynamic two-dimensional arrays. Dynamic multidimensional arrays are created similarly.
There are various ways you can create dynamic dimensional arrays. One way is as follows.
Consider the statement:
int *board[4];

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Dynamic Arrays

|

837

This statement declares board to be an array of four pointers wherein each pointer is of
type int. Because board[0], board[1], board[2], and board[3] are pointers, you
can now use these pointers to create the rows of board. Suppose that each row of board
has six columns. Then, the following for loop creates the rows of board.
for (int row = 0; row < 4; row++)
board[row] = new int[6];

Note that the expression new int[6] creates an array of six components of type int and
returns the base address of the array. The assignment statement then stores the returned
address into board[row]. It follows that after the execution of the previous for loop,
board is a two-dimensional array of four rows and six columns.
In the previous for loop, if you replace the number 6 with the number 10, then the loop
will create a two-dimensional array of four rows and 10 columns. In other words, the
number of columns of board can be specified during execution. However, the way
board is declared, the number of rows is fixed. So in reality, board is not a true dynamic
two-dimensional array.
Next, consider the following statement:
int **board;

This statement declares board to be a pointer to a pointer. In other words, board and
*board are pointers. Now board can store the address of a pointer or an array of pointers
of type int, and *board can store the address of an int memory space or an array of int
values.
Suppose that you want board to be an array of 10 rows and 15 columns. To accomplish
this, first we create an array of 10 pointers of type int and assign the address of that array
to board. The following statement accomplishes this:
board = new int* [10]; //create an array of 10 int pointers

Because the elements of board are int pointers, each of them can point to an array of int
values.
Next, we create the columns of board. The following for loop accomplishes this:
for (int row = 0; row < 10; row++)
board[row] = new int[15];

To access the components of board, you can use the array subscripting notation discussed
in Chapter 8.
Note that the number of rows and the number of columns of board can be specified
during program execution. The following program further explains how to create twodimensional arrays.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

838 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

EXAMPLE 12-7
// Dynamic two-dimensional arrays
#include <iostream>
#include <iomanip>
using namespace std;
void fill(int **p, int rowSize, int columnSize);
void print(int **p, int rowSize, int columnSize);
int main()
{
int **board;

//Line 1

int rows;
int columns;

//Line 2
//Line 3

cout << "Line 4: Enter the number of rows "
<<"and columns: ";
//Line 4
cin >> rows >> columns;
//Line 5
cout << endl;
//Line 6
//Create the rows of board
board = new int* [rows];

//Line 7

//Create the columns of board
for (int row = 0; row < rows; row++)
board[row] = new int[columns];

//Line 8
//Line 9

//Insert elements into board
fill(board, rows, columns);

//Line 10

cout << "Line 11: Board:" << endl;

//Line 11

//Output the elements of board
print(board, rows, columns);

//Line 12

return 0;
}
void fill(int **p, int rowSize, int columnSize)
{
for (int row = 0; row < rowSize; row++)
{
cout << "Enter " << columnSize << " number(s) for row "
<< "number " << row << ": ";
for (int col = 0; col < columnSize; col++)
cin >> p[row][col];
cout << endl;
}
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Shallow versus Deep Copy and Pointers |

839

void print(int **p, int rowSize, int columnSize)
{
for (int row = 0; row < rowSize; row++)
{
for (int col = 0; col < columnSize; col++)
cout << setw(5) << p[row][col];
cout << endl;
}
}

Sample Run: In this sample run, the user input is shaded.
Line 4: Enter the number of rows and columns: 3 4
Enter 4 number(s) for row number 0: 1 2 3 4
Enter 4 number(s) for row number 1: 5 6 7 8
Enter 4 number(s) for row number 2: 9 10 11 12
Line 11: Board:
1
2
3
5
6
7
9
10
11

4
8
12

The preceding program contains the functions fill and print. The function fill
prompts the user to enter the elements of a two-dimensional array of type int. The
function print outputs the elements of a two-dimensional array of type int.
For the most part, the preceding output should be clear. Let us look at the statements in
the function main. The statement in Line 1 declares board to be a pointer to a pointer of
type int. The statements in Lines 2 and 3 declare int variables rows and columns. The
statement in Line 4 prompts the user to input the number of rows and number of
columns. The statement in Line 5 stores the number of rows in the variable rows and
the number of columns in the variable columns. The statement in Line 7 creates the
rows of board, and the for loop in Lines 8 and 9 creates the columns of board. The
statement in Line 10 uses the function fill to fill the array board, and the statement in
Line 12 uses the function print to output the elements of board.

Shallow versus Deep Copy and Pointers
In an earlier section, we discussed pointer arithmetic and explained that if we are not careful,
one pointer might access the data of another (completely unrelated) pointer. This event might
result in unsuspected or erroneous results. Here, we discuss another peculiarity of pointers. To
facilitate the discussion, we will use diagrams to show pointers and their related memory.
Consider the following statements:
int *first;
int *second;
first = new int[10];
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

840 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

The first two statements declare first and second pointer variables of type int. The
third statement creates an array of 10 components, and the base address of the array is
stored into first (see Figure 12-8). (Note that first together with the arrow indicates
that first points to the allocated memory.)

first

FIGURE 12-8

Pointer first and the array to which it points

Suppose that some meaningful data is stored in the array pointed to by first. To be
specific, suppose that this array is as shown in Figure 12-9.
first

FIGURE 12-9

10 36 89 29 47 64 28 92 37 73

Pointer first and its array

Next, consider the following statement:
second = first;

//Line A

This statement copies the memory address held by first into second. After this statement
executes, both first and second point to the same array, as shown in Figure 12-10.
first

10 36 89 29 47 64 28 92 37 73

second

FIGURE 12-10

first and second after the statement second = first; executes

Let us next execute the following statement:
delete [] second;

After this statement executes, the array pointed to by second is deleted. This action
results in Figure 12-11.
first
second

FIGURE 12-11

first and second after the statement delete [] second; executes

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes and Pointers: Some Peculiarities

|

841

Because first and second point to the same array, after the statement:
delete [] second;

executes, first becomes invalid, that is, first (as well as second) are now dangling
pointers. Therefore, if the program later tries to access the memory pointed to by first,
either the program will access the wrong memory or it will terminate in an error. This
case is an example of a shallow copy. More formally, in a shallow copy, two or more
pointers of the same type point to the same memory; that is, they point to the same data.
On the other hand, suppose that instead of the earlier statement, second = first; (in
Line A), we have the following statements:
second = new int[10];
for (int j = 0; j < 10; j++)
second[j] = first[j];

The first statement creates an array of 10 components of type int, and the base address of
the array is stored in second. The second statement copies the array pointed to by first
into the array pointed to by second (see Figure 12-12).

FIGURE 12-12

first

10 36 89 29 47 64 28 92 37 73

second

10 36 89 29 47 64 28 92 37 73

first and second both pointing to their own data

Both first and second now point to their own data. If second deletes its memory, there
is no effect on first. This case is an example of a deep copy. More formally, in a deep
copy, two or more pointers of the same type each point to their own copy of the data.
From the preceding discussion, it follows that you must know when to use a shallow
copy and when to use a deep copy.

Classes and Pointers: Some Peculiarities
In the previous section, we discussed how to use the arrow notation to access class
members via the pointer if a pointer variable is of a class type. Because a class can have
pointer member variables, this section discusses some peculiarities of such classes. To
facilitate the discussion, we will use the following class:
class ptrMemberVarType
{

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

842 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

public:
.
.
.
private:
int x;
int lenP;
int *p;
};

Also, consider the following statements (see Figure 12-13):
ptrMemberVarType objectOne;
ptrMemberVarType objectTwo;

objectOne

FIGURE 12-13

objectTwo
x

x

lenP

lenP

p

p

Objects objectOne and objectTwo

Destructor
The object objectOne has a pointer member variable p. Suppose that during program
execution, the pointer p creates a dynamic array. When objectOne goes out of scope, all
of the member variables of objectOne are destroyed. However, p created a dynamic
array, and dynamic memory must be deallocated using the operator delete. Thus, if the
pointer p does not use the delete operator to deallocate the dynamic array, the memory
space of the dynamic array will stay marked as allocated, even though it cannot be
accessed. How do we ensure that when p is destroyed, the dynamic memory created
by p is also destroyed? Suppose that objectOne is as shown in Figure 12-14.

objectOne

x 8
lenP 50
p
5 36 24 15 ...

FIGURE 12-14

Object objectOne and its data

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes and Pointers: Some Peculiarities

|

843

Recall that if a class has a destructor, the destructor automatically executes whenever a
class object goes out of scope (see Chapter 10). Therefore, we can put the necessary code
in the destructor to ensure that when objectOne goes out of scope, the memory created
by the pointer p is deallocated. For example, the definition of the destructor for the
class ptrMemberVarType is:
ptrMemberVarType::~ptrMemberVarType()
{
delete [] p;
}

Of course, you must include the destructor as a member of the class in its definition.
Let us extend the definition of the class ptrMemberVarType by including the
destructor. Moreover, the remainder of this section assumes that the definition of the
destructor is as given previously—that is, the destructor deallocates the memory space
pointed to by p.
class ptrMemberVarType
{
public:
~ptrMemberVarType();
.
.
.
private:
int x;
int lenP;
int *p;
};
For the destructor to work properly, the pointer p must have a valid value. If p is not
properly initialized (that is, if the value of p is garbage) and the destructor executes,
either the program terminates with an error message or the destructor deallocates an
unrelated memory space. For this reason, you should exercise extra caution when working
with pointers.

Assignment Operator
This section describes the limitations of the built-in assignment operators for classes with
pointer member variables. Suppose that objectOne and objectTwo are as shown in
Figure 12-15.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

844 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

objectOne

x 8

objectTwo

x
lenP

lenP 50

p

p
5 36 24 15 ...

FIGURE 12-15

Objects objectOne and objectTwo

Recall that one of the built-in operations on classes is the assignment operator. For
example, the statement:
objectTwo = objectOne;

copies the member variables of objectOne into objectTwo. That is, the value of
objectOne.x is copied into objectTwo.x, and the value of objectOne.p is copied
into objectTwo.p. Because p is a pointer, this member-wise copying of the data would
lead to a shallow copying of the data. That is, both objectTwo.p and objectOne.p
would point to the same memory space, as shown in Figure 12-16.

objectOne

x 8

objectTwo

x 8

lenP 50

lenP 50

p

p
5 36 24 15 ...

FIGURE 12-16

Objects objectOne and objectTwo after the statement objectTwo = objectOne;
executes

Now, if objectTwo.p deallocates the memory space to which it points, objectOne.p
would become invalid. This situation could very well happen if the class
ptrMemberVarType has a destructor that deallocates the memory space pointed to by p
when an object of type ptrMemberVarType goes out of scope. It suggests that there must be
a way to avoid this pitfall. To avoid this shallow copying of data for classes with a pointer
member variable, C++ allows the programmer to extend the definition of the assignment
operator. This process is called overloading the assignment operator. Chapter 13 explains
how to accomplish this task by using operator overloading. Once the assignment operator is
properly overloaded, both objectOne and objectTwo have their own data, as shown in
Figure 12-17.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes and Pointers: Some Peculiarities

objectOne

objectTwo

x 8

845

x 8

lenP 50

lenP 50

p

p
5 36 24 15 ...

FIGURE 12-17

|

5 36 24 15 ...

Objects objectOne and objectTwo

Copy Constructor
When declaring a class object, you can initialize it by using the value of an existing object
of the same type. For example, consider the following statement:
ptrMemberVarType objectThree(objectOne);

The object objectThree is being declared and is also being initialized by using the value
of objectOne. That is, the values of the member variables of objectOne are copied into
the corresponding member variables of objectThree. This initialization is called the
default member-wise initialization. The default member-wise initialization is due to the
copy constructor provided by the compiler. Just as in the case of the assignment
operator, because the class ptrMemberVarType has member variables that are pointers,
this default initialization would lead to a shallow copying of the data, as shown in Figure
12-18. (Assume that objectOne is given as before.)

objectOne

x 8

objectThree

x 8

lenP 50

lenP 50

p

p
5 36 24 15 ...

FIGURE 12-18

Objects objectOne and objectThree

Before describing how to overcome this deficiency, let us describe one more situation that
could also lead to a shallow copying of the data. The solution to both these problems is the same.
Recall that as parameters to a function, class objects can be passed either by reference or
by value. Remember that the class ptrMemberVarType has the destructor, which
deallocates the memory space pointed to by p. Suppose that objectOne is as shown in
Figure 12-19.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

846 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

objectOne

x 8
lenP 50
p
5 36 24 15 ...

FIGURE 12-19

Object objectOne

Let us consider the following function prototype:
void destroyList(ptrMemberVarType paramObject);

The function destroyList has a formal value parameter, paramObject. Now consider
the following statement:
destroyList(objectOne);

In this statement, objectOne is passed as a parameter to the function destroyList.
Because objectOne is passed by value to paramObject, the copy constructor copies
the member variables of objectOne into the corresponding member variables of
paramObject. Just as in the previous case, paramObject.p and objectOne.p would
point to the same memory space, as shown in Figure 12-20.

destroyList
objectOne

x 8

paramObject

x 8

lenP 50

lenP 50

p

p
5 36 24 15 ...

FIGURE 12-20

Pointer member variables of objects objectOne and paramObject pointing to the
same array

Because objectOne is passed by value, the member variables of paramObject should
have their own copy of the data. In particular, paramObject.p should have its own
memory space. How do we ensure that this is, in fact, the case?

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes and Pointers: Some Peculiarities

|

847

If a class has pointer member variables:
•

During object declaration, the initialization of one object using the value
of another object will lead to a shallow copying of the data if the default
member-wise copying of data is allowed.
• If, as a parameter, an object is passed by value and the default member-wise
copying of data is allowed, it will lead to a shallow copying of the data.
In both cases, to force each object to have its own copy of the data, we must override the
definition of the copy constructor provided by the compiler; that is, we must provide our own
definition of the copy constructor. This is usually done by putting a statement that includes the
copy constructor in the definition of the class and then writing the definition of the copy
constructor. Then, whenever the copy constructor needs to be executed, the system would
execute the definition provided by us, not the one provided by the compiler. Therefore, for
the class ptrMemberVarType, we can overcome this shallow copying problem by including the copy constructor in the class ptrMemberVarType. Example 12-8 illustrates this.
The copy constructor automatically executes in three situations (the first two are
described previously).
•
•
•

When an object is declared and initialized by using the value of another object
When, as a parameter, an object is passed by value
When the return value of a function is an object

Therefore, once the copy constructor is properly defined for the class
ptrMemberVarType, both objectOne.p and objectThree.p will have their own
copies of the data. Similarly, objectOne.p and paramObject.p will have their own
copies of the data, as shown in Figure 12-21.

destroyList
objectOne

x 8

paramObject

lenP 50

lenP 50

p

p
5 36 24 15 ...

FIGURE 12-21

x 8

1
2
5 36 24 15 ...

Pointer member variables of objects objectOne and paramObject with their
own data

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

848 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

When the function destroyList exits, the formal parameter paramObject goes
out of scope, and the destructor for the object paramObject deallocates the memory space
pointed to by paramObject.p. However, this deallocation has no effect on objectOne.
The general syntax to include the copy constructor in the definition of a class is:
className(const className& otherObject);

Notice that the formal parameter of the copy constructor is a constant reference parameter.
Example 12-8 illustrates how to include the copy constructor in a class and how it works.
EXAMPLE 12-8
Consider the following class:
class ptrMemberVarType
{
public:
void print() const;
//Function to output the data stored in the array p.
void insertAt(int index, int num);
//Function to insert num into the array p at the
//position specified by index.
//If index is out of bounds, the program is terminated.
//If index is within bounds, but greater than the index
//of the last item in the list, num is added at the end
//of the list.
ptrMemberVarType(int size = 10);
//Constructor
//Creates an array of the size specified by the
//parameter size; the default array size is 10.
~ptrMemberVarType();
//Destructor
//deallocates the memory space occupied by the array p.
ptrMemberVarType(const ptrMemberVarType& otherObject);
//Copy constructor
private:
int maxSize; //variable to store the maximum size of p
int length; //variable to store the number elements in p
int *p;
//pointer to an int array
};

Suppose that the definitions of the members of the class ptrMemberVarType are as
follows:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes and Pointers: Some Peculiarities

|

849

void ptrMemberVarType::print() const
{
for (int i = 0; i < length; i++)
cout << p[i] << " ";
}
void ptrMemberVarType::insertAt(int index, int num)
{
//if index is out of bounds, terminate the program
assert(index >= 0 && index < maxSize);
if (index < length)
p[index] = num;
else
{
p[length] = num;
length++;
}
}
ptrMemberVarType::ptrMemberVarType(int size)
{
if (size <= 0)
{
cout << "The array size must be positive." << endl;
cout << "Creating an array of the size 10." << endl;
maxSize = 10;
}
else
maxSize = size;
length = 0;
p = new int[maxSize];
}
ptrMemberVarType::~ptrMemberVarType()
{
delete [] p;
}
//copy constructor
ptrMemberVarType::ptrMemberVarType
(const ptrMemberVarType& otherObject)
{
maxSize = otherObject.maxSize;
length = otherObject.length;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

850 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

p = new int[maxSize];
for (int i = 0; i < length; i++)
p[i] = otherObject.p[i];
}

Consider the following function main. (We assume that the definition of the class
ptrMemberVarType is in the header file ptrMemberVarType.h.)
#include <iostream>
#include "ptrMemberVarType.h"
using namespace std;
void testCopyConst(ptrMemberVarType temp);
int main()
{
ptrMemberVarType listOne;

//Line 1

int num;
int index;

//Line 2
//Line 3

cout << "Line 4: Enter 5 integers." << endl;

//Line 4

for (index = 0; index < 5; index++)
{
cin >> num;
listOne.insertAt(index, num);
}

//Line 5

cout << "Line 8: listOne: ";
listOne.print();
cout << endl;

//Line 8
//Line 9
//Line 10

//Line 6
//Line 7

//Declare listTwo and initialize it using listOne
ptrMemberVarType listTwo(listOne);
//Line 11
cout << "Line 12: listTwo: ";
listTwo.print();
cout << endl;

//Line 12
//Line 13
//Line 14

listTwo.insertAt(5, 34);
listTwo.insertAt(2, -76);

//Line 15
//Line 16

cout << "Line 17: After modifying listTwo: ";
listTwo.print();
cout << endl;

//Line 17
//Line 18
//Line 19

cout << "Line 20: After modifying listTwo, "
<< "listOne: ";
listOne.print();
cout << endl;

//Line 20
//Line 21
//Line 22

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Classes and Pointers: Some Peculiarities

|

851

cout << "Line 23: Calling the function testCopyConst"
<< endl;
//Line 23
//Call function testCopyConst
testCopyConst(listOne);

//Line 24

cout << "Line 25: After a call to the function "
<< "testCopyConst, " << endl
<< "
listOne is: ";
//Line 25
listOne.print();
cout << endl;

//Line 26
//Line 27

return 0;

//Line 28

}
void testCopyConst(ptrMemberVarType temp)
{
cout << "Line 29: *** Inside the function "
<< "testCopyConst ***" << endl;

//Line 29

cout << "Line 30: Object temp data: ";
temp.print();
cout << endl;

//Line 30
//Line 31
//Line 32

temp.insertAt(3, -100);
cout << "Line 34: After changing temp: ";
temp.print();
cout << endl;

//Line
//Line
//Line
//Line

cout << "Line 37: *** Exiting the function "
<< "testCopyConst ***" << endl;

//Line 37

33
34
35
36

}

Sample Run: In this sample run, the user input is shaded.
Line
14 8
Line
Line
Line
Line
Line
Line
Line
Line
Line
Line

4: Enter 5 integers.
34 2 58
8: listOne: 14 8 34 2 58
12: listTwo: 14 8 34 2 58
17: After modifying listTwo: 14 8 -76 2 58 34
20: After modifying listTwo, listOne: 14 8 34 2 58
23: Calling the function testCopyConst
29: *** Inside the function testCopyConst ***
30: Object temp data: 14 8 34 2 58
34: After changing temp: 14 8 34 -100 58
37: *** Exiting the function testCopyConst ***
25: After a call to the function testCopyConst,
listOne is: 14 8 34 2 58

In the preceding program, the statement in Line 1 declares listOne to be an object of type
ptrMemberVarType. The member variable p of listOne is an array of size 10, which is

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

852 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

the default array size. The for loop in Line 5 reads and stores five integers in listOne.p.
The statement in Line 9 outputs the numbers stored in listOne, that is, the five numbers
stored in p. (See the output of the line marked Line 8 in the sample run.)
The statement in Line 11 declares listTwo to be an object of type ptrMemberVarType and
also initializes listTwo using the values of listOne. The statement in Line 13 outputs the
numbers stored in listTwo. (See the output of the line marked Line 12 in the sample run.)
The statements in Lines 15 and 16 modify listTwo, and the statement in Line 18 outputs
the modified data of listTwo. (See the output of the line marked Line 17 in the sample
run.) The statement in Line 21 outputs the data stored in listOne. Notice that the data
stored in listOne is unchanged, even though listTwo modified its data. It follows that
the copy constructor used to initialize listTwo using listOne (at Line 11) provides
listTwo its own copy of the data.
The statements in Lines 23 through 28 show that when listOne is passed as a parameter by
value to the function testCopyConst (see Line 24), the corresponding formal parameter
temp has its own copy of data. Notice that the function testCopyConst modifies the
object temp; however, the object listOne remains unchanged. See the outputs of the lines
marked Line 23 (before the function testCopyConst is called) and Line 25 (after the
function testCopyConst terminates) in the sample run. Also notice that when the function
testCopyConst terminates, the destructor of the class ptrMemberVarType deallocates
the memory space occupied by temp.p, which has no effect on listOne.p.
For classes with pointer member variables, three things are normally done:
1. Include the destructor in the class.
2. Overload the assignment operator for the class.
3. Include the copy constructor.
Chapter 13 discusses overloading the assignment operator. Until then, whenever we
discuss classes with pointer member variables, out of the three items in the previous list,
we will implement only the destructor and the copy constructor.

Inheritance, Pointers, and Virtual Functions
Recall that as a parameter, a class object can be passed either by value or by reference. Earlier
chapters also said that the types of the actual and formal parameters must match. However, in
the case of classes, C++ allows the user to pass an object of a derived class to a formal parameter of the
base class type. This is because the derived class has the base class as its foundation. The formal
parameter recognizes the base class portion of the derived class and allows it to pass.
First, let us discuss the case in which the formal parameter is either a reference parameter
or a pointer. To be specific, let us consider the following classes:
class petType
{
public:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance, Pointers, and Virtual Functions |

853

void print();
petType(string n = "");
private:
string name;
};
class dogType: public petType
{
public:
void print();
dogType(string n = "", string b = "");
private:
string breed;
};

The class petType has three members. The class dogType is derived from the
class petType and has three members of its own. Both classes have a member
function print. Suppose that the definitions of the member functions of both classes
are as follows:
void petType::print()
{
cout << "Name: " << name;
}
petType::petType(string n)
{
name = n;
}
void dogType::print()
{
petType::print();
cout << ", Breed: " << breed << endl;
}

Consider the following function in a user program (client code):
void callPrint(petType& p)
{
p.print();
}

The function callPrint has a formal reference parameter p of type petType. You can
call the function callPrint by using an object of either type petType or type dogType
as a parameter. Moreover, the body of the function callPrint calls the member
function print. Consider the following function main:
int main()
{
petType pet("Lucky");
dogType dog("Tommy", "German Shepherd");
pet.print();
cout << endl;
dog.print();

//Line 1
//Line 2
//Line 3
//Line 4
//Line 5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

854 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

cout << "*** Calling the function callPrint ***"
<< endl;
//Line 6
callPrint(pet);
//Line 7
cout << endl;
//Line 8
callPrint(dog);
//Line 9
cout << endl;
//Line 10
return 0;
}

Sample Run:
Name: Lucky
Name: Tommy, Breed: German Shepherd
*** Calling the function callPrint ***
Name: Lucky
Name: Tommy

The statements in Lines 1 through 6 are quite straightforward. Let us look at the
statements in Lines 7 and 9. The statement in Line 7 calls the function callPrint and
passes the object pet as the parameter; it generates the fourth line of the output. The
statement in Line 9 also calls the function callPrint but passes the object dog as the
parameter; it generates the fifth line of the output. The output generated by the statements in Lines 7 and 9 shows only the value of name, even though each time a different
class object was passed as a parameter. Because in Line 9, object dog is passed as a
parameter to the function callPrint, one would expect that the output generated by
the statement in Line 9 should be the same as the second line of the output. What actually
occurred is that for both statements (Lines 7 and 9), the member function print of the
base class petType was executed. This is due to the fact that the binding of the
member function print in the body of the function callPrint occurred at compile
time. Because the formal parameter p of the function callPrint is of type petType, the
compiler associates the function print of the class petType for the statement
p.print();. More specifically, in compile-time binding, the necessary code to call
a specific function is generated by the compiler. (Compile-time binding is also known as
static binding or early binding.)
For the statement in Line 9, the actual parameter is of type dogType. Thus, when
the body of the function callPrint executes, logically the print function of object
dog should execute, which is not the case. So, during program execution, how does
C++ correct this problem of making the call to the appropriate function? C++
corrects this problem by providing the mechanism of virtual functions. The binding
of virtual functions occurs at program execution time, not at compile time. This kind
of binding is called run-time binding, late binding, or dynamic binding. More
formally, in run-time binding, the compiler does not generate the code to call a
specific function. Instead, it generates enough information to enable the run-time
system to generate the specific code for the appropriate function call. Run-time
binding is also known as dynamic binding.
In C++, virtual functions are declared using the reserved word virtual. Let us redefine
the previous classes using this feature.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance, Pointers, and Virtual Functions |

class petType
{
public:
virtual void print();
petType(string n = "");

855

//virtual function

private:
string name;
};
class dogType: public petType
{
public:
void print();
dogType(string n = "", string b = "");
private:
string breed;
};

Note that we need to declare a virtual function only in the base class.
The definition of the dogType member function print is the same as before. Because
we have placed a virtual function declaration in the base class, a base class object can use
the derived class’s definition. For example, if we execute the previous program with these
modifications, the output is as follows:
Sample Run:
Name: Lucky
Name: Tommy, Breed: German Shepherd
*** Calling the function callPrint ***
Name: Lucky
Name: Tommy, Breed: German Shepherd

This output shows that for the statement in Line 9, the print function of dogType is
executed (see the last two lines of the output).
The previous discussion also applies when a formal parameter is a pointer to a class, and a
pointer of the derived class is passed as an actual parameter. To illustrate this feature,
suppose we have the preceding classes. (We assume that the definition of the class
petType is in the header file petType.h, and the definition of the class dogType is in
the header file dogType.h.) Consider the following program:
#include <iostream>
#include "petType.h"
#include "dogType.h"
using namespace std;
void callPrint(petType *p);
int main()
{
petType *q;
dogType *r;

//Line 1
//Line 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

856 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

q = new petType("Lucky");
//Line 3
r = new dogType("Tommy", "German Shepherd"); //Line 4
q->print();
cout << endl;
r->print();

//Line 5
//Line 6
//Line 7

cout << "*** Calling the function callPrint
<< endl;
callPrint(q);
cout << endl;
callPrint(r);

***"
//Line
//Line
//Line
//Line

8
9
10
11

return 0;
}
void callPrint(petType *p)
{
p->print();
}

Sample Run:
Name: Lucky
Name: Tommy, Breed: German Shepherd
*** Calling the function callPrint ***
Name: Lucky
Name: Tommy, Breed: German Shepherd

The preceding examples show that if a formal parameter, say p of a class type, is either a
reference parameter or a pointer and p uses a virtual function of the base class, we can
effectively pass a derived class object as an actual parameter to p.
However, if p is a value parameter, then this mechanism of passing a derived class object as an
actual parameter to p does not work, even if p uses a virtual function. Recall that, if a formal
parameter is a value parameter, the value of the actual parameter is copied into the formal
parameter. Therefore, if a formal parameter is of a class type, the member variables of the
actual object are copied into the corresponding member variables of the formal parameter.
Suppose that we have the above classes—that is, petType and dogType. Consider the
following function definition:
void callPrint(petType p)
{
p.print();
}

//p is a value parameter

Further suppose that we have the following declaration:
dogType dog;

The object dog has two member variables, name and breed. The member variable name
is inherited from the base class. Consider the following function call:
callPrint(dog);
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Inheritance, Pointers, and Virtual Functions |

857

In this statement, because the formal parameter p is a value parameter, the member variables
of dog are copied into the member variables of p. However, because p is an object of type
petType, it has only one member variable. Consequently, only the member variable name of
dog will be copied into the member variable name of p. Also, because the statement:
p.print();

in the body of the function is linking print to the petType object p, it will result in
executing the member function print of the class petType.
The output of the following program further illustrates this concept. (As before, we
assume that the definition of the class petType is in the header file petType.h, and the
definition of the class dogType is in the header file dogType.h.)
//Chapter 12: Virtual Functions and Value Parameters
#include <iostream>
#include "petType.h"
#include "dogType.h"
using namespace std;
void callPrint(petType p);
int main()
{
petType pet("Lucky");
dogType dog("Tommy", "German Shepherd");

//Line 1
//Line 2
//Line 3
//Line 4
//Line 5

pet.print();
cout << endl;
dog.print();

cout << "*** Calling the function callPrint ***"
<< endl;
//Line 6
callPrint(pet);
//Line 7
cout << endl;
//Line 8
callPrint(dog);
//Line 9
cout << endl;
//Line 10
return 0;
}
void callPrint(petType p)
{

//p is a value parameter

p.print();
}

Sample Run:
Name: Lucky
Name: Tommy, Breed: German Shepherd
*** Calling the function callPrint ***
Name: Lucky
Name: Tommy

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

858 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Look closely at the output of the statements in Lines 7 and 9 (the last two lines of
output). In Line 9, because the formal parameter p is a value parameter, the member
variables of dog are copied into the corresponding member variables of p. However,
because p is an object of base type petType, it has only the one member variable
name. Consequently, only the member variable name of dog is copied into the
member variable name of p. Moreover, the statement p.print(); in the function
callPrint executes the function print of the base class petType, not of the
derived class dogType. Therefore, the last line of the output shows only the value
of name (the member variable of dog).
An object of the base class type cannot be passed to a formal parameter of the derived
class type because it is missing the derived class ‘‘parts.’’

Before closing this section, we discuss another issue related to virtual functions.
Suppose that the definition of the class petType is as before, and the definition of the
class dogType is modified slightly as follows:
class dogType: public petType
{
public:
void print();
void setBreed(string b = "");
dogType(string n = "", string b = "");
private:
string breed;
};

Consider the following statements:
petType pet("Lucky");
dogType dog("Tommy", "German Shepherd");
pet = dog;

C++ allows this type of assignment, that is, the values of a derived class object can be
copied into a base class object. (Note that the reverse statement, that is, dog = pet;
is not allowed.) Now, because the object pet has only one data member (name),
only the value of the data member name of dog is copied into the data member name
of pet. This is called the slicing problem. The following statement will result in a
compile-time error.
pet.setBreed("Siberian Husky");

C++ offers pointers as a way to treat a dogType object as a petType object without
losing the additional properties of the class dogType.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Abstract Classes and Pure Virtual Functions |

859

For example, suppose that you have the following statements:
petType *pet;
dogType *dog;
dog = new dogType("Tommy", "German Shepherd");
dog->setBreed("Siberian Husky ");
pet = dog;

The last statement copies the value of dog, which is a reference to the object dog, into
pet. So the pointer pet points to the object dog. Therefore, the output of the statement
pet->print();

is: Name: Tommy, Breed: Siberian Husky

Classes and Virtual Destructors
One thing recommended for classes with pointer member variables is that these classes should
have the destructor. The destructor executes automatically when the class object goes out of
scope. Thus, if the object creates dynamic memory space, the destructor can be designed to
deallocate that memory space. If a derived class object is passed to a formal parameter of the
base class type, the destructor of the base class executes regardless of whether the derived class
object is passed by reference or by value. Logically, however, the destructor of the derived
class should be executed when the derived class object goes out of scope.
To correct this problem, the destructor of the base class must be virtual. The virtual
destructor of a base class automatically makes the destructor of a derived class virtual.
When a derived class object is passed to a formal parameter of the base class type, then
when the object goes out of scope, the destructor of the derived class executes. After
executing the destructor of the derived class, the destructor of the base class executes.
Therefore, when the derived class object is destroyed, the base class part (that is, the
members inherited from the base class) of the derived class object is also destroyed.
If a base class contains virtual functions, make the destructor of the base class virtual.

Abstract Classes and Pure Virtual Functions
The preceding sections discussed virtual functions. Other than enforcing run-time binding of functions, virtual functions also have another use, which is discussed in this section.
Chapter 11 discussed the second principle of OOD—inheritance. Through inheritance
we can derive new classes without designing them from scratch. The derived classes, in
addition to inheriting the existing members of the base class, can add their own members
and also redefine or override public and protected member functions of the base class.
The base class can contain functions that you would want each derived class to implement. There are many scenarios when it is desirable for a class to serve as a base class for a
number of derived classes; however, the derived classes may contain certain functions that
may not have meaningful definitions in the base class.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

860 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Let us consider the class shape given in Chapter 11. As noted in that chapter, from the
class shape, you can derive other classes, such as rectangle, circle, ellipse, and so
on. Some of the things common to every shape are its center, using the center to move a shape
to a different location, and drawing the shape. We can include these in the class shape. For
example, you could have the definition of the class shape similar to the following:
class shape
{
public:
virtual void draw();
//Function to draw the shape.
virtual void move(double x, double y);
//Function to move the shape at the position
//(x, y).
.
.
.
};

Because the definitions of the functions draw and move are specific to a particular shape,
each derived class can provide an appropriate definition of these functions. Note that we
have made the functions draw and move virtual to enforce run-time binding of these
functions.
This definition of the class shape requires you to write the definitions of the functions
draw and move. However, at this point, there is no shape to draw or move. Therefore,
these function bodies have no code. One way to handle this is to make the body of these
functions empty. This solution would work, but it has a drawback. Once we write the
definitions of the functions of the class shape, then we could create an object of this
class and invoke the empty draw and move functions. Because there is no shape to work
with, we would like to prevent the user from creating objects of the class shape. It
follows that we would like to do the following two things—to not include the definitions
of the functions draw and move and to prevent the user from creating objects of the
class shape.
Because we do not want to include the definitions of the functions draw and move of the
class shape, we must convert these functions to pure virtual functions. In this case,
the prototypes of these functions are:
virtual void draw() = 0;
virtual void move(double x, double y) = 0;

Note the expression = 0 before the semicolon. Once you make these functions pure
virtual functions in the class shape, you no longer need to provide the definitions of
these functions for the class shape.
Once a class contains one or more pure virtual functions, then that class is called an
abstract class. Thus, the abstract definition of the class shape is similar to the
following:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Abstract Classes and Pure Virtual Functions |

861

class shape
{
public:
virtual void draw() = 0;
//Function to draw the shape. Note that this is a
//pure virtual function.
virtual void move(double x, double y) = 0;
//Function to move the shape at the position
//(x, y). Note that this is a pure virtual
//function.
.
.
.
};

Because an abstract class (or its implementation file) does not contain the definitions of
certain functions, it is not a complete class and you cannot create objects of that class.
Now suppose that we derive the class rectangle from the class shape. To make
rectangle a nonabstract class so that we can create objects of this class, the class (or its
implementation file) must provide the definitions of the pure virtual functions of its
base class, which is the class shape.
Note that in addition to the pure virtual functions, an abstract class can contain instance
variables, constructors, and functions that are not pure virtual. However, the abstract class
must provide the definitions of the constructor and functions that are not pure virtual.
The following example further illustrates how abstract classes work.
EXAMPLE 12-9
In Chapter 11, we defined the class partTimeEmployee, which was derived from the
class personType, to illustrate inheritance. We also noted that there are two types of
employees: full-time and part-time. The base salary of a full-time employee is usually
fixed for a year. In addition, a full-time employee may receive a bonus. On the other
hand, the salary of a part-time employee is usually calculated according to the pay rate per
hour and the number of hours worked. In this example, we first define the class
employeeType, derived from the class personType, to store an employee’s name
and ID. We include functions to set the ID and retrieve the ID. We also include pure
virtual functions print and calculatePay to print an employee’s data, which
includes the employee’s ID, name, and wages.
From the class employeeType, we derive the classes fullTimeEmployee and
partTimeEmployee and provide the definitions of the pure virtual functions of the
class employeeType.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

862 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

The definition of the class employeeType is:
#include "personType.h"
class employeeType: public personType
{
public:
virtual void print() const = 0;
//Function to output employee's data.
virtual double calculatePay() const = 0;
//Function to calculate and return the wages.
//Postcondition: Pay is calculated and returned
void setId(long id);
//Function to set the salary.
//Postcondition: personId = id;
long getId() const;
//Function to retrieve the id.
//Postcondition: returns personId
employeeType(string first = "", string last = "",
long id = 0);
//Constructor with parameters
//Sets the first name, last name, payRate, and
//hoursWorked according to the parameters. If
//no value is specified, the default values are
//assumed.
//Postcondition: firstName = first;
//
lastName = last; personId = id;
private:
long personId;
};

//stores the id

The definitions of the constructor and functions of the class employeeType that are
not pure virtual are:
void employeeType::setId(long id)
{
personId = id;
}
long employeeType::getId() const
{
return personId;
}
employeeType::employeeType(string first, string last, long id)
: personType(first, last)
{
personId = id;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Abstract Classes and Pure Virtual Functions |

863

The definition of the class fullTimeEmployee is:
#include "employeeType.h"
class fullTimeEmployee: public employeeType
{
public:
void set(string first, string last, long id,
double salary, double bonus);
//Function to set the first name, last name,
//id, and salary according to the parameters.
//Postcondition: firstName = first; lastName = last;
//
personId = id; empSalary = salary;
//
empBonus = bonus;
void setSalary(double salary);
//Function to set the salary.
//Postcondition: empSalary = salary;
double getSalary();
//Function to retrieve the salary.
//Postcondition: returns empSalary
void setBonus(double bonus);
//Function to set the bonus.
//Postcondition: empBonus = bonus;
double getBonus();
//Function to retrieve the bonus.
//Postcondition: returns empBonus;
void print() const;
//Function to output the first name, last name,
//and the wages.
//Postcondition: Outputs
//
Id:
//
Name: firstName lastName
//
Wages: $$$$.$$
double calculatePay() const;
//Function to calculate and return the wages.
//Postcondition: Pay is calculated and returned
fullTimeEmployee(string first = "", string last = "",
long id = 0, double salary = 0,
double bonus = 0);
//Constructor with default parameters.
//Sets the first name, last name, id, salary, and
//bonus according to the parameters. If
//no value is specified, the default values are
//assumed.
//Postcondition: firstName = first; lastName = last;
//
personId = id; empSalary = salary;
//
empBonus = bonus;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

864 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

private:
double empSalary;
double empBonus;
};

The definitions of the constructor and functions of the class fullTimeEmployee are:
void fullTimeEmployee::set(string first, string last,
long id,
double salary, double bonus)
{
setName(first, last);
setId(id);
empSalary = salary;
empBonus = bonus;
}
void fullTimeEmployee::setSalary(double salary)
{
empSalary = salary;
}
double fullTimeEmployee::getSalary()
{
return empSalary;
}
void fullTimeEmployee::setBonus(double bonus)
{
empBonus = bonus;
}
double fullTimeEmployee::getBonus()
{
return empBonus;
}
void fullTimeEmployee::print() const
{
cout << "Id: " << getId() << endl;
cout << "Name: ";
personType::print();
cout << endl;
cout << "Wages: $" << calculatePay() << endl;
}
double fullTimeEmployee::calculatePay() const
{
return empSalary + empBonus;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Abstract Classes and Pure Virtual Functions |

865

fullTimeEmployee::fullTimeEmployee(string first, string last,
long id, double salary,
double bonus)
: employeeType(first, last, id)
{
empSalary = salary;
empBonus = bonus;
}

The definition of the class partTimeEmployee is:
#include "employeeType.h"
class partTimeEmployee: public employeeType
{
public:
void set(string first, string last, long id, double rate,
double hours);
//Function to set the first name, last name, id,
//payRate, and hoursWorked according to the
//parameters.
//Postcondition: firstName = first; lastName = last;
//
personId = id;
//
payRate = rate; hoursWorked = hours
double calculatePay() const;
//Function to calculate and return the wages.
//Postcondition: Pay is calculated and returned.
void setPayRate(double rate);
//Function to set the salary.
//Postcondition: payRate = rate;
double getPayRate();
//Function to retrieve the salary.
//Postcondition: returns payRate;
void setHoursWorked(double hours);
//Function to set the bonus.
//Postcondition: hoursWorked = hours
double getHoursWorked();
//Function to retrieve the bonus.
//Postcondition: returns empBonus;
void print() const;
//Function to output the id, first name, last name,
//and the wages.
//Postcondition: Outputs
//
Id:
//
Name: firstName lastName
//
Wages: $$$$.$$

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

866 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

partTimeEmployee(string first = "", string last = "",
long id = 0,
double rate = 0, double hours = 0);
//Constructor with parameters
//Sets the first name, last name, payRate, and
//hoursWorked according to the parameters. If
//no value is specified, the default values are
//assumed.
//Postcondition: firstName = first; lastName = last;
//
personId = id, payRate = rate;
//
hoursWorked = hours;
private:
double payRate;
//stores the pay rate
double hoursWorked; //stores the hours worked
};

The definitions of the constructor and functions of the class partTimeEmployee are:
void partTimeEmployee::set(string first, string last, long id,
double rate, double hours)
{
setName(first, last);
setId(id);
payRate = rate;
hoursWorked = hours;
}
void partTimeEmployee::setPayRate(double rate)
{
payRate = rate;
}
double partTimeEmployee::getPayRate()
{
return payRate;
}
void partTimeEmployee::setHoursWorked(double hours)
{
hoursWorked = hours;
}
double partTimeEmployee::getHoursWorked()
{
return hoursWorked;
}
void partTimeEmployee::print() const
{
cout << "Id: " << getId() << endl;
cout << "Name: ";

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Abstract Classes and Pure Virtual Functions |

867

personType::print();
cout << endl;
cout << "Wages: $" << calculatePay() << endl;
}
double partTimeEmployee::calculatePay() const
{
return (payRate * hoursWorked);
}
//constructor
partTimeEmployee::partTimeEmployee(string first, string last,
long id,
double rate, double hours)
: employeeType(first, last, id)
{
payRate = rate;
hoursWorked = hours;
}

The following function main tests these classes:
#include <iostream>
#include "partTimeEmployee.h"
#include "fullTimeEmployee.h"
int main()
{
fullTimeEmployee newEmp("John", "Smith", 75, 56000, 5700);
partTimeEmployee tempEmp("Bill", "Nielson", 275, 15.50, 57);
newEmp.print();
cout << endl;
tempEmp.print();
return 0;
}

Sample Run:
Id: 75
Name: John Smith
Wages: $61700
Id: 275
Name: Bill Nielson
Wages: $883.5

The preceding output is self-explanatory. We leave the details as an exercise.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

868 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Array-Based Lists
A previous section of this chapter discussed how to use pointers to create dynamic arrays.
Chapter 8 briefly explained how loops can be used to process elements stored in an array.
Moreover, the previous sections of this chapter discussed abstract classes. Using these
features, this section discusses how to use arrays to manipulate lists. Let us first make the
following definition.
List: A collection of elements of the same type.
The length of a list is the number of elements in the list. Some of the operations
performed on a list are as follows:
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

Create the list. The list is initialized to an empty state.
Determine whether the list is empty.
Determine whether the list is full.
Find the size of the list.
Destroy, or clear, the list.
Determine whether an item is the same as a given list element.
Insert an item in the list at the specified location.
Remove an item from the list at the specified location.
Replace an item at the specified location with another item.
Retrieve an item from the list at the specified location.
Search the list for a given item.

The list we create can be sorted or unsorted. However, the algorithms to implement
certain operations are the same whether the list is sorted or unsorted. For example, a list,
sorted or unsorted, is empty if the length of the list is empty. However, the search
algorithms for sorted and unsorted lists are typically different. Therefore, next we create
the abstract class that implements some of these operations. We will separately describe
the classes to create sorted and unsorted lists. However, we must first decide how to store
the list in the computer’s memory.
Because all the elements of a list are of the same type, an effective, convenient, and a
common way to process a list is to store it in an array. Initially, the size of the array
holding the list elements is usually larger than the number of elements in the list so that, at
a later stage, the list can grow to a specific size. Thus, we must know how full the array is,
that is, we must keep track of the number of list elements stored in the array. Now, C++
allows the programmer to create dynamic arrays. Therefore, we will leave it for the user
to specify the size of the array. The size of the array can be specified when a list object is
declared. It follows that, in order to maintain and process the list in an array, we need the
following three variables:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Array-Based Lists

|

869

1. The array, list, holding the list elements.
2. A variable, length, to store the length of the list (that is, the number of
list elements currently in the array).
3. A variable, maxSize, to store the size of the array (that is, the maximum
number of elements that can be stored in the array).
Now that you know the operations to be performed on a list and ways to store the list
into computer memory, we can define the class implementing the list as an ADT (abstract
data type). For illustration purposes, we assume that the elements of the list are of type
int. We will remove this restriction when we discuss class templates in Chapter 13;
there, we will develop a generic class that can be used to process a variety of lists.
The following class defines array-based int lists as an ADT:
Now that you know the operations to be performed on a list and how to store the list
into the computer’s memory, next we define the abstract class arrayListType
implementing the list as an ADT (abstract data type).
class arrayListType
{
public:
bool isEmpty() const;
//Function to determine whether the list is empty
//Postcondition: Returns true if the list is empty;
//
otherwise, returns false.
bool isFull() const;
//Function to determine whether the list is full
//Postcondition: Returns true if the list is full;
//
otherwise, returns false.
int listSize() const;
//Function to determine the number of elements in
//the list.
//Postcondition: Returns the value of length.
int maxListSize() const;
//Function to determine the maximum size of the list
//Postcondition: Returns the value of maxSize.
void print() const;
//Function to output the elements of the list
//Postcondition: Elements of the list are output on the
//
standard output device.
bool isItemAtEqual(int location, int item) const;
//Function to determine whether item is the same as
//the item in the list at the position specified
//by location.
//Postcondition: Returns true if the list[location]
//
is the same as item; otherwise,
//
returns false.
//
If location is out of range, an
//
appropriate message is displayed.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

870 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

virtual void insertAt(int location, int insertItem) = 0;
//Function to insert insertItem in the list at the
//position specified by location.
//Note that this is an abstract function.
//Postcondition: Starting at location, the elements of
//
the list are shifted down,
//
list[location] = insertItem; length++;
//
If the list is full or location is out of
//
range, an appropriate message is displayed.
virtual void insertEnd(int insertItem) = 0;
//Function to insert insertItem at the end of
//the list. Note that this is an abstract function.
//Postcondition: list[length] = insertItem; and length++;
//
If the list is full, an appropriate
//
message is displayed.
void removeAt(int location);
//Function to remove the item from the list at the
//position specified by location
//Postcondition: The list element at list[location] is
//
removed and length is decremented by 1.
//
If location is out of range, an
//
appropriate message is displayed.
void retrieveAt(int location, int& retItem) const;
//Function to retrieve the element from the list at the
//position specified by location
//Postcondition: retItem = list[location]
//
If location is out of range, an
//
appropriate message is displayed.
virtual void replaceAt(int location, int repItem) = 0;
//Function to replace repItem the element in the list
//at the position specified by location.
//Note that this is an abstract function.
//Postcondition: list[location] = repItem
//
If location is out of range, an
//
appropriate message is displayed.
void clearList();
//Function to remove all the elements from the list
//After this operation, the size of the list is zero.
//Postcondition: length = 0;
virtual int seqSearch(int searchItem) const = 0;
//Function to search the list for searchItem.
//Note that this is an abstract function.
//Postcondition: If the item is found, returns the
//
location in the array where the item is
//
found; otherwise, returns -1.
virtual void remove(int removeItem) = 0;
//Function to remove removeItem from the list.
//Note that this is an abstract function.
//Postcondition: If removeItem is found in the list,
//
it is removed from the list and length
//
is decremented by one.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Array-Based Lists

|

871

arrayListType(int size = 100);
//Constructor
//Creates an array of the size specified by the
//parameter size. The default array size is 100.
//Postcondition: The list points to the array, length = 0,
//
and maxSize = size;
arrayListType (const arrayListType& otherList);
//Copy constructor
virtual ~arrayListType();
//Destructor
//Deallocate the memory occupied by the array.
protected:
int *list;
int length;
int maxSize;

//array to hold the list elements
//variable to store the length of the list
//variable to store the maximum
//size of the list

};

Figure 12-22 shows the UML class diagram of the class arrayListType. Note that in the
UML class diagram, the name of an abstract class and abstract function is shown in italics.

arrayListType
#*list: int
#length: int
#maxSize : int
+isEmpty () const: bool
+isFull() const: bool
+listSize () const: int
+maxListSize () const: int
+print() const : void
+isItemAtEqual (int, int) const: bool
+insertAt (int, int) = 0: void
+insertEnd (int) = 0: void
+removeAt (int): void
+retrieveAt (int, int&) const: void
+replaceAt (int, int) = 0: void
+clearList (): void
+seqSearch (int) const = 0: int
+remove(int ) = 0: void
+arrayListType (int = 100)
+arrayListType (const arrayListType &)
+~arrayListType ()

FIGURE 12-22

UML diagram of the class arrayListType

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

872 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Notice that the member variables of the class arrayListType are declared as
protected. Moreover notice that the functions insertAt, insertEnd, replaceAt,
seqSearch, insert, and remove are declared as abstract. This is because, as noted
earlier, typically we deal with two types of lists—lists whose elements are arranged
according to some criteria, such as sorted list, and lists whose elements are in no particular
order, unsorted lists. The algorithms to implement the operations, search, insert, and
remove slightly differs for sorted and unsorted lists. Therefore, by using the principle of
inheritance, from the class arrayListType, we in fact, will derive two classes:
orderedArrayListType and unorderedArrayListType.
Objects of the class unorderedArrayListType would arrange list elements in no
particular order, that is, these lists are unsorted. On the other hand, objects of the class
orderedArrayListType would arrange elements according to some comparison criteria,
usually, greater than or equal to. That is, these lists will be in ascending order. Moreover,
after inserting an element into or removing an element from an ordered list, the resulting
list will be ordered. We will, therefore, separately describe the algorithm to implement the
operations search, insert, and remove for unsorted and sorted lists. Because each of the classes
orderedArrayListType and unorderedArrayListType will provide separate definitions
of the functions insertAt, insertEnd, replaceAt, seqSearch, insert, and remove,
and because these functions would access the instance variable, to provide direct access to
the instance variables, the instance variables are declared as protected.
Next, we write the definitions of the nonabstract functions.
The list is empty if length is 0; it is full if length is equal to maxSize. Therefore, the
definitions of the functions isEmpty and isFull are
bool arrayListType::isEmpty() const
{
return (length == 0);
} //end isEmpty
bool arrayListType::isFull() const
{
return (length == maxSize);
} //end isFull

The member variable length of the class arrayListType stores the number of
elements currently in the list. Similarly, because the size of the array holding the list
elements is stored in the member variable maxSize, maxSize specifies the maximum size
of the list. Therefore, the definitions of the functions listSize and maxListSize are
int arrayListType::listSize() const
{
return length;
} //end listSize
int arrayListType::maxListSize() const
{
return maxSize;
} //end maxListSize

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Array-Based Lists

|

873

The member function print outputs the elements of the list. We assume that the output
is sent to the standard output device:
void arrayListType::print() const
{
for (int i = 0; i < length; i++)
cout << list[i] << " ";
cout << endl;
} //end print

The definition of the function isItemAtEqual is straightforward. If element at the position
location is the same as item, it returns true. If either location is out of range or
item is not in the list, it returns false. The definition of this function is:
bool arrayListType::isItemAtEqual(int location, int item)
{
if (location < 0 || location >= length)
{
cout << "The location of the item to be removed "
<< "is out of range." << endl;

const

return false;
}
else
return (list[location] == item);
} //end isItemAtEqual

The function removeAt removes an item from a specific location in the list. The location
of the item to be removed is passed as a parameter to this function. After removing the
item from the list, the length of the list is reduced by 1. If the item to be removed is
somewhere in the middle of the list, after removing the item we must move certain
elements up one array slot because we cannot leave holes in the portion of the array
containing the list. Figure 12-23 illustrates this concept.

list

FIGURE 12-23

[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
35 24 45 17 26 78

Array list

The number of elements currently in the list is 6, so length is 6. Thus, after removing an
element, the length of the list is 5. Suppose that the item to be removed is at, say location 3.
Clearly, we must move list[4] into list[3] and list[5] into list[4], in this order.
The definition of the function removeAt is
void arrayListType::removeAt(int location)
{
if (location < 0 || location >= length)
cout << "The location of the item to be removed "
<< "is out of range." << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

874 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

else
{
for (int i = location; i < length - 1; i++)
list[i] = list[i+1];
length--;
}
} //end removeAt

The definition of the function retrieveAt is straightforward. The index of the item to
be retrieved, and the location where to retrieve the item, are passed as parameters to this
function. The definition of this function is:
void arrayListType::retrieveAt(int location, int& retItem) const
{
if (location < 0 || location >= length)
cout << "The location of the item to be retrieved is "
<< "out of range" << endl;
else
retItem = list[location];
} //end retrieveAt

The function clearList removes the elements from the list, leaving it empty. Because
the member variable length indicates the number of elements in the list, the elements
are removed by simply setting length to 0. Therefore, the definition of this function is
void arrayListType::clearList()
{
length = 0;
} //end clearList

We now discuss the definition of the constructors and destructor. The constructor creates
an array of the size specified by the user, and initializes the length of the list to 0 and the
maxSize to the size of the array specified by the user. The size of the array is passed as a
parameter to the constructor. The default array size is 100. The destructor deallocates the
memory occupied by the array holding the list elements. The definitions of the constructor and the destructor are as follows:
arrayListType::arrayListType(int size)
{
if (size <= 0)
{
cout << "The array size must be positive. Creating "
<< "an array of the size 100." << endl;
maxSize = 100;
}
else
maxSize = size;
length = 0;
list = new int[maxSize];
} //end constructor
arrayListType::~arrayListType()
{
delete [] list;
} //end destructor
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Unordered Lists

|

875

Next we describe the copy constructor. Recall that the copy constructor is called when
an object is passed as a (value) parameter to a function, and when an object is declared and
initialized using the value of another object of the same type. It copies the values of the
member variables of the actual object into the corresponding member variables of the
formal parameter and the object being created. Its definition is
arrayListType::arrayListType(const arrayListType& otherList)
{
maxSize = otherList.maxSize;
length = otherList.length;
list = new int[maxSize]; //create the array
for (int j = 0; j < length; j++)
list[j] = otherList.list[j];
}//end copy constructor

//copy otherList

Unordered Lists
As described in the preceding section, we derive the class unorderedArrayListType
from the abstract class arrayListType and implement the operations insertAt,
insertEnd, replaceAt, seqSearch, insert, and remove.
The definition of the class unorderedArrayListType is: (To save space, we list the
member functions without documentation. The descriptions of these functions are the
same as the descriptions of the functions of the class arrayListType.)
class unorderedArrayListType: public arrayListType
{
public:
void insertAt(int location, int insertItem);
void insertEnd(int insertItem);
void replaceAt(int location, int repItem);
int seqSearch(int searchItem) const;
void remove(int removeItem);
unorderedArrayListType(int size = 100);
//Constructor.
};

We leave the UML class diagram and its inheritance hierarchy of the class
unorderedArrayListType as an exercise for you.
The function insertAt inserts an item at a specific location in the list. The item to be
inserted and the insert location in the array are passed as parameters to this function. In
order to insert the item somewhere in the middle of the list, we must first make room for
the new item. That is, we need to move certain elements down one array slot. Consider
the list in Figure 12-24.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

876 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
list 35 24 45 17 26 78

FIGURE 12-24

Array list

The number of elements currently in the list is 6, so length is 6. Thus, after inserting a
new element, the length of the list is 7. If the item is to be inserted at, say location 6, we
can easily accomplish this by copying the item in list[6]. On the other hand, if the
item is to be inserted at, say location 3, we first need to move elements list[3],
list[4], and list[5] one array slot left to make room for the new item. Thus, we
must first copy list[5] into list[6], list[4] into list[5], and list[3] into
list[4], in this order. Then we can copy the new item into list[3].
Of course, special cases such as trying to insert in a full list must be handled separately.
Some of these cases can be accomplished by other member functions.
The definition of the function insertAt is as follows:
void unorderedArrayListType::insertAt(int location,
int insertItem)
{
if (location < 0 || location >= maxSize)
cout << "The position of the item to be inserted "
<< "is out of range." << endl;
else if (length >= maxSize) //list is full
cout << "Cannot insert in a full list" << endl;
else
{
for (int i = length; i > location; i--)
list[i] = list[i - 1]; //move the elements down
list[location] = insertItem; //insert the item at
//the specified position
length++;
}
} //end insertAt

//increment the length

The function insertEnd can be implemented by using the function insertAt. However, the function insertEnd does not require the shifting of elements. Therefore, we
give its definition directly.
void unorderedArrayListType::insertEnd(int insertItem)
{
if (length >= maxSize) //the list is full
cout << "Cannot insert in a full list." << endl;
else
{
list[length] = insertItem; //insert the item at the end
length++; //increment the length
}
} //end insertEnd
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Unordered Lists

|

877

Chapter 8 describes a sequential or linear search. For easy reference and the sake of
completeness, next we give the sequential search algorithm for array-based lists:
int unorderedArrayListType::seqSearch(int searchItem) const
{
int loc;
bool found = false;
loc = 0;
while (loc < length && !found)
if (list[loc] == searchItem)
found = true;
else
loc++;
if (found)
return loc;
else
return -1;
} //end seqSearch

The function remove deletes an item from the list. The item to be deleted is passed as a
parameter to this function. In order to delete the item, the function calls the member
function seqSearch to determine whether or not the item to be deleted is in the list. If
the item to be deleted is found in the list, the item is removed from the list and the length
of the list is decremented by 1. If the item to be removed is found in the list, the function
seqSearch returns the index of the item in the list to be deleted. We can now use the
index returned by the function seqSearch, and use the function removeAt to remove
the item from the list. Therefore, the definition of the function remove is:
void unorderedArrayListType::remove(int removeItem)
{
int loc;
if (length == 0)
cout << "Cannot delete from an empty list." << endl;
else
{
loc = seqSearch(removeItem);
if (loc != -1)
removeAt(loc);
else
cout << "The item to be deleted is not in the list."
<< endl;
}
} //end remove

The definition of the function replaceAt is:
void unorderedArrayListType::replaceAt(int location, int repItem)
{
if (location < 0 || location >= length)
cout << "The location of the item to be "
<< "replaced is out of range." << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

878 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

else
list[location] = repItem;
} //end replaceAt

The definition of the constructor is:
unorderedArrayListType::unorderedArrayListType(int size)
: arrayListType(size)
{
} //end constructor

The following program tests the various operations on an unordered list.
EXAMPLE 12-10
#include <iostream>
#include "unorderedArrayListType.h"
using namespace std;
int main()
{
unorderedArrayListType intList(25);

//Line 1

int number;

//Line 2

cout << "List 3: Enter 8 integers: ";

//Line 3

for (int count = 0; count < 8; count++)
{
cin >> number;
intList.insertEnd(number);
}

//Line 4

cout << endl;
cout << "Line 8: intList: ";
intList.print();
cout << endl;

//Line
//Line
//Line
//Line

cout << "Line 11: Enter the number to be "
<< "deleted: ";
cin >> number;
cout << endl;

//Line 11
//Line 12
//Line 13

intList.remove(number);

//Line 14

cout << "Line 15: After removing " << number
<< " intList: ";
intList.print();
cout << endl;

//Line 15
//Line 16
//Line 17

cout << "Line 18: Enter the search item: ";

//Line 18

cin >> number;
cout << endl;

//Line 19
//Line 20

if (intList.seqSearch(number) != -1)
cout << "Line 22: " << number
<< " found in intList." << endl;

//Line 21

//Line 5
//Line 6
7
8
9
10

//Line 22

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Ordered Lists

else
cout << "Line 24: " << number
<< " is not in intList." << endl;

|

879

//Line 23
//Line 24

return 0;
}

Sample Run: In this sample run, the user input is shaded.
List
Line
Line
Line
Line
Line

3: Enter 8 integers: 23 89 54 32 56 11 88 39
8: intList: 23 89 54 32 56 11 88 39
11: Enter the number to be deleted: 23
15: After removing 23 intList: 89 54 32 56 11 88 39
18: Enter the search item: 11
22: 11 found in intList.

The preceding program is self-explanatory. We leave the details as an exercise.
The Web site accompanying this book contains the program
testProgUnorderedList_II.cpp, which illustrates how the copy constructor
on an unorderedArrayListType object works.

(Unordered Set) Recall that a list is a collection of elements of the same type. However, in
a list an element may repeat. That is, the elements of the list need not be distinct. On
the other hand, a set is also a collection of elements of the same type. However, the
elements of a set are distinct. It follows that a set is a list with distinct elements. In this
section we designed the class unorderedArrayListType to process unordered
lists. Note that the functions insertAt and insertEnd do not check whether the item
to be inserted is already in the list. Similarly, the function replaceAt, does not check if
the item to be replaced is already in the list. Just as you can design a class to manipulate
lists, you can also design a class to manipulate sets. Programming Exercise 12, at the end
of this chapter asks you to design the class unorderedSetType, derived from the
class unorderedArrayListType, to manipulate sets.

Ordered Lists
As described earlier we derive two classes from the abstract class arrayListType,
which are: unorderedArrayListType and orderedArrayListType. Elements of an
unorderedArrayListType object are in no particular order. However, elements of an
object orderedArrayListType are in ascending order. The preceding section described
the operation of the class unorderedArrayListType. This section describes the
class orderedArrayListType.
The class orderedArrayListType also contains the function insert to insert an item
at the proper place in the list. The following class defines ordered array-based int lists as

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

880 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

an ADT. (To save space, we list the member function without any documentation,
which is left as an exercise for you.)
class orderedArrayListType: public arrayListType
{
public:
void insertAt(int location, int insertItem);
void insertEnd(int insertItem);
void replaceAt(int location, int repItem);
int seqSearch(int searchItem) const;
void insert(int insertItem);
void remove(int removeItem);
orderedArrayListType(int size = 100);
//Constructor
};

We leave the UML class diagram and its inheritance hierarchy of the class
orderedArrayListType as an exercise for you.
We give only the definition of the function insert and leave others as an exercise for you.
The function insert inserts a new item at the proper place in the list and the length of
the list is increased by 1. The definition of this function is:
void orderedArrayListType::insert(int insertItem)
{
if (length == 0)
//list is empty
list[length++] = insertItem; //insert insertItem
//and increment length
else if (length == maxSize)
cout << "Cannot insert in a full list." << endl;
else
{
//Find the location in the list where to insert
//insertItem.
int loc;
bool found = false;
for (loc = 0; loc < length; loc++)
{
if (list[loc] >= insertItem)
{
found = true;
break;
}
}
for (int i = length; i > loc; i--)
list[i] = list[i - 1]; //move the elements down
list[loc] = insertItem; //insert insertItem
length++;
//increment the length
}
} //end insert
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Address of Operator and Classes

|

881

(Ordered Set) An ordered set is a collection of distinct elements of the same type.
Programming Exercise 13, at the end of this chapter asks you to design the class
orderedSetType, derived from the class orderedArrayListType, to
manipulate ordered sets.

Address of Operator and Classes
This chapter has used the address of operator, &, to store the address of a variable into a
pointer variable. The address of operator is also used to create aliases to an object.
Consider the following statements:
int x;
int &y = x;

The first statement declares x to be an int variable, and the second statement declares y
to be an alias of x. That is, both x and y refer to the same memory location. Thus, y is
like a constant pointer variable. The statement:
y = 25;

sets the value of y and, hence, the value of x to 25. Similarly, the statement:
x = 2 * x + 30;

updates the value of x and, hence, the value of y.
The address of operator can also be used to return the address of a private member
variable of a class. However, if you are not careful, this operation can result in serious
errors in the program. The following example helps illustrate this idea.
Consider the following class definition:
//header file testadd.h
#ifndef H_testAdd
#define H_testAdd
class testAddress
{
public:
void setX(int);
void printX() const;
int& addressOfX();
//this function returns the address
//of the x
private:
int x;
};
#endif

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

882 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

The definitions of the functions to implement the member functions are as follows:
//Implementation file testAdd.cpp
#include <iostream>
#include "testAdd.h"
using namespace std;
void testAddress::setX(int inX)
{
x = inX;
}
void testAddress::printX() const
{
cout << x;
}
int& testAddress::addressOfX()
{
return x;
}

Because the return type of the function addressOfX, which is int&, is an address of an
int memory location, the effect of the statement:
return x;

is that the address of x is returned.
Next, let us write a simple program that uses the class testAddress and illustrates
what can go wrong. Later, we will show how to fix the problem.
//Test program.
#include <iostream>
#include "testAdd.h"
using namespace std;
int main()
{
testAddress a;
int &y = a.addressOfX();
a.setX(50);
cout << "x in class testAddress = ";
a.printX();
cout << endl;
y = 25;
cout << "After y = 25, x in class testAddress = ";
a.printX();
cout << endl;
return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Address of Operator and Classes

|

883

Sample Run:
x in class testAddress = 50
After y = 25, x in class testAddress = 25

In the preceding program, after the statement:
int &y = a.addressOfX();

executes, y becomes an alias of the private member variable x of the object a. Thus, the
statement:
y = 25;

changes the value of x without using the member function setX.
Chapter 10 said that private member variables are not accessible outside of the class by
default. However, by returning their addresses, the programmer can make them accessible. One way to resolve this problem is to never provide the user of the class with the
addresses of the private member variables. Sometimes, however, it is necessary to
return the address of a private member variable, as we will see in the next chapter.
How can we prevent the program from directly manipulating the private member
variables? To fix this problem, we use the word const before the return type of the
function. This way, we can still return the addresses of the private member variables,
but at the same time prevent the programmer from directly manipulating the private
member variables. Let us rewrite the class testAddress using this feature.
#ifndef H_testAdd
#define H_testAdd
class testAddress
{
public:
void setX(int);
void printX() const;
const int& addressOfX(); //this function returns the
//address of the private data
//member
private:
int x;
};
#endif

The definition of the function addressOfX in the implementation file is:
const int& testAddress::addressOfX()
{
return x;
}

The same program will now generate a compile-time error.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

884 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

QUICK REVIEW
1.
2.
3.

Pointer variables contain the addresses of other variables as their values.
In C++, no name is associated with the pointer data type.
A pointer variable is declared using an asterisk, *, between the data type
and the variable. For example, the statements:
int *p;
char *ch;

4.
5.

declare p and ch to be pointer variables. The value of p points to a memory
space of type int, and the value of ch points to a memory space of type
char. Usually, p is called a pointer variable of type int, and ch is called a
pointer variable of type char.
In C++, & is called the address of operator.
The address of operator returns the address of its operand. For example, if p
is a pointer variable of type int and num is an int variable, the statement:
p = &num;

6.
7.

sets the value of p to the address of num.
When used as a unary operator, * is called the dereferencing operator.
The memory location indicated by the value of a pointer variable is
accessed by using the dereferencing operator, *. For example, if p is a
pointer variable of type int, the statement:
*p = 25;

8.
9.
10.
11.

12.

13.

sets the value of the memory location indicated by the value of p to 25.
You can use the member access operator arrow, ->, to access the component of an object pointed to by a pointer.
Pointer variables are initialized using either 0 (the integer zero), NULL,
nullptr, or the address of a variable of the same type.
The only number that can be directly assigned to a pointer variable is 0.
The only arithmetic operations allowed on pointer variables are increment
(++), decrement (--), addition of an integer to a pointer variable, subtraction of an integer from a pointer variable, and subtraction of a pointer from
another pointer.
Pointer arithmetic is different than ordinary arithmetic. When an integer is
added to a pointer, the value added to the value of the pointer variable is
the integer times the size of the object to which the pointer is pointing.
Similarly, when an integer is subtracted from a pointer, the value subtracted
from the value of the pointer variable is the integer times the size of the
object to which the pointer is pointing.
Pointer variables can be compared using relational operators. (It makes
sense to compare pointers of the same type.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

14.
15.
16.
17.
18.
19.
20.

885

The value of one pointer variable can be assigned to another pointer
variable of the same type.
A variable created during program execution is called a dynamic variable.
The operator new is used to create a dynamic variable.
The operator delete is used to deallocate the memory occupied by a
dynamic variable.
In C++, both new and delete are reserved words.
The operator new has two forms: one to create a single dynamic variable
and another to create an array of dynamic variables.
If p is a pointer of type int, the statement:
p = new int;

21.

22.

allocates storage of type int somewhere in memory and stores the address
of the allocated storage in p.
The operator delete has two forms: one to deallocate the memory
occupied by a single dynamic variable and another to deallocate the
memory occupied by an array of dynamic variables.
If p is a pointer of type int, the statement:
delete p;

23.
24.

deallocates the memory pointed to by p.
The array name is a constant pointer. It always points to the same memory
location, which is the location of the first array component.
To create a dynamic array, the form of the new operator that creates an
array of dynamic variables is used. For example, if p is a pointer of type
int, the statement:
p = new int[10];

25.

26.
27.

creates an array of 10 components of type int. The base address of the
array is stored in p. We call p a dynamic array.
Array notation can be used to access the components of a dynamic array.
For example, suppose p is a dynamic array of 10 components. Then, p[0]
refers to the first array component, p[1] refers to the second array
component, and so on. In particular, p[i] refers to the (i + 1)th component of the array.
An array created during program execution is called a dynamic array.
If p is a dynamic array, then the statement:
delete [] p;

28.

deallocates the memory occupied by p—that is, the components of p.
C++ allows a program to create dynamic multidimensional arrays.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

886 |

29.
30.
31.
32.
33.
34.

35.
36.
37.
38.
39.

40.

41.
42.

43.

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

In the statement int **board;, the variable board is a pointer to a
pointer.
In a shallow copy, two or more pointers of the same type point to the same
memory space; that is, they point to the same data.
In a deep copy, two or more pointers of the same type have their own
copies of the data.
If a class has a destructor, the destructor is automatically executed whenever
a class object goes out of scope.
If a class has pointer member variables, the built-in assignment operators
provide a shallow copy of the data.
A copy constructor executes when an object is declared and initialized by
using the value of another object and when an object is passed by value as a
parameter.
C++ allows a user to pass an object of a derived class to a formal parameter
of the base class type.
The binding of virtual functions occurs at execution time, not at compile
time, and is called dynamic, or run-time, binding.
In C++, virtual functions are declared using the reserved word virtual.
A class is called an abstract class if it contains one or more pure virtual
functions.
Because an abstract class is not a complete class—as it (or its implementation
file) does not contain the definitions of certain functions—you cannot
create objects of that class.
In addition to the pure virtual functions, an abstract class can contain
instance variables, constructors, and functions that are not pure virtual.
However, the abstract class must provide the definitions of constructors
and functions that are not pure virtual.
A list is a collection of elements of the same type.
The commonly performed operations on a list are as follows: create the list,
determine whether the list is empty, determine whether the list is full, find
the size of the list, destroy or clear the list, determine whether an item is the
same as a given list element, insert an item in the list at the specified
location, remove an item from the list at the specified location, replace an
item at the specified location with another item, retrieve an item from the
list from the specified location, and search the list for a given item.
The address of operator can be used to return the address of a private
member variable of a class.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

887

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.
b.
c.
d.

e.

f.

g.
h.
i.

j.
k.

In C++, pointer is a reserved word. (1)
In C++, pointer variables are declared using the word pointer. (2)
The address of operator returns the address and value of its operand. (3)
If p is a pointer variable, then *p refers to the memory location to
which p points. (3)
In C++, the dereferencing operator has a higher precedence than the
dot operator. (4)
Variables that are created during program execution are called dynamic
variables. (5)
Dynamic variables are destroyed using the operator new. (5, 6)
The statement delete p; deallocates the variable pointer p. (6)
The statement delete p; deallocates the dynamic variable that is
pointed to by p. (6)
If p is a pointer variable, then the statement p = p * 2; is valid in C++. (7)
Given the declaration:
int list[10];
int *p;

the statement:
p = list;

l.

is valid in C++. (8)
Given the declaration:
int *p;

the statement:
p = new int[50];

m.

n.
o.

p.

dynamically allocates an array of 50 components of type int, and
p contains the base address of the array. (8)
If a pointer p points to a dynamic array, the elements of p can be
processed using a range-based for loop. (9)
In C++, the return type of a function can be a pointer. (10)
In a shallow copy, two or more pointers of the same type point to the
same memory. (11)
The binding of virtual functions occurs at compile time. (13)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

888 |

2.

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Given the following declaration:
int num;
int *ptr1;
int *ptr2;
double *ptr3;

Mark the following statements as valid or invalid. If a statement is invalid, explain
why. (2, 3)

3.

4.

a.

ptr1 = ptr2;

b.

num = ptr1;

c.

ptr3 = ptr1;

d.

*prt3 = *ptr2;

e.

*ptr1 = *ptr2;

f.

num = *ptr2;

g.

ptr1 = &ptr2;

h.

ptr1 = &num;

i.

num = &ptr1;

How is * used to create pointers? Give an example to justify your
answer. (2)
b. How is * used to dereference pointers? Give an example to justify your
answer. (2)
Consider the following statement:

a.

int* p, q;
5.

6.

This statement could lead to what type of misinterpretation? (2)
Suppose that you have the declaration int *numPtr;. What is the difference between the expressions: *numPtr and &numPtr? (3)
What is the output of the following C++ code? (2, 3)
int x;
int y;
int *p = &x;
int *q = &y;
x = 62;
y = 38;
q = p;
*p = 55;
x = *q;
cout << x << " " << y << endl;
cout << *p << " " << *q << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

7.

|

889

Given the following statements:
int num;
int *numPtr;

8.

Write C++ statements that use the variable numPtr to increment the value
of the variable num. (2, 3)
What is the output of the following C++ code? (2, 3)
string *str;
string fName, lName;
str = &fName;
*str = "Miller";
str = &lName;
*str = "Tommy";
cout << fName << " " << lName << endl;

9.

What is the output of the following C++ code? (2, 3)
int num1;
int num2 = 14;
int *p = &num1;
*p = 35;
p = &num2;
num1 = num2 *3;
p = &num1;
num2 = 28;
*p = 37;
cout << *p << " " << num1 << " " << num2 << endl;

10.

What is the output of the following C++ code? (2, 3, 6)
int *length;
int *width;
length = new int;
*length = 5;
width = length;
length = new int;
*length = 2 * (*width);
cout << *length << " " << *width << " " << (*length) * (*width)
<< endl;

11.

What is the output of the following C++ code? (2, 3, 6)
int *first = new int;
int *second;
*first = 26;
second = first;
*second = *second + 8;
second = new int;
*second = *first - 7;
cout << *first << " " << *second << endl;

12.

What is the output of the following C++ code? (2, 3, 6)
int *p = new int;
int *q = new int;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

890 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

*p = 32;
*q = 20;
cout << 2 * (*p) << " " << (*q - 5) << endl;
q = p;
*p = 10;
cout << *p << " " << *q << endl;
p = new int;
*p = 12;
*q = 62;
cout << *p << " " << *q << endl;
13.

What is the output of the following C++ code? (Assume that decimal
numbers are output with two decimal places.) (2, 3, 6)
double *test1 = new double;
double *test2 = new double;
double *average;
average = test1;
*test1 = 45.00;
*test2 = 90.00;
test1 = test2;
test2 = new double;
*test2 = 86.00;
*average = ((*test1) + (*test2)) / 2;
cout << *test1 << " " << *test2 << " " << *average << endl;

14.

What is wrong with the following C++ code? (2, 3, 6)
double *deposit;
double *intRate;
double interest;

//Line 1
//Line 2
//Line 3

deposit = new double;
*deposit = 25000;

//Line 4
//Line 5

interest = (*deposit) * (*intRate); //Line 6
cout << interest << endl;
15.

16.

//Line 7

What is wrong with the following C++ code? (2, 3, 6)
double *firstPtr = new double;
double *nextPtr = new double;

//Line 1
//Line 2

*firstPtr = 62;
nextPtr = firstPtr;
delete firstPtr;
delete nextPtr;
firstPtr = new double;
*firstPtr = 28;

//Line
//Line
//Line
//Line
//Line
//Line

cout << *firstPtr << " " << *nextPtr << endl;

//Line 9

3
4
5
6
7
8

What is the output of the following C++ code? (2, 3, 6)
int *p;
int *q = new int;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

891

p = q;
*q = 75;
delete p;
p = new int;
*p = 62;
q = new int;
q = p;
*q = 26;
cout << *p << " " << *q << endl;
17.

What is stored in list after the following code executes? (8)
int list[7] = {10, 8, 15, 14, 16, 24, 36};
int *ptr = list;
*ptr = *ptr + 2;
ptr = ptr + 2;
*ptr = (*ptr) – *(ptr – 1);
ptr++;
*ptr = 2 * (*ptr) – 3;

18.

What is the output of the following C++ code? (8)
int num;
int *listPtr;
int *temp;
listPtr = new int[5];
num = 8;
temp = listPtr;
for (int j = 0; j < 5; j++)
{
*listPtr = num;
num = num + 2;
listPtr++;
}
listPtr = temp;
for (int k = 0; k < 5; k++)
{
*temp = *temp + 3;
temp++;
}
for (int k = 0; k < 5; k++)
{
cout << *listPtr << " ";
listPtr++;
}
cout << endl;

19.

Suppose that numPtr is a pointer of type int and gpaPtr is a pointer of
type double. Further suppose that numPtr = 1050 and gpaPtr = 2000.
Also suppose that the size of the memory allocated for an int value is 4

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

892 |

20.
21.
22.

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

bytes and the size of the memory allocated for a double value is 8 bytes.
What are the values of numPtr and gpaPtr after the statements numPtr =
numPtr + 2; and gpaPtr = gpaPtr + 3; execute? (7)
What does the operator new do? (6)
What does the operator delete do? (6)
What is the output of the following C++ code? (8)
int *tempList;
int num = 3;
tempList = new int[7];
tempList[6] = 4;
for (int j = 5; j >= 0; j--)
tempList[j] = tempList[j + 1] + j * num;
for (int j = 0; j < 7; j++)
cout << tempList [j] << " ";
cout << endl;

23.

Consider the following statement: (8)
int *num;

Write the C++ statement that dynamically creates an array of 10
components of type int and num contains the base address of the array.
b. Write a C++ code that inputs data into the array num from the standard
input device.
c. Write a C++ statement that deallocates the memory space of the array
to which num points.
Consider the following C++ code:
a.

24.

int *p;
p = new int[10];
for (int j = 0; j < 10; j++)
p[i] = 2 * j - 2;

25.
26.

Write the C++ statement that deallocates the memory space occupied by
the array to which p points. (6, 8)
Explain why you cannot use a range-based for loop on dynamic arrays. (9)
What is wrong with the following code? (9)
double *p;

//Line 1

p = new double[5];

//Line 2

for (int i = 0; i < 5; i++)
p[i] = pow(i, 2.0);

//Line 3
//Line 4

for (auto x: p)
cout << x << " ";

//Line 5
//Line 6

cout << endl;

//Line 7

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

27.
28.

29.

|

893

Explain the difference between a shallow copy and a deep copy of data. (11)
What is wrong with the following C++ code? (8, 11)
int *p;
int *q;

//Line 1
//Line 2

p = new int[5];
*p = 2;

//Line 3
//Line 4

for (int i = 1; i < 5; i++)
p[i] = p[i - 1] + i;

//Line 5
//Line 6

q = p;

//Line 7

delete [] p;

//Line 8

for (int j = 0; j < 5; j++)
cout << q[j] << " ";

//Line 9
//Line 10

cout << endl;

//Line 11

What is the output of the following C++ code? (8, 11)
int *myList = new int[5];
int *yourList = new int[10];
myList[0] = 3;
for (int i = 1; i < 5; i++)
myList[i] = myList[i - 1] + i;
for (int i = 0; i < 5; i++)
{
yourList[i] = myList[i] + 4;
yourList[i + 5] = myList[4 - i] - 3;
}
cout << "myList: ";
for (int i = 0; i < 5; i++)
cout << myList[i] << " ";
cout << endl;
cout << "yourList: ";
for (int i = 0; i < 10; i++)
cout << yourList[i] << " ";
cout << endl;

30.

a.

b.

Write a statement that declares sales to be a pointer to a pointer of type
double. (2)
Write a C++ code that dynamically creates a two-dimensional array of
five rows and seven columns and sales contains the base address of
that array. (8)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

894 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Write a C++ code that inputs data from the standard input device into
the array sales. (8)
d. Write a C++ code that deallocates the memory space occupied by the
two-dimensional array to which sales points. (8)
What is the purpose of a copy constructor? (12)
Name two situations in which a copy constructor executes. (12)
Name three things that you should do for classes with pointer member
variables. (12)
Suppose that you have the following classes, classA and classB:
c.

31.
32.
33.

34.

class classA
{
public:
virtual void print() const;
void doubleNum();
classA(int a = 0);
private:
int x;
};
void classA::print() const
{
cout << "ClassA x: " << x << endl;
}
void classA::doubleNum()
{
x = 2 * x;
}
classA::classA(int a)
{
x = a;
}
class classB: public classA
{
public:
void print() const;
void doubleNum();
classB(int a = 0, int b = 0);
private:
int y;
};
void classB::print() const
{
classA::print();

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

895

cout << "ClassB y: " << y << endl;
}
void classB::doubleNum()
{
classA::doubleNum();
y = 2 * y;
}
classB::classB(int a, int b)
: classA(a)
{
y = b;
}

What is the output of the following function main? (4, 12)
int main()
{
classA *ptrA;
classA objectA(2);
classB objectB(3, 5);
ptrA = &objectA;
ptrA->doubleNum();
ptrA->print();
cout << endl;
ptrA = &objectB;
ptrA->doubleNum();
ptrA->print();
cout << endl;
return 0;
}
35.

What is the output of the function main of Exercise 34, if the definition of
classA is replaced by the following definition? (13)
class classA
{
public:
virtual void print() const;
virtual void doubleNum();
classA(int a = 0);
private:
int x;
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

896 |

36.
37.
38.

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

What is the difference between compile-time binding and run-time binding? (13)
Is it legal to have an abstract class with all member functions pure virtual? (14)
Consider the following definition of the class studentType:
public studentType: public personType
{
public:
void print();
void calculateGPA();
void setID(long id);
void setCourses(const string c[], int noOfC);
void setGrades(const char cG[], int noOfC);
void
void
void
void

getID();
getCourses(string c[], int noOfC);
getGrades(char cG[], int noOfC);
studentType(string fName = "", string lastName = "",
long id, string c[] = NULL,
char cG[] = NULL, int noOfC = 0);

private:
long studentId;
string courses[6];
char coursesGrade[6]
int noOfCourses;
}

39.

40.

Rewrite the definition of the class studentType so that the functions print and
calculateGPA are pure virtual functions. (14)
Suppose that the definitions of the classes employeeType,
fullTimeEmployee, and partTimeEmployee are as given in Example
12-9 of this chapter. Which of the following statements is legal? (14)
a.

employeeType tempEmp;

b.

fullTimeEmployee newEmp();

c.

partTimeEmployee pEmp("Molly", "Burton", 101, 0.0, 0);

What is the effect of the following statements? (15)
a.

unorderedArrayListType intList1(50);

b.

unorderedArrayListType intList2(1000);

c.

unorderedArrayListType intList3(-10);

PROGRAMMING EXERCISES
1.
2.

Redo Programming Exercise 5 of Chapter 8 using dynamic arrays.
Redo Programming Exercise 6 of Chapter 8 using dynamic arrays.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

3.

4.

5.

|

897

Redo Programming Exercise 7 of Chapter 8 using dynamic arrays. You must
ask the user for the number of candidates and then create the appropriate
arrays to hold the data.
Programming Exercise 11 in Chapter 8 explains how to add large integers using
arrays. However, in that exercise, the program could add only integers of, at
most, 20 digits. This chapter explains how to work with dynamic integers.
Design a class named largeIntegers such that an object of this class can
store an integer of any number of digits. Add operations to add, subtract,
multiply, and compare integers stored in two objects. Also add constructors
to properly initialize objects and functions to set, retrieve, and print the values
of objects.
Banks offer various types of accounts, such as savings, checking, certificate
of deposits, and money market, to attract customers as well as meet their
specific needs. Two of the most commonly used accounts are savings and
checking. Each of these accounts has various options. For example, you may
have a savings account that requires no minimum balance but has a lower
interest rate. Similarly, you may have a checking account that limits the
number of checks you may write. Another type of account that is used to
save money for the long term is certificate of deposit (CD).
In this programming exercise, you use abstract classes and pure virtual
functions to design classes to manipulate various types of accounts. For
simplicity, assume that the bank offers three types of accounts: savings,
checking, and certificate of deposit, as described next.
Savings accounts: Suppose that the bank offers two types of savings
accounts: one that has no minimum balance and a lower interest rate and
another that requires a minimum balance and has a higher interest rate.
Checking accounts: Suppose that the bank offers three types of checking
accounts: one with a monthly service charge, limited check writing, no
minimum balance, and no interest; another with no monthly service charge,
a minimum balance requirement, unlimited check writing and lower interest;
and a third with no monthly service charge, a higher minimum requirement, a
higher interest rate, and unlimited check writing.
Certificate of deposit (CD): In an account of this type, money is left for
some time, and these accounts draw higher interest rates than savings or
checking accounts. Suppose that you purchase a CD for six months. Then
we say that the CD will mature in six months. The penalty for early
withdrawal is stiff.
Figure 12-25 shows the inheritance hierarchy of these bank accounts.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

898 |

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

bankAccount

checkingAccount

serviceChargeChecking

certificateOfDeposit

noServiceChargeChecking

savingsAccount

highInterestSavings

highInterestChecking

FIGURE 12-25

Inheritance hierarchy of banking accounts

Note that the classes bankAccount and checkingAccount are
abstract. That is, we cannot instantiate objects of these classes. The other
classes in Figure 12-25 are not abstract.
bankAccount: Every bank account has an account number, the name of
the owner, and a balance. Therefore, instance variables such as name,
accountNumber, and balance should be declared in the abstract class
bankAccount. Some operations common to all types of accounts are retrieve
account owner’s name, account number, and account balance; make deposits;
withdraw money; and create monthly statements. So include functions to
implement these operations. Some of these functions will be pure virtual.
checkingAccount: A checking account is a bank account. Therefore, it
inherits all the properties of a bank account. Because one of the objectives of
a checking account is to be able to write checks, include the pure virtual
function writeCheck to write a check.
serviceChargeChecking: A service charge checking account is a checking
account. Therefore, it inherits all the properties of a checking account. For
simplicity, assume that this type of account does not pay any interest, allows the
account holder to write a limited number of checks each month, and does not
require any minimum balance. Include appropriate named constants, instance
variables, and functions in this class.
noServiceChargeChecking: A checking account with no monthly service
charge is a checking account. Therefore, it inherits all the properties of a
checking account. Furthermore, this type of account pays interest, allows the
account holder to write checks, and requires a minimum balance.
highInterestChecking: A checking account with high interest is a checking

account with no monthly service charge. Therefore, it inherits all the properties

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

899

of a no service charge checking account. Furthermore, this type of account pays
higher interest and requires a higher minimum balance than the no service
charge checking account.
savingsAccount: A savings account is a bank account. Therefore, it inherits

all the properties of a bank account. Furthermore, a savings account also pays
interest.
highInterestSavings: A high-interest savings account is a savings account.
Therefore, it inherits all the properties of a savings account. It also requires a
minimum balance.
certificateOfDeposit: A certificate of deposit account is a bank account.

6.

7.

8.

9.

10.

Therefore, it inherits all the properties of a bank account. In addition, it has
instance variables to store the number of CD maturity months, interest rate, and
the current CD month.
Write the definitions of the classes described in this programming exercise and a
program to test your classes.
The function retrieveAt of the class arrayListType is written as a
void function. Rewrite this function so that it is written as a value returning
function, returning the required item. If location of the item to be returned is
out of range, use the assert function to terminate the program. Also, write
a program to test your function. Use the class unorderedArrayListType
to test your function.
The function removeAt of the class arrayListType removes an element
from the list by shifting the elements of the list. However, if the element to
be removed is at the beginning of the list and the list is fairly large it could
take a lot of computer time. Because the list elements are in no particular
order, you could simply remove the element by swapping the last element of
the list with the item to be removed and reducing the length of the list.
Rewrite the definition of the function removeAt using this technique. Use
the class unorderedArrayListType to test your function.
The function remove of the class arrayListType removes only the first
occurrence of an element. Add the function removeAll as an abstract
function to the class arrayListType, which would remove all occurrences
of a given element. Also, write the definition of the function removeAll in the
class unorderedArrayListType and write a program to test this function.
Add the function min as an abstract function to the class arrayListType
to return the smallest element of the list. Also, write the definition of the
function min in the class unorderedArrayListType and write a program
to test this function.
Add the function max as an abstract function to the class arrayListType
to return the largest element of the list. Also, write the definition of the
function max in the class unorderedArrayListType and write a program
to test this function.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
2

900 |

11.

12.

13.

Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists

Write the definitions of the functions of the class orderedArrayListType
that are not given in this chapter. Also, write a program to test various
operations of this class.
(Unordered Sets) As explained in this chapter, a set is a collection of
distinct elements of the same type. Design the class unorderedSetType,
derived from the class unorderedArrayListType, to manipulate sets.
Note that you need to redefine only the functions insertAt, insertEnd,
and replaceAt. If the item to be inserted is already in the list, the functions
insertAt and insertEnd output an appropriate message. Similarly, if the
item to be replaced is already in the list, the function replaceAt outputs an
appropriate message. Also, write a program to test your class.
(Ordered Sets) Programming Exercise 12 asks you to define the class
unorderedSetType to manipulate sets. The elements of an unorderedSetType
object are distinct, but in no particular order. Design the class orderedSetType,
derived from the class orderedArrayListType, to manipulate ordered sets.
The elements of an orderedSetType object are distinct and in ascending order.
Note that you need to redefine only the functions insert and replaceAt. If the
item to be inserted is already in the list, the function insert outputs an appropriate
message. Similarly, if the item to be replaced is already in the list, the function
replaceAt outputs an appropriate message. Also, write a program to test
your class.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

13
CHAPTER

ª HunThomas/Shutterstock

O VERLOADING
T EMPLATES

AND

I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about overloading

2.

Become familiar with the restrictions on operator overloading

3.

Examine the pointer this

4.

Learn about friend functions

5.

Learn how to overload operators as members and nonmembers of a class

6.

Discover how to overload various operators

7.

Become familiar with the requirements for classes with pointer member variables

8.

Learn about templates

9.

Explore how to construct function templates and class templates

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

902 |

Chapter 13: Overloading and Templates

In Chapter 10, you learned how classes in C++ are used to combine data and
operations on that data in a single entity. The ability to combine data and operations
on the data is called encapsulation. It is the first principle of object-oriented design
(OOD). Chapter 10 defined the abstract data type (ADT) and described how classes in
C++ implement ADT. Chapter 11 discussed how new classes can be derived from
existing classes through the mechanism of inheritance. Inheritance, the second principle
of OOD, encourages code reuse.
This chapter covers operator overloading and templates. Templates enable the
programmer to write generic code for related functions and classes. We will also simplify
function overloading (introduced in Chapter 6) through the use of templates, called
function templates.

Why Operator Overloading Is Needed
Chapter 10 defined and implemented the class clockType. It also showed how you
can use the class clockType to represent the time of day in a program. Let us review
some of the characteristics of the class clockType.
Consider the following statements:
clockType myClock(8, 23, 34);
clockType yourClock(4, 5, 30);

The first statement declares myClock to be an object of type clockType and initializes
the member variables hr, min, and sec of myClock to 8, 23, and 34, respectively.
The second statement declares yourClock to be an object of type clockType and
initializes the member variables hr, min, and sec of yourClock to 4, 5, and 30,
respectively.
Now consider the following statements:
myClock.printTime();
myClock.incrementSeconds();
if (myClock.equalTime(yourClock))
.
.
.

The first statement prints the value of myClock in the form hr:min:sec. The second
statement increments the value of myClock by one second. The third statement checks
whether the value of myClock is the same as the value of yourClock.
These statements do their job. However, if we can use the insertion operator << to
output the value of myClock, the increment operator ++ to increment the value of
myClock by one second, and relational operators for comparison, we can enhance the

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

903

flexibility of the class clockType considerably. More specifically, we prefer to use the
following statements instead of the previous statements:
cout << myClock;
myClock++;
if (myClock == yourClock)
.
.
.

Recall that the only built-in operations on classes are the assignment operator and the
member selection operator. Therefore, other operators cannot be directly applied to
class objects by default. However, C++ allows the programmer to extend the
definitions of operators such as relational operators, arithmetic operators, the insertion
operator for data output, and the extraction operator for data input—so they can be
applied to classes. In C++ terminology, this is called operator overloading.

Operator Overloading
Recall how the arithmetic operator / works. If both operands of / are integers, the result
is an integer; otherwise, the result is a floating-point number. This means that the /
operator has one definition when both operands are integers and another when an
operand is a floating-point number. Which definition is used depends on the data types
of the operand it is used with. Similarly, the stream insertion operator, <<, and the stream
extraction operator, >>, are overloaded. The operator >> is used as both a stream
extraction operator and a right shift operator. The operator << is used as both a stream
insertion operator and a left shift operator. These are examples of operator overloading.
(Note that the operators << and >> have also been overloaded for various data types, such
as int, double, and string.)
Other examples of overloaded operators are + and -. The results of + and - are different
for integer arithmetic, floating-point arithmetic, and pointer arithmetic.
C++ allows the user to overload most of the operators so that the operators can work
effectively in a specific application. It does not allow the user to create new operators.
Most of the existing operators can be overloaded to manipulate class objects.
In order to overload an operator, you must write function(s) (that is, the header and
body) to define what operation the overloaded operator indicates should be performed.
The name of the function that overloads an operator is the reserved word operator
followed by the operator to be overloaded. For example, the name of the function to
overload the operator >= is:
operator>=

Operator function: The function that overloads an operator.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

904 |

Chapter 13: Overloading and Templates

Syntax for Operator Functions
The result of an operation is a value. Therefore, the operator function is a value-returning
function.
The syntax of the heading for an operator function is:
returnType operator operatorSymbol(formal parameter list)

In C++, operator is a reserved word.
Recall that the only built-in operations on classes are assignment (=) and member
selection. To use other operators on class objects, they must be explicitly overloaded.
Operator overloading provides the same concise expressions for user-defined data types as
it does for built-in data types.
To overload an operator for a class:
1. Include the statement to declare the function prototype to overload the
operator (that is, the operator function) in the definition of the class.
2. Write the definition of the operator function.
Certain rules must be followed when you include an operator function in a class
definition. These rules are described in the section, ‘‘Operator Functions as Member
Functions and Nonmember Functions’’ later in this chapter.

Overloading an Operator: Some Restrictions
When overloading an operator, keep the following in mind:
1. You cannot change the precedence of an operator.
2. The associativity cannot be changed. (For example, the associativity of
the arithmetic operator addition is from left to right, and it cannot be
changed.)
3. Default parameters cannot be used with an overloaded operator.
4. You cannot change the number of parameters an operator takes.
5. You cannot create new operators. Only existing operators can be overloaded.
6. The operators that cannot be overloaded are:
.

.*

::

?:

sizeof

7. The meaning of how an operator works with built-in types, such as int,
remains the same. That is, you cannot redefine how operators work with
built-in data types.
8. Operators can be overloaded either for objects of the user-defined types,
or for a combination of objects of the user-defined type and objects of
the built-in type.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

905

EXAMPLE 13-1
In the beginning of this chapter, we remarked that if we can overload various operators for
a class, then we can increase the flexibility of the class. Now that we know the syntax to
overload an operator for a class and certain restrictions on operator overloading, in this
example, we only illustrate how to overload the relational operator == for the class
clockType. After discussing, in general, various concepts related to operator overloading,
later in this chapter in the Programming Example clockType, we will show how to overload
other operators, such as >>, <<, and ++ (pre-increment), for the class clockType.
The prototype of the function to overload the equality operator for the class clockType is:
bool operator==(const clockType& otherClock) const;

Therefore, this statement must be included in the definition of the class clockType.
Because in this example we are illustrating how to only overload the operator ==, we do
not include the functions to increment the time. So consider the following definition of
the class clockType:
class clockType
{
public:
void setTime(int hours, int minutes, int seconds);
void printTime() const;
bool operator==(const clockType& otherClock) const;
//Overload the operator ==
clockType(int = 0, int = 0, int = 0);
private:
int hr;
int min;
int sec;
};

Next we must write the definition of the function operator==, which is:
bool clockType::operator==(const clockType& otherClock) const
{
return (hr == otherClock.hr && min == otherClock.min
&& sec == otherClock.sec);
}

Notice that the body of the function operator== is the same as the body of the function
equalTime given in Chapter 10. Also, the definitions of other functions of the class
clockType are the same as given in Chapter 10.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

906 |

Chapter 13: Overloading and Templates

The following program illustrates how to use the modified definition of the class
clockType:
#include <iostream>
#include "clockType.h"
using namespace std;
int main()
{
clockType myClock(8, 23, 50);
clockType yourClock(8, 23, 50);
clockType tempClock(9, 16, 25);

//Line
//Line
//Line
//Line
//Line

1
2
3
4
5

cout << "Line 6: myClock: ";
myClock.printTime();
cout << endl;

//Line 6
//Line 7
//Line 8

cout << "Line 9: yourClock: ";
yourClock.printTime();
cout << endl;

//Line 9
//Line 10
//Line 11

cout << "Line 12: tempClock: ";
tempClock.printTime();
cout << endl;

//Line 12
//Line 13
//Line 14

//Compare myClock and yourClock
if (myClock == yourClock)
cout << "Line 16: The time of myClock and "
<< "yourClock are equal." << endl;
else
cout << "Line 18: The time of myClock and "
<< "yourClock are not equal." << endl;
//Compare myClock and tempClock
if (myClock == tempClock)
cout << "Line 20: The time of myClock and "
<< "tempClock are equal." << endl;
else
cout << "Line 22: The time of myClock and "
<< "tempClock are not equal." << endl;
return 0;
}//end main

//Line 15
//Line 16
//Line 17
//Line 18
//Line 19
//Line 20
//Line 21
//Line 22
//Line 23
//Line 24

Sample Run:
Line
Line
Line
Line
Line

6: myClock: 08:23:50
9: yourClock: 08:23:50
12: tempClock: 09:16:25
16: The time of myClock and yourClock are equal.
22: The time of myClock and tempClock are not equal.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

907

The sample run is easy to follow. However, note that the statement in Line 15 uses the
operator == to compare the time of myClock and yourClock. Similarly, the statement
in Line 19 uses the operator == to compare the time of myClock and tempClock. The
output of statements in Lines 16 and 22 show that the operator == is successfully
overloaded for the class clockType.
Before discussing operator overloading in general, in the next two sections we discuss
two important concepts related to operator overloading.

Pointer this
A member function of a class can (directly) access the member variables of a given
object of that class. Sometimes, it is necessary for a member function to refer to the
object as a whole, rather than the object’s individual member variables. How do you
refer to the object as a whole (that is, as a single unit) in the definition of the member
function, especially when the object is not passed as a parameter? Every object of a
class maintains a (hidden) pointer to itself, and the name of this pointer is this. In
C++, this is a reserved word. The pointer this (in a member function) is available
for you to use. When an object invokes a member function, the member function
references the pointer this of the object. For example, suppose that test is a class
and has a member function called one. Further suppose that the definition of one
looks like the following:
test test::one()
{
.
.
.
return *this;
}

If x and y are objects of type test, then the statement:
y = x.one();

copies the value of object x into object y. That is, the member variables of x are copied
into the corresponding member variables of y. When object x invokes function one, the
pointer this in the definition of member function one refers to object x, so this means
the address of x and *this means the contents of x. On the other hand, in the statement
x = y.one();

the pointer this in the definition of member function one refers to object y, and so
this means the address of y and *this means the contents of y. So the statement copies
the contents of object y into object x.
The following example illustrates how the pointer this works.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

908 |

Chapter 13: Overloading and Templates

EXAMPLE 13-2
In Chapter 11, we defined the class rectangleType. We will add a function to this
class to illustrate how the pointer this works. We do not give the complete definition of
this class. We only show the function that uses the pointer this to return the whole
object. The complete definition can be found at the Web site accompanying this book.
class rectangleType
{
public:
//The functions setDimension, getLength, getWidth, area,
//perimeter, print, and the constructors are the same as before.
rectangleType doubleDimensions();
//Postcondition: length = 2 * length;
//
width = 2 * width;
private:
double length;
double width;
};

Suppose that the definition of the member function doubleDimensions is:
rectangleType rectangleType::doubleDimensions()
{
length = 2 * length;
width = 2 * width;
return *this;
}

The function doubleDimensions doubles both the length and width of the object and
uses the pointer this to return the value of the entire object.
Consider the following function main:
//Chapter 13: this pointer illustration
#include <iostream>
#include <iomanip>
#include "rectangleType.h"

//Line 1
//Line 2
//Line 3

using namespace std;

//Line 4

int main()
{
rectangleType oldYard(20.00, 10.00);
rectangleType newYard;

//Line
//Line
//Line
//Line

cout << fixed << showpoint << setprecision(2);

5
6
7
8

//Line 9

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

cout << "Line 10: Area of oldYard = "
<< oldYard.area() << endl;

//Line 10

newYard = oldYard.doubleDimensions();

//Line 11

cout << "Line 12: Area of newYard = "
<< newYard.area() << endl;

//Line 12

return 0;
}

|

909

//Line 13
//Line 14

Sample Run
Line 10: Area of oldYard = 200.00
Line 12: Area of newYard = 800.00

For the most part, the output is self-explanatory. The statement in Line 7 creates the
object oldYard and sets the length and width to 20.00 and 10.00, respectively. The
statement in Line 8 creates the object newYard and using the default constructor sets the
length and width to 0.00, and 0.00, respectively. The statement in Line 10 outputs the
area of oldYard. The statement in Line 11 doubles the dimensions of oldYard and then
the object oldYard, with new length and width, is returned by the pointer this. The
assignment operator then copies the value of oldYard into newYard. The statement in
Line 12 outputs the area of newYard.
The following example shows another way of how the pointer this works.
EXAMPLE 13-3
Consider the following class:
class rectangleType
{
public:
void setDimension(double l, double w);
double getLength() const;
double getWidth() const;
double area() const;
double perimeter() const;
void print() const;
rectangleType& setLength(double l);
//Function to set the length.
//Postcondition: length = l
//
After setting the length, a reference to the object,
//
that is, the address of the object, is returned.
rectangleType& setWidth(double w);
//Function to set the width.
//Postcondition: width = w
//
After setting the width a reference to the object,
//
that is, the address of the object, is returned.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

910 |

Chapter 13: Overloading and Templates

rectangleType(double l = 0.0, double w = 0.0);
private:
double length;
double width;
};

Note that the definition of the class rectangleType is the same as given in Chapter
11, except that here, in the definition of the class rectangleType, we have added the
functions setLength and setWidth to individually set a rectangle’s length and width,
and then return the entire object. We have also replaced the constructors with the
constructor with default parameters.
The definitions of the functions print, setDimension, getLength, getWidth,
area, and perimeter are the same as before. The definition of the constructor with
default parameters is the same as the definition of the constructor with parameters. The
definitions of the functions setLength and setWidth are as follows:
rectangleType& rectangleType::setLength(double l)
{
length = l;
return *this;
}
rectangleType& rectangleType::setWidth(double w)
{
width = w;
return *this;
}

The following program shows how to use the class rectangleType. (We assume that
the definition of the class rectangleType is in the file rectangleType.h.)
//Test Program: class rectangleType
#include <iostream>
#include <iomanip>
#include "rectangleType.h"

//Line 1
//Line 2
//Line 3

using namespace std;

//Line 4

int main()
{
rectangleType myRectangle;
rectangleType yourRectangle;

//Line
//Line
//Line
//Line

5
6
7
8

cout << fixed << showpoint << setprecision(2);

//Line 9

myRectangle.setLength(15.25).setWidth(12.00);

//Line 10

cout << "Line 11 -- myRectangle: ";
myRectangle.print();
cout << endl;

//Line 11
//Line 12
//Line 13

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

yourRectangle.setLength(18.50);

//Line 14

cout << "Line 15 -- yourRectangle: ";
yourRectangle.print();
cout << endl;

//Line 15
//Line 16
//Line 17

yourRectangle.setWidth(7.50);

//Line 18

cout << "Line 19 -- yourRectangle: ";
yourRectangle.print();
cout << endl;

//Line 19
//Line 20
//Line 21

return 0;

//Line 22
//Line 23

}

|

911

Sample Run
Line 11: myRectangle: Length = 15.25; Width = 12.00
Line 15: yourRectangle: Length = 18.50; Width = 0.00
Line 19: yourRectangle: Length = 18.50; Width = 7.50

The statements in Lines 7 and 8 declare and, using the constructor with default parameters, initialize the objects myRectangle and yourRectangle, to default values.
Consider the statement in Line 10, which is:
myRectangle.setLength(15.25).setWidth(12.00);

First the expression:
myRectangle.setLength(15.25)

is executed because the associativity of the dot operator is from left to right. This
expression sets the length of myRectangle to 15.25 and returns a reference of the
calling object, which is myRectangle. Thus, the returned *this pointer makes the
next expression executed equivalent to
myRectangle.setWidth(12.00)

which sets the width of myRectangle to 12.00. By returning the dereferenced this
pointer, member functions can be ‘‘chained’’ like this. The statement in Line 12 outputs
the value of myRectangle.
The statement in Line 14 sets the length of the object yourRectangle to 18.50, and
ignores the *this value returned. The statement in Line 16 outputs the value of
yourRectangle. Notice the output in Line 15. The value printed for width is 0.00,
which was stored when the object was declared in Line 8. Next, the statement in Line 18
sets the width of yourRectangle, and the statement in Line 20 outputs the value of
yourRectangle.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

912 |

Chapter 13: Overloading and Templates

Friend Functions of Classes
A friend function of a class is a nonmember function of the class but has access to all of
the members (public or non-public) of the class. To make a function be a friend to a
class, the reserved word friend precedes the function prototype (in the class definition).
The word friend appears only in the function prototype in the class definition, not in
the definition of the friend function. In other words, friendship is always given by the
class, never taken by the function.
Consider the following statements:
class classIllusFriend
{
friend void two(/*parameters*/);
.
.
.
};

In the definition of the class classIllusFriend, two is declared as a friend of the
class classIllusFriend. That is, it is a nonmember function of the class
classIllusFriend. When you write the definition of the function two, any object
of type classIllusFriend, which is included in the definition as either a local variable
of two or a formal parameter of two, can access its private members within the
definition of the function two. (Example 13-4 illustrates this concept.) Moreover,
because a friend function is not a member of a class, its declaration can be placed
within the private, protected, or public part of the class. However, they are
typically placed before any member function declaration.
DEFINITION OF A friend FUNCTION
When writing the definition of a friend function, the name of the class and the scope
resolution operator do not precede the name of the friend function in the function
heading because it is not a member function of the class. Also, recall that the word
friend does not appear in the heading of the friend function’s definition. Thus, the
definition of the function two in the previous class classIllusFriend is:
void two(/*parameters*/)
{
.
.
.
}

Of course, we will place the definition of the friend function in the implementation file.
The next section illustrates the difference between a member function and a nonmember
function (friend function) when we overload some of the operators for a specific class.
The following example shows how a friend function accesses the private members of
a class.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

913

EXAMPLE 13-4
In this example, we use the class rectangleType to illustrate how a friend function
works. In the following definition we do not document the functions. The complete
definition of this class is available at the Web site accompanying this book.
class rectangleType
{
friend void rectangleFriend(rectangleType recObject);
public:
void setDimension(double l, double w);
double getLength() const;
double getWidth() const;
double area() const;
double perimeter() const;
void print() const;
rectangleType();
rectangleType(double l, double w);
private:
double length;
double width;
};

In the definition of the class rectangleType, rectangleFriend is declared as a
friend function. Suppose that the definition of the function rectangleFriend is:
void rectangleFriend(rectangleType recFriendObject)
{
cout << "recFriendObject area: " << recFriendObject.area()
<< endl;
recFriendObject.length = recFriendObject.length + 5;
recFriendObject.width = recFriendObject.width + 5;
cout << "After increasing length and width by 5 units "
<< "each, \n
recFriendObject area: "
<< recFriendObject.area() << endl;
}

The function rectangleFriend contains a (value) formal parameter recFriendObject
of type rectangleType. (Note that because rectangleType is a value parameter, it
will copy the value of its actual parameter.) The first statement outputs the area of the
object recFriendObject. The next two statements increase the length and width
of recFriendObject by 5 units. The next statement outputs the area of the object
recFriendObject using the new length and width. Note that the recFriendObject
accesses its private member variables length and width and increase their values

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

914 |

Chapter 13: Overloading and Templates

by 5 units. If rectangleFriend is not declared as a friend function of the
class rectangleType, then this statement would result in a syntax error because an
object cannot directly access its private members.
The definition of the remaining functions and constructors of the class rectangleType
is as given in Chapter 11.
Now consider the definition of the following function main:
//Friend Function Illustration
#include <iostream>
#include <iomanip>
#include "rectangleType.h"

//Line 1
//Line 2
//Line 3

using namespace std;

//Line 4

int main()
{
rectangleType myYard(25, 18);

//Line 5
//Line 6
//Line 7

cout << fixed << showpoint << setprecision(2); //Line 8
cout << "myYard area: " << myYard.area()
<< endl;

//Line 9

cout << "Passing object myYard to the friend "
<< "function rectangleFriend." << endl;
//Line 10
rectangleFriend(myYard);

//Line 11

return 0;

//Line 12
//Line 13

}

Sample Run
myYard area: 450.00
Passing object myYard to the friend function rectangleFriend.
recFriendObject area: 450.00
After increasing length and width by 5 units each,
recFriendObject area: 690.00

For the most part, the output is self-explanatory. The statement in Line 9 outputs the area
of myYard. The statement in Line 11 calls the function rectangleFriend (a friend
function of the class rectangleType) and passes the object myYard as an actual
parameter. Notice that the function rectangleFriend generates the last three lines of
the output.
Later in this chapter, you will learn that for a class, stream insertion and extraction
operators can be overloaded only as friend functions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

915

Operator Functions as Member Functions
and Nonmember Functions
The beginning of this chapter stated that certain rules must be followed when you include
an operator function in the definition of a class. This section describes these rules.
Most operator functions can be either member functions or nonmember functions—that
is, friend functions of a class. To make an operator function be a member or nonmember function of a class, keep the following in mind:
1. The function that overloads any of the operators (), [], ->, or = for a
class must be declared as a member of the class.
2. Suppose that an operator op is overloaded for a class—say, opOverClass.
(Here, op stands for an operator that can be overloaded, such as + or >>.)
If the far left operand of op is an object of a different type (that is,
not of type opOverClass), the function that overloads the operator
op for opOverClass must be a nonmember—that is, a friend of
the class opOverClass.
b. If the operator function that overloads the operator op for the
class opOverClass is a member of the class opOverClass,
then when applying op on objects of type opOverClass, the far
left operand of op must be of type opOverClass.
a.

You must follow these rules when including an operator function in a class definition.
You will see later in this chapter that functions that overload the insertion operator, <<,
and the extraction operator, >>, for a class must be nonmembers—that is, friend
functions of the class.
Except for certain operators noted previously, operators can be overloaded either as
member functions or as nonmember functions. The following discussion shows the
difference between these two types of functions.
To facilitate our discussion of operator overloading, we will use the class rectangleType,
given next. (Although Chapter 11 defines this class, Chapter 11 is not a prerequisite for this
chapter. For easy reference, we reproduce the definition of this class and the definitions of the
member functions.)
class rectangleType
{
public:
void setDimension(double l, double w);
//Function to set the length and width of the rectangle.
//Postcondition: length = l; width = w;
double getLength() const;
//Function to return the length of the rectangle.
//Postcondition: The value of length is returned.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

916 |

Chapter 13: Overloading and Templates

double getWidth() const;
//Function to return the width of the rectangle.
//Postcondition: The value of width is returned.
double area() const;
//Function to return the area of the rectangle.
//Postcondition: The area of the rectangle is
//
calculated and returned.
double perimeter() const;
//Function to return the perimeter of the rectangle.
//Postcondition: The perimeter of the rectangle is
//
calculated and returned.
void print() const;
//Function to output the length and width of
//the rectangle.
rectangleType();
//Default constructor
//Postcondition: length = 0; width = 0;
rectangleType(double l, double w);
//Constructor with parameters
//Postcondition: length = l; width = w;
private:
double length;
double width;
};

The definitions of the member functions of the class rectangleType are as follows:
void rectangleType::setDimension(double l, double w)
{
if (l >= 0)
length = l;
else
length = 0;
if (w >= 0)
width = w;
else
width = 0;
}
double rectangleType::getLength() const
{
return length;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

917

double rectangleType::getWidth()const
{
return width;
}
double rectangleType::area() const
{
return length * width;
}
double rectangleType::perimeter() const
{
return 2 * (length + width);
}
void rectangleType::print() const
{
cout << "Length = " << length
<< "; Width = " << width;
}
rectangleType::rectangleType(double l, double w)
{
setDimension(l, w);
}
rectangleType::rectangleType()
{
length = 0;
width = 0;
}

The class rectangleType has two private member variables: length and width,
both of type double. We will add operator functions to the class rectangleType as
we overload the operators.
Also, suppose that you have the following statements:
rectangleType myRectangle;
rectangleType yourRectangle;
rectangleType tempRect;

That is, myRectangle, yourRectangle, and tempRect are objects of type
rectangleType.
C++ consists of both binary and unary operators. It also has a ternary operator, ?:, which
cannot be overloaded. The next few sections discuss how to overload various binary and unary
operators.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

918 |

Chapter 13: Overloading and Templates

Overloading Binary Operators
Suppose that # represents a binary operator (arithmetic, such as +; or relational, such as
==) that is to be overloaded for the class rectangleType. This operator can be
overloaded as either a member function of the class or as a friend function. We will
describe both ways to overload this operator.
OVERLOADING THE BINARY OPERATORS AS MEMBER FUNCTIONS
Suppose that # is overloaded as a member function of the class rectangleType. The
name of the function to overload # for the class rectangleType is:
operator#

Because myRectangle and yourRectangle are both objects of type rectangleType,
you can perform the operation:
myRectangle # yourRectangle

The compiler translates this expression into the following expression:
myRectangle.operator#(yourRectangle)

This expression clearly shows that the function operator# has only one parameter,
which is yourRectangle. The object on the left of the operator# is the object that is
invoking the function operator#, and the object on the right of operator# is passed
as a parameter to this function.
Because operator# is a member of the class rectangleType and myRectangle is
an object of type rectangleType, in the previous statement, operator# has direct
access to the private members of the object myRectangle.
GENERAL SYNTAX TO OVERLOAD THE BINARY (ARITHMETIC OR RELATIONAL)
OPERATORS AS MEMBER FUNCTIONS
This section describes the general form of the functions used to overload binary operators
as member functions of a class.

Function Prototype (to be included in the definition of the class):
returnType operator#(const className&) const;

in which # stands for the binary arithmetic or relational operator to be overloaded;
returnType is the type of value returned by the function; and className is the name
of the class for which the operator is being overloaded.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

919

Function Definition:
returnType className::operator#
(const className& otherObject) const
{
//algorithm to perform the operation
return value;
}

The return type of the functions that overload relational operators is bool.

EXAMPLE 13-5
Let us overload +, *, ==, and != for the class rectangleType. These operators are
overloaded as member functions.
class rectangleType
{
public:
void setDimension(double l, double w);
double getLength() const;
double getWidth() const;
double area() const;
double perimeter() const;
void print() const;
rectangleType operator+(const rectangleType&) const;
//Overload the operator +
rectangleType operator*(const rectangleType&) const;
//Overload the operator *
bool operator==(const rectangleType&) const;
//Overload the operator ==
bool operator!=(const rectangleType&) const;
//Overload the operator !=
rectangleType();
rectangleType(double l, double w);
private:
double length;
double width;
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

920 |

Chapter 13: Overloading and Templates

The definition of the function operator+ is as follows:
rectangleType rectangleType::operator+
(const rectangleType& rectangle) const
{
rectangleType tempRect;
tempRect.length = length + rectangle.length;
tempRect.width = width + rectangle.width;
return tempRect;
}

Notice that operator+ adds the corresponding lengths and widths of the two rectangles.
The definition of the function operator* is as follows:
rectangleType rectangleType::operator*
(const rectangleType& rectangle) const
{
rectangleType tempRect;
tempRect.length = length * rectangle.length;
tempRect.width = width * rectangle.width;
return tempRect;
}

Notice that operator* multiplies the corresponding lengths and widths of the two rectangles.
Two rectangles are equal if their lengths and widths are equal. Therefore, the definition
of the function to overload the operator == is:
bool rectangleType::operator==
(const rectangleType& rectangle) const
{
return (length == rectangle.length &&
width == rectangle.width);
}

Two rectangles are not equal if either their lengths are not equal or their widths are not
equal. Therefore, the definition of the function to overload the operator != is:
bool rectangleType::operator!=
(const rectangleType& rectangle) const
{
return (length != rectangle.length ||
width != rectangle.width);
}

(Note that after writing the definition of the function to overload the operator ==, you
can use it to write the definition of the function to overload the operator !=. We leave
the details as an exercise.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

921

Consider the following program. (We assume that the definition of the class
rectangleType is in the header file rectangleType.h.)
//This program shows how to use the class rectangleType.
#include <iostream>
#include "rectangleType.h"
using namespace std;
int main()
{
rectangleType
rectangleType
rectangleType
rectangleType

rectangle1(23, 45);
rectangle2(12, 10);
rectangle3;
rectangle4;

//Line
//Line
//Line
//Line

1
2
3
4

cout << "Line 5: rectangle1: ";
rectangle1.print();
cout << endl;

//Line 5
//Line 6
//Line 7

cout << "Line 8: rectangle2: ";
rectangle2.print();
cout << endl;

//Line 8
//Line 9
//Line 10

rectangle3 = rectangle1 + rectangle2;

//Line 11

cout << "Line 12: rectangle3: ";
rectangle3.print();
cout << endl;

//Line 12
//Line 13
//Line 14

rectangle4 = rectangle1 * rectangle2;

//Line 15

cout << "Line 16: rectangle4: ";
rectangle4.print();
cout << endl;

//Line 16
//Line 17
//Line 18

if (rectangle1 == rectangle2)
cout << "Line 20: rectangle1 and "
<< "rectangle2 are equal." << endl;
else
cout << "Line 22: rectangle1 and "
<< "rectangle2 are not equal."
<< endl;

//Line 19

if (rectangle1 != rectangle3)
cout << "Line 24: rectangle1 and "
<< "rectangle3 are not equal."
<< endl;
else
cout << "Line 25: rectangle1 and "
<< "rectangle3 are equal." << endl;

//Line 20
//Line 21
//Line 22
//Line 23
//Line 24
//Line 25
//Line 26

return 0;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

922 |

Chapter 13: Overloading and Templates

Sample Run:
Line
Line
Line
Line
Line
Line

5: rectangle1: Length = 23; Width = 45
8: rectangle2: Length = 12; Width = 10
12: rectangle3: Length = 35; Width = 55
16: rectangle4: Length = 276; Width = 450
22: rectangle1 and rectangle2 are not equal.
24: rectangle1 and rectangle3 are not equal.

For the most part, the preceding output is self-explanatory. However, let us look at the
statements in Lines 11, 15, 19, and 23. The statement in Line 11 uses the operator + to
add the lengths and widths of rectangle1 and rectangle2 and stores the result in
rectangle3. (That is, after the execution of this statement, the length of rectangle3
is the sum of the lengths of rectangle1 and rectangle2, and the width of
rectangle3 is the sum of the widths of rectangle1 and rectangle2. The statement
in Line 13 outputs the length and width of rectangle3.) Similarly, the statement in
Line 15 uses the operator * to multiply the lengths and widths of rectangle1 and
rectangle2 and stores the result in rectangle4. (The statement in Line 17 outputs
the length and width of rectangle4.) The statement in Line 19 uses the relational
operator == to determine whether the dimensions of rectangle1 and rectangle2 are
the same. Similarly, the statement in Line 23 uses the relational operator != to determine
whether the dimensions of rectangle1 and rectangle3 are the same.

OVERLOADING THE BINARY OPERATORS (ARITHMETIC OR RELATIONAL) AS
NONMEMBER FUNCTIONS
Suppose that # represents the binary operator (arithmetic or relational) that is to be
overloaded as a nonmember function of the class rectangleType.

Further suppose that the following operation is to be performed:
myRectangle # yourRectangle

In this case, the expression is compiled as:
operator#(myRectangle, yourRectangle)

Here, we see that both myRectangle and yourRectangle are passed as parameters to
the function operator#. The function operator# is not a member of the object
myRectangle or the object yourRectangle and so cannot be called by either.
To include the operator function operator# as a nonmember function of the class in
the definition of the class, the reserved word friend must appear before the function
heading. Also, the function operator# must have a parameter for each of its two
operands.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

923

GENERAL SYNTAX TO OVERLOAD THE BINARY (ARITHMETIC OR RELATIONAL)
OPERATORS AS NONMEMBER FUNCTIONS
This section describes the general form of the functions to overload the binary operators
as nonmember functions of a class.

Function Prototype (to be included in the definition of the class):
friend returnType operator#(const className&,
const className&);

in which # stands for the binary operator to be overloaded; returnType is the type of
value returned by the function; and className is the name of the class for which the
operator is being overloaded.
Function Definition:
returnType operator#(const className& firstObject,
const className& secondObject)
{
//algorithm to perform the operation
return value;
}

EXAMPLE 13-6
This example illustrates how to overload the operators + and == as nonmember functions
of the class rectangleType.
To include the operator function operator+ as a nonmember function of the class
rectangleType, its prototype in the definition of rectangleType is:
friend rectangleType operator+(const rectangleType&,
const rectangleType&);

The definition of the function operator+ is as follows:
rectangleType operator+(const rectangleType& firstRect,
const rectangleType& secondRect)
{
rectangleType tempRect;
tempRect.length = firstRect.length + secondRect.length;
tempRect.width = firstRect.width + secondRect.width;
return tempRect;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

924 |

Chapter 13: Overloading and Templates

In the preceding definition, the corresponding member variables of firstRect and
secondRect are added, and the result is stored in tempRect. Recall that the
private members of a class are local to the class and, therefore, cannot be accessed
outside of the class. If we follow this rule, then because operator+ is not a member
of the class rectangleType, expressions such as firstRect.length should be
illegal in its definition because length is a private member of firstRect.
However, because operator+ is declared as a friend function of the class
rectangleType, an object of type rectangleType can access its private
members in the definition of operator+. Also, note that in the function heading,
the name of the class—that is, rectangleType—and the scope resolution operator are
not included before the name of the function operator+, because the function operator+
is not a member of the class.
To include the operator function operator== as a nonmember function of the class
rectangleType, its prototype in the definition of rectangleType is:
friend bool operator==(const rectangleType& ,
const rectangleType&);

The definition of the function operator== is as follows:
bool operator==(const rectangleType& firstRect,
const rectangleType& secondRect)
{
return (firstRect.length == secondRect.length &&
firstRect.width == secondRect.width);
}

You can write a program similar to the one in Example 13-5 to test the overloading of
the operators + and == as nonmembers.

Overloading the Stream Insertion (<<) and Extraction (>>)
Operators
If an operator function is a member function of a class, then the leftmost operand of that
operator must be an object of that class. Therefore, the operator function that overloads the
insertion operator, <<, or the extraction operator, >>, for a class must be a nonmember
function of that class.
Consider the expression:
cout << myRectangle;

In this expression, the far left operand of << (that is, cout) is an ostream object, not an
object of type rectangleType. Because the far left operand of << is not an object of
type rectangleType, the operator function that overloads the insertion operator for
rectangleType must be a nonmember function of the class rectangleType.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

925

Similarly, the operator function that overloads the stream extraction operator for
rectangleType must also be a nonmember function of the class rectangleType.
OVERLOADING THE STREAM INSERTION OPERATOR (<<)
The general syntax to overload the stream insertion operator, <<, for a class is described next.

Function Prototype (to be included in the definition of the class):
friend ostream& operator<<(ostream&, const className&);

Function Definition:
ostream& operator<<(ostream& osObject, const className& cObject)
{
//local declaration, if any
//Output the members of cObject.
//osObject << . . .
//Return the stream object.
return osObject;
}

In this function definition:
•
•

Both parameters are reference parameters.
The first parameter—that is, osObject— is a reference to an ostream
object.
• The second parameter is usually a const reference to a particular class,
because (recall from Chapter 10) the most effective way to pass an object
as a parameter to a class is by reference. In this case, the formal parameter
does not need to copy the member variables of the actual parameter. The
word const appears before the class name because we want to print only
the member variables of the object. That is, the function should not
modify the member variables of the object.
• The function return type is a reference to an ostream object.
The return type of the function to overload the operator << must be a reference to an
ostream object for the following reasons.

Suppose that the operator << is overloaded for the class rectangleType. The statement:
cout << myRectangle;

is equivalent to the statement:
operator<<(cout, myRectangle);

This is a perfectly legal statement because both of the actual parameters are objects, not
the value of the objects. The first parameter, cout, is of type ostream; the second
parameter, myRectangle, is of type rectangleType.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

926 |

Chapter 13: Overloading and Templates

Now consider the following statement:
cout << myRectangle << yourRectangle;

This statement is equivalent to the statement:
operator<<(operator<<(cout, myRectangle), yourRectangle); //Line A

because the associativity of the operator << is from left to right.
To execute the previous statement, you must first execute the expression:
cout << myRectangle

that is, the expression:
operator<<(cout, myRectangle)

After executing this expression, which outputs the value of myRectangle, whatever is
returned by the function operator << will become the left-side parameter of the
operator << (that is, the first parameter of the function operator<<) in order to output
the value of object yourRectangle (see the statement in Line A). The left-side
parameter of the operator << must be an object of the ostream type, so the expression:
cout << myRectangle

must return the object cout (not its value) to the left side of the second operator << in
order to output the value of yourRectangle.
Therefore, the return type of the function operator<< must be a reference to an object
of the ostream type.
OVERLOADING THE STREAM EXTRACTION OPERATOR (>>)
The general syntax to overload the stream extraction operator, >>, for a class is described next.

Function Prototype (to be included in the definition of the class):
friend istream& operator>>(istream&, className&);

Function Definition:
istream& operator>>(istream& isObject, className& cObject)
{
//local declaration, if any
//Read the data into cObject.
//isObject >> . . .
//Return the stream object.
return isObject;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

927

In this function definition:
•
•

Both parameters are reference parameters.
The first parameter—that is, isObject—is a reference to an istream
object.
• The second parameter is usually a reference to a particular class. The data
read will be stored in the object.
• The function return type is a reference to an istream object.
For the same reasons as explained previously (when we overloaded the insertion operator
<<), the return type of the function operator>> must be a reference to an istream
object. We can then successfully execute statements of the following type:
cin >> myRectangle >> yourRectangle;

Example 13-7 shows how the stream insertion and extraction operators are overloaded
for the class rectangleType.
EXAMPLE 13-7
The definition of the class rectangleType and the definitions of the operator
functions are:
#include <iostream>
using namespace std;
class rectangleType
{
//Overload the stream insertion and extraction operators
friend ostream& operator<< (ostream&, const rectangleType &);
friend istream& operator>> (istream&, rectangleType &);
public:
void setDimension(double l, double w);
double getLength() const;
double getWidth() const;
double area() const;
double perimeter() const;
void print() const;
rectangleType operator+(const rectangleType&) const;
//Overload the operator +
rectangleType operator*(const rectangleType&) const;
//Overload the operator *
bool operator==(const rectangleType&) const;
//Overload the operator ==
bool operator!=(const rectangleType&) const;
//Overload the operator !=

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

928 |

Chapter 13: Overloading and Templates

rectangleType();
rectangleType(double l, double w);
private:
double length;
double width;
};

Notice that we have removed the member function print because we are overloading
the stream insertion operator <<.
//The definitions of the functions operator+, operator*,
//operator==, and operator!= are the same as in Example 13-6.
ostream& operator<< (ostream& osObject,
const rectangleType& rectangle)
{
osObject << "Length = " << rectangle.length
<< "; Width = " << rectangle.width;
return osObject;
}
istream& operator>> (istream& isObject,
rectangleType& rectangle)
{
isObject >> rectangle.length >> rectangle.width;
return isObject;
}

Consider the following program. (We assume that the definition of the class
rectangleType is in the header file rectangleType.h.)
//This program shows how to use the modified class rectangleType.
#include <iostream>
#include "rectangleType.h"
using namespace std;
int main()
{
rectangleType myRectangle(23, 45);
rectangleType yourRectangle;

//Line 1
//Line 2

cout << "Line 3: myRectangle: " << myRectangle
<< endl;

//Line 3

cout << "Line 4: Enter the length and width "
<<"of a rectangle: ";
cin >> yourRectangle;
cout << endl;

//Line 4
//Line 5
//Line 6

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

cout << "Line 7: yourRectangle: "
<< yourRectangle << endl;
cout <<
<<
cout <<
<<

"Line 8: myRectangle + yourRectangle: "
myRectangle + yourRectangle << endl;
"Line 9: myRectangle * yourRectangle: "
myRectangle * yourRectangle << endl;

|

929

//Line 7
//Line 8
//Line 9

return 0;
}

Sample Run: In this sample run, the user input is shaded.
Line 3: myRectangle: Length = 23; Width = 45
Line 4: Enter the length and width of a rectangle: 32 15
Line 7: yourRectangle: Length = 32; Width = 15
Line 8: myRectangle + yourRectangle: Length = 55; Width = 60
Line 9: myRectangle * yourRectangle: Length = 736; Width = 675

The statements in Lines 1 and 2 declare and initialize myRectangle and yourRectangle
to be objects of type rectangleType. The statement in Line 3 outputs the value of
myRectangle using cout and the insertion operator. The statement in Line 5 inputs the
data into yourRectangle using cin and the extraction operator. The statement in Line 7
outputs the value of yourRectangle using cout and the insertion operator. The cout
statement in Line 8 adds the lengths and widths of myRectangle and yourRectangle
and outputs the result. Similarly, the cout statement in Line 9 multiplies the lengths and
widths of myRectangle and yourRectangle and outputs the result. The output shows
that both the stream insertion and stream extraction operators were overloaded successfully.

Overloading the Assignment Operator (=)
One of the built-in operations on classes is the assignment operation. The assignment
operator causes a member-wise copy of the member variables of the class. For example,
the statement:
myRectangle = yourRectangle;

is equivalent to the statements:
myRectangle.length = yourRectangle.length;
myRectangle.width = yourRectangle.width;

From Chapter 12, recall that the built-in assignment operator works well for classes that
do not have pointer member variables, but not for classes with pointer member variables.
Therefore, to avoid the shallow copy of data for classes with pointer member variables,
we must explicitly overload the assignment operator.
Recall that to overload the assignment operator = for a class, the operator function
operator= must be a member of that class.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

930 |

Chapter 13: Overloading and Templates

GENERAL SYNTAX TO OVERLOAD THE ASSIGNMENT OPERATOR = FOR A CLASS
The general syntax to overload the assignment operator = for a class is described next.

Function Prototype (to be included in the definition of the class):
const className& operator=(const className&);

Function Definition:
const className& className::operator=
(const className& rightObject)
{
//local declaration, if any
if (this != &rightObject) //avoid self-assignment
{
//algorithm to copy rightObject into this object
}
//Return the object assigned.
return *this;
}

In the definition of the function operator=:
•
•
•

There is only one formal parameter.
The formal parameter is usually a const reference to a particular class.
The function return type is a const reference to a particular class.

We now explain why the return type of the function operator= should be a reference
of the class type.
Suppose that the assignment operator = is overloaded for the class rectangleType.
The statement:
myRectangle = yourRectangle;

is equivalent to the statement:
myRectangle.operator=(yourRectangle);

That is, the object yourRectangle becomes the actual parameter to the function:
operator=

Now consider the statement:
myRectangle = yourRectangle = tempRect;

Because the associativity of the operator = is from right to left, this statement is equivalent
to the statement:
myRectangle.operator=(yourRectangle.operator=(tempRect)); //Line A

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

931

Clearly, we must first execute the expression:
yourRectangle.operator=(tempRect)

that is, the expression:
yourRectangle = tempRect

The value returned by the expression:
yourRectangle.operator=(tempRect)

will become the parameter to the function operator= in order to assign a value to the
object myRectangle (see the statement in Line A). Because the formal parameter of the
function operator= is a reference parameter, the expression:
yourRectangle.operator=(tempRect)

must return a reference to the object, rather than its value. That is, it must return a
reference to the object yourRectangle, not the value of yourRectangle. For this
reason, the return type of the function to overload the assignment operator = for a class
must be a reference to the class type.
Now consider the statement:
myRectangle = myRectangle;

//Line B

Here, we are trying to copy the value of myRectangle into myRectangle; that is, this
statement is a self-assignment. One reason why we must prevent such assignments is
because they waste computer time. First, however, we explain how the body of the
assignment operator prevents such assignments.
As noted above, the body of the function operator= does prevent assignments, such as
the one given in Line B. Let us see how.
Consider the if statement in the body of the operator function operator=:
if (this != &rightObject) //avoid self-assignment
{
//algorithm to copy rightObject into this object
}

The statement:
myRectangle = myRectangle;

is compiled into the statement:
myRectangle.operator=(myRectangle);

Because the function operator= is invoked by the object myRectangle, the pointer
this in the body of the function operator= refers to the object myRectangle.
Furthermore, because myRectangle is also a parameter of the function operator=,

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

932 |

Chapter 13: Overloading and Templates

the formal parameter rightObject also refers to the object myRectangle. Therefore,
in the expression:
this != &rightObject

this and &rightObject both mean the address of myRectangle. Thus, the expression will evaluate to false and the body of the if statement will be skipped.
This note illustrates another reason why the body of the operator function must prevent
self-assignments. Let us consider the following class:

class arrayClass
{
public:
const arrayClass& operator= (const& arrayClass);
.
.
.
private:
int *list;
int length;
int maxSize;
};
The class arrayClass has a pointer member variable, list, which is used to
create an array to store integers. Suppose that the definition of the function to overload
the assignment operator for the class arrayClass is written without the if
statement, as follows:

const arrayClass & arrayClass::operator=
(const arrayClass& otherList)
{
delete [] list;
//Line 1
maxSize = otherList.maxSize;
//Line 2
length = otherList.length;
//Line 3
list = new int[maxSize];

//Line 4

for (int i = 0; i < length; i++)
list[i] = otherList.list[i];

//Line 5
//Line 6

return *this;

//Line 7

}
Suppose that we have the following declaration in a user program:

arrayClass myList;
Consider the following statement:

myList = myList;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

933

This is a self-assignment. When this statement executes in the body of the function
operator=:
1.

list means myList.list, maxSize means myList.maxSize,
and length means myList.length.

2. otherList

is the same as myList.

The statement in Line 1 destroys list, that is, myList.list, so the array
holding the numbers no longer exists. That is, it is not valid. The problem is in
Line 6. Here, the expression list[i] = otherList.list[i] is equivalent to
the statement myList.list[i] = myList.list[i]. Because
myList.list[i] has no valid data (it was destroyed in Line 1), the statement in
Line 6 produces garbage.
It follows that the definition of the function operator= must prevent self-assignments.
The correct definition of operator= for the class arrayClass is:

const arrayClass& arrayClass::operator=
(const arrayClass& otherList)
{
if (this != &otherList)
//Line 1
{
delete [] list;
//Line 2
maxSize = otherList.maxSize;
//Line 3
length = otherList.length;
//Line 4
list = new int[maxSize];

//Line 5

for (int i = 0; i < length; i++)
list[i] = otherList.list[i];

//Line 6
//Line 7

}
return *this;

//Line 8

}

The following example illustrates how to overload the assignment operator.
EXAMPLE 13-8
Consider the following class:
class cAssignmentOprOverload
{
public:
const cAssignmentOprOverload&
operator=(const cAssignmentOprOverload& otherList);
//Overload assignment operator

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

934 |

Chapter 13: Overloading and Templates

void print() const;
//Function to print the list
void insertEnd(int item);
//Function to insert an item at the end of the list
//Postcondition: if the list is not full,
//
length++; list[length] = item;
//
if the list is full,
//
output an appropriate message
void destroyList();
//Function to destroy the list
//Postcondition: length = 0; maxSize = 0; list = NULL;
cAssignmentOprOverload(int size = 0);
//Constructor
//Postcondition: length = 0; maxSize = size;
//
list is an array of size maxSize
private:
int maxSize;
int length;
int *list;
};

The definitions of the member functions of the class cAssignmentOprOverload are:
void cAssignmentOprOverload::print() const
{
if (length == 0)
cout << "The list is empty." << endl;
else
{
for (int i = 0; i < length; i++)
cout << list[i] << " ";
cout << endl;
}
}
void cAssignmentOprOverload::insertEnd(int item)
{
if (length == maxSize)
cout << "List is full" << endl;
else
list[length++] = item;
}
void cAssignmentOprOverload::destroyList()
{
delete [] list;
list = nullptr;
length = 0;
maxSize = 0;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

935

cAssignmentOprOverload::cAssignmentOprOverload(int size)
{
maxSize = size;
length = 0;
if (maxSize == 0)
list = nullptr;
else
list = new int[maxSize];
}
const cAssignmentOprOverload& cAssignmentOprOverload::operator=
(const cAssignmentOprOverload& otherList)
{
if (this != &otherList) //avoid self-assignment; Line 1
{
delete [] list;
//Line 2
maxSize = otherList.maxSize;
//Line 3
length = otherList.length;
//Line 4
list = new int[maxSize];

//Line 5

for (int i = 0; i < length; i++)
list[i] = otherList.list[i];

//Line 6
//Line 7

}
return *this;

//Line 8

}

The function to overload the assignment operator works as follows. The statement in
Line 1 checks whether an object is copying itself. The statement in Line 2 destroys
list. The statements in Lines 3 and 4 copy the values of the member variables
maxSize and length of otherList into the member variables maxSize and
length of list, respectively. The statement in Line 5 creates the array to store the
numbers. The for loop in Line 6 copies otherList into list. The statement in
Line 8 returns the address of this object, because the return type of the function
operator= is a reference type.
The following program tests the class cAssignmentOprOverload:

1
3

#include <iostream>
#include "classAssignmentOverload.h"
using namespace std;
int main()
{
cAssignmentOprOverload intList1(10);
cAssignmentOprOverload intList2;
cAssignmentOprOverload intList3;

//Line 9
//Line 10
//Line 11

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

936 |

Chapter 13: Overloading and Templates

int i;
int number;

//Line 12
//Line 13

cout << "Line 14: Enter 5 integers: ";

//Line 14

for (i = 0; i < 5; i++)
{
cin >> number;
intList1.insertEnd(number);
}

//Line 15
//Line 16
//Line 17

cout << endl;
cout << "Line 19: intList1: ";
intList1.print();

//Line 18
//Line 19
//Line 20

intList3 = intList2 = intList1;

//Line 21

cout << "Line 22: intList2: ";
intList2.print();

//Line 22
//Line 23

intList2.destroyList();

//Line 24

cout << endl;
cout << "Line 26: intList2: ";
intList2.print();

//Line 25
//Line 26
//Line 27

cout << "Line 28: After destroying intList2, "
<< "intList1: ";
intList1.print();

//Line 28
//Line 29

cout << "Line 30: After destroying intList2, "
<< "intList3: ";
intList3.print();
cout << endl;

//Line 30
//Line 31
//Line 32

return 0;
}

Sample Run: In this sample run, the user input is shaded.
Line 14: Enter 5 integers: 8 5 3 7 2
Line 19: intList1: 8 5 3 7 2
Line 22: intList2: 8 5 3 7 2
Line 26: intList2: The list is empty.
Line 28: After destroying intList2, intList1: 8 5 3 7 2
Line 30: After destroying intList2, intList3: 8 5 3 7 2

The statement in Line 9 creates intList1 of size 10; the statements in Lines 10 and 11
create intList2 and intList3 of (default) size 50. The statements in Lines 15 through
17 input the data into intList1, and the statement in Line 20 outputs intList1. The

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

937

statement in Line 21 copies intList1 into intList2 and then copies intList2 into
intList3. The statement in Line 23 outputs intList2 (see Line 22 in the sample run,
which contains the output of Lines 22 and 23). The statement in Line 24 destroys
intList2. The statement in Line 27 outputs intList2, which is empty. (See Line
26 in the sample run, which contains the output of Lines 26 and 27.) After destroying
intList2, the program outputs the contents of intList1 and intList3 (see Lines 28
and 30 in the sample run). The sample run clearly shows that the destruction of
intList2 affects neither intList1 nor intList3, because intList1 and intList3
each have their own data.

Overloading Unary Operators
The process of overloading unary operators is similar to the process of overloading binary
operators. The only difference is that in the case of binary operators, the operator has two
operands. In the case of unary operators, the operator has only one parameter. Therefore,
to overload a unary operator for a class:
1. If the operator function is a member of the class, it has no parameters.
2. If the operator function is a nonmember—that is, a friend function of
the class—it has one parameter.
Next, we describe how to overload the increment and decrement operators.
OVERLOADING THE INCREMENT (++) AND DECREMENT (--) OPERATORS
The increment operator has two forms: pre-increment (++u) and post-increment (u++), in
which u is a variable, say, of type int. In the case of pre-increment, ++u, the value of the
variable, u, is incremented by 1 before the value of u is used in an expression. In the case of
post-increment, the value of u is used in the expression before it is incremented by 1.
Overloading the Pre-Increment Operator. Overloading the pre-increment operator is quite
straightforward. In the function definition, first we increment the value of the object,
and then we use the pointer this to return the object’s value.

For example, suppose that we overload the pre-increment operator for the class
rectangleType to increment the length and width of a rectangle by 1. Also, suppose
that the operator function operator++ is a member of the class rectangleType.
The operator function operator++ then has no parameters and we use the pointer
this to return the incremented value of the object:
rectangleType rectangleType::operator++()
{
//increment the length and width
++length;
++width;
return *this; //return the incremented value of the object
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

938 |

Chapter 13: Overloading and Templates

Because myRectangle is an object of type rectangleType, the statement:
++myRectangle;

increments the values of the length and width of myRectangle by 1. Moreover, the pointer
this associated with myRectangle returns the incremented value of myRectangle,
which in this case is ignored.
Now, yourRectangle is also an object of type rectangleType, so the statement:
yourRectangle = ++myRectangle;

increments the length and width of myRectangle by 1, and the pointer this associated
with myRectangle returns the incremented value of myRectangle, which is copied
into yourRectangle.
GENERAL SYNTAX TO OVERLOAD THE PRE-INCREMENT OPERATOR ++ AS A MEMBER FUNCTION
The general syntax to overload the pre-increment operator ++ as a member function is
described next.

Function Prototype (to be included in the definition of the class):
className operator++();

Function Definition:
className className::operator++()
{
//increment the value of the object by 1
return *this;
}

The operator function to overload the pre-increment operator can also be a nonmember
of the class rectangleType, which we describe next.
If the operator function operator++ is a nonmember function of the class
rectangleType, it has one parameter, which is an object of type rectangleType.
(As before, we assume that the increment operator increments the length and width of a
rectangle by 1.)
rectangleType operator++(rectangleType& rectangle)
{
//increment the length and width of the rectangle
(rectangle.length)++;
(rectangle.width)++;
return rectangle; //return the incremented
//value of the object
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

939

GENERAL SYNTAX TO OVERLOAD THE PRE-INCREMENT OPERATOR ++ AS A NONMEMBER FUNCTION
The general syntax to overload the pre-increment operator ++ as a nonmember function
is described next.

Function Prototype (to be included in the definition of the class):
friend className operator++(className&);

Function Definition:
className operator++(className& incObj)
{
//increment incObj by 1
return incObj;
}

OVERLOADING THE POST-INCREMENT OPERATOR
We now discuss how to overload the post-increment operator. As in the case of the preincrement operator, we first describe the overloading of this operator as a member of a class.

Let us overload the post-increment operator for the class rectangleType. In both cases,
pre- and post-increment, the name of the operator function is the same—operator++. To
distinguish between pre- and post-increment operator overloading, we use a dummy
parameter (of type int) in the function heading of the operator function. The dummy
parameter is not used in the definition of the function. Its only purpose is to distinguish
between the pre- and post-increment versions of operator++. Thus, the function
prototype for the post-increment operator of the class rectangleType is:
rectangleType operator++(int);

The statement:
myRectangle++;

is compiled by the compiler in the statement:
myRectangle.operator++(0);

and so the function operator++ with a parameter executes. Notice that the parameter 0
is only used to distinguish between the pre- and post-increment operator functions.
The post-increment operator first uses the value of the object in the expression and then
increments the value of the object. So the steps required to implement this function are:
1. Save the value of the object—in, say, temp.
2. Increment the value of the object.
3. Return the value that was saved in temp.
The function definition of the post-increment operator for the class rectangleType is:
rectangleType rectangleType::operator++(int u)
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

940 |

Chapter 13: Overloading and Templates

{
rectangleType temp = *this;

//use this pointer to copy
//the value of the object

//increment the length and width
length++;
width++;
return temp;

//return the old value of the object

}

GENERAL SYNTAX TO OVERLOAD THE POST-INCREMENT OPERATOR ++ AS A MEMBER FUNCTION
The general syntax to overload the post-increment operator ++ as a member function is
described next.

Function Prototype (to be included in the definition of the class):
className operator++(int);

Function Definition:
className className::operator++(int u)
{
className temp = *this;
//use this pointer to copy
//the value of the object
//increment the object
return temp;

//return the old value of the object

}

The post-increment operator can also be overloaded as a nonmember function of the
class. In this situation, the operator function operator++ has two parameters. The
definition of the function to overload the post-increment operator for the class
rectangleType as a nonmember is:
rectangleType operator++(rectangleType& rectangle, int u)
{
rectangleType temp = rectangle; //copy rectangle into temp
//increment the length and width of rectangle
(rectangle.length)++;
(rectangle.width)++;
return temp;

//return the old value of the object

}

GENERAL SYNTAX TO OVERLOAD THE POST-INCREMENT OPERATOR ++ AS A NONMEMBER FUNCTION
The general syntax to overload the post-increment operator ++ as a nonmember function
is described next.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

941

Function Prototype (to be included in the definition of the class):
friend className operator++(className&, int);

Function Definition:
className operator++(className& incObj, int u)
{
className temp = incObj; //copy incObj into temp
//increment incObj
return temp;

//return the old value of the object

}

The decrement operators can be overloaded in a similar way, the details of which are left
as an exercise for you.
Let us now write the definition of the class rectangleType and show how the
operator functions appear in the class definition. Because certain operators can be overloaded as either member or nonmember functions, we give two equivalent definitions of
the class rectangleType. In the first definition, the increment, decrement, arithmetic, and relational operators are overloaded as member functions. In the second
definition, the increment, decrement, arithmetic, and relational operators are overloaded
as nonmember functions.
The definition of the class rectangleType is as follows:
//Definition of the class rectangleType
//The increment, decrement, arithmetic, and relational
//operator functions are members of the class.
#include <iostream>
using namespace std;
class rectangleType
{
//Overload the stream insertion and extraction operators
friend ostream& operator<<(ostream&, const rectangleType &);
friend istream& operator>>(istream&, rectangleType &);
public:
void setDimension(double l, double w);
double getLength() const;
double getWidth() const;
double area() const;
double perimeter() const;
//Overload the arithmetic operators
rectangleType operator+(const rectangleType &) const;
rectangleType operator-(const rectangleType &) const;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

942 |

Chapter 13: Overloading and Templates

rectangleType operator*(const rectangleType&) const;
rectangleType operator/(const rectangleType&) const;
//Overload the increment and decrement operators
rectangleType operator++();
//pre-increment
rectangleType operator++(int);
//post-increment
rectangleType operator--();
//pre-decrement
rectangleType operator--(int);
//post-decrement
//Overload the relational operators
bool operator==(const rectangleType&) const;
bool operator!=(const rectangleType&) const;
bool operator<=(const rectangleType&) const;
bool operator<(const rectangleType&) const;
bool operator>=(const rectangleType&) const;
bool operator>(const rectangleType&) const;
//Constructors
rectangleType();
rectangleType(double l, double w);
private:
double length;
double width;
};

Following is the definition of the class rectangleType, in which the increment,
decrement, arithmetic, and relational operators are overloaded as nonmembers.
//Definition of the class rectangleType
//The increment, decrement, arithmetic, and relational
//operator functions are nonmembers of the class.
#include <iostream>
using namespace std;
class rectangleType
{
//Overload the stream insertion and extraction operators
friend ostream& operator<<(ostream&, const rectangleType&);
friend istream& operator>>(istream&, rectangleType&);
//Overload the arithmetic operators
friend rectangleType operator+(const rectangleType&,
const rectangleType&);
friend rectangleType operator-(const rectangleType&,
const rectangleType&);
friend rectangleType operator*(const rectangleType&,
const rectangleType&);
friend rectangleType operator/(const rectangleType&,
const rectangleType&);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operator Overloading

|

943

//Overload the increment and decrement operators
friend rectangleType operator++(rectangleType&);
//pre-increment
friend rectangleType operator++(rectangleType&, int);
//post-increment
friend rectangleType operator--(rectangleType&);
//pre-decrement
friend rectangleType operator--(rectangleType&, int);
//post-decrement
//Overload the relational operators
friend bool operator==(const rectangleType&,
const rectangleType&);
friend bool operator!=(const rectangleType&,
const rectangleType&);
friend bool operator<=(const rectangleType&,
const rectangleType&);
friend bool operator<(const rectangleType&,
const rectangleType&);
friend bool operator>=(const rectangleType&,
const rectangleType&);
friend bool operator>(const rectangleType&,
const rectangleType&);
public:
void setDimension(double l, double w);
double getLength() const;
double getWidth() const;
double area() const;
double perimeter() const;
//Constructors
rectangleType();
rectangleType(double l, double w);
private:
double length;
double width;
};

The definitions of the functions to overload the operators for the class rectangleType
are left as an exercise for you. (See Programming Exercises 1 and 2 at the end of this chapter.)

Operator Overloading: Member versus Nonmember
The preceding sections discussed and illustrated how to overload operators. Certain
operators must be overloaded as member functions of the class, and some must be
overloaded as nonmember (friend) functions. What about the operators that can be
overloaded as either member functions or nonmember functions? For example, the
binary arithmetic operator + can be overloaded as a member function or a nonmember
function. If you overload + as a member function, then the operator + has direct access to
the member variables of one of the objects, and you need to pass only one object as a

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

944 |

Chapter 13: Overloading and Templates

parameter. On the other hand, if you overload + as a nonmember function, then you must
pass both objects as parameters. When both objects are passed as parameters, the code may
become somewhat clearer. So, other than following the restrictions on operator overloading,
it is a matter of preference whether you overload + as a member or as a nonmember
function. In the remainder of this chapter, if we overload an operator as a member function,
we will leave it as an exercise for you to overload it as a nonmember function.

Classes and Pointer Member Variables (Revisited)
Chapter 12 described the peculiarities of classes with pointer member variables. Now that
we have discussed how to overload various operators, let us review the peculiarities of classes
with pointer member variables, for the sake of completeness, and how to avoid them.
Recall that the only built-in operations on classes are assignment and member selection.
The assignment operator provides a member-wise copy of the data. That is, the member
variables of an object are copied into the corresponding member variables of another
object of the same type. We have seen that this member-wise copy does not work well
for classes with pointer member variables. Other problems that may arise with classes with
pointer member variables relate to deallocating dynamic memory when an object goes
out of scope and passing a class object as a parameter by value. To resolve these problems,
classes with pointer member variables must:
1. Explicitly overload the assignment operator
2. Include the copy constructor
3. Include the destructor

Operator Overloading: One Final Word
Next, we look at three examples that illustrate operator overloading. Before delving into
these examples, you must remember the following: Suppose that an operator op is
overloaded for a class—say, rectangleType. Whenever we use the operator op on
objects of type rectangleType, the body of the function that overloads the operator op
for the class rectangleType executes. Therefore, whatever code you put in the body
of the function executes.

PROGRAMMING EXAMPLE:

Watch
the Video

clockType

Chapter 10 defined a class clockType to implement the time of day in a program.
We implemented the operations to print the time, increment the time, and compare
the two times for equality using functions. This example redefines the class
clockType. It also overloads the stream insertion and extraction operators for easy
input and output, relational operators for comparisons, and the increment operator to
increment the time by one second. The program that uses the class clockType
requires the user to input the time in the form hr:min:sec.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: clockType

|

945

The definition of the class clockType is as follows:
//Header file newClock.h
#ifndef H_newClock
#define H_newClock
#include <iostream>
using namespace std;
class clockType
{
friend ostream& operator<<(ostream&, const clockType&);
friend istream& operator>>(istream&, clockType&);
public:
void setTime(int hours, int minutes, int seconds);
//Function to set the member variables hr, min, and sec.
//Postcondition: hr = hours; min = minutes; sec = seconds;
void getTime(int& hours, int& minutes, int& seconds) const;
//Function to return the time.
//Postcondition: hours = hr; minutes = min; seconds = sec;
clockType operator++();
//Overload the pre-increment operator.
//Postcondition: The time is incremented by one second.
bool operator==(const clockType& otherClock) const;
//Overload the equality operator.
//Postcondition: Returns true if the time of this clock
//
is equal to the time of otherClock,
//
otherwise it returns false.
bool operator!=(const clockType& otherClock) const;
//Overload the not equal operator.
//Postcondition: Returns true if the time of this clock
//
is not equal to the time of otherClock,
//
otherwise it returns false.
bool operator<=(const clockType& otherClock) const;
//Overload the less than or equal to operator.
//Postcondition: Returns true if the time of this clock
//
is less than or equal to the time of
//
otherClock, otherwise it returns false.
bool operator<(const clockType& otherClock) const;
//Overload the less than operator.
//Postcondition: Returns true if the time of this clock
//
is less than the time of otherClock,
//
otherwise it returns false.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

946 |

Chapter 13: Overloading and Templates

bool operator>=(const clockType& otherClock) const;
//Overload the greater than or equal to operator.
//Postcondition: Returns true if the time of this clock
//
is greater than or equal to the time of
//
otherClock, otherwise it returns false.
bool operator>(const clockType& otherClock) const;
//Overload the greater than operator.
//Postcondition: Returns true if the time of this clock
//
is greater than the time of otherClock,
//
otherwise it returns false.
clockType(int hours = 0, int minutes = 0, int seconds = 0);
//Constructor to initialize the object with the values
//specified by the user. If no values are specified,
//the default values are assumed.
//Postcondition: hr = hours; min = minutes;
//
sec = seconds;
private:
int hr; //variable to store the hours
int min; //variable to store the minutes
int sec; //variable to store the seconds
};
#endif

Figure 13-1 shows a UML class diagram of the class clockType.

clockType
–hr: int
–min: int
–sec: int
+operator<<(ostream&, const clockType&): ostream&
+operator>>(istream&, clockType&): istream&
+setTime(int, int, int): void
+getTime(int&, int&, int&) const: void
+operator++(): clockType
+operator==(const clockType&) const: bool
+operator!=(const clockType&) const: bool
+operator<=(const clockType&) const: bool
+operator<(const clockType&) const: bool
+operator>=(const clockType&) const: bool
+operator>(const clockType&) const: bool
+clockType(int = 0, int = 0, int = 0)

FIGURE 13-1

UML class diagram of the class clockType

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: clockType

|

947

Let us now write the definitions of the functions to implement the operations of the
class clockType. Notice that the class clockType overloads only the preincrement operator. For consistency, however, the class should also overload the
post-increment operator. This step is left as an exercise for you. (See Programming
Exercise 5 at the end of this chapter.)
First, we write the definition of the function operator++. The algorithm to
increment the time by one second is as follows:
a. Increment the seconds by 1.
b. If seconds > 59,
b.1. Set the seconds to 0.
b.2. Increment the minutes by 1.
b.3. If minutes > 59,
b.3.1. Set the minutes to 0.
b.3.2. Increment the hours by 1.
b.3.3. If hours > 23,
b.3.3.1. Set the hours to 0.
c. Return the incremented value of the object.
The definition of the function operator++ is:
//Overload the pre-increment operator.
clockType clockType::operator++()
{
sec++;
//Step a
if (sec > 59)
{
sec = 0;
min++;
if (min > 59)
{
min = 0;
hr++;
if (hr > 23)
hr = 0;

//Step b
//Step b.1
//Step b.2
//Step b.3
//Step b.3.1
//Step b.3.2
//Step b.3.3
//Step b.3.3.1

}
}
return *this;

//Step c

}

The definition of the function operator== is quite simple. The two times are the
same if they have the same hours, minutes, and seconds. Therefore, the definition of
the function operator== is:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

948 |

Chapter 13: Overloading and Templates

//Overload the equality operator.
bool clockType::operator==(const clockType& otherClock) const
{
return (hr == otherClock.hr && min == otherClock.min
&& sec == otherClock.sec);
}

The definition of the function operator<= is given next. The first time is less than
or equal to the second time if:
1. The hours of the first time are less than the hours of the second time, or
2. The hours of the first time and the second time are the same, but the
minutes of the first time are less than the minutes of the second time, or
3. The hours and minutes of the first time and the second time are the
same, but the seconds of the first time are less than or equal to the
seconds of the second time.
The definition of the function operator<= is:
//Overload the less than or equal to operator.
bool clockType::operator<=(const clockType& otherClock) const
{
return ((hr < otherClock.hr) ||
(hr == otherClock.hr && min < otherClock.min) ||
(hr == otherClock.hr && min == otherClock.min &&
sec <= otherClock.sec));
}

In a similar manner, we can write the definitions of the other relational operator
functions as follows:
//Overload the not equal operator.
bool clockType::operator!=(const clockType& otherClock) const
{
return (hr != otherClock.hr || min != otherClock.min
|| sec != otherClock.sec);
}
//Overload the less than or equal to operator.
bool clockType::operator<=(const clockType& otherClock) const
{
return ((hr < otherClock.hr) ||
(hr == otherClock.hr && min < otherClock.min) ||
(hr == otherClock.hr && min == otherClock.min &&
sec <= otherClock.sec));
}
//Overload the less than operator.
bool clockType::operator<(const clockType& otherClock) const
{
return ((hr < otherClock.hr) ||
(hr == otherClock.hr && min < otherClock.min) ||
(hr == otherClock.hr && min == otherClock.min &&
sec < otherClock.sec));
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: clockType

|

949

//Overload the greater than or equal to operator.
bool clockType::operator>=(const clockType& otherClock) const
{
return ((hr > otherClock.hr) ||
(hr == otherClock.hr && min > otherClock.min) ||
(hr == otherClock.hr && min == otherClock.min &&
sec >= otherClock.sec));
}
//Overload the greater than operator.
bool clockType::operator>(const clockType& otherClock) const
{
return ((hr > otherClock.hr) ||
(hr == otherClock.hr && min > otherClock.min) ||
(hr == otherClock.hr && min == otherClock.min &&
sec > otherClock.sec));
}

(Note that after writing the definition of the function to overload the operator ==, you
can use the operator == to write the definition of the function to overload the operator
!=. Similarly, you can use the operators == and < to write the definition of the function
to overload the operator <=, and so on. We leave the details as an exercise.)
The definitions of the functions setTime and getTime are the same as given in
Chapter 10. They are included here for the sake of completeness. Moreover, we have
modified the definition of the constructor so that it uses the function setTime to set
the time. The definitions are as follows:
void clockType::setTime(int hours, int minutes, int seconds)
{
if (0 <= hours && hours < 24)
hr = hours;
else
hr = 0;
if (0 <= minutes && minutes < 60)
min = minutes;
else
min = 0;
if (0 <= seconds && seconds < 60)
sec = seconds;
else
sec = 0;
}
void clockType::getTime(int& hours, int& minutes,
int& seconds) const
{
hours = hr;
minutes = min;
seconds = sec;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

950 |

Chapter 13: Overloading and Templates

//Constructor
clockType::clockType(int hours, int minutes, int seconds)
{
setTime(hours, minutes, seconds);
}

We now discuss the definition of the function operator<<. The time must be
output in the form:
hh:mm:ss

The algorithm to output the time in this format is the same as the body of the
printTime function of clockType given in Chapter 10. Here, after printing
the time in the previous format, we must return the ostream object. Therefore,
the definition of the function operator<< is:
//Overload the stream insertion operator.
ostream& operator<<(ostream& osObject, const clockType& timeOut)
{
if (timeOut.hr < 10)
osObject << '0';
osObject << timeOut.hr << ':';
if (timeOut.min < 10)
osObject << '0';
osObject << timeOut.min << ':';
if (timeOut.sec < 10)
osObject << '0';
osObject << timeOut.sec;
return osObject;

//return the ostream object

}

Let us now discuss the definition of the function operator>>. The input to the
program is of the form:
hh:mm:ss

That is, the input is the hours followed by a colon, followed by the minutes, followed by
a colon, followed by the seconds. The algorithm to input the time is:
a.
b.
c.
d.
e.
f.

Get the input, which is a number, and store it in the member
variable hr. Also check if the input is valid.
Get the next input, which is a colon, and discard it.
Get the next input, which is a number, and store it in the
member variable min. Also check if the input is valid.
Get the next input, which is a colon, and discard it.
Get the next input, which is a number, and store it in the
member variable sec. Also check if the input is valid.
Return the istream object.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: clockType

|

951

Clearly, we need a local variable of type char to read the colon.
The definition of the function operator>> is:
//overload the stream extraction operator
istream& operator>> (istream& is, clockType& timeIn)
{
char ch;
is >> timeIn.hr;

//Step a

if (timeIn.hr < 0 || timeIn.hr >= 24)
timeIn.hr = 0;

//Step a

is.get(ch);

//Read and discard :. Step b

is >> timeIn.min;

//Step c

if (timeIn.min < 0 || timeIn.min >= 60)
timeIn.min = 0;

//Step c

is.get(ch);

//Read and discard :. Step d

is >> timeIn.sec;

//Step e

if (timeIn.sec < 0 || timeIn.sec >= 60)
timeIn.sec = 0;

//Step e

return is;

//Step f

}

The following test program uses the class clockType:
//**********************************************************
// Author: D.S. Malik
//
// This program shows how to use the class clockType.
//**********************************************************
#include <iostream>
#include "newClock.h"

1
3

using namespace std;
int main()
{
clockType myClock(5, 6, 23);
clockType yourClock;
cout << "Line 3: myClock = " << myClock
<< endl;

//Line 1
//Line 2
//Line 3

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

952 |

Chapter 13: Overloading and Templates

cout << "Line 4: yourClock = " << yourClock
<< endl;

//Line 4

cout << "Line 5: Enter the time in the form "
<< "hr:min:sec ";
cin >> myClock;
cout << endl;

//Line 5
//Line 6
//Line 7

cout << "Line 8: The new time of myClock = "
<< myClock << endl;

//Line 8

++myClock;

//Line 9

cout << "Line 10: After incrementing the time, "
<< "myClock = " << myClock << endl;
//Line 10
yourClock.setTime(13, 35, 38);

//Line 11

cout << "Line 12: After setting the time, "
<< "yourClock = " << yourClock << endl;

//Line 12

if (myClock
cout <<
<<
else
cout <<
<<

== yourClock)
//Line
"Line 14: The times of myClock and "
"yourClock are equal." << endl;
//Line
//Line
"Line 16: The times of myClock and "
"yourClock are not equal." << endl; //Line

if (myClock
cout <<
<<
<<
else
cout <<
<<
<<

<= yourClock)
"Line 18: The time of myClock is "
"less than or equal to " << endl
"the time of yourClock." << endl;
"Line 20: The time of myClock is "
"greater than the time of "
"yourClock." << endl;

13
14
15
16

//Line 17
//Line 18
//Line 19
//Line 20

return 0;
}

Sample Run: In this sample run, the user input is shaded.
Line 3: myClock = 05:06:23
Line 4: yourClock = 00:00:00
Line 5: Enter the time in the form hr:min:sec 4:50:59
Line 8: The new time of myClock = 04:50:59
Line 10: After incrementing the time, myClock = 04:51:00
Line 12: After setting the time, yourClock = 13:35:38
Line 16: The times of myClock and yourClock are not equal.
Line 18: The time of myClock is less than or equal to
the time of yourClock.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Complex Numbers

PROGRAMMING EXAMPLE:

|

953

Complex Numbers

A number of the form a + ib, in which i2 = -1 and a and b are real numbers, is called a
complex number. We call a the real part and b the imaginary part of a + ib.
Complex numbers can also be represented as ordered pairs (a, b). The addition and
multiplication of complex numbers are defined by the following rules:
(a + ib) + (c + id ) = (a + c) + i(b + d )
(a + ib) * (c + id ) = (ac - bd ) + i(ad + bc)
Using the ordered pair notation, these rules are written as:
(a, b) + (c, d ) = ((a + c), (b + d ))
(a, b) * (c, d ) = ((ac - bd ), (ad + bc))
C++ has no built-in data type that allows us to manipulate complex numbers. In this
example, we will construct a data type, complexType, that can be used to process
complex numbers. We will overload the stream insertion and stream extraction
operators for easy input and output. We will also overload the operators + and * to
perform addition and multiplication of complex numbers. If x and y are complex
numbers, we can evaluate expressions such as x + y and x * y.
//Specification file complexType.h
#ifndef H_complexNumber
#define H_complexNumber
#include <iostream>
using namespace std;
class complexType
{
//Overload the stream insertion and extraction operators
friend ostream& operator<<(ostream&, const complexType&);
friend istream& operator>>(istream&, complexType&);
public:
void setComplex(const double& real, const double& imag);
//Function to set the complex numbers according to
//the parameters.
//Postcondition: realPart = real; imaginaryPart = imag;
void getComplex(double& real, double& imag) const;
//Function to retrieve the complex number.
//Postcondition: real = realPart; imag = imaginaryPart;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

954 |

Chapter 13: Overloading and Templates

complexType(double real = 0, double imag = 0);
//Constructor
//Initializes the complex number according to
//the parameters.
//Postcondition: realPart = real; imaginaryPart = imag;
complexType operator+
(const complexType& otherComplex) const;
//Overload the operator +
complexType operator*
(const complexType& otherComplex) const;
//Overload the operator *
bool operator== (const complexType& otherComplex) const;
//Overload the operator ==
private:
double realPart;
//variable to store the real part
double imaginaryPart; //variable to store the
//imaginary part
};
#endif

Figure 13-2 shows a UML class diagram of the class complexType.

complexType
–realPart: double
–imaginaryPart: double
+operator<<(ostream&, const complexType&): ostream&
+operator>>(istream&, complexType&): istream&
+setComplex(const double&, const double&): void
+getComplex(double& double&) const: void
+operator+(const complexType&) const: complexType
+operator*(const complexType&) const: complexType
+operator==(const complexType&) const: bool
+complexType(double = 0, double = 0)

FIGURE 13-2

UML class diagram of the class complexType

Next, we write the definitions of the functions to implement various operations of
the class complexType.
The definitions of most of these functions are straightforward. We will discuss only
the definitions of the functions to overload the stream insertion operator, <<, and the
stream extraction operator, >>.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Complex Numbers

|

955

To output a complex number in the form:
(a, b)

in which a is the real part and b is the imaginary part, the algorithm is:
a.
b.
c.
d.
e.

Output
Output
Output
Output
Output

the
the
the
the
the

left parenthesis, (.
real part.
comma and a space.
imaginary part.
right parenthesis, ).

Therefore, the definition of the function operator<< is:
ostream& operator<<(ostream& osObject,
const complexType& complex)
{
osObject
osObject
osObject
osObject
osObject

<<
<<
<<
<<
<<

"(";
complex.realPart;
", ";
complex.imaginaryPart;
")";

return osObject;

//Step
//Step
//Step
//Step
//Step

a
b
c
d
e

//return the ostream object

}

Next, we discuss the definition of the function to overload the stream extraction
operator, >>.
The input is of the form:
(3, 5)

In this input, the real part of the complex number is 3, and the imaginary part is 5.
The algorithm to read this complex number is:
a.
b.
c.
d.
e.

Read
Read
Read
Read
Read

and
and
and
and
and

discard the left parenthesis.
store the real part.
discard the comma.
store the imaginary part.
discard the right parenthesis.

1
3

Following these steps, the definition of the function operator>> is:
istream& operator>>(istream& isObject, complexType& complex)
{
char ch;
isObject >> ch;
isObject >> complex.realPart;

//Step a
//Step b

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

956 |

Chapter 13: Overloading and Templates

isObject >> ch;
isObject >> complex.imaginaryPart;
isObject >> ch;
return isObject;

//Step c
//Step d
//Step e

//return the istream object

}

The definitions of the other functions are as follows:
bool complexType::operator==
(const complexType& otherComplex) const
{
return (realPart == otherComplex.realPart &&
imaginaryPart == otherComplex.imaginaryPart);
}
//Constructor
complexType::complexType(double real, double imag)
{
realPart = real;
imaginaryPart = imag;
}
//Function to set the complex number after the object
//has been declared.
void complexType::setComplex(const double& real,
const double& imag)
{
realPart = real;
imaginaryPart = imag;
}
void complexType::getComplex(double& real, double& imag) const
{
real = realPart;
imag = imaginaryPart;
}
//overload the operator +
complexType complexType::operator+
(const complexType& otherComplex) const
{
complexType temp;
temp.realPart = realPart + otherComplex.realPart;
temp.imaginaryPart = imaginaryPart
+ otherComplex.imaginaryPart;
return temp;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Complex Numbers

|

957

//overload the operator *
complexType complexType::operator*
(const complexType& otherComplex) const
{
complexType temp;
temp.realPart = (realPart * otherComplex.realPart) (imaginaryPart * otherComplex.imaginaryPart);
temp.imaginaryPart = (realPart * otherComplex.imaginaryPart)
+ (imaginaryPart * otherComplex.realPart);
return temp;
}

The following program illustrates the use of the class complexType:
//**********************************************************
// Author: D.S. Malik
//
// This program shows how to use the class complexType.
//**********************************************************
#include <iostream>
#include "complexType.h"
using namespace std;
int main()
{
complexType num1(23, 34);
complexType num2;
complexType num3;

//Line 1
//Line 2
//Line 3

cout << "Line 4: Num1 = " << num1 << endl;
cout << "Line 5: Num2 = " << num2 << endl;

//Line 4
//Line 5

cout << "Line 6: Enter the complex number "
<< "in the form (a, b) ";
cin >> num2;
cout << endl;

//Line 6
//Line 7
//Line 8

cout << "Line 9: New value of num2 = "
<< num2 << endl;

//Line 9

num3 = num1 + num2;

//Line 10

cout << "Line 11: Num3 = " << num3 << endl;

//Line 11

cout << "Line 12: " << num1 << " + " << num2
<< " = " << num1 + num2 << endl;

//Line 12

cout << "Line 13: " << num1 << " * " << num2
<< " = " << num1 * num2 << endl;

//Line 13

return 0;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

958 |

Chapter 13: Overloading and Templates

Sample Run: In this sample run, the user input is shaded.
Line
Line
Line
Line
Line
Line
Line

4: Num1 = (23, 34)
5: Num2 = (0, 0)
6: Enter the complex number in the form (a, b) (3, 4)
9: New value of num2 = (3, 4)
11: Num3 = (26, 38)
12: (23, 34) + (3, 4) = (26, 38)
13: (23, 34) * (3, 4) = (-67, 194)

You can extend this data type to perform subtraction and division on complex numbers.
Next, we will define a class, called newString, and overload the assignment and
relational operators. That is, when we declare a variable of type newString, we will
be able to use the assignment operator to copy one string into another and relational
operators to compare the two strings.
Before discussing the class newString, however, we will examine the overloading
of the operator []. Recall that we have used the operator [] to access the components
of an array. To access individual characters in a string of type newString, we have to
overload the operator [] for the class newString.

Overloading the Array Index (Subscript)
Operator ([])
Recall that the function to overload the operator [] for a class must be a member of the
class. Furthermore, because an array can be declared as constant or nonconstant, we need
to overload the operator [] to handle both cases.
The syntax to declare the operator function operator[] as a member of a class for
nonconstant arrays is:
Type& operator[](int index);

The syntax to declare the operator function operator[] as a member of a class for
constant arrays is:
const Type& operator[](int index) const;

in which Type is the data type of the array elements.
Suppose that classTest is a class that has an array member variable. The definition of
classTest to overload the operator [] is:
class classTest
{
public:
Type& operator[](int index);
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Overloading the Array Index (Subscript) Operator ([])

|

959

//Overload the operator for nonconstant arrays
const Type& operator[](int index) const;
//Overload the operator for constant arrays
.
.
.
private:
Type *list; //pointer to the array
int arraySize;
};

in which Type is the data type of the array elements.
The definitions of the functions to overload the operator [] for classTest are:
//Overload the operator [] for nonconstant arrays
Type& classTest::operator[](int index)
{
assert(0 <= index && index < arraySize);
return list[index];
//return a pointer of the
//array component
}
//Overload the operator [] for constant arrays
const Type& classTest::operator[](int index) const
{
assert(0 <= index && index < arraySize);
return list[index]; //return a pointer of the
//array component
}
The preceding function definitions use the assert statement. (For an explanation of the
assert statement, see Chapter 4 or the Appendix.)

Consider the following statements:
classTest list1;
classTest list2;
const classTest list3;

In the case of the statement:
list1[2] = list2[3];

the body of the operator function operator[] for nonconstant arrays is executed. In the
case of the statement:
list1[2] = list3[5];

first, the body of the operator function operator[] for constant arrays is executed
because list3 is a constant array. Next, the body of the operator function operator[]
for nonconstant arrays is executed to complete the execution of the assignment statement
for list1.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

960 |

Chapter 13: Overloading and Templates

PROGRAMMING EXAMPLE:

newString

Chapter 8 discussed C-strings. Recall that:
1.
2.
3.
4.

A C-string is a sequence of one or more characters.
C-strings are enclosed in double quotation marks.
C-strings are null terminated.
C-strings are stored in character arrays.

The only aggregate operations allowed on C-strings are input and output. To use
other operations, the programmer needs to include the header file cstring, which
contains the specifications of many functions for string manipulation.
Initially, C++ did not provide any built-in data types to handle C-strings. More
recent versions of C++, however, provide a string class to handle C-strings and
operations on C-strings.
Our objective in this example is to define our own class for C-string manipulation
and, at the same time, to further illustrate operator overloading. More specifically,
we overload the assignment operator, the relational operators, and the stream
insertion and extraction operators for easy input and output. Let us call this class
newString. First, we give the definition of the class newString:
//Header file myString.h
#ifndef H_myString
#define H_myString
#include <iostream>
using namespace std;
class newString
{
//Overload the stream insertion and extraction operators.
friend ostream& operator << (ostream&, const newString&);
friend istream& operator >> (istream&, newString&);
public:
const newString& operator=(const newString&);
//overload the assignment operator
newString(const char *);
//constructor; conversion from the char string
newString();
//Default constructor to initialize the string to null
newString(const newString&);
//Copy constructor

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: newString

|

961

~newString();
//Destructor
char &operator[] (int);
const char &operator[](int) const;
//overload the relational operators
bool operator==(const newString&) const;
bool operator!=(const newString&) const;
bool operator<=(const newString&) const;
bool operator<(const newString&) const;
bool operator>=(const newString&) const;
bool operator>(const newString&) const;
private:
char *strPtr;
int strLength;

//pointer to the char array
//that holds the string
//variable to store the length
//of the string

};
#endif

The class newString has two private member variables: one to store the
C-string and one to store the length of the C-string.
Next, we give the definitions of the functions to implement the newString operations.
The implementation file includes the header file cassert because we are using the
function assert. (For an explanation of the function assert, see Chapter 4 or the
header file cassert in the Appendix).
//Implementation file myStringImp.cpp
#include <iostream>
#include <iomanip>
#include <cstring>
#include <cassert>
#include "myString.h"
using namespace std;
//Constructor: conversion from the char string to newString
newString::newString(const char *str)
{
strLength = strlen(str);
strPtr = new char[strLength + 1]; //allocate memory to
//store the char string
strcpy(strPtr, str); //copy string into strPtr
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

962 |

Chapter 13: Overloading and Templates

//Default constructor to store the null string
newString::newString()
{
strLength = 0;
strPtr = new char[1];
strcpy(strPtr, "");
}
newString::newString(const newString& rightStr) //copy constructor
{
strLength = rightStr.strLength;
strPtr = new char[strLength + 1];
strcpy(strPtr, rightStr.strPtr);
}
newString::~newString() //destructor
{
delete [] strPtr;
}
//overload the assignment operator
const newString& newString::operator=(const newString& rightStr)
{
if (this != &rightStr) //avoid self-copy
{
delete [] strPtr;
strLength = rightStr.strLength;
strPtr = new char[strLength + 1];
strcpy(strPtr, rightStr.strPtr);
}
return *this;
}
char& newString::operator[] (int index)
{
assert(0 <= index && index < strLength);
return strPtr[index];
}
const char& newString::operator[](int index) const
{
assert(0 <= index && index < strLength);
return strPtr[index];
}
//Overload the relational operators.
bool newString::operator==(const newString& rightStr) const
{
return (strcmp(strPtr, rightStr.strPtr) == 0);
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: newString

|

963

bool newString::operator<(const newString& rightStr) const
{
return (strcmp(strPtr, rightStr.strPtr) < 0);
}
bool newString::operator<=(const newString& rightStr) const
{
return (strcmp(strPtr, rightStr.strPtr) <= 0);
}
bool newString::operator>(const newString& rightStr) const
{
return (strcmp(strPtr, rightStr.strPtr) > 0);
}
bool newString::operator>=(const newString& rightStr) const
{
return (strcmp(strPtr, rightStr.strPtr) >= 0);
}
bool newString::operator!=(const newString& rightStr) const
{
return (strcmp(strPtr, rightStr.strPtr) != 0);
}
//Overload the stream insertion operator <<
ostream& operator << (ostream& osObject, const newString& str)
{
osObject << str.strPtr;
return osObject;
}
//Overload the stream extraction operator >>
istream& operator >> (istream& isObject, newString& str)
{
char temp[81];
isObject >> setw(81) >> temp;
str = temp;
return isObject;
}

Consider the statement:
isObject >> setw(81) >> temp;

in the definition of the function operator>>. Because temp is declared to be an
array of size 81, the largest string that can be stored into temp is of length 80. The
manipulator setw in this statement (that is, in the input statement) ensures that no
more than 80 characters are read into temp.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

964 |

Chapter 13: Overloading and Templates

Most of these functions are quite straightforward. Let us explain the functions that overload the conversion constructor, the assignment operator, and the copy constructor.
The conversion constructor is a single-parameter function that converts its argument to an object of the constructor’s class. In our case, the conversion constructor
converts a string to an object of the newString type.
Note that the assignment operator is explicitly overloaded only for objects of the
newString type. However, the overloaded assignment operator also works if we
want to store a C-string into a newString object. Consider the declaration:
newString str;

and the statement:
str = "Hello there";

The compiler translates this statement into:
str.operator=("Hello there");

1. First, the compiler automatically invokes the conversion constructor
to create an object of the newString type to temporarily store the
string "Hello there".
2. Second, the compiler invokes the overloaded assignment operator to
assign the temporary newString object to the object str.
Hence, it is not necessary to explicitly overload the assignment operator to store a
C-string into an object of type newString.
Next, we write a C++ program that tests some of the operations of the class
newString.
//**********************************************************
// Author: D.S. Malik
//
// This program shows how to use the class newString.
//**********************************************************
#include <iostream>
#include "myString.h"
using namespace std;
int main()
{
newString str1 = "Sunny";
const newString str2("Warm");

//initialize str1 using
//the assignment operator
//initialize str2 using the
//conversion constructor

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: newString

|

965

newString str3; //initialize str3 to the empty string
newString str4; //initialize str4 to the empty string
cout << "Line 1: " << str1 << "
" << str2
<< " ***" << str3 << "###." << endl;
if (str1 <= str2)
cout << "Line
<< "than
else
cout << "Line
<< "than

//Line 1

//compare str1 and str2; Line
3: " << str1 << " is less "
or equal to" << str2 << endl; //Line
//Line
5: " << str2 << " is less "
" << str1 << endl;
//Line

2
3
4
5

cout << "Line 6: Enter a string with a length "
<< "of at least 7: ";
//Line 6
cin >> str1;
//input str1;
Line 7
cout << endl;
//Line 8
cout << "Line 9: The new value of "
<< "str1 = " << str1 << endl;

//Line 9

str4 = str3 = "Birth Day";

//Line 10

cout << "Line 11: str3 = " << str3
<< ", str4 = " << str4 << endl;

//Line 11

str3 = str1;
cout << "Line 13: The new value of str3 = "
<< str3 << endl;

//Line 12

str1 = "Bright Sky";

//Line 14

//Line 13

str3[1] = str1[5];
//Line 15
cout << "Line 16: After replacing the second "
<< "character of str3 = " << str3 << endl; //Line 16
str3[2] = str2[0];
//Line 17
cout << "Line 18: After replacing the third "
<< "character of str3 = " << str3 << endl; //Line 18
str3[5] = 'g';
//Line 19
cout << "Line 20: After replacing the sixth "
<< "character of str3 = " << str3 << endl; //Line 20
return 0;
}

Sample Run: In this sample run, the user input is shaded.
Line 1: Sunny
Warm ***###.
Line 3: Sunny is less than or equal to Warm

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

966 |

Line
Line
Line
Line
Line
Line
Line

Chapter 13: Overloading and Templates

6: Enter a string with a length of at least 7: 123456789
9: The new value of str1 = 123456789
11: str3 = Birth Day, str4 = Birth Day
13: The new value of str3 = 123456789
16: After replacing the second character of str3 = 1t3456789
18: After replacing the third character of str3 = 1tW456789
20: After replacing the sixth character of str3 = 1tW45g789

The preceding program works as follows. The statement in Line 1 outputs the values
of str1, str2, and str3. Notice that the value of str3 is to be printed between
*** and ###. Because str3 is empty, nothing is printed between *** and ###; see
Line 1 in the sample run. The statements in Lines 2 through 5 compare str1 and
str2 and output the result. The statement in Line 7 inputs a string with a length of at
least 7 into str1, and the statement in Line 9 outputs the new value of str1. Note
that in the statement (see Line 10):
str4 = str3 = "Birth Day";

Because the associativity of the assignment operator is from right to left, first the
statement str3 = "Birth Day"; executes, and then the statement str4 = str3;
executes. The statement in Line 11 outputs the values of str3 and str4. The
statements in Lines 15, 17, and 19 use the array subscripting operator [] to individually manipulate the characters of str3. The meanings of the remaining statements
are straightforward.

Function Overloading
The previous section discussed operator overloading. Operator overloading provides the
programmer with the same concise notation for user-defined data types as the operator
has for built-in types. The types of parameters used with an operator determine the action
to take. Similar to operator overloading, C++ allows the programmer to overload a
function name. Chapter 6 introduced function overloading. For easy reference in the
following discussion, let us review this concept.
Recall that a class can have more than one constructor, but all constructors of a class have
the same name, which is the name of the class. This is an example of overloading a
function. Further recall that overloading a function refers to having several functions
with the same name but different parameter lists. The parameter list determines which
function will execute.
For function overloading to work, we must give the definition of each function. The
next section teaches you how to overload functions with a single code segment and leave
the job of generating code for separate functions for the compiler.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Templates |

967

Templates
Templates are a very powerful feature of C++. They allow you to write a single code
segment for a set of related functions, called a function template, and for a set of related
classes, called a class template. The syntax we use for templates is:
template <class Type>
declaration;

in which Type is the name of a data type, built-in or user-defined, and declaration is
either a function declaration or a class declaration. In C++, template is a reserved word.
The word class in the heading refers to any user-defined type or built-in type. Type is
referred to as a formal parameter to the template. (Note that in the first line, template
<class Type>, the keyword class can be replaced with the keyword typename.)
Similar to variables being parameters to functions, types (that is, data types) are parameters
to templates.

Function Templates
In Chapter 6, when we introduced function overloading, the function larger was
overloaded to find the larger of two integers, characters, floating-point numbers, or
strings. To implement the function larger, we need to write four function definitions
for the data type: one for int, one for char, one for double, and one for string.
However, the body of each function is similar. C++ simplifies the process of overloading
functions in cases such as this by providing function templates.
The syntax of the function template is:
template <class Type>
function definition;

in which Type is referred to as a formal parameter of the template. It is used to specify the
type of parameters to the function and the return type of the function and to declare
variables within the function.
The statements:
template <class Type>
Type larger(Type x, Type y)
{
if (x >= y)
return x;
else
return y;
}

define a function template larger, which returns the larger of two items. In the function
heading, the type of the formal parameters x and y is Type, which will be specified by the
type of the actual parameters when the function is called. The statement:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

968 |

Chapter 13: Overloading and Templates

cout << larger(5, 6) << endl;

is a call to the function template larger. Because 5 and 6 are of type int, the data type
int is substituted for Type, and the compiler generates the appropriate code.
Note that the function template larger will work only for those data types for which
the operator >= has been defined.
If we omit the body of the function in the function template definition, the function
template, as usual, is the prototype.
The following example illustrates the use of function templates.
EXAMPLE 13-9
The following program uses the function template larger to determine the larger of the
two items.
// Template larger
#include <iostream>
#include "myString.h"
using namespace std;
template <class Type>
Type larger(Type x, Type y);
int main()
{
cout <<
<<
cout <<
<<
cout <<
<<

"Line 1: Larger of 5 and 6 = "
larger(5, 6) << endl;
"Line 2: Larger of A and B = "
larger('A', 'B') << endl;
"Line 3: Larger of 5.6 and 3.2 = "
larger(5.6, 3.2) << endl;

newString str1 = "Hello";
newString str2 = "Happy";

//Line 1
//Line 2
//Line 3
//Line 4
//Line 5

cout << "Line 6: Larger of " << str1 << " and "
<< str2 << " = " << larger(str1, str2)
<< endl;
//Line 6
return 0;
}
template <class Type>
Type larger(Type x, Type y)
{
if (x >= y)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Templates |

969

return x;
else
return y;
}

Sample Run:
Line
Line
Line
Line

1:
2:
3:
6:

Larger
Larger
Larger
Larger

of
of
of
of

5 and 6 = 6
A and B = B
5.6 and 3.2 = 5.6
Hello and Happy = Hello

Class Templates
Like function templates, class templates are used to write a single code segment for a set of
related classes. For example, in Chapter 10, we defined a list as an ADT; our list element
type was int. If the list element type changes from int to, say, char, double, or
string, we need to write separate classes for each element type. For the most part, the
operations on the list and the algorithms to implement those operations remain the same.
Using class templates, we can create a generic class listType, and the compiler can
generate the appropriate source code for a specific implementation.
The syntax we use for a class template is:
template <class Type>
class declaration

Class templates are called parameterized types because, based on the parameter type, a
specific class is generated.
The following statements define listType to be a class template:
template <class elemType>
class listType
{
public:
bool isEmpty() const;
//Function to determine whether the list is empty.
//Postcondition: Returns true if the list is empty,
//
otherwise it returns false.
bool isFull() const;
//Function to determine whether the list is full.
//Postcondition: Returns true if the list is full,
//
otherwise it returns false.
bool search(const elemType& searchItem) const;
//Function to search the list for searchItem.
//Postcondition: Returns true if searchItem
//
is found in the list, and
//
false otherwise.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

970 |

Chapter 13: Overloading and Templates

void insert(const elemType& newElement);
//Function to insert newElement in the list.
//Precondition: Prior to insertion, the list must
//
not be full.
//Postcondition: The list is the old list plus
//
newElement.
void remove(const elemType& removeElement);
//Function to remove removeElement from the list.
//Postcondition: If removeElement is found in the list,
//
it is deleted from the list, and the
//
list is the old list minus removeElement.
//
If the list is empty, output the message
//
"Cannot delete from the empty list."
void destroyList();
//Function to destroy the list.
//Postcondition: length = 0;
void printList();
//Function to output the elements of the list.
listType();
//Default constructor
//Sets the length of the list to 0.
//Postcondition: length = 0;
protected:
elemType list[100];
int length;

//array to hold the list elements
//variable to store the number of
//elements in the list

};

This definition of the class template listType is a generic definition and includes
only the basic operations on a list. To derive a specific list from this list and to add or
rewrite the operations, we declare the array containing the list elements and the length of
the list as protected.
Next, we describe a specific list. Suppose that you want to create a list to process integer
data. The statement:
listType<int> intList;

//Line 1

declares intList to be an object of listType. The protected member list is an array
of 100 components, with each component being of type int. Similarly, the statement:
listType<newString> stringList;

//Line 2

declares stringList to be an object of listType. The protected member list is
an array of 100 components, with each component being of type newString.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Templates |

971

In the statements in Lines 1 and 2, listType<int> and listType<newString> are
referred to as template instantiations or instantiations of the class template listType<elemType>,
in which elemType is the class parameter in the template header. A template instantiation
can be created with either a built-in or user-defined type.
The function members of a class template are considered function templates. Thus, when
giving the definitions of the function members of a class template, we must follow the
definition of the function template. For example, the definition of the member insert
of the class listType is:
template <class elemType>
void listType<elemType>::insert(elemType newElement)
{
.
.
.
}

In the heading of the member function’s definition, the name of the class is specified with
the parameter elemType.
The statement in Line 1 declares intList to be a list of 100 components. When the
compiler generates the code for intList, it replaces the word elemType with int in
the definition of the class listType. The template parameter in the definitions of the
member functions (for example, elemType in the definition of insert) of the class
listType is also replaced by int.
HEADER FILE AND IMPLEMENTATION FILE OF A CLASS TEMPLATE
Until now, we have placed the definition of the class (in the header file) and the definitions
of the member functions (in the implementation file) in separate files. The object code was
generated from the implementation file and linked with the user code. However, this
mechanism of separating the class definition and the definitions of the member functions
does not work with class templates. Passing parameters to a function has an effect at run
time, whereas passing a parameter to a class template has an effect at compile time. Because
the actual parameter to a class is specified in the user code and because the compiler cannot
instantiate a function template without the actual parameter to the template, we can no
longer compile the implementation file independently of the user code.

This problem has several possible solutions. We could put the class definition and the
definitions of the function templates directly in the client code, or we could put the class
definition and the definitions of the function templates together in the same header file.
Another alternative is to put the class definition and the definitions of the functions in
separate files (as usual) but include a directive to the implementation file at the end of the
header file. In either case, the function definitions and the client code are compiled
together. For illustrative purposes, we will put the class definition and the function
definitions in the same header file.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

972 |

Chapter 13: Overloading and Templates

Array-Based Lists (Revisited)
In Chapter 12, we designed the classes arrayListType, unorderedArrayListType,
and orderedArrayListType to process lists in an array. However, these classes, as
designed in Chapter 12, process only those lists whose elements are of type int. Now that
we have discussed how to use class templates to create a generic code, in this section, we
redesign these classes so that they can be used to process any type of list. Moreover, in this
chapter, we discussed how to overload the assignment operator. Therefore, in addition to the
operations discussed in Chapter 12, we also overload the assignment operator for the class
arrayListType because it has a pointer member variable.
The following class template defines the abstract class arrayListType as an ADT.
(To save space, we only list the functions. The documentation of these functions is similar
to ones given in Chapter 12. The source code file at the Web site accompanying this
book contains the documentation of these functions.)
template <class elemType>
class arrayListType
{
public:
const arrayListType<elemType>&
operator=(const arrayListType<elemType>&);
//Overloads the assignment operator
bool isEmpty() const;
bool isFull() const;
int listSize() const;
int maxListSize() const;
void print() const;
bool isItemAtEqual(int location, const elemType& item) const;
virtual void insertAt(int location, const elemType& insertItem) = 0;
virtual void insertEnd(const elemType& insertItem) = 0;
void removeAt(int location);
void retrieveAt(int location, elemType& retItem) const;
virtual void replaceAt(int location, const elemType& repItem) = 0;
void clearList();
virtual int seqSearch(const elemType& searchItem) const = 0;
virtual void remove(const elemType& removeItem) = 0;
arrayListType(int size = 100);
arrayListType (const arrayListType<elemType>& otherList);
virtual ~arrayListType();
protected:
elemType *list; //array to hold the list elements
int length;
//variable to store the length of the list
int maxSize;
//variable to store the maximum
//size of the list
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Templates |

973

The definitions of the functions to implement the operations of the class arrayListType are
similar to the ones given in Chapter 12. Here the functions to implement these operations are
function templates. For example, the definitions of the functions print, isItemAtEqual,
removeAt, retrieveAt, the constructor, and the destructor are:
template <class elemType>
void arrayListType<elemType>::print() const
{
for (int i = 0; i < length; i++)
cout << list[i] << " ";
cout << endl;
}
template <class elemType>
bool arrayListType<elemType>::isItemAtEqual(int location,
const elemType& item) const
{
if (location < 0 || location >= length)
{
cout << "The location of the item to be removed "
<< "is out of range." << endl;
return false;
}
else
return (list[location] == item);
} //end isItemAtEqual
template <class elemType>
void arrayListType<elemType>::removeAt(int location)
{
if (location < 0 || location >= length)
cout << "The location of the item to be removed "
<< "is out of range." << endl;
else
{
for (int i = location; i < length - 1; i++)
list[i] = list[i + 1];
length--;
}
} //end removeAt
template <class elemType>
void arrayListType<elemType>::retrieveAt(int location,
elemType& retItem) const
{
if (location < 0 || location >= length)
cout << "The location of the item to be retrieved is "
<< "out of range" << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

974 |

Chapter 13: Overloading and Templates

else
retItem = list[location];
} //end retrieveAt
template <class elemType>
arrayListType<elemType>::arrayListType(int size)
{
if (size <= 0)
{
cout << "The array size must be positive. Creating "
<< "an array of the size 100. " << endl;
maxSize = 100;
}
else
maxSize = size;
length = 0;
list = new elemType[maxSize];
}
template <class elemType>
arrayListType<elemType>::~arrayListType()
{
delete [] list;
}

Next, because we are overloading the assignment for the class arrayListType, we
give the definition of the function template to overload the assignment operator.
template <class elemType>
const arrayListType<elemType>& arrayListType<elemType>::
operator=(const arrayListType<elemType>& otherList)
{
if (this != &otherList)
//avoid self-assignment
{
delete [] list;
maxSize = otherList.maxSize;
length = otherList.length;
list = new elemType[maxSize];
for (int i = 0; i < length; i++)
list[i] = otherList.list[i];
}
return *this;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Templates |

975

We leave it as an exercise for you to provide the definitions of the remaining function
templates for the class arrayListType. (See Programming Exercise 20 at the end of
this chapter.)
Recall that the class arrayListType is an abstract class. So its objects cannot be
instantiated. Next we describe the nonabstract class unorderedArrayListType
derived from the class arrayListType.
template <class elemType>
class unorderedArrayListType: public arrayListType <elemType>
{
public:
void insertAt(int location, const elemType& insertItem);
void insertEnd(const elemType& insertItem);
void replaceAt(int location, const elemType& repItem);
int seqSearch(const elemType& searchItem) const;
void remove(const elemType& removeItem);
unorderedArrayListType(int size = 100);
//Constructor
};

As in the case of the class arrayListType, the definitions of the member functions of
the class unorderedArrayListType is similar to ones given in Chapter 12. For
example, the definitions of the functions insertEnd, seqSearch, replaceAt, and
remove, and constructor are as follows:
template <class elemType>
void unorderedArrayListType<elemType>::insertEnd
(const elemType& insertItem)
{
if (length >= maxSize) //the list is full
cout << "Cannot insert in a full list." << endl;
else
{
list[length] = insertItem; //insert the item at the end
length++; //increment the length
}
} //end insertEnd
template <class elemType>
int unorderedArrayListType<elemType>::seqSearch
(const elemType& searchItem) const
{
int loc;
bool found = false;
for (loc = 0; loc < length; loc++)
if (list[loc] == searchItem)
{
found = true;
break;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

976 |

Chapter 13: Overloading and Templates

if (found)
return loc;
else
return -1;
} //end seqSearch
template <class elemType>
void unorderedArrayListType<elemType>::remove
(const elemType& removeItem)
{
int loc;
if (length == 0)
cout << "Cannot delete from an empty list." << endl;
else
{
loc = seqSearch(removeItem);
if (loc != -1)
removeAt(loc);
else
cout << "The item to be deleted is not in the list."
<< endl;
}
} //end remove
template <class elemType>
void unorderedArrayListType<elemType>::replaceAt(int location,
const elemType& repItem)
{
if (location < 0 || location >= length)
cout << "The location of the item to be "
<< "replaced is out of range." << endl;
else
list[location] = repItem;
} //end replaceAt
template <class elemType>
unorderedArrayListType<elemType>::
unorderedArrayListType(int size)
: arrayListType<elemType>(size)
{
}

We leave it as an exercise for you to provide the definitions of the remaining function
templates for the class unorderedArrayListType. (See Programming Exercise 20 at
the end of this chapter.)
The following example illustrates how to use the class unorderedArrayListType
to process a list of strings.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Templates |

977

EXAMPLE 13-10
The following program tests the various operations on an array-based list.
#include <iostream>
#include <string>
#include "unorderedArrayListType.h"
using namespace std;
int main()
{
unorderedArrayListType<string> stringList(25);

//Line 1

string str;

//Line 2

cout << "List 3: Enter 5 strings: ";

//Line 3

for (int count = 0; count < 5; count++)
{
cin >> str;
stringList.insertEnd(str);
}

//Line 4

cout << endl;
cout << "Line 8: stringList: ";
stringList.print();
cout << endl;

//Line
//Line
//Line
//Line

cout << "Line 11: Enter the string to be "
<< "deleted: ";
cin >> str;
cout << endl;

//Line 11
//Line 12
//Line 13

//Line 5
//Line 6
7
8
9
10

stringList.remove(str);
cout << "Line 15: After removing " << str
<< " stringList: ";
stringList.print();
cout << endl;

//Line 14

cout << "Line 18: Enter the search item: ";

//Line 18

cin >> str;
cout << endl;

//Line 19
//Line 20

if (stringList.seqSearch(str) != -1)
cout << "Line 22: " << str
<< " found in stringList." << endl;
else
cout << "Line 24: " << str
<< " is not in stringList." << endl;

//Line 21

//Line 15
//Line 16
//Line 17

//Line 22
//Line 23
//Line 24

return 0;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

978 |

Chapter 13: Overloading and Templates

Sample Run: In this sample run, the user input is shaded.
List 3: Enter 5 strings: hello sunny warm winter summer
Line 8: stringList: hello sunny warm winter summer
Line 11: Enter the string to be deleted: hello
Line 15: After removing hello stringList: sunny warm winter summer
Line 18: Enter the search item: winter
Line 22: winter found in stringList.

The preceding program works as follows. The statement in Line 1 declares stringList
to be an object of the type unorderedArrayListType. The member variable list of
stringList is an array of 25 components and the component type is string. The
statement in Line 2 declares the string variable str. The statement in Line 3 prompts
the user to enter 5 strings. The statement in Line 5 gets the next string from the input
stream. The statement in Line 6 uses the member function insertEnd of stringList
to store the string into stringList. The statement in Line 9 uses the member function
print of stringList to output the elements of stringList. The statement in Line 11
prompts the user to enter the string to be deleted from stringList, and the statement
in Line 12 gets the string to be deleted from the input stream. The statement in Line 14
uses the member function remove of stringList to remove the string from stringList. The statement in Line 16 outputs the modified stringList.
The statements in Lines 18 through 24 tests the function seqSearch.
The Web site accompanying this book contains additional programs illustrating how to
use the class template unorderedArrayListType to create lists of double
elements and clockType objects.

Just as we can derive the class template unorderedArrayListType, from the
abstact class template arrayListType, to manipulate unordered lists, we can also
derive the class template orderedArrayListType to manipulate ordered lists.
(See Programming Exercise 21 at the end of this chapter.)

QUICK REVIEW
1.
2.

3.
4.

An operator that has different meanings with different data types is said to
be overloaded.
In C++, >> is used as a stream extraction operator and as a right shift
operator. Similarly, << is used as a stream insertion operator and as a left
shift operator. Both are examples of operator overloading.
Any function that overloads an operator is called an operator function.
The syntax of the heading of the operator function is:
returnType operator operatorSymbol(parameters)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

5.
6.
7.

8.
9.
10.

11.
12.
13.
14.
15.
16.
17.
18.
19.

20.
21.

22.

23.

979

In C++, operator is a reserved word.
Operator functions are value-returning functions.
Except for the assignment operator and the member selection operator, to
use an operator on class objects, that operator must be overloaded. The
assignment operator performs a default member-wise copy.
For classes with pointer member variables, the assignment operator must be
explicitly overloaded.
Operator overloading provides the same concise notation for user-defined
data types as is available for built-in data types.
When an operator is overloaded, its precedence cannot be changed, its
associativity cannot be changed, default parameters cannot be used, the
number of parameters that the operator takes cannot be changed, and
the way in which an operator works with built-in data types remains the same.
It is not possible to create new operators. Only existing operators can be
overloaded.
Most C++ operators can be overloaded.
The operators that cannot be overloaded are ., .*, ::, ?:, and sizeof.
The pointer this refers to the object as a whole.
The operator functions that overload the operators (), [], ->, or = for a
class must be members of that class.
A friend function is a nonmember of a class.
The heading of the prototype of a friend function is preceded by the
word friend.
In C++, friend is a reserved word.
If an operator function is a member of a class, the far left operand of the
operator must be a class object (or a reference to a class object) of that
operator’s class.
The binary operator function as a member of a class has only one parameter; as a nonmember of a class, it has two parameters.
The operator functions that overload the stream insertion operator, <<, and
the stream extraction operator, >>, for a class must be friend functions of
that class.
To overload the pre-increment (++) operator for a class if the operator
function is a member of that class, it must have no parameters. Similarly, to
overload the pre-decrement (--) operator for a class if the operator function is a member of that class, it must have no parameters.
To overload the post-increment (++) operator for a class if the operator function is a member of that class, it must have one parameter,
of type int. The user does not specify any value for the parameter.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

980 |

24.
25.
26.
27.
28.
29.
30.
31.

Chapter 13: Overloading and Templates

The dummy parameter in the function heading helps the compiler
generate the correct code. The post-decrement operator has similar
conventions.
A conversion constructor is a single-parameter function.
A conversion constructor converts its argument to an object of the constructor’s class. The compiler implicitly calls such constructors.
Classes with pointer member variables must overload the assignment operator and include both the copy constructor and the destructor.
In C++, a function name can be overloaded.
In C++, template is a reserved word.
Using templates, you can write a single code segment for a set of related
functions—called the function template.
Using templates, you can write a single code segment for a set of related
classes—called the class template.
The syntax of a template is:
template <class Type>
declaration;

32.
33.
34.
35.

in which Type is a user-defined identifier, which is used to pass types (that
is, data types) as parameters, and declaration is either a function or a
class. The word class in the heading refers to any user-defined data type
or built-in data type.
Class templates are called parameterized types.
In a class template, the parameter Type specifies how a generic class
template is to be customized to form a specific template class.
The parameter Type is mentioned in every class header and member
function definition.
Suppose cType is a class template, and func is a member function of
cType. The heading of the function definition of func is:
template <class Type>
funcType cType<Type>::func(parameters)

36.

in which funcType is the type of the function, such as void.
Suppose cType is a class template, which can take int as a parameter. The
statement:
cType<int> x;

declares x to be an object of type cType, and the type passed to the class
cType is int.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

981

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
The function that overloads an operator is called the operator function. (1)
b.
In C++, all operators can be overloaded for user-defined data types. (2)
c.
In C++, operators cannot be redefined for built-in types. (2)
d.
C++ allows users to create their own operators. (2)
e.
The precedence of an operator cannot be changed, but its associativity
can be changed. (2)
f.
A friend function of a class is a nonmember function of the class, so it
cannot access the members of the class. (4)
g. When writing the definition of a friend function, the keyword
friend must appear in the function heading. (4)
h. In C++, all operators can be overloaded as member functions of a class. (5)
i.
Every instance of an overloaded function has the same number of
parameters. (1, 2, 5, 6)
j.
It is not necessary to overload relational operators for classes that have
only int member variables. (1, 5, 6)
k. The function heading of the operator function to overload the preincrement operator (++) and the post-increment operator (++) is the
same because both operators have the same symbols. (6)
l.
Templates provide the capability for software reuse. (8)
m. The member function of a class template is a function template. (9)
What are the two things that you need to overload an operator for a
class? (1, 2)
Name the operators that cannot be overloaded. (2)
Within the definition of an operator function, how do you refer to the
object as a whole? (3)
What is the difference between the two statements return this; and
return *this;? (3)
What is a friend function? (3)
What is the difference between a friend function of a class and a member
function of a class? (3)
a.

2.

3.
4.

5.

6.
7.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

982 |

8.

Chapter 13: Overloading and Templates

Consider the definition of the class dateType given in Chapter 11. (3)
Write the statement that includes a friend function named before in
the class dateType that takes as parameters two objects of type
dateType and returns true if the date represented by the first object
comes before the date represented by the second object; otherwise, the
function returns false.
b. Write the definition of the function you defined in part a.
Suppose that the operator << is to be overloaded for a user-defined class
mystery. Why must << be overloaded as a friend function? (3)
Suppose that the binary operator + is overloaded as a member function for a
class strange. How many parameters does the function operator+
have? (5, 6)
Which operators must be overloaded as members of a class? (5)
Consider the following declaration: (6)
a.

9.

10.

11.
12.

class strange
{
.
.
.
};

Write a statement that shows the declaration in the class strange to
overload the operator >>.
b. Write a statement that shows the declaration in the class strange to
overload the operator =.
c. Write a statement that shows the declaration in the class strange to
overload the binary operator + as a member function.
d. Write a statement that shows the declaration in the class strange to
overload the operator == as a member function.
e. Write a statement that shows the declaration in the class strange to
overload the post-increment operator ++ as a member function.
Assume the declaration of Exercise 12. (6)
a.

13.

a.

b.

c.

Write a statement that shows the declaration in the class strange to
overload the binary operator + as a friend function.
Write a statement that shows the declaration in the class strange to
overload the operator == as a friend function.
Write a statement that shows the declaration in the class strange to
overload the post-increment operator ++ as a friend function.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

14.

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

1
2
3
4
5
6
7
8
9
10

Find the error(s) in the following code: (6)
class temp
{
public:
int operator*(const temp& obj);
//Returns the object containing the
//product of the corresponding members
//of this object and obj.
temp();
temp(int, int);
private:
int a;
int b;
};

16.

17.

983

Find the error(s) in the following code: (6)
class secret
{
public:
secret operator>=(secret);
secret();
secret(int, int);
private:
int a;
int b;
};

15.

|

//Line
//Line
//Line
//Line

1
2
3
4

//Line
//Line
//Line
//Line
//Line
//Line

5
6
7
8
9
10

Find the error(s) in the following code: (6)
class discover
{
public:
discover operator+(const discover& a,
const discover& b);
//Returns the object containing the
//sum of the corresponding members
//of the objects a and b.

//Line 1
//Line 2
//Line 3

discover();
discover(int, int);
private:
int first;
int second;
};

//Line
//Line
//Line
//Line
//Line
//Line

//Line 4

5
6
7
8
9
10

Find the error(s) in the following code: (6)
class mystery
{
friend mystery operator<(const mystery& a,
const mystery& b);
//Return true if object a is less than
//object b; otherwise it returns false
.
.
.

//Line 1
//Line 2
//Line 3

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

984 |

Chapter 13: Overloading and Templates

private:
double r;
};
18.

//Line 4
//Line 5
//Line 6

Find the error(s) in the following code: (6)
class mystery
{
friend mystery operator+(const mystery& a,
const mystery& b) const;
//Return true if object a is less than
//object b; otherwise it returns false
.
.
.
private:
double r;
};

19.

double discover::operator+(const discover& a,
const discover& b)
{
discover temp;
temp.first = a.first + b.first;
temp.second = a.second + b.second;
return temp;
}

21.
22.
23.

24.

//Line 3

//Line 4
//Line 5
//Line 6

Find the error(s) in the following code: (6)
class discover
{
friend double operator+(const discover&,
const discover&);
public:
discover();
discover(double, double);
private:
double first;
double second;
};

20.

//Line 1
//Line 2

//Line 1
//Line 2
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

3
4
5
6
7
8
9
10

//Line 11
//Line 12
//Line
//Line
//Line
//Line

13
14
15
16

In a class, why do you include the function that overloads the stream
insertion operator, <<, as a friend function? (5, 6)
b. In a class, why do you include the function that overloads the stream
extraction operator, >>, as a friend function? (5, 6)
What is returned by the function that overloads the operator >> for a class? (6)
What is returned by the function that overloads the operator << for a class? (6)
What is the purpose of a dummy parameter in a function that overloads the
post-increment or post-decrement operator for a class? (6)
What type of value should be returned by a function that overloads a
relational operator? (6)
a.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

25.
26.
27.
28.

29.

30.
31.

32.

33.

34.

|

985

How many parameters are required to overload the pre-increment operator
for a class as a member function? (6)
How many parameters are required to overload the pre-increment operator
for a class as a friend function? (6)
How many parameters are required to overload the post-increment operator for a class as a member function? (6)
How many parameters are required to overload the post-increment operator for a class as a friend function? (6)
Let a + ib be a complex number.
The conjugate of a + ib is a – ib, and the
pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ
absolute value of a + ib is a2 þ b2 . Extend the definition of the class
complexType of the Programming Example: Complex Numbers by overloading the operators ~ and ! as member functions so that ~ returns the
conjugate of a complex number and ! returns the absolute value. Also,
write the definitions of these operator functions. (6)
Redo Exercise 29 so that the operators ~ and ! are overloaded as nonmember functions. (6)
When should a class overload the assignment operator and define the copy
constructor? (7)
What are the three things that you must do for classes with pointer member
variables. (7)
Find the error(s) in the following code: (8, 9)
template <class type>
class strange
{
.
.
.
};

//Line 1
//Line 2

strange<int> s1;
strange<type> s2;

//Line 3
//Line 4

Consider the following declaration: (8, 9)
template <class type>
class strange
{
.
.
.
private:
type a;
type b;
};
a.

b.

Write a statement that declares sObj to be an object of type strange
such that the private member variables a and b are of type int.
Write a statement that shows the declaration in the class strange to
overload the operator == as a member function.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

986 |

Chapter 13: Overloading and Templates

Assume that two objects of type strange are equal if their corresponding member variables are equal. Write the definition of the function
operator== for the class strange, which is overloaded as a
member function.
Consider the definition of the following function template: (8, 9)
c.

35.

template <class Type>
Type surprise(Type x, Type y)
{
return x + y;
}

What is the output of the following statements?

36.

a.

cout << surprise(5, 7) << endl;

b.

string str1 = "Sunny";
string str2 = " Day";
cout << surprise(str1, str2) << endl;

Consider the definition of the following function template: (8, 9)
template <class type>
type funcExp(type list[], int size)
{
type x = list[0];
type y = list[size - 1];
for (int j = 1; j < size - 1; j++)
{
if (x < list[j])
x = list[j];
if (y > list[size - 1 - j])
y = list[size - 1 - j];
}
return y + x;
}

Further suppose that you have the following declarations:
double sales[7] = {280.50, 320.00, 56.00, 78.90, 300.00,
100.00, 250.00};
string names[] = {"Mike", "Lisa", "Nancy", "Robinson",
"Miller", "Sam"};

What is the output of the following statements?

37.

a.

cout << funcExp(sales, 7) << endl;

b.

cout << funcExp(names, 6) << endl;

Write the definition of the function template that swaps the contents of two
variables. (8, 9)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

38.

a.

|

987

Overload the operator + for the class newString to perform string
concatenation. For example, if s1 is "Hello " and s2 is "there", the
statement:
s3 = s1 + s2;

b.

should assign "Hello there" to s3, in which s1, s2, and s3 are
newString objects. (6)
Overload the operator += for the class newString to perform the
following string concatenation. Suppose that s1 is "Hello " and s2 is
"there". Then, the statement:
s1 += s2;

should assign "Hello there" to s1, in which s1 and s2 are
newString objects. (6)

PROGRAMMING EXERCISES
1.

This chapter uses the class rectangleType to illustate how to overload the
operators +, *, ==, !=, >>, and <<. In this exercise, first redefine the class
rectangleType by declaring the instance variables as protected and then
overload additional operators as defined in parts a to c.
a.

b.

c.

d.

e.

2.

a.

b.

Overload the pre- and post-increment and decrement operators to
increment and decrement, respectively, the length and width of a
rectangle by one unit. (Note that after decrementing the length and
width, they must be postive.)
Overload the binary operator - to subtract the dimensions of one
rectangle from the corresponding dimensions of another rectangle. If
the resulting dimensions are not positive, output an appropriate message
and do not perform the operation.
The operators == and != are overloaded by considering the lengths and
widths of rectangles. Redefine the functions to overload the relational
operator by considering the areas of rectangles as follows: Two rectangles are the same, if they have the same area; otherwise, the rectangles
are not the same. Similary, rectangle yard1 is greater than rectangle
yard2 if the area of yard1 is greater than the area of yard2. Overload
the remaining relational operators using similar definitions.
Write the definitions of the functions to overload the operators defined
in parts a to c.
Write a test program that tests various operations on the
class rectangleType.
Redo Programming Exercise 1 by overloading the operators as
nonmembers of the class rectangleType.
Write a test program that tests various operations on the
class rectangleType.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

988 |

Chapter 13: Overloading and Templates

3.

Chapter 11 defined the class boxType by extending the definition of
the class rectangleType. In this exercise, derive the
class boxType from the class rectangleType, defined in Exercise
1, add the functions to overload the operators +, -, *, ==, !=, <=, <,
>=, >, and pre- and post-increment and decrement operators as members of the class boxType. Also overload the operators << and >>.
Overload the relational operators by considering the volume of the boxes.
For example, two boxes are the same if they have the same volume.
Write the definitions of the functions of the class boxType as defined
in part a.
Write a test program that tests various operations on the
class rectangleType.
Redo Programming Exercise 3 by overloading the operators as
nonmembers of the class boxType.
Write a test program that tests various operations on the class
boxType.
Extend the definition of the class clockType by overloading
the post-increment operator function as a member of the class
clockType.
Write the definition of the function to overload the post-increment
operator for the class clockType as defined in part a.
The increment and relational operators in the class clockType are
overloaded as member functions. Rewrite the definition of the class
clockType so that these operators are overloaded as nonmember functions. Also, overload the post-increment operator for the class
clockType as a nonmember.
Write the definitions of the member functions of the class clockType
as designed in part a.
Write a test program that tests various operations on the class as designed
in parts a and b.
Extend the definition of the class complexType so that it performs
the subtraction and division operations. Overload the operators subtraction and division for this class as member functions.
If (a, b) and (c, d ) are complex numbers:
(a, b) - (c, d ) = (a - c, b - d ).
If (c, d ) is nonzero:
(a, b) / (c, d) = ((ac + bd ) / (c2 + d 2), (-ad + bc) / (c2 + d 2)).
Write the definitions of the functions to overload the operators - and / as
defined in part a.
Write a test program that tests various operations on the class
complexType. Format your answer with two decimal places.

a.

b.

c.

4.

a.

b.

5.

a.

b.

6.

a.

b.

c.

7.

a.

b.

c.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

8.

a.

b.

c.

9.

a.

|

989

Rewrite the definition of the class complexType so that the arithmetic and relational operators are overloaded as nonmember functions.
Write the definitions of the member functions of the class complexType
as designed in part a.
Write a test program that tests various operations on the class
complexType as designed in parts a and b. Format your answer with
two decimal places.
Extend the definition of the class newString as follows:

Overload the operators + and += to perform the string concatenation operations.
ii.
Add the function length to return the length of the string.
b. Write the definition of the function to implement the operations
defined in part a.
c. Write a test program to test various operations on the newString objects.
Rational fractions are of the form a / b, in which a and b are integers and
b 6¼ 0. In this exercise, by ‘‘fractions’’ we mean rational fractions. Suppose
a / b and c / d are fractions. Arithmetic operations on fractions are
defined by the following rules:
i.

10.

a=b þ c=d ¼ ðad þ bcÞ=bd
a=b  c=d ¼ ðad  bcÞ=bd
a=b  c=d ¼ ac=bd
ða=bÞ=ðc=dÞ ¼ ad=bc; in which c=d 6¼ 0:
Fractions are compared as follows: a / b op c / d if ad op bc, in which op is
any of the relational operations. For example, a / b < c / d if ad < bc.
Design a class—say, fractionType—that performs the arithmetic and
relational operations on fractions. Overload the arithmetic and relational
operators so that the appropriate symbols can be used to perform the
operation. Also, overload the stream insertion and stream extraction
operators for easy input and output.
Write a C++ program that, using the class fractionType, performs
operations on fractions.
Among other things, test the following: Suppose x, y, and z are objects
of type fractionType. If the input is 2/3, the statement:
cin >> x;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

990 |

Chapter 13: Overloading and Templates

should store 2/3 in x. The statement:
cout << x + y << endl;

should output the value of x + y in fraction form. The statement:
z = x + y;

11.

should store the sum of x and y in z in fraction form. Your answer need
not be in the lowest terms.
Recall that in C++, there is no check on an array index out of bounds.
However, during program execution, an array index out of bounds can
cause serious problems. Also, in C++, the array index starts at 0.
Design and implement the class myArray that solves the array index out
of bounds problem and also allows the user to begin the array index starting
at any integer, positive or negative. Every object of type myArray is an
array of type int. During execution, when accessing an array component,
if the index is out of bounds, the program must terminate with an appropriate error message. Consider the following statements:
myArray<int> list(5);
myArray<int> myList(2, 13);
myArray<int> yourList(-5, 9);

12.

13.

//Line 1
//Line 2
//Line 3

The statement in Line 1 declares list to be an array of 5 components, the
component type is int, and the components are: list[0], list[1], ...,
list[4]; the statement in Line 2 declares myList to be an array of 11 components, the component type is int, and the components are: myList[2],
myList[3], ..., myList[12]; the statement in Line 3 declares yourList
to be an array of 14 components, the component type is int, and the
components are: yourList[-5], yourList[-4], ..., yourList[0],
..., yourList[8]. Write a program to test the class myArray.
Programming Exercise 11 processes only int arrays. Redesign the class
myArray using class templates so that the class can be used in any
application that requires arrays to process data.
Design a class to perform various matrix operations. A matrix is a set of
numbers arranged in rows and columns. Therefore, every element of a
matrix has a row position and a column position. If A is a matrix of five
rows and six columns, we say that the matrix A is of the size 5  6 and
sometimes denote it as A56. Clearly, a convenient place to store a matrix is
in a two-dimensional array. Two matrices can be added and subtracted if
they have the same size. Suppose A = [aij] and B = [bij] are two matrices of

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

991

the size m  n, in which aij denotes the element of A in the ith row and the
jth column, and so on. The sum and difference of A and B are given by:
A þ B ¼ ½aij þ bij 
A  B ¼ ½aij  bij 
The multiplication of A and B (A * B) is defined only if the number
of columns of A is the same as the number of rows of B. If A is of the size
m  n and B is of the size n  t, then A *B = [cik] is of the size m  t and
the element cik is given by the formula:
cik ¼ ai1 b1k þ ai2 b2k þ    þ ain bnk

14.

Design and implement a class matrixType that can store a matrix of any size.
Overload the operators +, -, and * to perform the addition, subtraction, and
multiplication operations, respectively, and overload the operator << to output a
matrix. Also, write a test program to test various operations on the matrices.
a. In Programming Exercise 4 in Chapter 10, we defined a class
romanType to implement Roman numbers in a program. In that
exercise, we also implemented a function, romanToPositiveInteger,
to convert a Roman number into its equivalent positive integer.
Modify the definition of the class romanType so that the member
variables are declared as protected. Use the class newString, as
designed in Programming Exercise 9, to manipulate strings. Furthermore,
overload the stream insertion and stream extraction operators for easy
input and output. The stream insertion operator outputs the Roman
number in the Roman format.
Also, include a member function, positiveIntegerToRoman, that
converts a positive integer to an equivalent Roman number format. Write
the definition of the member function positiveIntegerToRoman.

b.

For simplicity, we assume that only the letter I can appear in front of
another letter and that it appears only in front of the letters V and X. For
example, 4 is represented as IV, 9 is represented as IX, 39 is represented as
XXXIX, and 49 is represented as XXXXIX. Also, 40 will be represented as
XXXX, 190 will be represented as CLXXXX, and so on.
Derive a class extRomanType from the class romanType to do
the following: In the class extRomanType, overload the arithmetic
operators +, -, *, and / so that arithmetic operations can be performed on
Roman numbers. Also, overload the pre- and post-increment and decrement operators as member functions of the class extRomanType.
To add (subtract, multiply, or divide) Roman numbers, add (subtract,
multiply, or divide, respectively) their positive integer representations and

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

992 |

15.

16.

then convert the result to the Roman number format. For subtraction, if
the first number is smaller than the second number, output a message
saying that, ‘‘Because the first number is smaller than the
second, the numbers cannot be subtracted’’. Similarly, for division, the numerator must be larger than the denominator. Use similar
conventions for the increment and decrement operators.
c.
Write the definitions of the functions to overload the operators
described in part b.
d.
Write a program to test your class.
Consider the class dateType given in Chapter 11. In this class, add the
functions to overload the increment and decrement operators to increase
the date by a day and decrease the date by a day, respectively; relational
operators to compare two dates; and stream operators for easy input and
output. (Assume that the date is input and output in the form MM-DD-YYYY.)
Also write a program to test your class.
Programming Exercise 16, Chapter 10, describes how to design the class
lineType to implement a line. Redo this programming exercise so that
the class lineType:
a.
b.

c.
d.

e.

f.

g.

h.

17.

Chapter 13: Overloading and Templates

Overloads the stream insertion operator, <<, for easy output.
Overloads the stream extraction operator, >>, for easy intput. (The line
ax + by ¼ c is input as (a, b, c).)
Overloads the assignment operator to copy a line into another line.
Overloads the unary operator +, as a member function, so that it returns
true if a line is vertical; false otherwise.
Overloads the unary operator -, as a member function, so that it returns
true if a line is horizontal; false otherwise.
Overloads the operator ==, as a member function, so that it returns
true if two lines are equal; false otherwise.
Overloads the operator ||, as a member function, so that it returns
true if two lines are parallel; false otherwise.
Overloads the operator &&, as a member function, so that it returns
true if two lines are perpendicular; false otherwise.

Write a program to test your class.
Consider the classes class cashRegister and dispenserType given in
the Programming Example ‘‘Juice Machine’’ in Chapter 10.
a.

In the class class cashRegister, add the functions to overload the
binary operators + and – to add and subtract an amount in a cash
register; the relational operators to compare the amount in two cash
registers; and the stream insertion operator for easy output.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

993

The class dispenserType, in the Programming Example ‘‘Juice
Machine’’ in Chapter 10, is designed to implement a dispenser to hold
and release products. In this class, add the functions to overload the
increment and decrement operators to increment and decrement the
number of items by one, respectively, and the stream insertion operator
for easy output.
c. Write a program to test the classes designed in parts a and b.
(Stock Market) Write a program to help a local stock trading company
automate its systems. The company invests only in the stock market. At the
end of each trading day, the company would like to generate and post the
listing of its stocks so that investors can see how their holdings performed
that day. We assume that the company invests in, say, 10 different stocks.
The desired output is to produce two listings, one sorted by stock symbol
and another sorted by percent gain from highest to lowest.
b.

18.

The input data is provided in a file in the following format:
symbol openingPrice closingPrice todayHigh todayLow
prevClose volume

For example, the sample data is:
MSMT 112.50 115.75 116.50 111.75 113.50 6723823
CBA 67.50 75.50 78.75 67.50 65.75 378233
.
.
.

The first line indicates that the stock symbol is MSMT, today’s opening price was
112.50, the closing price was 115.75, today’s high price was 116.50, today’s low
price was 111.75, yesterday’s closing price was 113.50, and the number of shares
currently being held is 6723823.
The listing sorted by stock symbols must be of the following form:
********* First Investor's Heaven **********
*********
Financial Report
**********
Stock
Today
Previous Percent
Symbol Open
Close
High
Low
Close
Gain
------ ------------------------ ------ABC 123.45 130.95 132.00 125.00 120.50
8.67%
AOLK
80.00
75.00
82.00
74.00
83.00
-9.64%
CSCO 100.00 102.00 105.00
98.00 101.00
0.99%
IBD
68.00
71.00
72.00
67.00
75.00
-5.33%
MSET 120.00 140.00 145.00 140.00 115.00
21.74%
Closing Assets: $9628300.00
-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

Volume
-----10000
5000
25000
15000
30920

Develop this programming exercise in two steps. In the first step (part a), design and
implement a stock object. In the second step (part b), design and implement an
object to maintain a list of stocks.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

994 |

a.

Chapter 13: Overloading and Templates

(Stock Object) Design and implement the stock object. Call the class
that captures the various characteristics of a stock object stockType.
The main components of a stock are the stock symbol, stock price, and
number of shares. Moreover, we need to output the opening price,
closing price, high price, low price, previous price, and the percent
gain/loss for the day. These are also all the characteristics of a stock.
Therefore, the stock object should store all this information.
Perform the following operations on each stock object:
i.
ii.
iii.
iv.
v.

Set the stock information.
Print the stock information.
Show the different prices.
Calculate and print the percent gain/loss.
Show the number of shares.
a.1.

a.2.
a.3.

The natural ordering of the stock list is by stock symbol.
Overload the relational operators to compare two stock
objects by their symbols.
Overload the insertion operator, <<, for easy output.
Because the data is stored in a file, overload the stream
extraction operator, >>, for easy input.

For example, suppose infile is an ifstream object and the input file
was opened using the object infile. Further suppose that myStock is
a stock object. Then, the statement:
infile >> myStock;

b.

reads the data from the input file and stores it in the object myStock.
(Note that this statement reads and stores the data in the relevant
components of myStock.)
Now that you have designed and implemented the class stockType
to implement a stock object in a program, it is time to create a list of
stock objects.
Let us call the class to implement a list of stock objects stockListType.
The class stockListType must be derived from the class
listType, which you designed and implemented in the previous
exercise. However, the class stockListType is a very specific class,
designed to create a list of stock objects. Therefore, the class
stockListType is no longer a template.
Add and/or overwrite the operations of the class listType to
implement the necessary operations on a stock list.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

995

The following statement derives the class stockListType from the
class listType.
class stockListType: public listType<stockType>

{
member list
};
The member variables to hold the list elements, the length of the list,
and the max listSize were declared as protected in the class
listType. Therefore, these members can be directly accessed in the
class stockListType.
Because the company also requires you to produce the list ordered by
the percent gain/loss, you need to sort the stock list by this component.
However, you are not to physically sort the list by the component
percent gain/loss. Instead, you will provide a logical ordering with
respect to this component.

19.

20.

21.

22.

To do so, add a member variable, an array, to hold the indices of the
stock list ordered by the component percent gain/loss. Call this array
sortIndicesGainLoss. When printing the list ordered by the
component percent gain/loss, use the array sortIndicesGainLoss
to print the list. The elements of the array sortIndicesGainLoss
will tell which component of the stock list to print next.
c. Write a program that uses these two classes to automate the company’s
analysis of stock data.
Write the definitions of the member functions of the classes
arrayListType and unorderedArrayListType that are not given in
this chapter. Also, write a program to test your function.
Write the definition of the class template orderedArrayListType,
derived from the class arrayListType, to implement an ordered list. As
in Chapter 12, add the function insert to this class. Provide the definitions
of the nonabstract functions. Also, write a program to test your class.
(Unordered Sets) Redo Programming Exercise 12 of Chapter 12 using
templates.
(Ordered Sets) Redo Programming Exercise 13 of Chapter 12 using
templates.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
3

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

14
CHAPTER

ª HunThomas/Shutterstock

E XCEPTION H ANDLING
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn what an exception is

2.

Learn how to handle exceptions within a program

3.

Learn how a try/catch block is used to handle exceptions

4.

Learn how to throw an exception

5.

Become familiar with C++ exception classes and how to use them in a program

6.

Learn how to create your own exception classes

7.

Discover how to throw and rethrow an exception

8.

Explore exception-handling techniques

9.

Explore stack unwinding

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

998 |

Chapter 14: Exception Handling

An exception is an occurrence of an undesirable situation that can be detected during
program execution. For example, division by zero is an exception. Similarly, trying to open
an input file that does not exist is an exception, as is an array index that goes out of bounds.
Until now, we have dealt with certain exceptions by using either an if statement or
the assert function. For instance, in Examples 5-3 and 5-4, before dividing sum by
counter or count, we checked whether counter or count was nonzero. Similarly,
in the Programming Example newString (Chapter 13), we used the assert function to
determine whether the array index is within bounds.
On the other hand, there were places where we simply ignored the exception. For
instance, while determining a substring in a string (Chapter 7), we never checked
whether the starting position of the substring was within range. Also, we did not handle
the array index out-of-bounds exception. However, in all of these cases, if exceptions
occurred during program execution, either we included code to terminate the program
or the program terminated with an appropriate error message. For instance, if we opened
an input file in the function main and the input file did not exist, we terminated the
function main, so the program was terminated.
There are situations when an exception occurs, but you don’t want the program to
simply ignore the exception and terminate. For example, a program that monitors
stock performance should not automatically sell if the account balance goes below a
certain level. It should inform the stockholder and request an appropriate action.
Similarly, a program that monitors a patient’s heartbeat cannot be terminated if the
blood pressure goes very high. A program that monitors a satellite in space cannot be
terminated if there is a temporary power failure in some section of the satellite.
The code to handle exceptions depends on the type of application you develop. One
common way to provide exception-handling code is to add exception-handling code at
the point where an error can occur. This technique allows the programmer reading the
code to see the exception-handling code together with the actual code and to determine
whether the error-checking code is properly implemented. The disadvantage of this approach
is that the program can become cluttered with exception-handling code, which can make
understanding and maintaining the program difficult. This can distract the programmer from
ensuring that the program functions correctly.

Handling Exceptions within a Program
In Chapter 3, we noted that if you try to input invalid data into a variable, the input
stream enters the fail state, so an exception occurs. This occurs, for example, if you try
to input a letter into an int variable. Chapter 3 also showed how to clear and restore
the input stream. Chapter 4 introduced the assert function and explained how to use
it to avoid certain unforeseeable errors, such as division by zero. Even though the
function assert can check whether an expression meets the required condition(s), if
the conditions are not met, it terminates the program. As indicated in the previous
section, situations occur in which, if something goes wrong, the program should not be
simply terminated.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Handling Exceptions within a Program |

999

This section discusses how to handle exceptions. However, first we offer some examples
that show what can happen if an exception is not handled. We also review some of the
ways to handle exceptions.
The program in Example 14-1 shows what happens when division by zero occurs and the
problem is not addressed.
EXAMPLE 14-1
// Division by zero.
#include <iostream>
using namespace std;
int main()
{
int dividend, divisor, quotient;

//Line 1

cout << "Line 2: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 2
//Line 3
//Line 4

cout << "Line 5: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 5
//Line 6
//Line 7

quotient = dividend / divisor;
cout << "Line 9: Quotient = " << quotient
<< endl;

//Line 8

return 0;

//Line 10

//Line 9

}

Sample Run 1:
Line 2: Enter the dividend: 12
Line 5: Enter the divisor: 5
Line 9: Quotient = 2

Sample Run 2:
Line 2: Enter the dividend: 24
Line 5: Enter the divisor: 0
CPP_Proj1.exe has encountered a problem and needs to close. We are
sorry for the inconvenience.

In Sample Run 1, the value of divisor is nonzero, so no exception occurs. The program
calculates and outputs the quotient and terminates normally.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1000

| Chapter 14: Exception Handling

In Sample Run 2, the value entered for divisor is 0. The statement in Line 8 divides
dividend by the divisor. However, the program does not check whether divisor is
0 before dividing dividend by divisor. So the program crashes with the message
shown. Notice that the error message is platform independent, that is, IDE dependent.
Some IDEs might not give this error message and might simply hang.
Next, consider Example 14-2. This is the same program as in Example 14-1, except that
in Line 8, the program checks whether divisor is zero.
EXAMPLE 14-2
// Checking division by zero.
#include <iostream>
using namespace std;
int main()
{
int dividend, divisor, quotient;

//Line 1

cout << "Line 2: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 2
//Line 3
//Line 4

cout << "Line 5: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 5
//Line 6
//Line 7

if (divisor != 0)
{
quotient = dividend / divisor;
cout << "Line 10: Quotient = " << quotient
<< endl;
}
else
cout << "Line 12: Cannot divide by zero."
<< endl;

//Line 8

return 0;

//Line 9
//Line 10
//Line 11
//Line 12
//Line 13

}

Sample Run 1:
Line 2: Enter the dividend: 12
Line 5: Enter the divisor: 5
Line 10: Quotient = 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Handling Exceptions within a Program

|

1001

Sample Run 2:
Line 2: Enter the dividend: 24
Line 5: Enter the divisor: 0
Line 12: Cannot divide by zero.

In Sample Run 1, the value of divisor is nonzero, so no exception occurs. The program
calculates and outputs the quotient and terminates normally.
In Sample Run 2, the value entered for divisor is 0. In Line 8, the program checks
whether divisor is 0. Because divisor is 0, the expression in the if statement fails, so
the else part executes, which outputs the third line of the sample run.
The program in Example 14-3 uses the function assert to determine whether the divisor is
zero. If the divisor is zero, the function assert terminates the program with an error message.
EXAMPLE 14-3
// Division by zero and the assert function.
#include <iostream>
#include <cassert>
using namespace std;
int main()
{
int dividend, divisor, quotient;

//Line 1

cout << "Line 2: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 2
//Line 3
//Line 4

cout << "Line 5: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 5
//Line 6
//Line 7

assert(divisor != 0);
quotient = dividend / divisor;

//Line 8
//Line 9

cout << "Line 10: Quotient = " << quotient
<< endl;

//Line 10

return 0;

//Line 11

}

Sample Run 1:
Line 2: Enter the dividend: 26
Line 5: Enter the divisor: 7
Line 10: Quotient = 3

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1002

| Chapter 14: Exception Handling

Sample Run 2:
Line 2: Enter the dividend: 24
Line 5: Enter the divisor: 0
Assertion failed: divisor != 0, file c:\chapter 14 source code\ch14_exp3.cpp,
line 20

In Sample Run 1, the value of divisor is nonzero, so no exception occurs. The program
calculates and outputs the quotient and terminates normally.
In Sample Run 2, the value entered for divisor is 0. In Line 8, the function assert
checks whether divisor is nonzero. Because divisor is 0, the expression in the
assert statement evaluates to false, and the function assert terminates the program
with the error message shown in the third line of the output.

C++ Mechanisms of Exception Handling
Examples 14-1 through 14-3 show what happens when an exception occurs in a program
and is not processed. This section describes how to include the necessary code to handle
exceptions within a program.

try/catch Block
The statements that may generate an exception are placed in a try block. The try block
also contains statements that should not be executed if an exception occurs. The try
block is followed by one or more catch blocks. A catch block specifies the type of
exception it can catch and contains an exception handler.
The general syntax of the try/catch block is:
try
{
//statements
}
catch (dataType1 identifier)
{
//exception-handling code
}
.
.
.
catch (dataTypen identifier)
{
//exception-handling code
}
.
.
.
catch (...)
{
//exception-handling code
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Handling Exceptions within a Program

|

1003

Suppose there is a statement that can generate an exception, for example, division by 0.
Usually, before executing such a statement, we check whether certain conditions are met.
For example, before performing the division, we check whether the divisor is nonzero. If
the conditions are not met, we typically generate an exception, which in C++ terminology
is called throwing an exception. This is typically done using the throw statement, which
we will explain shortly. We will show what is typically thrown to generate an exception.
Let us now note the following about try/catch blocks.
•

If no exception is thrown in a try block, all catch blocks associated
with that try block are ignored and program execution resumes after the
last catch block.
• If an exception is thrown in a try block, the remaining statements in that
try block are ignored. The program searches the catch blocks in the
order they appear after the try block and looks for an appropriate exception handler. If the type of thrown exception matches the parameter type
in one of the catch blocks, the code of that catch block executes, and
the remaining catch blocks after this catch block are ignored.
• The last catch block that has an ellipses (three dots) is designed to catch
any type of exception.
Consider the following catch block:
catch (int x)
{
//exception-handling code
}

In this catch block:
• The identifier x acts as a parameter. In fact, it is called a catch block parameter.
• The data type int specifies that this catch block can catch an exception
of type int.
• A catch block can have at most one catch block parameter.
Essentially, the catch block parameter becomes a placeholder for the value thrown. In
this case, x becomes a placeholder for any thrown value that is of type int. In other
words, if the thrown value is caught by this catch block, then the thrown value is stored
in the catch block parameter. This way, if the exception-handling code wants to do
something with that value, it can be accessed via the catch block parameter.
Suppose in a catch block heading only the data type is specified, that is, there is no
catch block parameter. The thrown value then may not be accessible in the catch block
exception-handling code.
THROWING AN EXCEPTION
In order for an exception to occur in a try block and be caught by a catch block, the
exception must be thrown in the try block. The general syntax to throw an exception is:
throw expression;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1004

| Chapter 14: Exception Handling

in which expression is a constant value, variable, or object. The object being thrown
can be either a specific object or an anonymous object. It follows that in C++, an
exception is a value.
In C++, throw is a reserved word.
Example 14-4 illustrates how to use a throw statement.
EXAMPLE 14-4
Suppose we have the following declaration:
int num = 5;
string str = "Something is wrong!!!";
throw expression

Effect

throw
throw
throw
throw

The constant value 4 is thrown.
The value of the variable x is thrown.
The object str is thrown.
An anonymous string object with
the string "Exception found!"
is thrown.

4;
x;
str;
string("Exception found!");

ORDER OF catch BLOCKS
A catch block can catch either all exceptions of a specific type or all types of exceptions.
The heading of a catch block specifies the type of exception it handles. As noted
previously, the catch block that has an ellipses (three dots) is designed to catch any type
of exception. Therefore, if we put this catch block first, then this catch block can catch
all types of exceptions.

Suppose that an exception occurs in a try block and is caught by a catch block. The
remaining catch blocks associated with that try block are then ignored. Therefore, you
should be careful about the order in which you list catch blocks following a try block.
For example, consider the following sequence of try/catch blocks:
try
{
//statements
}
catch (...)
{
//statements
}
catch (int x)
{
//statements
}

//Line 1

//Line 2

//Line 3

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Handling Exceptions within a Program

|

1005

Suppose that an exception is thrown in the try block. Because the catch block in Line 2
can catch exceptions of all types, the catch block in Line 3 cannot be reached. For this
sequence of try/catch blocks, some compilers might, in fact, give a syntax error (check
your compiler’s documentation).
In a sequence of try/catch blocks, if the catch block with an ellipses (in the heading) is
needed, then it should be the last catch block of that sequence.
USING try/catch BLOCKS IN A PROGRAM
Next, we provide examples that illustrate how a try/catch block might appear in a program.

A common error that might occur when performing numeric calculations is division by
zero with integer values. If, during program execution, division by zero occurs with integer
values and is not addressed by the program, the program might terminate with an error message
or might simply hang. Example 14-5 shows how to handle division by zero exceptions.
EXAMPLE 14-5
This example illustrates how to catch and handle division by zero exceptions. It also
shows how a try/catch block might appear in a program.
// Handling division by zero exception.
#include <iostream>
using namespace std;
int main()
{
int dividend, divisor, quotient;
try
{

//Line 1
//Line 2

cout << "Line 3: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 3
//Line 4
//Line 5

cout << "Line 6: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 6
//Line 7
//Line 8

if (divisor == 0)
throw 0;

//Line 9
//Line 10

quotient = dividend / divisor;

//Line 11

cout << "Line 12: Quotient = " << quotient
<< endl;

//Line 12

}
catch (int)

//Line 13

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1006

| Chapter 14: Exception Handling

{
cout << "Line 14: Division by 0." << endl;

//Line 14

}
return 0;

//Line 15

}

Sample Run 1: In this sample run, the user input is shaded.
Line 3: Enter the dividend: 17
Line 6: Enter the divisor: 8
Line 12: Quotient = 2

Sample Run 2: In this sample run, the user input is shaded.
Line 3: Enter the dividend: 34
Line 6: Enter the divisor: 0
Line 14: Division by 0.

This program works as follows. The statement in Line 1 declares the int variables dividend,
divisor, and quotient. The try block starts at Line 2. The statement in Line 3 prompts the
user to enter the value for the dividend; the statement in Line 4 stores this number in the
variable dividend. The statement in Line 6 prompts the user to enter the value for the divisor,
and the statement in Line 7 stores this number in the variable divisor. The statement in
Line 9 checks whether the value of divisor is 0. If the value of divisor is 0, the statement
in Line 10 throws the constant value 0. The statement in Line 11 calculates the quotient
and stores it in quotient. The statement in Line 12 outputs the value of quotient.
The catch block starts in Line 13 and catches an exception of type int.
In Sample Run 1, the program does not throw any exception.
In Sample Run 2, the entered value of divisor is 0. Therefore, the statement in Line 10
throws 0, which is caught by the catch block starting in Line 13. The statement in Line
14 outputs the appropriate message.
The program in Example 14-6 is the same as the program in Example 14-5, except that
the throw statement throws the value of the variable divisor.
EXAMPLE 14-6
// Handling division by zero exception.
#include <iostream>
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Handling Exceptions within a Program

int main()
{
int dividend, divisor, quotient;
try
{

|

1007

//Line 1
//Line 2

cout << "Line 3: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 3
//Line 4
//Line 5

cout << "Line 6: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 6
//Line 7
//Line 8

if (divisor == 0)
throw divisor;

//Line 9
//Line 10

quotient = dividend / divisor;

//Line 11

cout << "Line 12: Quotient = " << quotient
<< endl;

//Line 12

}
catch (int x)
{
cout << "Line 14: Division by " << x
<< endl;
}
return 0;

//Line 13
//Line 14
//Line 15

}

Sample Run 1: In this sample run, the user input is shaded.
Line 3: Enter the dividend: 14
Line 6: Enter the divisor: 5
Line 12: Quotient = 2

Sample Run 2: In this sample run, the user input is shaded.
Line 3: Enter the dividend: 23
Line 6: Enter the divisor: 0
Line 14: Division by 0

This program works the same way as the program in Example 14-5.
The program in Example 14-7 illustrates how to handle division by zero, division by a
negative integer, and input failure exceptions. It also shows how to throw and catch an
object. This program is similar to the programs in Examples 14-5 and 14-6.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1008

| Chapter 14: Exception Handling

EXAMPLE 14-7
// Handle division by zero, division by a negative integer,
// and input failure exceptions.
#include <iostream>
#include <string>
using namespace std;
int main()
{
int dividend, divisor = 1, quotient;

//Line 1

string inpStr
= "The input stream is in the fail state.";

//Line 2

try
{

//Line 3
cout << "Line 4: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 4
//Line 5
//Line 6

cout << "Line 7: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 7
//Line 8
//Line 9

if (divisor == 0)
throw divisor;
else if (divisor < 0)
throw string("Negative divisor.");
else if (!cin)
throw inpStr;

//Line
//Line
//Line
//Line
//Line
//Line

quotient = dividend / divisor;

//Line 16

cout << "Line 17: Quotient = " << quotient
<< endl;

//Line 17

}
catch (int x)
{
cout << "Line 19: Division by " << x
<< endl;
}
catch (string s)
{
cout << "Line 21: " << s << endl;
}
return 0;

10
11
12
13
14
15

//Line 18
//Line 19
//Line 20
//Line 21
//Line 22

}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Handling Exceptions within a Program

|

1009

Sample Run 1: In this sample run, the user input is shaded.
Line 4: Enter the dividend: 23
Line 7: Enter the divisor: 6
Line 17: Quotient = 3

Sample Run 2: In this sample run, the user input is shaded.
Line 4: Enter the dividend: 34
Line 7: Enter the divisor: -6
Line 21: Negative divisor.

Sample Run 3: In this sample run, the user input is shaded.
Line 4: Enter the dividend: 34
Line 7: Enter the divisor: g
Line 21: The input stream is in the fail state.

In this program, the statements in Lines 1 and 2 declare the variables used in the program.
Notice that the string object inpStr is also initialized.
The statements in Lines 4 through 9 input the data into the variables dividend and
divisor. The statement in Line 10 checks whether divisor is 0, the statement in Line
12 checks whether divisor is negative, and the statement in Line 14 checks whether the
standard input stream is in the fail state.
The statement in Line 11 throws the variable divisor, the statement in Line 13 throws
an anonymous string object with the string "Negative divisor.", and the statement in
Line 15 throws the object inpStr.
The catch block in Line 18 catches an exception of type int, and the catch block in Line
20 catches an exception of type string. If the exception is thrown by the statement in Line
11, it is caught and processed by the catch block in Line 18. If the exception is thrown by
the statements in Lines 13 or 15, it is caught and processed by the catch block in Line 20.
In Sample Run 1, the program does not encounter any problems. In Sample Run 2, division
by a negative number occurs. In Sample Run 3, the standard input stream enters the fail state.

Using C++ Exception Classes
C++ provides support to handle exceptions via a hierarchy of classes. The class
exception is the base of the classes designed to handle exceptions. Among others, this
class contains the function what. The function what returns a string containing an

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1010

| Chapter 14: Exception Handling

appropriate message. All derived classes of the class exception override the function
what to issue their own error messages.
Two classes are immediately derived from the class exception: logic_error and
runtime_error. Both of these classes are defined in the header file stdexcept.
To deal with logical errors in a program, such as a string subscript out of range or an invalid
argument to a function call, several classes are derived from the class logic_error. For
example, the class invalid_argument is designed to deal with illegal arguments used in
a function call. The class out_of_range deals with the string subscript out of range
error. If a length greater than the maximum allowed for a string object is used, the class
length_error deals with this error. For example, recall that every string object has a
maximum length (see Chapter 7). If a length larger then the maximum length allowed for a
string is used, then the length_error exception is generated. If the operator new cannot
allocate memory space, this operator throws a bad_alloc exception.
The class runtime_error is designed to deal with errors that can be detected only
during program execution. For example, to deal with arithmetic overflow and underflow
exceptions, the classes overflow_error and underflow_error are derived from the
class runtime_error.
Examples 14-8 and 14-9 illustrate how C++’s exception classes are used to handle
exceptions in a program.
The program in Example 14-8 shows how to handle the exceptions out_of_range and
length_error. Notice that in this program, these exceptions are thrown by the string
functions substr and the string concatenation operator +. Because the exceptions are
thrown by these functions, we do not include any throw statement in the try block.
EXAMPLE 14-8
// Handling out_of_range and length_error exceptions.
#include <iostream>
#include <string>
using namespace std;
int main()
{
string sentence;
string str1, str2, str3;
try
{

//Line 1
//Line 2
//Line 3

sentence = "Testing string exceptions!";
cout << "Line 5: sentence = " << sentence
<< endl;

//Line 4
//Line 5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Handling Exceptions within a Program

|

1011

cout << "Line 6: sentence.length() = "
<< static_cast<int>(sentence.length())
<< endl;
//Line 6
str1 = sentence.substr(8, 20);
cout << "Line 8: str1 = " << str1
<< endl;

//Line 7

str2 = sentence.substr(28, 10);
cout << "Line 10: str2 = " << str2
<< endl;

//Line 9

str3 = "Exception handling. " + sentence;
cout << "Line 12: str3 = " << str3
<< endl;

//Line 11

}
catch (out_of_range re)
{
cout << "Line 14: In the out_of_range "
<< "catch block: " << re.what()
<< endl;
}
catch (length_error le)
{
cout << "Line 16: In the length_error "
<< "catch block: " << le.what()
<< endl;
}
return 0;

//Line 8

//Line 10

//Line 12
//Line 13

//Line 14
//Line 15

//Line 16
//Line 17

}

Sample Run:
Line
Line
Line
Line

5: sentence = Testing string exceptions!
6: sentence.length() = 26
8: str1 = string exceptions!
14: In the out_of_range catch block: invalid string position

In this program, the statement in Line 7 uses the function substr to determine a
substring in the string object sentence. The length of the string sentence is 26. Because
the starting position of the substring is 8, which is less than 26, no exception is thrown.
However, in the statement in Line 9, the starting position of the substring is 28, which is
greater than 26 (the length of sentence). Therefore, the function substr throws an
out_of_range exception, which is caught and processed by the catch block in Line 13.
Notice that in the statement in Line 14, the object re uses the function what to return
the error message, invalid string position.
The program in Example 14-9 illustrates how to handle the exception bad_alloc
thrown by the operator new.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1012

| Chapter 14: Exception Handling

EXAMPLE 14-9
// Handling bad_alloc exception thrown by the operator new.
#include <iostream>
using namespace std;
int main()
{
int *list[100];

//Line 1

try
{

//Line 2
for (int i = 0; i
{
list[i] = new
cout << "Line
<< "] of
<< endl;
}

< 100; i++)

//Line 3

int[50000000];
4: Created list[" << i
50000000 components."

//Line 4

}
catch (bad_alloc be)
{
cout << "Line 7: In the bad_alloc catch "
<< "block: " << be.what() << "."
<< endl;
}
return 0;

//Line 5
//Line 6

//Line 7
//Line 8

}

Sample Run:
Line
Line
Line
Line
Line
Line
Line
Line
Line

4:
4:
4:
4:
4:
4:
4:
4:
7:

Created list[0] of 50000000 components.
Created list[1] of 50000000 components.
Created list[2] of 50000000 components.
Created list[3] of 50000000 components.
Created list[4] of 50000000 components.
Created list[5] of 50000000 components.
Created list[6] of 50000000 components.
Created list[7] of 50000000 components.
In the bad_alloc catch block: bad allocation.

The preceding program works as follows. The statement in Line 1 declares list to be an
array of 100 pointers. The body of the for loop in Line 3 is designed to execute 100
times. For each iteration of the for loop, the statement in Line 4 uses the operator new to
allocate an array of 50000000 components of type int. As shown in the sample run, the
operator new is able to create eight arrays of 50000000 components each. In the ninth
iteration, the operator new is unable to create the array and throws a bad_alloc

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Creating Your Own Exception Classes

|

1013

exception. This exception is caught and processed by the catch block in Line 6. Notice
that the expression be.what() returns the string bad allocation. (Moreover, the
string returned by be.what() is IDE dependent. Some IDEs might return the string
bad_alloc.) After the statement in Line 7 executes, control exits the try/catch block,
and the statement in Line 8 terminates the program.

Creating Your Own Exception Classes
Watch
the Video

Whenever you create your own classes or write programs, exceptions are likely to occur.
As you have seen, C++ provides numerous exception classes to deal with these situations.
However, it does not provide all of the exception classes you will ever need. Therefore,
C++ enables programmers to create their own exception classes to handle both the
exceptions not covered by C++’s exception classes and their own exceptions. This
section describes how to create your own exception classes.
C++ uses the same mechanism to process the exceptions that you define as it uses for built-in
exceptions. However, you must throw your own exceptions using the throw statement.
In C++, any class can be considered an exception class. Therefore, an exception class is
simply a class. It need not be inherited from the class exception. What makes a class
an exception is how you use it.
The exception class that you define can be very simple in the sense that it does not contain
any members. For example, the following code can be considered an exception class:
class dummyExceptionClass
{
};

The program in Example 14-10 uses a user-defined class (with no members) to throw an
exception.
EXAMPLE 14-10
// Using a user-defined exception class.
#include <iostream>
using namespace std;

1
4

class divByZero
{};
int main()
{
int dividend, divisor, quotient;

//Line 1

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1014

| Chapter 14: Exception Handling

try
{

//Line 2
cout << "Line 3: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 3
//Line 4
//Line 5

cout << "Line 6: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 6
//Line 7
//Line 8

if (divisor == 0)
throw divByZero();

//Line 9
//Line 10

quotient = dividend / divisor;
cout << "Line 12: Quotient = " << quotient
<< endl;

//Line 11

}
catch (divByZero)
{
cout << "Line 14: Division by zero!"
<< endl;
}
return 0;

//Line 12
//Line 13
//Line 14
//Line 15

}

Sample Run 1: In this sample run, the user input is shaded.
Line 3: Enter the dividend: 34
Line 6: Enter the divisor: 5
Line 12: Quotient = 6

Sample Run 2: In this sample run, the user input is shaded.
Line 3: Enter the dividend: 56
Line 6: Enter the divisor: 0
Line 14: Division by zero!

The preceding program works as follows. If the user enters 0 for the divisor, the
statement in Line 10 throws an anonymous object of the class divByZero.
The class divByZero has no members, so we cannot really do anything with
the thrown object. Therefore, in the catch block in Line 13, we specify only the data type
name without the parameter name. The statement in Line 14 outputs the appropriate error
message.
Let us again consider the statement throw divByZero(); in Line 10. Notice that in this
statement, divByZero is the name of the class, the expression divByZero() creates an
anonymous object of this class, and the throw statement throws the object.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Creating Your Own Exception Classes

|

1015

The exception class divByZero designed and used in Example 14-10 has no members.
Next, we illustrate how to create exception classes with members.
If you want to include members in your exception class, you typically include constructors
and the function what. Consider the following definition of the class divisionByZero.
// User-defined exception class.
#include <iostream>
#include <string>
using namespace std;
class divisionByZero
{
public:
divisionByZero()
{
message = "Division by zero";
}

//Line
//Line
//Line
//Line

1
2
3
4

//Line 5
//Line 6

divisionByZero(string str)
{
message = str;
}

//Line
//Line
//Line
//Line

7
8
9
10

string what()
{
return message;
}

//Line
//Line
//Line
//Line

11
12
13
14

private:
string message;
};

//Line 15
//Line 16
//Line 17

The definition of the class divisionByZero contains two constructors: the default
constructor and the constructor with parameters. The default constructor stores the
string "Division by zero" in an object. The constructor with parameters allows users
to create their own error messages. The function what is used to return the string stored
in the object.
In the definition of the class divisionByZero, the constructors can also be
written as:

divisionByZero() : message("Division by zero"){}
divisionByZero(string str) : message(str){}

The program in Example 14-11 uses the preceding class to throw an exception.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1016

| Chapter 14: Exception Handling

EXAMPLE 14-11
// Using user-defined exception class divisionByZero with
// default error message.
#include <iostream>
#include "divisionByZero.h"
using namespace std;
int main()
{
int dividend, divisor, quotient;
try
{

//Line 1
//Line 2

cout << "Line 3: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 3
//Line 4
//Line 5

cout << "Line 6: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 6
//Line 7
//Line 8

if (divisor == 0)
throw divisionByZero();

//Line 9
//Line 10

quotient = dividend / divisor;
cout << "Line 12: Quotient = " << quotient
<< endl;

//Line 11

}
catch (divisionByZero divByZeroObj)
{
cout << "Line 14: In the divisionByZero "
<< "catch block: "
<< divByZeroObj.what() << endl;
}
return 0;

//Line 12
//Line 13

//Line 14
//Line 15

}

Sample Run 1: In this sample run, the user input is shaded.
Line 3: Enter the dividend: 34
Line 6: Enter the divisor: 5
Line 12: Quotient = 6

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Creating Your Own Exception Classes

|

1017

Sample Run 2: In this sample run, the user input is shaded.
Line 3: Enter the dividend: 56
Line 6: Enter the divisor: 0
Line 14: In the divisionByZero catch block: Division by zero

In this program, the statement in Line 10 throws an object (exception) of the class
divisionByZero if the user enters 0 for the divisor. This thrown exception is caught
and processed by the catch block in Line 13. The parameter divByZeroObj in the
catch block catches the value of the thrown object and then uses the function what to
return the string stored in the object. The statement in Line 14 outputs the appropriate
error message.
The program in Example 14-12 is similar to the program in Example 14-11. Here, the
thrown object is still an anonymous object, but the error message is specified by the user
(see the statement in Line 10).
EXAMPLE 14-12
// Using user-defined exception class divisionByZero with a
// specific error message.
#include <iostream>
#include "divisionByZero.h"
using namespace std;
int main()
{
int dividend, divisor, quotient;
try
{

//Line 1
//Line 2

cout << "Line 3: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 3
//Line 4
//Line 5

cout << "Line 6: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 6
//Line 7
//Line 8

//Line 9
if (divisor == 0)
throw divisionByZero("Found division by zero"); //Line 10
quotient = dividend / divisor;
cout << "Line 12: Quotient = " << quotient
<< endl;

//Line 11
//Line 12

}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1018

| Chapter 14: Exception Handling

catch(divisionByZero divByZeroObj)
{
cout << "Line 14: In the divisionByZero "
<< "catch block: "
<< divByZeroObj.what() << endl;
}

//Line 13

return 0;

//Line 15

//Line 14

}

Sample Run 1: In this sample run, the user input is shaded.
Line 3: Enter the dividend: 34
Line 6: Enter the divisor: 5
Line 12: Quotient = 6

Sample Run 2: In this sample run, the user input is shaded.
Line 3: Enter the dividend: 56
Line 6: Enter the divisor: 0
Line 14: In the divisionByZero catch block: Found division by zero

This program works the same way as the program in Example 14-11. The details are left
as an exercise for you.
In the programs in Examples 14-11 and 14-12, the data manipulation is done in the
function main. Therefore, the exception is thrown, caught, and processed in the function
main. The program in Example 14-13 uses the user-defined function doDivision to
manipulate the data. Therefore, the exception is thrown, caught, and processed in the
function doDivision.
EXAMPLE 14-13
// Handling an exception thrown by a function.
#include <iostream>
#include "divisionByZero.h"
using namespace std;
void doDivision();
int main()
{
doDivision();

//Line 1

return 0;

//Line 2

}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Creating Your Own Exception Classes

void doDivision()
{
int dividend, divisor, quotient;

|

1019

//Line 3

try
{
cout << "Line 4: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 4
//Line 5
//Line 6

cout << "Line 7: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 7
//Line 8
//Line 9

if (divisor == 0)
throw divisionByZero();

//Line 10
//Line 11

quotient = dividend / divisor;
cout << "Line 13: Quotient = " << quotient
<< endl;

//Line 12

}
catch (divisionByZero divByZeroObj)
{
cout << "Line 15: In the function "
<< "doDivision: "
<< divByZeroObj.what() << endl;
}

//Line 13
//Line 14

//Line 15

}

Sample Run 1: In this sample run, the user input is shaded.
Line 4: Enter the dividend: 34
Line 7: Enter the divisor: 5
Line 13: Quotient = 6

Sample Run 2: In this sample run, the user input is shaded.
Line 4: Enter the dividend: 56
Line 7: Enter the divisor: 0
Line 15: In the function doDivision: Division by zero

EXAMPLE 14-14
Example 10-8 defined the class circleType to implement the basic properties of a
circle. If a circleType object tries to set the radius to a negative number, then the
function setRadius of this class sets the radius to 0. In this example, first we define the
class negativeNumber to handle negative number exceptions and then use this class to
throw an exception if a circleType object tries to set the radius to a negative number.
So consider the following class:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1020

| Chapter 14: Exception Handling

// User-defined exception class.
#include <iostream>
#include <string>
using namespace std;
class negativeNumber
{
public:
negativeNumber()
{
message = "Number cannot be negative";
}
negativeNumber(string str)
{
message = str + " cannot be negative";
}
string what()
{
return message;
}
private:
string message;
};

Note that the definition of the class negativeNumber is similar to the definition of the
class divisionByZero.
The definition of the class circleType is the same as in Example 10-8, except for the
definition of function setRadius. The modified definition of this function is:
void circleType::setRadius(double r)
{
if (r < 0)
throw negativeNumber("Radius");
radius = r;
}

If the value of the parameter r is a negative number, the function setRadius throws a
negativeNumber object. In this case, the value of the instance variable message of the
object thrown is "Radius cannot be negative". The user program will handle the
exception, if any, thrown by this function.
Consider the following program:
//The user program that uses the class circleType
#include
#include
#include
#include

<iostream>
<iomanip>
"circleType.h"
"negativeNumber.h"

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Creating Your Own Exception Classes

|

1021

using namespace std;
int main()
{
circleType circle;

//Line 1
//Line 2
//Line 3

double radius;

//Line 4

cout << fixed << showpoint << setprecision(2);

//Line 5

try
{
cout << "Line 8: Enter the radius of a circle: ";
cin >> radius;
cout << endl;

//Line
//Line
//Line
//Line
//Line

circle.setRadius(radius);

//Line 11

cout <<
<<
<<
<<
<<

"Line 12: circle - "
"radius: " << circle.getRadius()
", area: " << circle.area()
", circumference: "
circle.circumference() << endl;

}
catch (negativeNumber obj)
{
cout << "Line 16: " << obj.what() << endl;
}
return 0;
}//end main

//Line
//Line
//Line
//Line
//Line
//Line

6
7
8
9
10

12
13
14
15
16
17

//Line 18
//Line 19

Sample Run 1: In this sample run, the user input is shaded.
Line 8: Enter the radius of a circle: 4.75
Line 12: circle - radius: 4.75, area: 70.88, circumference: 29.85

Sample Run 2: In this sample run, the user input is shaded.
Line 8: Enter the radius of a circle: -2.65
Line 16: Radius cannot be negative

The preceding program works as follows. The statement in Line 3 creates the circleType
object circle and using the default constructor sets the radius to 0.0. The statement in Line 4
declares the double variable radius. The try/catch block, between Lines 7 and 17 contains
the code to prompt the user to enter the radius of the circle and depending on the value entered by
the user generates the output. For example, if the user enters a nonnegative radius, the statement
in Line 11 sets the radius of the circle and the statement in Line 12 outputs the radius, area, and the
perimeter of the circle. If the user enters a negative number, the statement in Line 11 throws an
exception, which is a negativeNumber object, and the catch block processes the exception. In
Sample Run 1, the user enters 4.75, a nonnegative number, and the program outputs the radius,
area, and the perimeter of the circle. In Sample Run 2, the user enters -2.65, which is a negative
number, and the statement in Line 16 outputs that the radius cannot be negative.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1022

| Chapter 14: Exception Handling

Rethrowing and Throwing an Exception
When an exception occurs in a try block, control immediately passes to one of the
catch blocks. Typically, a catch block either handles the exception or partially processes
the exception and then rethrows the same exception, or it rethrows another exception in
order for the calling environment to handle the exception. The catch block in Examples
14-4 through 14-14 handles the exception. The mechanism of rethrowing or throwing
an exception is quite useful in cases in which a catch block catches the exception but
cannot handle the exception, or if the catch block decides that the exception should be
handled by the calling block or environment. This allows the programmer to provide the
exception-handling code all in one place.
To rethrow or throw an exception, we use the throw statement. The general syntax to
rethrow an exception caught by a catch block is:
throw;

(in this case, the same exception is rethrown) or:
throw expression;

in which expression is a constant value, variable, or object. The object being thrown
can be either a specific object or an anonymous object.
A function specifies the exceptions it throws (to be handled somewhere) in its heading
using the throw clause. For example, the following function specifies that it throws
exceptions of type int, string, and divisionByZero, in which divisionByZero is
the class, as defined previously.
void expThrowExcep(int x) throw (int, string, divisionByZero)
{
.
.
.
//include the appropriate throw statements
.
.
.
}

The program in Example 14-15 further explains how a function specifies the exception it throws.
EXAMPLE 14-15
// Handling an exception, in the main function, thrown by another
// function. The function throws the same exception object.
#include <iostream>
#include "divisionByZero.h"

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Creating Your Own Exception Classes

|

1023

using namespace std;
void doDivision() throw (divisionByZero);
int main()
{
try
{
doDivision();
}
catch (divisionByZero divByZeroObj)
{
cout << "Line 4: In main: "
<< divByZeroObj.what() << endl;
}
return 0;

//Line 1
//Line 2
//Line 3
//Line 4
//Line 5

}
void doDivision() throw (divisionByZero)
{
int dividend, divisor, quotient;
try
{

//Line 6
//Line 7

cout << "Line 8: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 8
//Line 9
//Line 10

cout << "Line 11: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 11
//Line 12
//Line 13

//Line 14
if (divisor == 0)
throw divisionByZero("Found division by 0!"); //Line 15
quotient = dividend / divisor;
cout << "Line 17: Quotient = " << quotient
<< endl;
}
catch (divisionByZero)
{
throw;
}

//Line 16
//Line 17
//Line 18
//Line 19

}

Sample Run 1: In this sample run, the user input is shaded.
Line 8: Enter the dividend: 34
Line 11: Enter the divisor: 5
Line 17: Quotient = 6

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1024

| Chapter 14: Exception Handling

Sample Run 2: In this sample run, the user input is shaded.
Line 8: Enter the dividend: 56
Line 11: Enter the divisor: 0
Line 4: In main: Found division by 0!

In this program, if the value of divisor is 0, the statement in Line 15 throws an
exception of type divisionByZero, which is an anonymous object of this class, with
the message string:
"Found division by 0!"

The statement in Line 19, in the catch block, throws the same exception value, which in
this case is an object.
In Sample Run 1, no exception is thrown.
Let us see what happens in Sample Run 2. The function main calls the function doDivision
in the try block. In the function doDivision, the value of divisor is 0, so the statement in
Line 15 throws an exception. The exception is caught by the catch block in Line 18. The
statement in Line 19 rethrows the same exception. In other words, the catch block catches
and rethrows the same exception. Therefore, the function call statement in Line 2 results in
throwing an exception. This exception is caught and processed by the catch block in Line 3.

EXAMPLE 14-16
// Handling exception, in the main function, thrown by another
// function. The function throws a different exception object.
#include <iostream>
#include "divisionByZero.h"
using namespace std;
void doDivision() throw (divisionByZero);
int main()
{
try
{
doDivision();
}
catch (divisionByZero divByZeroObj)
{
cout << "Line 4: In main: "
<< divByZeroObj.what() << endl;
}
return 0;

//Line 1
//Line 2
//Line 3
//Line 4
//Line 5

}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Creating Your Own Exception Classes

void doDivision() throw (divisionByZero)
{
int dividend, divisor, quotient;
try
{

|

1025

//Line 6
//Line 7

cout << "Line 8: Enter the dividend: ";
cin >> dividend;
cout << endl;

//Line 8
//Line 9
//Line 10

cout << "Line 11: Enter the divisor: ";
cin >> divisor;
cout << endl;

//Line 11
//Line 12
//Line 13

if (divisor == 0)
throw divisionByZero();

//Line 14
//Line 15

quotient = dividend / divisor;
cout << "Line 17: Quotient = " << quotient
<< endl;

//Line 16

}
catch (divisionByZero)
{
throw
divisionByZero("Division by zero found!");
}

//Line 17
//Line 18
//Line 19

}

Sample Run 1: In this sample run, the user input is shaded.
Line 8: Enter the dividend: 34
Line 11: Enter the divisor: 5
Line 17: Quotient = 6

Sample Run 2: In this sample run, the user input is shaded.
Line 8: Enter the dividend: 56
Line 11: Enter the divisor: 0
Line 4: In main: Division by zero found!

This program works the same way as the program in Example 14-15. The only
difference is that here, the catch block in Line 18 rethrows a different exception
value, that is, object.

The programs in Examples 14-15 and 14-16 illustrate how a function can rethrow the
same exception or throw another exception for the calling function to handle. This
mechanism is quite useful because it allows a program to handle all of the exceptions in
one location, rather than spread the exception-handling code throughout the program.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1026

| Chapter 14: Exception Handling

Exception-Handling Techniques
When an exception occurs in a program, the programmer usually has three choices:
terminate the program, include code in the program to recover from the exception, or
log the error and continue. The following sections discuss each of these situations.

Terminate the Program
In some cases, it is best to let the program terminate when an exception occurs. Suppose
you have written a program that inputs data from a file. If the input file does not exist
when the program executes, then there is no point in continuing with the program. In
this case, the program can output an appropriate error message and terminate.

Fix the Error and Continue
In other cases, you will want to handle the exception and let the program continue.
Suppose that you have a program that takes as input an integer. If a user inputs a letter in
place of a number, the input stream will enter the fail state. This is a situation in which
you can include the necessary code to keep prompting the user to input a number until
the entry is valid. The program in Example 14-17 illustrates this situation.
EXAMPLE 14-17
// Handle exceptions by fixing the errors. The program continues to
// prompt the user until a valid input is entered.
#include <iostream>
#include <string>
using namespace std;
int main()
{
int number;
bool done = false;

//Line 1
//Line 2

string str =
"The input stream is in the fail state."; //Line 3
do
{
cout << "Line 8: Enter an integer: ";
cin >> number;
cout << endl;

//Line
//Line
//Line
//Line
//Line
//Line
//Line

if (!cin)
throw str;

//Line 11
//Line 12

try
{

4
5
6
7
8
9
10

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exception-Handling Techniques

done = true;
cout << "Line 14: Number = " << number
<< endl;
}
catch (string messageStr)
{
cout << "Line 18: " << messageStr
<< endl;
cout << "Line 19: Restoring the "
<< "input stream." << endl;
cin.clear();
cin.ignore(100, '\n');
}

|

1027

//Line 13
//Line
//Line
//Line
//Line

14
15
16
17

//Line 18
//Line
//Line
//Line
//Line

19
20
21
22

}
while (!done);

//Line 23

return 0;

//Line 24

}

Sample Run: In this sample run, the user input is shaded.
Line 8: Enter an integer: r5
Line 18: The input stream is in the fail state.
Line 19: Restoring the input stream.
Line 8: Enter an integer: d45
Line 18: The input stream is in the fail state.
Line 19: Restoring the input stream.
Line 8: Enter an integer: hw3
Line 18: The input stream is in the fail state.
Line 19: Restoring the input stream.
Line 8: Enter an integer: 48
Line 14: Number = 48

This program prompts the user to enter an integer. If the input is invalid, the standard
input stream enters the fail state. In the try block, the statement in Line 12 throws an
exception, which is a string object. Control passes to the catch block, and the exception
is caught and processed. The statement in Line 20 restores the input stream to its good
state, and the statement in Line 21 clears the rest of the input from the line. The
do. . .while loop continues to prompt the user until the user inputs a valid number.

Log the Error and Continue
The program that terminates when an exception occurs usually assumes that this termination is reasonably safe. However, if your program is designed to run a nuclear reactor or
continuously monitor a satellite, it cannot be terminated if an exception occurs. These
programs should report the exception, but the program must continue to run.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1028

| Chapter 14: Exception Handling

For example, consider a program that analyzes an airline’s ticketing transactions. Because
numerous ticketing transactions occur each day, a program is run at the end of each day
to validate that day’s transactions. This type of program would take an enormous amount
of time to process the transactions and use exceptions to identify any erroneous entries.
Instead, when an exception occurs, the program should write the exception into a file
and continue to analyze the transactions.

Stack Unwinding
The examples given in this chapter show how to catch and process an exception. In
particular, you learned how to catch and process an exception in the same block, as well
as process the caught exception in the calling environment.
When an exception is thrown in, say, a function, the function can do the following:
•
•

Do nothing.
Partially process the exception and throw the same exception or a new
exception.
• Throw a new exception.
In each of these cases, the function call stack is unwound so that the exception can be
caught in the next try/catch block. When the function call stack is unwound, the
function in which the exception was not caught and/or rethrown terminates, and the
memory for its local variables is destroyed. The stack unwinding continues until either a
try/catch handles the exception or the program does not handle the exception. If the
program does not handle the exception, then the function terminate is called to
terminate the program.
Examples 14-18 and 14-19 illustrate how the exceptions are propagated. For this, let us
define the following exception class:
// User-defined myException class.
#include <string>
using namespace std;
class myException
{
public:
myException()
{
message = "Something is wrong!";
}
myException(string str)
{
message = str;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Stack Unwinding |

1029

string what()
{
return message;
}
private:
string message;
};
In the definition of the class myException, the constructors can also be written
as follows:

myException() : message("Something is wrong!"){}
myException(string str) : message(str){}

The program in Example 14-18 illustrates how exceptions thrown in a function get
processed in the calling environment.
EXAMPLE 14-18
// Processing exceptions thrown by a function in the calling
// environment.
#include <iostream>
#include "myException.h"
using namespace std;
void functionA() throw (myException);
void functionB() throw (myException);
void functionC() throw (myException);
int main()
{
try
{
functionA();
}
catch (myException me)
{
cout << me.what() << " Caught in main." << endl;
}
return 0;
}
void functionA() throw (myException)
{
functionB();
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1030

| Chapter 14: Exception Handling

void functionB()
{
functionC();
}

throw (myException)

void functionC() throw (myException)
{
throw myException("Exception generated in function C.");
}

Sample Run:
Exception generated in function C. Caught in main.

In this program, the function main calls functionA, functionA calls functionB, and
functionB calls functionC. The function functionC creates and throws an exception
of type myException. The functions functionA and functionB do not process the
exception thrown by functionC.
The function main calls functionA in the try block and catches the exception thrown
by functionC. The parameter me in the catch block heading catches the value of the
exception and then uses the function what to return the string stored in that object. The
output statement in the catch block outputs the appropriate message.
The program in Example 14-19 is similar to the program in Example 14-18. Here, the
exception is caught and processed by the immediate calling environment.
EXAMPLE 14-19
// Processing exceptions, thrown by a function, in the
// immediate calling environment.
#include <iostream>
#include "myException.h"
using namespace std;
void functionA();
void functionB();
void functionC() throw (myException);
int main()
{
try
{
functionA();
}
catch (myException e)
{
cout << e.what() << " Caught in main." << endl;
}
return 0;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

1031

void functionA()
{
functionB();
}
void functionB()
{
try
{
functionC();
}
catch (myException me)
{
cout << me.what() << " Caught in functionB." << endl;
}
}
void functionC() throw (myException)
{
throw myException("Exception generated in functionC.");
}

Sample Run:
Exception generated in functionC. Caught in functionB.

In this program, the exception is caught and processed by functionB. Even though the
function main contains the try/catch block, the try block does not throw any
exceptions because the exception thrown by functionC is caught and processed by
functionB.

QUICK REVIEW
1.
2.
3.
4.
5.

6.
7.
8.

An exception is an occurrence of an undesirable situation that can be
detected during program execution.
Some typical ways of dealing with exceptions are to use an if statement or
the assert function.
The function assert can check whether an expression meets the required
condition(s). If the conditions are not met, it terminates the program.
The try/catch block is used to handle exceptions within a program.
Statements that may generate an exception are placed in a try block. The
try block also contains statements that should not be executed if an
exception occurs.
The try block is followed by one or more catch blocks.
A catch block specifies the type of exception it can catch and contains an
exception handler.
If the heading of a catch block contains...(ellipses) in place of parameters,
then this catch block can catch exceptions of all types.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1032

9.

10.

11.
12.
13.

14.
15.

| Chapter 14: Exception Handling

If no exceptions are thrown in a try block, all catch blocks associated
with that try block are ignored and program execution resumes after the
last catch block.
If an exception is thrown in a try block, the remaining statements in the try
block are ignored. The program searches the catch blocks, in the order they
appear after the try block, and looks for an appropriate exception handler. If
the type of the thrown exception matches the parameter type in one of the
catch blocks, then the code in that catch block executes and the remaining
catch blocks after this catch block are ignored.
The data type of the catch block parameter specifies the type of exception
that the catch block can catch.
A catch block can have, at most, one catch block parameter.
If only the data type is specified in a catch block heading, that is, if there is
no catch block parameter, then the thrown value may not be accessible in
the catch block exception-handling code.
In order for an exception to occur in a try block and be caught by a catch
block, the exception must be thrown in the try block.
The general syntax to throw an exception is:
throw expression;

16.
17.
18.
19.
20.

21.
22.
23.
24.
25.

in which expression is a constant value, variable, or object. The object
being thrown can be either a specific object or an anonymous object.
C++ provides support to handle exceptions via a hierarchy of classes.
The class exception is the base class of the exception classes provided by
C++.
The function what returns the string containing the exception object
thrown by C++’s built-in exception classes.
The class exception is contained in the header file exception.
The two classes that are immediately derived from the class exception
are logic_error and runtime_error. Both of these classes are defined in
the header file stdexcept.
The class invalid_argument is designed to deal with illegal arguments
used in a function call.
The class out_of_range deals with the string subscript out_of_range error.
If a length greater than the maximum allowed for a string object is used, the
class length_error deals with this error.
If the operator new cannot allocate memory space, this operator throws a
bad_alloc exception.
The class runtime_error is designed to deal with errors that can be
detected only during program execution. For example, to deal with arithmetic

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

26.

27.
28.

29.
30.

|

1033

overflow and underflow exceptions, the classes overflow_error and
underflow_error are derived from the class runtime_error.
A catch block typically handles the exception or partially processes the
exception and then either rethrows the same exception or rethrows another
exception in order for the calling environment to handle the exception.
C++ enables programmers to create their own exception classes to handle both
the exceptions not covered by C++’s exception classes and their own exceptions.
C++ uses the same mechanism to process the exceptions you define as it
uses for built-in exceptions. However, you must throw your own exceptions using the throw statement.
In C++, any class can be considered an exception class. It need not be inherited
from the class exception. What makes a class an exception is how it is used.
The general syntax to rethrow an exception caught by a catch block is:
throw;

(in this case, the same exception is rethrown) or:
throw expression;

31.
32.

33.

in which expression is a constant value, variable, or object. The object
being thrown can be either a specific object or an anonymous object.
A function specifies the exceptions it throws in its heading using the throw
clause.
When an exception is thrown in a function, the function can do the
following: do nothing, partially process the exception and throw the same
exception or a new exception, or throw a new exception. In each of these
cases, the function call stack is unwound so that the exception can be caught
in the next try/catch block. The stack unwinding continues until a try/
catch handles the exception or the program does not handle the exception.
If the program does not handle the exception, then the function terminate
is called to terminate the program.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.

b.

c.

Division by zero is an exception while opening an input file that does
not exist is not an exception. (1)
Suppose you use the assert function to check if certain conditions
are met. If the conditions are not met, then the assert function
terminates the program. (2)
One way to handle an exception is to print an error message and exit
the program. (2)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1034

| Chapter 14: Exception Handling

All exceptions need to be reported to avoid compilation errors. (2)
Every try block must have a catch block. (3)
f. The order in which catch blocks are listed is not important. (3)
g. If an exception is thrown in a try block, the remaining statements in
that try block are executed after executing a catch block. (3)
h. In C++, an exception is a value. (3)
i. The class invalid_range deals with the string subscript out_of_range
error. (5)
j. In C++, any class can be considered an exception class. (6)
k. The exception class must contain at least one member. (6)
l. An exception can be caught either in the function where it occurred, or
in any of the functions that led to the invocation of the method. (7)
m. When the function call stack is unwound, the function in which the
exception was not caught terminates, but the memory for its local
variables remains allocated. (9)
What is the difference between a try block and a catch block? (3)
What will happen if an exception is thrown but not caught? (3)
What happens if no exception is thrown in a try block? (3)
What happens if an exception is thrown in a try block? (3)
Which catch block catches all types of exceptions? (3)
How many parameters can a catch block have? (3)
What happens if in a catch block heading only the data type is specified, that is,
there is no catch block parameter. (3)
What is the general syntax to throw an exception? (4)
What is wrong with the following C++ code? Also, provide the correct code. (3, 4)
d.
e.

2.
3.
4.
5.
6.
7.
8.

9.
10.

double balance = 25000;
double intRate;
catch (double x)
{
cout << "Negative interest rate: " << x << endl;
}
try
{
cout << "Enter the interest rate: ";
cin >> intRate;
cout << endl;
if (intRate < 0.0)
throw intRate;
cout << "Interest: $" << balance * intRate / 100 << endl;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

11.

|

1035

What is wrong with the following C++ code? Also, provide the correct code. (3, 4)
double radius;
try
{
cout << "Enter the radius: ";
cin >> radius;
cout << endl;
if (radius < 0.0)
throw radius;
cout << "Area: " << 3.1416 * radius * radius << endl;
}
cout << "Entering the catch block." << endl;
catch (double x)
{
cout << "Negative radius: " << x << endl;
}

12.

Consider the following C++ code: (3, 4)
double balance;
try
{
cout << "Enter the balance: ";
cin >> balance;
cout << endl;
if (balance < 1000.00)
throw balance;
cout << "Leaving the try block." << endl;
}
catch (double x)
{
cout << "Current balance: " << x << endl
<< "Balance must be greater than 1000.00" << endl;
}

In this code, identify the try block.
b. In this code, identify the catch block.
c. In this code, identify the catch block parameter and its type.
d. In this code, identify the throw statement.
Assume the code given in Exercise 12. (3, 4)
a.

13.

a.
b.
c.

What is the output if the input is 1200?
What is the output if the input is 975?
What is the output if the input is -2000?

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1036

14.

| Chapter 14: Exception Handling

Consider the following C++ code: (3, 4)
int lowerLimit;
.
.
.
try
{
cout << "Entering the try block." << endl;
if (lowerLimit < 100)
throw exception("Lower limit violation.");
cout << "Exiting the try block." << endl;
}
catch (exception eObj)
{
cout << "Exception: " << eObj.what() << endl;
}
cout << "After the catch block" << endl;

What is the output if:
The value of lowerLimit is 50?
b. The value of lowerLimit is 150?
Consider the following C++ code: (3, 4)
a.

15.

int lowerLimit;
int divisor;
int result;
try
{
cout << "Entering the try block." << endl;
if (divisor == 0)
throw 0;
if (lowerLimit < 100)
throw string("Lower limit violation.");
result = lowerLimit / divisor;
cout << "Exiting the try block." << endl;
}
catch (int x)
{
cout << "Exception: " << x << endl;
result = 120;
}
catch (string str)
{
cout << "Exception: " << str << endl;
}
cout << "After the catch block" << endl;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

1037

What is the output if:
The value of lowerLimit is 50, and the value of divisor is 10?
The value of lowerLimit is 50, and the value of divisor is 0?
c. The value of lowerLimit is 150, and the value of divisor is 10?
d. The value of lowerLimit is 150, and the value of divisor is 0?
Which classes are directly derived from the class exception? (5)
Which class is used to deal with illegal arguments used in a function call? (5)
If you define your own exception class, what is typically included in that
class? (6)
What type of statement is used to rethrow an exception? (7)
Define an exception class called tornadoException. The class should have
two constructors, including the default constructor. If the exception is thrown
with the default constructor, the method what should return "Tornado: Take
cover immediately!". The other constructor has a single parameter, say, m, of
the int type. If the exception is thrown with this constructor, the method what
should return "Tornado: m miles away; and approaching!" (6, 7)
Write a C++ program to test the class tornadoException specified in
Exercise 20. (6, 7)
Suppose the exception class myException is defined as follows: (6, 7)
a.
b.

16.
17.
18.

19.
20.

21.

22.

class myException
{
public:
myException()
{
message = "myException thrown!";
cout << "Immediate attention required!"
<< endl;
}
myException(string msg)
{
message = msg;
cout << "Attention required!" << endl;
}
string what()
{
return message;
}
private:
string message;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
4

1038

| Chapter 14: Exception Handling

Suppose that in a user program, the catch block has the following form:
catch (myException mE)
{
cout << mE.what() << endl;
}

What output will be produced if the exception is thrown with the default constructor? Also, what output will be produced if the exception is thrown with the
constructor with parameters with the following actual parameter?
"May Day, May Day"
23.
24.
25.

If a function throws an exception, how does it specify that exception? (7)
Name three exception-handling techniques. (8)
Suppose an exception is thrown in a function. What are the three things the
function can do? (9)

PROGRAMMING EXERCISES
1.

2.

3.

4.

5.

Write a program that prompts the user to enter a length in feet and inches
and outputs the equivalent length in centimeters. If the user enters a negative
number or a nondigit number, throw and handle an appropriate exception
and prompt the user to enter another set of numbers.
Redo Programming Exercise 8 of Chapter 4 so that your program handles
exceptions such as division by zero and invalid input.
Redo Programming Exercise 7 of Chapter 7 so that your program handles
exceptions such as division by zero and invalid input.
Write a program that prompts the user to enter time in 12-hour notation.
The program then outputs the time in 24-hour notation. Your program
must contain three exception classes: invalidHr, invalidMin, and
invalidSec. If the user enters an invalid value for hours, then the program
should throw and catch an invalidHr object. Similar conventions for the
invalid values of minutes and seconds.
Write a program that prompts the user to enter a person’s date of birth in
numeric form such as 8-27-1980. The program then outputs the date of
birth in the form: August 27, 1980. Your program must contain at least two
exception classes: invalidDay and invalidMonth. If the user enters
an invalid value for day, then the program should throw and catch an
invalidDay object. Similar conventions for the invalid values of month
and year. (Note that your program must handle a leap year.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

15
CHAPTER

ª HunThomas/Shutterstock

R ECURSION
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about recursive definitions

2.

Explore the base case and the general case of a recursive definition

3.

Discover what a recursive algorithm is

4.

Learn about recursive functions

5.

Become familiar with direct and indirect recursion

6.

Explore how to use recursive functions to implement recursive algorithms

7.

Become aware of recursion vs. iteration

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1040

| Chapter 15: Recursion

In previous chapters, to devise solutions to problems, we used the most common technique
called iteration. For certain problems, however, using the iterative technique to obtain the
solution is quite complicated. This chapter introduces another problem-solving technique
called recursion and provides several examples demonstrating how recursion works.

Recursive Definitions
The process of solving a problem by reducing it to smaller versions of itself is called recursion.
Recursion is a very powerful way to solve certain problems for which the solution would
otherwise be very complicated. Let us consider a problem that is familiar to most everyone.
In mathematics, the factorial of a nonnegative integer is defined as follows:
0! ¼ 1
n! ¼ n  ðn  1Þ!

if

n>0

ð15-1Þ
ð15-2Þ

In this definition, 0! is defined to be 1, and if n is an integer greater than 0, first we find
(n  1)! and then multiply it by n. To find (n  1)!, we apply the definition again. If
(n  1) > 0, then we use Equation 15-2; otherwise, we use Equation 15-1. Thus, for an
integer n greater than 0, n! is obtained by first finding (n  1)! (that is, n! is reduced to a
smaller version of itself) and then multiplying (n  1)! by n.
Let us apply this definition to find 3!. Here, n = 3. Because n > 0, we use Equation 15-2
to obtain:
3! ¼ 3  2!
Next, we find 2! Here, n = 2. Because n > 0, we use Equation 15-2 to obtain:
2! ¼ 2  1!
Now, to find 1!, we again use Equation 15-2 because n = 1 > 0. Thus:
1! ¼ 1  0!
Finally, we use Equation 15-1 to find 0!, which is 1. Substituting 0! into 1! gives 1! = 1.
This gives 2! = 2  1! = 2  1 = 2, which, in turn, gives 3! = 3  2! = 3  2 = 6.
The solution in Equation 15-1 is direct—that is, the right side of the equation contains
no factorial notation. The solution in Equation 15-2 is given in terms of a smaller version
of itself. The definition of the factorial given in Equations 15-1 and 15-2 is called a
recursive definition. Equation 15-1 is called the base case (that is, the case for which
the solution is obtained directly); Equation 15-2 is called the general case.
Recursive definition: A definition in which something is defined in terms of a smaller

version of itself.
From the previous example (factorial), it is clear that:
1. Every recursive definition must have one (or more) base cases.
2. The general case must eventually be reduced to a base case.
3. The base case stops the recursion.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Recursive Definitions

|

1041

The concept of recursion in computer science works similarly. Here, we talk about
recursive algorithms and recursive functions. An algorithm that finds the solution to a
given problem by reducing the problem to smaller versions of itself is called a recursive
algorithm. The recursive algorithm must have one or more base cases, and the general
solution must eventually be reduced to a base case.
A function that calls itself is called a recursive function. That is, the body of the
recursive function contains a statement that causes the same function to execute again
before completing the current call. Recursive algorithms are implemented using recursive
functions.
Next, let us write the recursive function that implements the factorial function.
int fact(int num)
{
if (num == 0)
return 1;
else
return num * fact(num - 1);
}

Figure 15-1 traces the execution of the following statement:
cout << fact(3) << endl;

fact(3)
num

fact(3) = 6

3

because num != 0
return 3 * fact(2);
fact(2)

return 3 * 2
fact(2) = 2

num 2
because num != 0
return 2 * fact(1);
fact(1)

return 2 * 1

fact(1) = 1

num 1
because num != 0
return 1 * fact(0);

return 1 * 1

fact(0)
num 0
because num is 0
return 1;

FIGURE 15-1

fact(0) = 1
return 1

Execution of fact(3)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1042

| Chapter 15: Recursion

The output of the previous cout statement is:
6

In Figure 15-1, the down arrow represents the successive calls to the function fact, and the
upward arrows represent the values returned to the caller, that is, the calling function.
Let us note the following from the preceding example, involving the factorial function.
•

Logically, you can think of a recursive function as having an unlimited
number of copies of itself.
• Every call to a recursive function—that is, every recursive call—has its
own code and its own set of parameters and local variables.
• After completing a particular recursive call, control goes back to the
calling environment, which is the previous call. The current (recursive)
call must execute completely before control goes back to the previous
call. The execution in the previous call begins from the point immediately following the recursive call.

Direct and Indirect Recursion
A function is called directly recursive if it calls itself. A function that calls another
function and eventually results in the original function call is said to be indirectly
recursive. For example, if function A calls function B and function B calls function A,
then function A is indirectly recursive. Indirect recursion can be several layers deep. For
example, suppose that function A calls function B, function B calls function C, function C
calls function D, and function D calls function A. Function A is then indirectly recursive.
Indirect recursion requires the same careful analysis as direct recursion. The base cases
must be identified, and appropriate solutions to them must be provided. However,
tracing through indirect recursion can be tedious. You must, therefore, exercise extra
care when designing indirect recursive functions. For simplicity, the problems in this
book involve only direct recursion.
A recursive function in which the last statement executed is the recursive call is called a
tail recursive function. The function fact is an example of a tail recursive function.

Infinite Recursion
Figure 15-1 shows that the sequence of recursive calls eventually reached a call that made
no further recursive calls. That is, the sequence of recursive calls eventually reached a base
case. On the other hand, if every recursive call results in another recursive call, then the
recursive function (algorithm) is said to have infinite recursion. In theory, infinite
recursion executes forever. Every call to a recursive function requires the system to
allocate memory for the local variables and formal parameters. The system also saves this
information so that after completing a call, control can be transferred back to the right
caller. Therefore, because computer memory is finite, if you execute an infinite recursive

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Problem Solving Using Recursion |

1043

function on a computer, the function executes until the system runs out of memory and
results in an abnormal termination of the program.
Recursive functions (algorithms) must be carefully designed and analyzed. You must make
sure that every recursive call eventually reduces to a base case. This chapter provides several
examples that illustrate how to design and implement recursive algorithms.
To design a recursive function, you must do the following:
a. Understand the problem requirements.
b. Determine the limiting conditions. For example, for a list, the
limiting condition is the number of elements in the list.
c. Identify the base cases and provide a direct solution to each base case.
d. Identify the general cases and provide a solution to each general case
in terms of smaller versions of itself.

Problem Solving Using Recursion
Examples 15-1 through 15-3 illustrate how recursive algorithms are developed and
implemented in C++ using recursive functions.
E X A M P L E 1 5 - 1: L A R G E S T E L E M E N T I N A N A R R A Y
In Chapter 8, we used a loop to find the largest element in an array. In this example, we use a
recursive algorithm to find the largest element in an array. Consider the list given in Figure 15-2.

[0] [1] [2] [3] [4] [5] [6]
list

FIGURE 15-2

5

8

2

10

9

4

list with six elements

The largest element in the list in Figure 15-2 is 10.
Suppose list is the name of the array containing the list elements. Also, suppose that
list[a]...list[b] stands for the array elements list[a], list[a + 1], ..., and
list[b]. For example, list[0]...list[5] represents the array elements
list[0], list[1], list[2], list[3], list[4], and list[5]. Similarly,
list[1]...list[5] represents the array elements list[1], list[2], list[3],
list[4], and list[5]. To write a recursive algorithm to find the largest element in
list, let us think in terms of recursion.
If list is of length 1, then list has only one element, which is the largest element.
Suppose the length of list is greater than 1. To find the largest element in

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1044

| Chapter 15: Recursion

list[a]... list[b], we first find the largest element in list[a + 1]...list[b]
and then compare this largest element with list[a]. That is, the largest element in
list[a]...list[b] is given by:
maximum(list[a], largest(list[a + 1]...list[b]))

Let us apply this formula to find the largest element in the list shown in Figure 15-2. This list
has six elements, given by list[0]...list[5]. Now, the largest element in list is:
maximum(list[0], largest(list[1]...list[5]))

That is, the largest element in list is the maximum of list[0] and the largest element
in list[1]...list[5]. To find the largest element in list[1]...list[5], we use
the same formula again because the length of this list is greater than 1. The largest element
in list[1]...list[5] is then:
maximum(list[1], largest(list[2]...list[5]))

and so on. We see that every time we use the preceding formula to find the largest
element in a sublist, the length of the sublist in the next call is reduced by one.
Eventually, the sublist is of length 1, in which case the sublist contains only one element,
which is the largest element in the sublist. From this point onward, we backtrack through
the recursive calls. This discussion translates into the following recursive algorithm, which
is presented in pseudocode:
Base Case: The size of the list is 1
The only element in the list is the largest element

General Case: The size of the list is greater than 1
To find the largest element in list[a]...list[b]
a. Find the largest element in list[a + 1]...list[b]
and call it max
b. Compare the elements list[a] and max
if (list[a] >= max)
the largest element in list[a]...list[b] is list[a]
otherwise
the largest element in list[a]...list[b] is max

This algorithm translates into the following C++ function to find the largest element in
an array:
int largest(const int list[], int lowerIndex, int upperIndex)
{
int max;
if (lowerIndex == upperIndex) //size of the sublist is one
return list[lowerIndex];
else
{
max = largest(list, lowerIndex + 1, upperIndex);
if (list[lowerIndex] >= max)
return list[lowerIndex];
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Problem Solving Using Recursion |

1045

else
return max;

1
5

}
}

Consider the list given in Figure 15-3.

[0] [1] [2] [3]
list

FIGURE 15-3

5

10

12

8

list with four elements

Let us trace the execution of the following statement:
cout << largest(list, 0, 3) << endl;

Here, upperIndex = 3 and the list have four elements. Figure 15-4 traces the execution
of largest(list, 0, 3).

return 12

largest(list,0,3)
lowerIndex

0

upperIndex

3

max

max 12

because lowerIndex != upperIndex
max = largest(list,1,3)

because list[0] < max
return max
return 12

largest(list,1,3)
lowerIndex 1

upperIndex

3

max

max 12

because lowerIndex != upperIndex
max = largest(list,2,3)

because list[1] < max
return max
return 12

largest(list,2,3)
lowerIndex

2

upperIndex

3

max

max

because lowerIndex != upperIndex
max = largest(list,3,3)

8

because list[2] > max
return list[2]

largest(list,3,3)
lowerIndex

3

upperIndex

3

max

return 8

because lowerIndex == upperIndex
return list[3]

FIGURE 15-4

Execution of largest(list, 0, 3)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1046

| Chapter 15: Recursion

The value returned by the expression largest(list, 0, 3) is 12, which is the largest
element in list.
The following C++ program uses the function largest to determine the largest element
in a list.
//Largest Element in an Array
#include <iostream>
using namespace std;
int largest(const int list[], int lowerIndex, int upperIndex);
int main()
{
int intArray[10] = {23, 43, 35, 38, 67, 12, 76, 10, 34, 8};
cout << "The largest element in intArray: "
<< largest(intArray, 0, 9);
cout << endl;
return 0;
}
int largest(const int list[], int lowerIndex, int upperIndex)
{
int max;
if (lowerIndex == upperIndex) //size of the sublist is one
return list[lowerIndex];
else
{
max = largest(list, lowerIndex + 1, upperIndex);
if (list[lowerIndex] >= max)
return list[lowerIndex];
else
return max;
}
}

Sample Run:
The largest element in intArray: 76

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Problem Solving Using Recursion |

1047

E X A M P L E 1 5 - 2: F I B O N A C C I N U M B E R
In Chapter 5, we designed a program to determine the desired Fibonacci number. In
this example, we write a recursive function, rFibNum, to determine the desired
Fibonacci number. The function rFibNum takes as parameters three numbers representing the first two numbers of the Fibonacci sequence and a number n, the desired nth
Fibonacci number. The function rFibNum returns the nth Fibonacci number in the
sequence.
Recall that the third Fibonacci number is the sum of the first two Fibonacci numbers.
The fourth Fibonacci number in a sequence is the sum of the second and third Fibonacci
numbers. Therefore, to calculate the fourth Fibonacci number, we add the second
Fibonacci number and the third Fibonacci number (which is itself the sum of the first
two Fibonacci numbers). The following recursive algorithm calculates the nth Fibonacci
number, in which a denotes the first Fibonacci number, b the second Fibonacci number,
and n the nth Fibonacci number.
8
if n ¼ 1
<a
rFibNumða;b;nÞ ¼ b
if n ¼ 2 ð15-3Þ
:
rFibNumða;b;n  1Þ þ rFibNumða;b;n  2Þ if n > 2:
Suppose that we want to determine:
rFibNum(2, 5, 4)

Here, a = 2, b = 5, and n = 4. That is, we want to determine the fourth Fibonacci
number of the sequence whose first number is 2 and whose second number is 5.
Because n is 4 > 2:
1. rFibNum(2, 5, 4) = rFibNum(2, 5, 3) + rFibNum(2, 5, 2)
Next, we determine rFibNum(2, 5, 3) and rFibNum(2, 5, 2). Let us
first determine rFibNum(2, 5, 3). Here, a = 2, b = 5, and n is 3.
Because n is 3:
1.a.

rFibNum(2, 5, 3) = rFibNum(2, 5, 2) + rFibNum(2, 5, 1)

This statement requires us to determine rFibNum(2, 5, 2) and
rFibNum(2, 5, 1). In rFibNum(2, 5, 2), a = 2, b = 5, and n = 2.
Therefore, from the definition given in Equation 15-3, it follows
that:
1.a.1. rFibNum(2, 5, 2) = 5
To find rFibNum(2, 5, 1), note that a = 2, b = 5, and n = 1.
Therefore, by the definition given in Equation 15-3:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1048

| Chapter 15: Recursion

1.a.2. rFibNum(2, 5, 1) = 2
We substitute the values of rFibNum(2, 5, 2) and
rFibNum(2, 5, 1) into (1.a) to get:
rFibNum(2, 5, 3) = 5 + 2 = 7

Next, we determine rFibNum(2, 5, 2). As in (1.a.1), rFibNum(2,
5, 2) = 5. We can substitute the values of rFibNum(2, 5, 3) and
rFibNum(2, 5, 2) into (1) to get:
rFibNum(2, 5, 4) = 7 + 5 = 12

The following recursive function implements this algorithm:
int rFibNum(int a, int b, int n)
{
if (n == 1)
return a;
else if (n == 2)
return b;
else
return rFibNum(a, b, n - 1) + rFibNum(a, b, n - 2);
}

Let us trace the execution of the following statement:
cout << rFibNum(2, 3, 5) << endl;

In this statement, the first number is 2, the second number is 3, and we want to determine
the fifth Fibonacci number of the sequence. Figure 15-5 traces the execution of the
expression rFibNum(2,3,5). The value returned is 13, which is the fifth Fibonacci
number of the sequence whose first number is 2 and second number is 3.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Problem Solving Using Recursion |

b 3

1
5

return 13

rFibNum(2,3,5)
a 2

1049

5

n

return rFibNum(2,3,4) + rFibNum(2,3,3)

return 5
return 8
rFibNum(2,3,3)

rFibNum(2,3,4)
a 2

b 3

n

4

a 2

b 3

n

3

return rFibNum(2,3,3) + rFibNum(2,3,2) return rFibNum(2,3,2) + rFibNum(2,3,1)

rFibNum(2,3,3)
a 2

b 3

n

rFibNum(2,3,2)

3

a 2

return rFibNum(2,3,2) + rFibNum(2,3,1)

return 3
rFibNum(2,3,2)
a 2

b 3

return b

FIGURE 15-5

return 3

return 3

return 5

b 3

return b

n 2

return 2

rFibNum(2,3,2)

rFibNum(2,3,1)

a 2

a 2

b 3

return b

n 2

b 3

n 1

return a

return 2
rFibNum(2,3,1)
a 2

n 2

b 3

n 1

return a

Execution of rFibNum(2, 3, 5)

The following C++ program uses the function rFibNum:
//Chapter 15: Fibonacci Number
#include <iostream>
using namespace std;
int rFibNum(int a, int b, int n);
int main()
{
int firstFibNum;
int secondFibNum;
int nth;
cout << "Enter the first Fibonacci number: ";
cin >> firstFibNum;
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1050

| Chapter 15: Recursion

cout << "Enter the second Fibonacci number: ";
cin >> secondFibNum;
cout << endl;
cout << "Enter the position of the desired Fibonacci number: ";
cin >> nth;
cout << endl;
cout << "The Fibonacci number at position " << nth
<< " is: " << rFibNum(firstFibNum, secondFibNum, nth)
<< endl;
return 0;
}
int rFibNum(int a, int b, int n)
{
if (n == 1)
return a;
else if (n == 2)
return b;
else
return rFibNum(a, b, n - 1) + rFibNum(a, b, n - 2);
}

Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1
Enter the first Fibonacci number: 2
Enter the second Fibonacci number: 5
Enter the position of the desired Fibonacci number: 6
The Fibonacci number at position 6 is: 31

Sample Run 2
Enter the first Fibonacci number: 12
Enter the second Fibonacci number: 18
Enter the position of the desired Fibonacci number: 15
The Fibonacci number at position 15 is: 9582

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Problem Solving Using Recursion |

1051

E X A M P L E 1 5 - 3: T O W E R O F H A N O I
In the nineteenth century, a game called the Tower of Hanoi became popular in Europe.
This game represents work that is under way in the temple of Brahma. At the creation of
the universe, priests in the temple of Brahma were supposedly given three diamond
needles, with one needle containing 64 golden disks. Each golden disk is slightly smaller
than the disk below it. The priests’ task is to move all 64 disks from the first needle to the
third needle. The rules for moving the disks are as follows:
1. Only one disk can be moved at a time.
2. The removed disk must be placed on one of the needles.
3. A larger disk cannot be placed on top of a smaller disk.
The priests were told that once they had moved all of the disks from the first needle to the
third needle, the universe would come to an end.
Our objective is to write a program that prints the sequence of moves needed to transfer
the disks from the first needle to the third needle. Figure 15-6 shows the Tower of Hanoi
problem with three disks.

1
2
3

FIGURE 15-6

Tower of Hanoi problem with three disks

As before, we think in terms of recursion. Let us first consider the case in which the
first needle contains only one disk. In this case, the disk can be moved directly from
needle 1 to needle 3. So let us consider the case in which the first needle contains
only two disks. In this case, first we move the first disk from needle 1 to needle 2,
and then we move the second disk from needle 1 to needle 3. Finally, we move the
first disk from needle 2 to needle 3. Next, we consider the case in which the first
needle contains three disks and then generalize this to the case of 64 disks (in fact, to
an arbitrary number of disks).
Suppose that needle 1 contains three disks. To move disk number 3 to needle 3, the top
two disks must first be moved to needle 2. Disk number 3 can then be moved from
needle 1 to needle 3. To move the top two disks from needle 2 to needle 3, we use the
same strategy as before. This time, we use needle 1 as the intermediate needle. Figure 15-7
shows a solution to the Tower of Hanoi problem with three disks.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1052

| Chapter 15: Recursion

1
2
3

2
3

2
3

1

(a) Move 1: Move disk 1 from needle 1 to needle 3

3

2

1

3

1
2

3

3

1

2

3

(e) Move 5: Move disk 1 from needle 2 to needle 1

1

2
3

3

2

1

1
2

1
2

3

(d) Move 4: Move disk 3 from needle 1 to needle 3

(c) Move 3: Move disk 1 from needle 3 to needle 2

1
2

1

(b) Move 2: Move disk 2 from needle 1 to needle 2

1

2

3

1

2
3

(f) Move 6: Move disk 2 from needle 2 to needle 3

1
2
3

(g) Move 7: Move disk 1 from needle 1 to needle 3

FIGURE 15-7

Solution to Tower of Hanoi problem with three disks

Let us now generalize this problem to the case of 64 disks. To begin, the first needle
contains all 64 disks. Disk number 64 cannot be moved from needle 1 to needle 3
unless the top 63 disks are on the second needle. So first, we move the top 63 disks
from needle 1 to needle 2, and then we move disk number 64 from needle 1 to
needle 3. Now the top 63 disks are all on needle 2. To move disk number 63 from
needle 2 to needle 3, we first move the top 62 disks from needle 2 to needle 1, and
then we move disk number 63 from needle 2 to needle 3. To move the remaining
62 disks, we use a similar procedure. This discussion translates into the following
recursive algorithm given in pseudocode. Suppose that needle 1 contains n disks, in
which n  1.
1. Move the top n  1 disks from needle 1 to needle 2, using needle 3 as
the intermediate needle.
2. Move disk number n from needle 1 to needle 3.
3. Move the top n  1 disks from needle 2 to needle 3, using needle 1 as
the intermediate needle.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Recursion or Iteration?

|

1053

This recursive algorithm translates into the following C++ function:
void moveDisks(int count, int needle1, int needle3, int needle2)
{
if (count > 0)
{
moveDisks(count - 1, needle1, needle2, needle3);
cout << "Move disk " << count << " from " << needle1
<< " to " << needle3 << "." << endl;
moveDisks(count - 1, needle2, needle3, needle1);
}
}

Tower of Hanoi: Analysis
Let us determine how long it would take to move all 64 disks from needle 1 to needle 3.
If needle 1 contains three disks, then the number of moves required to move all three
disks from needle 1 to needle 3 is 23  1 = 7. Similarly, if needle 1 contains 64 disks, then
the number of moves required to move all 64 disks from needle 1 to needle 3 is 264  1.
Because 210 ¼ 1024  1000 ¼ 103 , we have:
264 ¼ 24  260  24  1018 ¼ 1:6  1019
The number of seconds in one year is approximately 3.2  107. Suppose the priests move
one disk per second and they do not rest. Now:
1:6  1019 ¼ 5  3:2  1018 ¼ 5  ð3:2  107 Þ  1011 ¼ ð3:2  107 Þ  ð5  1011 Þ
The time required to move all 64 disks from needle 1 to needle 3 is roughly 5  1011
years. It is estimated that our universe is about 15 billion years old (1.5  1010). Also,
5  1011 = 50  1010  33  (1.5  1010). This calculation shows that our universe
would last about 33 times as long as it already has.
Assume that a computer can generate 1 billion (109) moves per second. Then the number
of moves that the computer can generate in one year is:
ð3:2  107 Þ  109 ¼ 3:2  1016
So the computer time required to generate 264 moves is:
264  1:6  1019 ¼ 1:6  1016  103 ¼ ð3:2  1016 Þ  500
Thus, it would take about 500 years for the computer to generate 264 moves at the rate of
1 billion moves per second.

Recursion or Iteration?
In Chapter 5, we designed a program to determine a desired Fibonacci number. That
program used a loop to perform the calculation. In other words, the programs in Chapter
5 used an iterative control structure to repeat a set of statements. More formally, iterative
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1054

| Chapter 15: Recursion

control structures use a looping structure, such as while, for, or do. . .while, to
repeat a set of statements. In Example 15-2, we designed a recursive function to calculate
a Fibonacci number. From the examples here, it follows that in recursion, a set of
statements is repeated by having the function call itself. Moreover, a selection control
structure is used to control the repeated calls in recursion.
Similarly, in Chapter 8, we used an iterative control structure (a for loop) to determine
the largest element in a list. In this chapter, we use recursion to determine the largest
element in a list. In addition, this chapter began by designing a recursive function to find
the factorial of a nonnegative integer. Using an iterative control structure, we can also
write an algorithm to find the factorial of a nonnegative integer. The only reason to give a
recursive solution to a factorial problem is to illustrate how recursion works.
We thus see that there are usually two ways to solve a particular problem—iteration and
recursion. The obvious question is which method is better—iteration or recursion? There
is no simple answer. In addition to the nature of the problem, the other key factor in
determining the best solution method is efficiency.
Example 6-13 (Chapter 6), while tracing the execution of the problem, showed us that
whenever a function is called, memory space for its formal parameters and (automatic)
local variables is allocated. When the function terminates, that memory space is then
deallocated.
This chapter, while tracing the execution of recursive functions, also shows us that
every (recursive) call has its own set of parameters and (automatic) local variables. That
is, every (recursive) call requires the system to allocate memory space for its formal
parameters and (automatic) local variables and then deallocate the memory space when
the function exits. Thus, there is overhead associated with executing a (recursive)
function both in terms of memory space and computer time. Therefore, a recursive
function executes more slowly than its iterative counterpart. On slower computers,
especially those with limited memory space, the (slow) execution of a recursive
function would be visible.
Today’s computers, however, are fast and have inexpensive memory. Therefore, the
execution of a recursion function is not noticeable. Keeping the power of today’s
computers in mind, the choice between the two alternatives—iteration or recursion—
depends on the nature of the problem. Of course, for problems such as mission control
systems, efficiency is absolutely critical and, therefore, the efficiency factor would dictate
the solution method.
As a general rule, if you think that an iterative solution is more obvious and easier to
understand than a recursive solution, use the iterative solution, which would be more
efficient. On the other hand, problems exist for which the recursive solution is more
obvious or easier to construct, such as the Tower of Hanoi problem. (In fact, it turns out
that it is difficult to construct an iterative solution for the Tower of Hanoi problem.)
Keeping the power of recursion in mind, if the definition of a problem is inherently
recursive, then you should consider a recursive solution.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Converting a Number from Binary to Decimal |

PROGRAMMING EXAMPLE:

Watch
the Video

1055

Converting a Number from Binary to
Decimal

In Chapter 1, we explained that the language of a computer, called machine
language, is a sequence of 0s and 1s. When you press the key A on the keyboard,
01000001 is stored in the computer. Also, you know that the collating sequence of A
in the ASCII character set is 65. In fact, the binary representation of A is 01000001,
and the decimal representation of A is 65.
The numbering system we use is called the decimal system, or base 10 system. The
numbering system that the computer uses is called the binary system, or base 2
system. In this and the next programming example, we discuss how to convert a
number from base 2 to base 10 and from base 10 to base 2.

Binary to To convert a number from base 2 to base 10, we first find the weight of each bit in
Decimal the binary number. The weight of each bit in the binary number is assigned from

right to left. The weight of the rightmost bit is 0. The weight of the bit immediately
to the left of the rightmost bit is 1, the weight of the bit immediately to the left of it is
2, and so on. Consider the binary number 1001101. The weight of each bit is as
follows:
Weight 6 5 4 3 2 1 0
1 0 0 1 1 0 1
We use the weight of each bit to find the equivalent decimal number. For each bit,
we multiply the bit by 2 to the power of its weight and then we add all of the
numbers. For the above binary number, the equivalent decimal number is:
1  26 þ 0  25 þ 0  24 þ 1  23 þ 1  22 þ 0  21 þ 1  20
¼ 64 þ 0 þ 0 þ 8 þ 4 þ 0 þ 1
¼ 77
To write a program that converts a binary number into the equivalent decimal
number, we note two things: (1) the weight of each bit in the binary number must
be known, and (2) the weight is assigned from right to left. Because we do not
know in advance how many bits are in the binary number, we must process the bits
from right to left. After processing a bit, we can add 1 to its weight, giving the
weight of the bit immediately to the left of it. Also, each bit must be extracted from
the binary number and multiplied by 2 to the power of its weight. To extract a bit,
we can use the mod operator. Consider the following recursive algorithm, which is
given in pseudocode:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1056

| Chapter 15: Recursion

if (binaryNumber > 0)
{
bit = binaryNumber % 10;
//extract the rightmost bit
decimal = decimal + bit * power(2, weight);
binaryNumber = binaryNumber / 10; //remove the rightmost
//bit
weight++;
convert the binaryNumber into decimal
}

This algorithm assumes that the memory locations decimal and weight have been
initialized to 0 before using the algorithm. This algorithm translates to the following
C++ recursive function:
void binToDec(int binaryNumber, int& decimal, int& weight)
{
int bit;
if (binaryNumber > 0)
{
bit = binaryNumber % 10;
decimal = decimal
+ bit * static_cast<int>(pow(2.0, weight));
binaryNumber = binaryNumber / 10;
weight++;
binToDec(binaryNumber, decimal, weight);
}
}

In this function, both decimal and weight are reference parameters. The actual
parameters corresponding to these parameters are initialized to 0. After extracting the
rightmost bit, this function updates the decimal number and the weight of the next
bit. Suppose decimalNumber and bitWeight are int variables. Consider the
following statements:
decimalNumber = 0;
bitWeight = 0;
binToDec(1101, decimalNumber, bitWeight);

Figure 15-8 traces the execution of the last statement, that is, binToDec(1101,
decimalNumber, bitWeight);. It shows the content of the variables
decimalNumber and bitWeight next to each function call.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Converting a Number from Binary to Decimal |

1057

binToDec(1101,decimalNumber,bitWeight)
before call
decimalNumber
bitWeight

binaryNumber 1101
0
0

bit

because binaryNumber > 0
bit = 1101 % 10 = 1;
decimal = 0 + 1 * 20 = 1;
weight = 1;
binaryNumber = 1101 / 10 = 110;
binToDec(110,decimal,weight);
binToDec(110,decimal,weight)

before call
decimalNumber
bitWeight

binaryNumber

110

bit

because binaryNumber > 0
bit = 110 % 10 = 0;
decimal = 1 + 0 * 21 = 1;
weight = 2;
binaryNumber = 110 / 10 = 11;
binToDec(11,decimal,weight);

1
1

binToDec(11,decimal,weight)
before call
decimalNumber
bitWeight

1
2

binaryNumber 11
bit
because binaryNumber > 0
bit = 11 % 10 = 1;
decimal = 1 + 1 * 22 = 5;
weight = 3;
binaryNumber = 11 / 10 = 1;
binToDec(1,decimal,weight);
binToDec(1,decimal,weight)

before call
decimalNumber
bitWeight

binaryNumber
5
3

1

bit

because binaryNumber > 0
bit = 1 % 10 = 1;
decimal = 5 + 1 * 23 = 13;
weight = 4;
binaryNumber = 1 / 10 = 0;
binToDec(0,decimal,weight);
binToDec(0,decimal,weight)

before call
decimalNumber
bitWeight

FIGURE 15-8

binaryNumber
13
4

0

bit

because binaryNumber is 0
the if statement fails and this
call exits

Execution of binToDec(1101, decimalNumber, bitWeight);

In Figure 15-8, each down arrow represents the successive function call. Because the
last statement of the function binToDec is a function call, after this statement
executes, nothing happens. After the statement:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1058

| Chapter 15: Recursion

binToDec(1101, decimalNumber, bitWeight);

executes, the value of the variable decimalNumber is 13.
The following C++ program tests the function binToDec:
//******************************************************
// Author: D. S. Malik
//
// Program: Binary to decimal
// This program uses recursion to find the decimal
// representation of a binary number.
//******************************************************
#include <iostream>
#include <cmath>
using namespace std;
void binToDec(int binaryNumber, int& decimal, int& weight);
int main()
{
int decimalNumber;
int bitWeight;
int binaryNum;
decimalNumber = 0;
bitWeight = 0;
cout << "Enter number in binary: ";
cin >> binaryNum;
cout << endl;
binToDec(binaryNum, decimalNumber, bitWeight);
cout << "Binary " << binaryNum << " = " << decimalNumber
<< " decimal" << endl;
return 0;
}
void binToDec(int binaryNumber, int& decimal, int& weight)
{
int bit;
if (binaryNumber > 0)
{
bit = binaryNumber % 10;
decimal = decimal
+ bit * static_cast<int>(pow(2.0, weight));
binaryNumber = binaryNumber / 10;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Converting a Number from Decimal to Binary

|

1059

weight++;
binToDec(binaryNumber, decimal, weight);
}
}

Sample Run: In this sample run, the user input is shaded.
Enter a number in binary: 11010110
Binary 11010110 = 214 decimal

PROGRAMMING EXAMPLE:

Converting a Number from Decimal to
Binary

The previous programming example discussed and designed a program to convert a
number from a binary representation to a decimal format—that is, from base 2 to base
10. This programming example discusses and designs a program that uses recursion to
convert a nonnegative integer in decimal format—that is, base 10—into the equivalent binary number—that is, base 2. First, we define some terms.
Let x be an integer. We call the remainder of x after division by 2 the rightmost bit of x.
Thus, the rightmost bit of 33 is 1 because 33 % 2 is 1, and the rightmost bit of 28 is 0
because 28 % 2 is 0.
We first illustrate the algorithm to convert an integer in base 10 to the equivalent
number in binary format, with the help of an example.
Suppose we want to find the binary representation of 35. First, we divide 35 by 2. The
quotient is 17, and the remainder—that is, the rightmost bit of 35—is 1. Next, we
divide 17 by 2. The quotient is 8, and the remainder—that is, the rightmost bit of 17—
is 1. Next, we divide 8 by 2. The quotient is 4, and the remainder—that is, the
rightmost bit of 8—is 0. We continue this process until the quotient becomes 0.
The rightmost bit of 35 cannot be printed until we have printed the rightmost bit of
17. The rightmost bit of 17 cannot be printed until we have printed the rightmost bit
of 8, and so on. Thus, the binary representation of 35 is the binary representation of
17 (that is, the quotient of 35 after division by 2), followed by the rightmost bit of 35.
Thus, to convert an integer num in base 10 into the equivalent binary number, we
first convert the quotient num / 2 into an equivalent binary number and then append
the rightmost bit of num to the binary representation of num / 2.
This discussion translates into the following recursive algorithm, in which binary(num)
denotes the binary representation of num.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1060

| Chapter 15: Recursion

1. binary(num) = num if num = 0.
2. binary(num) = binary(num / 2) followed by num % 2 if num > 0.
The following recursive function implements this algorithm:
void decToBin(int num, int base)
{
if (num > 0)
{
decToBin(num / base, base);
cout << num % base;
}
}

Figure 15-9 traces the execution of the following statement:
decToBin(13, 2);

in which num is 13 and base is 2.
decToBin(13,2)
Call 1

num 13

execute
cout << 13 % 2;

base 2

because num > 0
decToBin(13/2,2);

Output: 1

decToBin(6,2)
num 6

base 2

Call 2 because num > 0
decToBin(6/2,2);

execute
cout << 6 % 2;
Output: 0

decToBin(3,2)
Call 3

num 3

base 2

because num > 0
decToBin(3/2,2);

execute
cout << 3 % 2;
Output: 1

decToBin(1,2)
num 1

base 2
Call 4 because num > 0
decToBin(1/2,2);

execute
cout << 1 % 2;
Output: 1

decToBin(0,2)
Call 5

FIGURE 15-9

num 0

base 2

because num is 0
exit this call

Execution of decToBin(13, 2)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Converting a Number from Decimal to Binary

|

1061

Because the if statement in call 5 fails, this call does not print anything. The first
output is produced by call 4, which prints 1; the second output is produced by call 3,
which prints 1; the third output is produced by call 2, which prints 0; and the fourth
output is produced by call 1, which prints 1. Thus, the output of the statement:
decToBin(13, 2);

is:
1101

The following C++ program tests the function decToBin.
//******************************************************
// Author: D. S. Malik
//
// Program: Decimal to binary
// This program uses recursion to find the binary
// representation of a nonnegative integer.
//******************************************************
#include <iostream>
using namespace std;
void decToBin(int num, int base);
int main()
{
int decimalNum;
int base;
base = 2;
cout << "Enter number in decimal: ";
cin >> decimalNum;
cout << endl;
cout << "Decimal " << decimalNum << " = ";
decToBin(decimalNum, base);
cout << " binary" << endl;
return 0;
}
void decToBin(int num, int base)
{
if (num > 0)
{
decToBin(num / base, base);
cout << num % base;
}
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1062

| Chapter 15: Recursion

Sample Run: In this sample run, the user input is shaded.
Enter a number in decimal: 57
Decimal 57 = 111001 binary

QUICK REVIEW
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.

The process of solving a problem by reducing it to smaller versions of itself
is called recursion.
A recursive definition defines a problem in terms of smaller versions of itself.
Every recursive definition has one or more base cases.
A recursive algorithm solves a problem by reducing it to smaller versions of itself.
Every recursive algorithm has one or more base cases.
The solution to the problem in a base case is obtained directly.
A function is called recursive if it calls itself.
Recursive algorithms are implemented using recursive functions.
Every recursive function must have one or more base cases.
The general solution breaks the problem into smaller versions of itself.
The general case must eventually be reduced to a base case.
The base case stops the recursion.
While tracing a recursive function:
•

14.
15.
16.
17.

Logically, you can think of a recursive function as having an unlimited
number of copies of itself.
• Every call to a recursive function—that is, every recursive call—has its
own code and its own set of parameters and local variables.
• After completing a particular recursive call, control goes back to the
calling environment, which is the previous call. The current (recursive)
call must execute completely before control goes back to the previous
call. The execution in the previous call begins from the point immediately following the recursive call.
A function is called directly recursive if it calls itself.
A function that calls another function and eventually results in the original
function call is said to be indirectly recursive.
A recursive function in which the last statement executed is the recursive
call is called a tail recursive function.
To design a recursive function, you must do the following:
a.
b.

Understand the problem requirements.
Determine the limiting conditions. For example, for a list, the limiting
condition is the number of elements in the list.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

c.
d.

|

1063

Identify the base cases and provide a direct solution to each base case.
Identify the general cases and provide a solution to each general case in
terms of smaller versions of itself.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

2.
3.
4.
5.
6.
7.

Mark the following statements as true or false.
a. A recursive solution of a problem reduces the problem into smaller
versions of itself. (1)
b. Every recursive definition must have one or more base cases. (2)
c. The general case stops the recursion. (2, 3)
d. In the general case, the solution to the problem is obtained directly. (2, 3)
e. It is not necessary for a recursive function to have a base case because
the general case provides the solution. (2, 4)
f.
A recursive function always returns a value. (4)
g. Every call to a recursive function has its own code and its own set of
parameters and local variables. (4)
h. A function that calls itself is called directly recursive. (5)
What is a base case? (2)
What is a recursive case? (2)
What is direct recursion? (5)
What is indirect recursion? (5)
What is tail recursion? (1, 5)
Consider the following recursive function: (2, 3, 4, 6)
int mystery(int number)
{
if (number == 0)
return number;
else
return(mystery(number + 1) - number);
}
a.
b.
c.
d.
e.
f.

//Line 1
//Line
//Line
//Line
//Line

2
3
4
5

Identify the base case.
Identify the general case.
What valid values can be passed as parameters to the function mystery?
If mystery(0) is a valid call, what is its value? If not, explain why.
If mystery(10) is a valid call, what is its value? If not, explain why.
If mystery(-3) is a valid call, what is its value? If not, explain why.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1064

8.

| Chapter 15: Recursion

Consider the following recursive function: (2, 3, 4, 6)
void funcRec(int u, char v)
{
if (u == 0)
cout << v;
else
{
char w;
w = static_cast<char>
(static_cast<int>(v) + 1);
funcRec(u - 1, w);
}
}

//Line 1
//Line
//Line
//Line
//Line
//Line

2
3
4
5
6

//Line
//Line
//Line
//Line

7
8
9
10

Answer the following questions:
a.
b.
c.

Identify the base case.
Identify the general case.
What is the output of the following statement?
funcRec(5, 'A');

9.

Consider the following recursive function:
void recFun(int x)
{
if (x > 0)
{
cout << x % 10 << " ";
recFun(x / 10);
}
else if (x != 0)
cout << x << endl;
}

What is the output of the following statements? (4, 6)
a. recFun(258); b. recFun(7); c. recFun(36); d. recFun(-85);
10.

Consider the following recursive function:
void recFun(int u)
{
if (u == 0)
cout << "Zero! ";
else
{
cout << "Negative ";
recFun(u + 1);
}
}

What is the output, if any, of the following statements? (4, 6)
a.

recFun(8); b.

recFun(0); c.

recFun(-2);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

11.

|

1065

Consider the following recursive function:
void exercise(int x)
{
if (x > 0 && x < 10)
{
cout << x << " ";
exercise(x + 1);
}
}

What is the output of the following statements? (4, 6)
a. exercise(0); b. exercise(5); c. exercise(10); d. exercise(-5);
12.

Consider the following function:
int test(int x, int y)
{
if (x <= y)
return y - x;
else
return test(x - 1, y + 1);
}

What is the output of the following statements? (4, 6)

13.

a.

cout << test(3, 100) << endl;

b.

cout << test(15, 7) << endl;

Consider the following function:
int func(int x)
{
if (x == 0)
return 2;
else if (x == 1)
return 3;
else
return (func(x - 1) + func(x - 2));
}

What is the output of the following statements? (4, 6)

14.

a.

cout << func(0) << endl;

b.

cout << func(1) << endl;

c.

cout << func(2) << endl;

d.

cout << func(5) << endl;

Consider the following recursive function:
void recFun(int x, int y)
{
if (x > 0 && y > 0)
{

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1066

| Chapter 15: Recursion

if (x >= y && y != 0)
{
cout << x % y << " ";
recFun(x - y, y);
}
else if (y > x && x != 0)
{
cout << y % x << " ";
recFun(y - x, x);
}
}
else
cout << x + y << endl;
}

What is the output of the following statements? (4, 6)
a. recFun(180, 38); b. recFun(75, 26); c. recFun(13, 86);
d. recFun(56, 148);
15.

Consider the following function:
int test(int x, int y)
{
if (abs(x - y) <= 1)
return x + y;
else if (x > y)
return test(x - 1, y + 1);
else if (y > x)
return test(x + 1, y - 1);
}

What is the output of the following statements? (4, 6)

16.

17.

a.

cout << test(8, 2) << endl;

b.

cout << test(5, 16) << endl;

c.

cout << test(-25, 2) << endl;

d.

cout << test(8, -6) << endl;

e.

cout << test(-20, -36) << endl;

Suppose that intArray is an array of integers, and length specifies the
number of elements in intArray. Also, suppose that low and high are two
integers such that 0 <= low < length, 0 <= high < length, and low <
high. That is, low and high are two indices in intArray. Write a
recursive definition that reverses the elements in intArray between low
and high. (2, 3, 4, 6)
Write a recursive algorithm to multiply two positive integers m and n using
repeated addition. Specify the base case and the general case. (2, 3, 4, 6)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

18.

|

1067

Consider the following problem: How many ways can a committee of four
people be selected from a group of 10 people? There are many other similar
problems in which you are asked to find the number of ways to select a set
of items from a given set of items. The general problem can be stated as
follows: Find the number of ways r different things can be chosen from a set
of n items, in which r and n are nonnegative integers and r  n. Suppose
C(n, r) denotes the number of ways r different things can be chosen from a
set of n items. Then, C(n, r) is given by the following formula:
n!
Cðn;rÞ ¼
r!ðn  rÞ!
in which the exclamation point denotes the factorial function. Moreover,
C(n, 0) = C(n, n) = 1. It is also known that C(n, r) = C(n – 1, r – 1) + C(n – 1, r).
(2, 3, 4, 6)
a.

b.

Write a recursive algorithm to determine C(n, r). Identify the base
case(s) and the general case(s).
Using your recursive algorithm, determine C(5, 3) and C(9, 4).

PROGRAMMING EXERCISES
1.

Write a recursive function that takes as a parameter a nonnegative integer
and generates the following pattern of stars. If the nonnegative integer is 4,
then the pattern generated is:
****
***
**
*
*
**
***
****

2.

Also, write a program that prompts the user to enter the number of lines in
the pattern and uses the recursive function to generate the pattern. For
example, specifying 4 as the number of lines generates the above pattern.
Write a recursive function to generate the following pattern of stars:
*
* *
* * *
* * * *
* * *
* *
*

Also, write a program that prompts the user to enter the number of lines in
the pattern and uses the recursive function to generate the pattern. For
example, specifying 4 as the number of lines generates the above pattern.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1068

3.

4.

5.

6.

7.

8.

9.

10.

11.

12.

| Chapter 15: Recursion

Write a recursive function, vowels, that returns the number of vowels in a
string. Also, write a program to test your function.
Write a recursive function named sumSquares that returns the sum of the
squares of the numbers from 0 to num, in which num is a nonnegative int
variable. Do not use global variables; use the appropriate parameters. Also
write a program to test your function.
Write a recursive function that finds and returns the sum of the elements of
an int array. Also, write a program to test your function.
A palindrome is a string that reads the same both forward and backward. For
example, the string "madam" is a palindrome. Write a program that uses a
recursive function to check whether a string is a palindrome. Your program
must contain a value-returning recursive function that returns true if the
string is a palindrome and false otherwise. Do not use any global variables;
use the appropriate parameters.
Write a recursive function that returns both the smallest and the largest
element in an int array. Also, write a program to test your function.
Write a recursive function that returns true if the digits of a positive integer
are in increasing order; otherwise, the function returns false. Also, write a
program to test your function.
Write a recursive function, reverseDigits, that takes an integer as a
parameter and returns the number with the digits reversed. Also, write a
program to test your function.
Write a recursive function, sumDigits, that takes an integer as a parameter
and returns the sum of the digits of the integer. Also, write a program to test
your function.
Write a recursive function, power, that takes as parameters two integers x
and y such that x is nonzero and returns xy. You can use the following
recursive definition to calculate xy. If y  0:
8
if y ¼ 0
<1
powerðx; yÞ ¼ x
if y ¼ 1
:
x  powerðx; y  1Þ if y > 1:
If y < 0:
1
:
powerðx; yÞ ¼
powerðx; yÞ
Also, write a program to test your function.
(Greatest Common Divisor) Given two integers x and y, the following
recursive definition determines the greatest common divisor of x and y,
written gcd(x,y):

x
if y ¼ 0
gcdðx; yÞ ¼
gcdðy; x%yÞ if y 6¼ 0
Note: In this definition, % is the mod operator.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

13.

14.

15.

16.

17.

18.

|

1069

Write a recursive function, gcd, that takes as parameters two integers and
returns the greatest common divisor of the numbers. Also, write a program
to test your function.
(Ackermann’s Function) The Ackermann’s function is defined as follows:
8
if m ¼ 0
< n þ 1;
Aðm; nÞ ¼ Aðm  1; 1Þ;
if n ¼ 0
:
Aðm  1; Aðm; n  1ÞÞ; otherwise;
in which m and n are nonnegative integers. Write a recursive function to
implement Ackermann’s function. Also write a program to test your function.
What happens when you call the function with m ¼ 4 and n ¼ 3?
Write a recursive function to implement the recursive algorithm of Exercise
16 (reversing the elements of an array between two indices). Also, write a
program to test your function.
Write a recursive function to implement the recursive algorithm of Exercise
17 (multiplying two positive integers using repeated addition). Also, write a
program to test your function.
Write a recursive function to implement the recursive algorithm of Exercise
18 (determining the number of ways to select a set of things from a given set
of things). Also, write a program to test your function.
(Recursive Sequential Search) The sequential search algorithm given in
Chapter 8 is nonrecursive. Write and implement a recursive version of the
sequential search algorithm.
In the Programming Example, Converting a Number from Decimal to Binary,
given in this chapter, you learned how to convert a decimal number into the
equivalent binary number. Two more number systems, octal (base 8) and
hexadecimal (base 16), are of interest to computer scientists. In fact, in C++,
you can instruct the computer to store a number in octal or hexadecimal.
(Appendix C describes these number systems.)
The digits in the octal number system are 0, 1, 2, 3, 4, 5, 6, and 7. The digits
in the hexadecimal number system are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D,
E, and F. So A in hexadecimal is 10 in decimal, B in hexadecimal is 11 in
decimal, and so on.
The algorithm to convert a positive decimal number into an equivalent number
in octal (or hexadecimal) is the same as discussed for binary numbers. Here, we
divide the decimal number by 8 (for octal) and by 16 (for hexadecimal). Suppose
ab represents the number a to the base b. For example, 7510 means 75 to the base
10 (that is decimal), and 8316 means 83 to the base 16 (that is, hexadecimal). Then
75310 = 13618 and 75310 = 2F116.
Write a program that uses a recursive function to convert a number in decimal
to base 8 or base 16.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
5

1070

19.

| Chapter 15: Recursion

The function sqrt from the header file cmath can be used to find the square
root of a nonnegative real number. Using Newton’s method, you can also write
an algorithm to find the square root of a nonnegative real number within a
given tolerance as follows: Suppose x is a nonnegative real number, a is the
approximate square root of x, and epsilon is the tolerance. Start with a = x.
a.

b.

If |a2  x|  epsilon, then a is the square root of x within the tolerance;
otherwise:
Replace a with (a2 + x) / (2a) and repeat Step a
in which |a2  x| denotes the absolute value of a2  x.

Write a recursive function to implement this algorithm to find the square root of
a nonnegative real number. Also, write a program to test your function.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

16
CHAPTER

ª HunThomas/Shutterstock

L INKED L ISTS
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about linked lists

2.

Become familiar with the basic properties of linked lists

3.

Explore the insertion and deletion operations on linked lists

4.

Discover how to build and manipulate a linked list

5.

Learn how to implement linked lists as ADTs

6.

Learn how to create linked list iterators

7.

Learn how to implement the basic operations on a linked list

8.

Learn how to create unordered linked lists

9.

Learn how to create ordered linked lists

10.

Learn how to construct a doubly linked list

11.

Become familiar with circular linked lists

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1072

| Chapter 16: Linked Lists

You have already seen how data is organized and processed sequentially using an array
called a sequential list. You have performed several operations on sequential lists, such as
sorting, inserting, deleting, and searching. You also found that if data is not sorted, then
searching for an item in the list can be very time consuming especially with large lists.
Once the data is sorted, you can use a binary search and improve the search algorithm.
However, in this case, insertion and deletion become time consuming especially with
large lists, because these operations require data movement. Also, because the array size
must be fixed during execution, new items can be added only if there is room. Thus,
there are limitations when you organize data in an array.
This chapter helps you to overcome some of these problems. Chapter 12 showed how
memory (variables) can be dynamically allocated and deallocated using pointers. This
chapter uses pointers to organize and process data in lists called linked lists. Recall that
when data is stored in an array, memory for the components of the array is contiguous—
that is, the blocks are allocated one after the other. However, as we will see, the
components (called nodes) of a linked list need not be contiguous.

Linked Lists
A linked list is a collection of components called nodes. Every node (except the last node)
contains the address of the next node. Thus, every node in a linked list has two components:
one to store the relevant information (that is, data) and one to store the address, called the
link, of the next node in the list. The address of the first node in the list is stored in a separate
location called the head or first. Figure 16-1 is a pictorial representation of a node.

data link

FIGURE 16-1

Structure of a node

Linked list: A list of items, called nodes, in which the order of the nodes is determined
by the address, called the link, stored in each node.
The list in Figure 16-2 is an example of a linked list.

head

FIGURE 16-2

45

65

34

76

Linked list

The arrow in each node indicates that the address of the node to which it is pointing is
stored in that node. The down arrow in the last node indicates that this link field is nullptr.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Lists

|

1073

For a better understanding of this notation, suppose that the first node is at memory location
1200, and the second node is at memory location 1575. We thus have Figure 16-3.

1200
head

FIGURE 16-3

1200

1
6

1575

45 1575

65

Linked list and values of the links

The value of the head is 1200, the data part of the first node is 45, and the link component
of the first node contains 1575, the address of the second node. If no confusion arises, then
we will use the arrow notation whenever we draw the figure of a linked list.
For simplicity and for the ease of understanding and clarity, Figures 16-3 through 16-6
use decimal integers as the values of memory addresses. However, in computer memory,
the memory addresses are in binary.
Because each node of a linked list has two components, we need to declare each node as a
class or struct. The data type of each node depends on the specific application—that

is, what kind of data is being processed. However, the link component of each node is a
pointer. The data type of this pointer variable is the node type itself. For the previous
linked list, the definition of the node is as follows. (Suppose that the data type is int.)
struct nodeType
{
int info;
nodeType *link;
};

The variable declaration is:
nodeType *head;

Linked Lists: Some Properties
To help you better understand the concept of a linked list and a node, some important
properties of linked lists are described next.
Consider the linked list in Figure 16-4.

head
2000

2000
17

2800

info link

FIGURE 16-4

92

2800

1500
1500

info link

63

3600
3600

info link

45

0

info link

Linked list with four nodes

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1074

| Chapter 16: Linked Lists

This linked list has four nodes. The address of the first node is stored in the pointer head.
Each node has two components: info, to store the info, and link, to store the address of
the next node. For simplicity, we assume that info is of type int.
Suppose that the first node is at location 2000, the second node is at location 2800,
the third node is at location 1500, and the fourth node is at location 3600. Therefore,
the value of head is 2000, the value of the component link of the first node is 2800,
the value of the component link of the second node is 1500, and so on. Also, the
down arrow in the component link of the last node indicates that this value is
nullptr. The number at the top of each node is the address of that node. The
following table shows the values of head and some other nodes in the list shown in
Figure 16-4.
Value
head

2000

head->info

17

head->link

2800

head->link->info

92

Explanation
Because head is 2000 and the info of
the node at location 2000 is 17
Because head->link is 2800 and the
info of the node at location 2800 is 92

Suppose that current is a pointer of the same type as the pointer head. Then, the
statement:
current = head;

copies the value of head into current (see Figure 16-5).

head
2000

2000
17

2800
2800

info link

92

1500
1500

info link

63

3600
3600

info link

45
info link

current 2000

FIGURE 16-5

Linked list after the statement current = head; executes

Clearly, in Figure 16-5:
current
current->info
current->link
current->link->info

Value
2000
17
2800
92

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Lists

|

1075

Now consider the statement:
current = current->link;

This statement copies the value of current->link, which is 2800, into current.
Therefore, after this statement executes, current points to the second node in the list.
(When working with linked lists, we typically use these types of statements to advance a
pointer to the next node in the list.) See Figure 16-6.

head
2000

2000
17

2800
2800

info link

92

1500
1500

info link

63

3600
3600

info link

45
info link

current 2800

FIGURE 16-6

List after the statement current = current->link; executes

In Figure 16-6:

current
current->info
current->link
current->link->info

Value
2800
92
1500
63

Finally, note that in Figure 16-6:

head->link->link
head->link->link->info
head->link->link->link
head->link->link->link->info
current->link->link
current->link->link->info
current->link->link->link
current->link->link->link->info

Value
1500
63
3600
45
3600
45
nullptr
Does not exist

From now on, when working with linked lists, we will use only the arrow notation.
TRAVERSING A LINKED LIST
The basic operations of a linked list are as follows: search the list to determine whether a
particular item is in the list, insert an item in the list, and delete an item from the list.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1076

| Chapter 16: Linked Lists

These operations require the list to be traversed. That is, given a pointer to the first node
of the list, we must step through the nodes of the list.
Suppose that the pointer head points to the first node in the list, and the link of the last
node is nullptr. We cannot use the pointer head to traverse the list because if we use
head to traverse the list, we would lose the nodes of the list. This problem occurs because
the links are in only one direction. The pointer head contains the address of the first
node, the first node contains the address of the second node, the second node contains the
address of the third node, and so on. If we move head to the second node, the first node
is lost (unless we save a pointer to this node). If we keep advancing head to the next
node, we will lose all of the nodes of the list (unless we save a pointer to each node before
advancing head, which is impractical because it would require additional computer time
and memory space to maintain the list).
Therefore, we always want head to point to the first node. It now follows that we must
traverse the list using another pointer of the same type. Suppose that current is a pointer
of the same type as head. The following code traverses the list:
current = head;
while (current != nullptr)
{
//Process the current node
current = current->link;
}

For example, suppose that head points to a linked list of numbers. The following code
outputs the data stored in each node:
current = head;
while (current != nullptr)
{
cout << current->info << " ";
current = current->link;
}

ITEM INSERTION AND DELETION
This section discusses how to insert an item into, and delete an item from, a linked list.
Consider the following definition of a node. (For simplicity, we assume that the info
type is int. The next section, which discusses linked lists as an abstract data type (ADT)
using templates, uses the generic definition of a node.)
struct nodeType
{
int info;
nodeType *link;
};

We will use the following variable declaration:
nodeType *head, *p, *q, *newNode;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Lists

|

1077

INSERTION
Consider the linked list shown in Figure 16-7.

head

45

65

34

1
6

76

p

FIGURE 16-7

Linked list before item insertion

Suppose that p points to the node with info 65, and a new node with info 50 is to be
created and inserted after p. Consider the following statements:
newNode = new nodeType; //create newNode
newNode->info = 50;
//store 50 in the new node
newNode->link = p->link;
p->link = newNode;

Table 16-1 shows the effect of these statements.
TABLE 16-1

Inserting a Node in a Linked List

Statement

Effect
head

45

newNode = new nodeType;

65

34

76

65

34

76

p
newNode
head

45

newNode->info = 50;

p
newNode
head

45

65

34

76

34

76

p

newNode->link = p->link;

newNode

head

p->link = newNode;

50

45

50

65
p
newNode

50

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1078

| Chapter 16: Linked Lists

Note that the sequence of statements to insert the node is very important because to insert
newNode in the list, we use only one pointer, p, to adjust the links of the node of the
linked list. Suppose that we reverse the sequence of the statements and execute the
statements in the following order:
p->link = newNode;
newNode->link = p->link;

Figure 16-8 shows the resulting list after these statements execute.

head

45

65

34

76

p
newNode

FIGURE 16-8

50

List after the execution of the statement p->link = newNode; followed by the
execution of the statement newNode->link = p->link;

From Figure 16-8, it is clear that newNode points back to itself and the remainder of the
list is lost.
Using two pointers, we can simplify the insertion code somewhat. Suppose q points to
the node with info 34 (see Figure 16-9).

head

45

65

34
q

p
newNode

FIGURE 16-9

76

50

List with pointers p and q

The following statements insert newNode between p and q.
newNode->link = q;
p->link = newNode;

The order in which these statements execute does not matter. To illustrate this, suppose
that we execute the statements in the following order:
p->link = newNode;
newNode->link = q;

Table 16-2 shows the effect of these statements.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Lists

TABLE 16-2

|

1079

Inserting a Node in a Linked List Using Two Pointers

Statement

Effect
head

45

34

65
p

p->link = newNode;

newNode

head

50

65

45

1
6

76

q

34

76

p

newNode->link = q;

newNode

q

50

Deletion
Consider the linked list shown in Figure 16-10.

head

45

65

34

76

p

FIGURE 16-10

Node to be deleted is with info 34

Suppose that the node with info 34 is to be deleted from the list. The following
statement removes the node from the list:
p->link = p->link->link;

Figure 16-11 shows the resulting list after the preceding statement executes.

head

45

65

34

76

p

FIGURE 16-11

List after the statement newNode->link = q; executes

From Figure 16-11, it is clear that the node with info 34 is removed from the list.
However, the memory is still occupied by this node, and this memory is inaccessible; that
is, this node is dangling. To deallocate the memory, we need a pointer to this node. The

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1080

| Chapter 16: Linked Lists

following statements delete the node from the list and deallocate the memory occupied
by this node.
q = p->link;
p->link = q->link;
delete q;

Table 16-3 shows the effect of these statements.
TABLE 16-3

Deleting a Node from a Linked List

Statement

Effect
head

45

q = p->link;

p->link = q->link;

65
p

head

34

45

head

34

65
p

delete q;

76

q

45

76

q
65

76

p

Building a Linked List
Now that we know how to insert a node in a linked list, let us see how to build a linked
list. First, we consider a linked list in general. If the data we read is unsorted, the linked
list will be unsorted. Such a list can be built in two ways: forward and backward. In the
forward manner, a new node is always inserted at the end of the linked list. In the
backward manner, a new node is always inserted at the beginning of the list. We will
consider both cases.
BUILDING A LINKED LIST FORWARD
Suppose that the nodes are in the usual info-link form, and info is of type int. Let us
assume that we process the following data:
2 15 8 24 34

We need three pointers to build the list: one to point to the first node in the list, which
cannot be moved; one to point to the last node in the list; and one to create the new
node. Consider the following variable declaration:
nodeType *first, *last, *newNode;
int num;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Lists

|

1081

Suppose that first points to the first node in the list. Initially, the list is empty, so both
first and last are nullptr. Thus, we must have the statements:
first = nullptr;
last = nullptr;

1
6

to initialize first and last to nullptr.
Next, consider the following statements:
1
2

cin >> num;
newNode = new nodeType;

3

newNode->info = num;

4

newNode->link = nullptr;

5

if (first == nullptr)

//read and store a number in num
//allocate memory of type nodeType
//and store the address of the
//allocated memory in newNode
//copy the value of num into the
//info field of newNode
//initialize the link field of
//newNode to nullptr
//if first is nullptr, the list is empty;
//make first and last point to newNode

{
5a
5b

first = newNode;
last = newNode;

}
else
//list is not empty
{
6a
last->link = newNode; //insert newNode at the end of the list
6b
last = newNode;
//set last so that it points to the
//actual last node in the list
}
6

Let us now execute these statements. Initially, both first and last are nullptr.
Therefore, we have the list as shown in Figure 16-12.

first
last

FIGURE 16-12

Empty list

After statement 1 executes, num is 2. Statement 2 creates a node and stores the address of
that node in newNode. Statement 3 stores 2 in the info field of newNode, and statement
4 stores nullptr in the link field of newNode (see Figure 16-13).

newNode

FIGURE 16-13

2

newNode with info 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1082

| Chapter 16: Linked Lists

Because first is nullptr, we execute statements 5a and 5b. Figure 16-14 shows the
resulting list.

first
last

2

newNode

FIGURE 16-14

List after inserting newNode in it

We now repeat statements 1 through 6b. After statement 1 executes, num is 15. Statement
2 creates a node and stores the address of this node in newNode. Statement 3 stores 15 in
the info field of newNode, and statement 4 assigns nullptr to the link field of newNode
(see Figure 16-15).

first
last

2
newNode

FIGURE 16-15

15

List and newNode with info 15

Because first is not nullptr, we execute statements 6a and 6b. Figure 16-16 shows
the resulting list.

first

2

15
last

FIGURE 16-16

newNode

List after inserting newNode at the end

We now repeat statements 1 through 6b three more times. Figure 16-17 shows the
resulting list.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Lists

first

2

15

8

24

1083

34
last

FIGURE 16-17

|

newNode

List after inserting 8, 24, and 34

To build the linked list, we can put the previous statements in a loop and execute the
loop until certain conditions are met. We can, in fact, write a C++ function to build a
linked list.
Suppose that we read a list of integers ending with -999. The following function,
buildListForward, builds a linked list (in a forward manner) and returns the pointer
of the built list:
nodeType* buildListForward()
{
nodeType *first, *newNode, *last;
int num;
cout << "Enter a list of integers ending with -999."
<< endl;
cin >> num;
first = nullptr;
while (num != -999)
{
newNode = new nodeType;
newNode->info = num;
newNode->link = nullptr;
if (first == nullptr)
{
first = newNode;
last = newNode;
}
else
{
last->link = newNode;
last = newNode;
}
cin >> num;
} //end while
return first;
} //end buildListForward

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1084

| Chapter 16: Linked Lists

BUILDING A LINKED LIST BACKWARD
Now we consider the case of building a linked list backward. For the previously given
data—2, 15, 8, 24, and 34—the linked list is as shown in Figure 16-18.

first

34

24

8

15

2

newNode

FIGURE 16-18

List after building it backward

Because the new node is always inserted at the beginning of the list, we do not need to
know the end of the list, so the pointer last is not needed. Also, after inserting the new
node at the beginning, the new node becomes the first node in the list. Thus, we need to
update the value of the pointer first to correctly point to the first node in the list. We
see, then, that we need only two pointers to build the linked list: one to point to the list
and one to create the new node. Because initially the list is empty, the pointer first
must be initialized to nullptr. In pseudocode, the algorithm is:
1. Initialize first to nullptr.
2. For each item in the list,
a.
b.
c.
d.

Create the new node, newNode.
Store the item in newNode.
Insert newNode before first.
Update the value of the pointer first.

The following C++ function builds the linked list backward and returns the pointer of
the built list:
nodeType* buildListBackward()
{
nodeType *first, *newNode;
int num;
cout << "Enter a list of integers ending with -999."
<< endl;
cin >> num;
first = nullptr;
while (num != -999)
{
newNode = new nodeType;
newNode->info = num;
newNode->link = first;

//create a node
//store the data in newNode
//put newNode at the beginning

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked List as an ADT

first = newNode;
cin >> num;

|

1085

//of the list
//update the head pointer of
//the list, that is, first
//read the next number

}
return first;
} //end buildListBackward

Linked List as an ADT
The previous sections taught you the basic properties of linked lists and how to construct
and manipulate them. Because a linked list is a very important data structure, rather than
discuss specific lists such as a list of integers or a list of strings, this section discusses linked lists
as an abstract data type (ADT). Using templates, this section gives a generic definition of
linked lists, which is then used in the next section and later in this book. The programming
example at the end of this chapter also uses this generic definition of linked lists.
The basic operations on linked lists are:
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

Initialize the list.
Determine whether the list is empty.
Print the list.
Find the length of the list.
Destroy the list.
Retrieve the info contained in the first node.
Retrieve the info contained in the last node.
Search the list for a given item.
Insert an item in the list.
Delete an item from the list.
Make a copy of the linked list.

In general, there are two types of linked lists—sorted lists, whose elements are arranged
according to some criteria, and unsorted lists, whose elements are in no particular order.
The algorithms to implement the operations search, insert, and remove slightly differ for
sorted and unsorted lists. Therefore, we will define the class linkedListType to
implement the basic operations on a linked list as an abstract class. Using the principle
of inheritance, we, in fact, will derive two classes—unorderedLinkedList and
orderedLinkedList—from the class linkedListType.
Objects of the class unorderedLinkedList would arrange list elements in no particular order, that is, these lists may not be sorted. On the other hand, objects of the class
orderedLinkedList would arrange elements according to some comparison criteria,
usually less than or equal to. That is, these lists will be in ascending order. Moreover, after

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1086

| Chapter 16: Linked Lists

inserting an element into or removing an element from an ordered list, the resulting list
will be ordered.
If a linked list is unordered, we can insert a new item at either the end or the
beginning. Furthermore, you can build such a list in either a forward manner or a
backward manner. The function buildListForward inserts the new item at the end,
whereas the function buildListBackward inserts the new item at the beginning. To
accommodate both operations, we will write two functions: insertFirst to insert
the new item at the beginning of the list and insertLast to insert the new item at
the end of the list. Also, to make the algorithms more efficient, we will use two
pointers in the list: first, which points to the first node in the list, and last, which
points to the last node in the list.

Structure of Linked List Nodes
Recall that each node of a linked list must store the data as well as the address for the next
node in the list (except the last node of the list). Therefore, the node has two member
variables. To simplify operations such as insert and delete, we define the class to implement the node of a linked list as a struct. The definition of the struct nodeType is:
//Definition of the node
template <class Type>
struct nodeType
{
Type info;
nodeType<Type> *link;
};
The class to implement the node of a linked list is declared as a struct. Programming
Exercise 9, at the end of this chapter, asks you to redefine the class to implement the nodes
of a linked list so that the member variables of the class nodeType are private.

Member Variables of the class linkedListType
To maintain a linked list, we use two pointers: first and last. The pointer first points
to the first node in the list, and last points to the last node in the list. We also keep a count
of the number of nodes in the list. Therefore, the class linkedListType has three
member variables, as follows:
protected:
int count;

//variable to store the number of
//elements in the list
nodeType<Type> *first; //pointer to the first node
//of the list
nodeType<Type> *last; //pointer to the last node
//of the list

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked List as an ADT

|

1087

Linked List Iterators
One of the basic operations performed on a list is to process each node of the list. This
requires the list to be traversed, starting at the first node. Moreover, a specific application
requires each node to be processed in a very specific way. A common technique to
accomplish this is to provide an iterator. So what is an iterator? An iterator is an object
that produces each element of a container, such as a linked list, one element at a time.
The two most common operations on iterators are ++ (the increment operator) and * (the
dereferenceing operator). The increment operator advances the iterator to the next node
in the list, and the dereferencing operator returns the info of the current node.
Note that an iterator is an object. So we need to define a class, which we will call
linkedListIterator, to create iterators to objects of the class linkedListType.
The iterator class would have one member variable pointing to (the current) node.
template <class Type>
class linkedListIterator
{
public:
linkedListIterator();
//Default constructor.
//Postcondition: current = nullptr;
linkedListIterator(nodeType<Type> *ptr);
//Constructor with a parameter.
//Postcondition: current = ptr;
Type operator*();
//Function to overload the dereferencing operator *.
//Postcondition: Returns the info contained in the node.
linkedListIterator<Type> operator++();
//Overload the pre-increment operator.
//Postcondition: The iterator is advanced to the next
//
node.
bool operator==(const linkedListIterator<Type>& right) const;
//Overload the equality operator.
//Postcondition: Returns true if this iterator is equal to
//
the iterator specified by right,
//
otherwise it returns false.
bool operator!=(const linkedListIterator<Type>& right) const;
//Overload the not equal to operator.
//Postcondition: Returns true if this iterator is not equal
//
to the iterator specified by right,
//
otherwise it returns false.
private:
nodeType<Type> *current; //pointer to point to the current
//node in the linked list
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1088

| Chapter 16: Linked Lists

Figure 16-19 shows the UML class diagram of the class linkedListIterator.

linkedListIterator<Type>
-*current: nodeType<Type>
+linkedListIterator()
+linkedListIterator(nodeType<Type>)
+operator*(): Type
+operator++(): linkedListIterator<Type>
+operator==(const linkedListIterator<Type>&) const: bool
+operator!=(const linkedListIterator<Type>&) const: bool

FIGURE 16-19

UML class diagram of the class linkedListIterator

The definitions of the functions of the class linkedListIterator are:
template <class Type>
linkedListIterator<Type>::linkedListIterator()
{
current = nullptr;
}
template <class Type>
linkedListIterator<Type>::
linkedListIterator(nodeType<Type> *ptr)
{
current = ptr;
}
template <class Type>
Type linkedListIterator<Type>::operator*()
{
return current->info;
}
template <class Type>
linkedListIterator<Type> linkedListIterator<Type>::operator++()
{
current = current->link;
return *this;
}
template <class Type>
bool linkedListIterator<Type>::operator==
(const linkedListIterator<Type>& right) const
{
return (current == right.current);
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked List as an ADT

|

1089

template <class Type>
bool linkedListIterator<Type>::operator!=
(const linkedListIterator<Type>& right) const
{
return (current != right.current);
}

Now that we have defined the classes to implement the node of a linked list and an
iterator to a linked list, next we describe the class linkedListType to implement the
basic properties of a linked list.
The following abstract class defines the basic properties of a linked list as an ADT:
template <class Type>
class linkedListType
{
public:
const linkedListType<Type>& operator=
(const linkedListType<Type>&);
//Overload the assignment operator.
void initializeList();
//Initialize the list to an empty state.
//Postcondition: first = nullptr, last = nullptr, count = 0;
bool isEmptyList() const;
//Function to determine whether the list is empty.
//Postcondition: Returns true if the list is empty,
//
otherwise it returns false.
void print() const;
//Function to output the data contained in each node.
//Postcondition: none
int length() const;
//Function to return the number of nodes in the list.
//Postcondition: The value of count is returned.
void destroyList();
//Function to delete all the nodes from the list.
//Postcondition: first = nullptr, last = nullptr, count = 0;
Type front() const;
//Function to return the first element of the list.
//Precondition: The list must exist and must not be
//
empty.
//Postcondition: If the list is empty, the program
//
terminates; otherwise, the first
//
element of the list is returned.
Type back() const;
//Function to return the last element of the list.
//Precondition: The list must exist and must not be
//
empty.
//Postcondition: If the list is empty, the program
//
terminates; otherwise, the last
//
element of the list is returned.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1090

| Chapter 16: Linked Lists

virtual bool search(const Type& searchItem) const = 0;
//Function to determine whether searchItem is in the list.
//Postcondition: Returns true if searchItem is in the
//
list, otherwise the value false is
//
returned.
virtual void insertFirst(const Type& newItem) = 0;
//Function to insert newItem at the beginning of the list.
//Postcondition: first points to the new list, newItem is
//
inserted at the beginning of the list,
//
last points to the last node in the list,
//
and count is incremented by 1.
virtual void insertLast(const Type& newItem) = 0;
//Function to insert newItem at the end of the list.
//Postcondition: first points to the new list, newItem
//
is inserted at the end of the list,
//
last points to the last node in the list,
//
and count is incremented by 1.
virtual void deleteNode(const Type& deleteItem) = 0;
//Function to delete deleteItem from the list.
//Postcondition: If found, the node containing
//
deleteItem is deleted from the list.
//
first points to the first node, last
//
points to the last node of the updated
//
list, and count is decremented by 1.
linkedListIterator<Type> begin();
//Function to return an iterator at the begining of the
//linked list.
//Postcondition: Returns an iterator such that current is
//
set to first.
linkedListIterator<Type> end();
//Function to return an iterator one element past the
//last element of the linked list.
//Postcondition: Returns an iterator such that current is
//
set to nullptr.
linkedListType();
//default constructor
//Initializes the list to an empty state.
//Postcondition: first = nullptr, last = nullptr, count = 0;
linkedListType(const linkedListType<Type>& otherList);
//copy constructor
linkedListType();
//destructor
//Deletes all the nodes from the list.
//Postcondition: The list object is destroyed.
protected:
int count;

//variable to store the number of
//elements in the list

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked List as an ADT

|

1091

nodeType<Type> *first; //pointer to the first node of the list
nodeType<Type> *last; //pointer to the last node of the list
private:
void copyList(const linkedListType<Type>& otherList);
//Function to make a copy of otherList.
//Postcondition: A copy of otherList is created and
//
assigned to this list.
};

Figure 16-20 shows the UML class diagram of the class linkedListType.

linkedListType<Type>
#count: int
#*first: nodeType<Type>
#*last: nodeType<Type>
+operator=(const linkedListType<Type>&):
const linkedListType<Type>&
+initializeList(): void
+isEmptyList() const: bool
+print() const: void
+length() const: int
+destroyList(): void
+front() const: Type
+back() const: Type
+search(const Type&) const = 0: bool
+insertFirst(const Type&) = 0: void
+insertLast(const Type&) = 0: void
+deleteNode(const Type&) = 0: void
+begin(): linkedListIterator<Type>
+end(): linkedListIterator<Type>
+linkedListType()
+linkedListType(const linkedListType<Type>&)
+~linkedListType()
-copyList(const linkedListType<Type>&): void

FIGURE 16-20

UML class diagram of the class linkedListType

Note that typically, in the UML diagram, the name of an abstract class and abstract
function is shown in italics.
The instance variables first and last, as defined earlier, of the class
linkedListType are protected, not private, because as noted previously, we will
derive the classes unorderedLinkedList and orderedLinkedList from the
class linkedListType. Because each of the classes unorderedLinkedList

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1092

| Chapter 16: Linked Lists

and orderedLinkedList will provide separate definitions of the functions search,
insertFirst, insertLast, and deleteNode and because these functions would access
the instance variable, to provide direct access to the instance variables, the instance variables
are declared as protected.
The definition of the class linkedListType includes a member function to overload
the assignment operator. For classes that include pointer data members, the assignment
operator must be explicitly overloaded (see Chapters 12 and 13). For the same reason, the
definition of the class also includes a copy constructor.
Notice that the definition of the class linkedListType contains the member function
copyList, which is declared as a private member. This is due to the fact that this
function is used only to implement the copy constructor and overload the assignment
operator.
Next, we write the definitions of the nonabstract functions of the class LinkedListClass.
The list is empty if first is nullptr. Therefore, the definition of the function
isEmptyList to implement this operation is as follows:
template <class Type>
bool linkedListType<Type>::isEmptyList() const
{
return (first == nullptr);
}

DEFAULT CONSTRUCTOR
The default constructor, linkedListType, is quite straightforward. It simply initializes
the list to an empty state. Recall that when an object of the linkedListType type is
declared and no value is passed, the default constructor is executed automatically.
template <class Type>
linkedListType<Type>::linkedListType() //default constructor
{
first = nullptr;
last = nullptr;
count = 0;
}

DESTROY THE LIST
The function destroyList deallocates the memory occupied by each node. We traverse
the list starting from the first node and deallocate the memory by calling the operator
delete. We need a temporary pointer to deallocate the memory. Once the entire list is
destroyed, we must set the pointers first and last to nullptr and count to 0.
template <class Type>
void linkedListType<Type>::destroyList()
{
nodeType<Type> *temp;
//pointer to deallocate the memory
//occupied by the node

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked List as an ADT

|

1093

while (first != nullptr) //while there are nodes in the list
{
temp = first;
//set temp to the current node
first = first->link; //advance first to the next node
delete temp;
//deallocate the memory occupied by temp
}
last = nullptr; //initialize last to nullptr; first has already
//been set to nullptr by the while loop
count = 0;
}

INITIALIZE THE LIST
The function initializeList initializes the list to an empty state. Note that the
default constructor or the copy constructor has already initialized the list when the list
object was declared. This operation, in fact, reinitializes the list to an empty state, so it
must delete the nodes (if any) from the list. This task can be accomplished by using the
destroyList operation, which also resets the pointers first and last to nullptr
and sets count to 0.
template <class Type>
void linkedListType<Type>::initializeList()
{
destroyList(); //if the list has any nodes, delete them
}

Print the List
The member function print prints the data contained in each node. To do so, we must
traverse the list, starting at the first node. Because the pointer first always points to the
first node in the list, we need another pointer to traverse the list. (If we use first to
traverse the list, the entire list will be lost.)
template <class Type>
void linkedListType<Type>::print() const
{
nodeType<Type> *current; //pointer to traverse the list
//set current so that it points to
//the first node
while (current != nullptr) //while more data to print
{
cout << current->info << " ";
current = current->link;
}
}//end print
current = first;

Length of a List
The length of a linked list (that is, how many nodes are in the list) is stored in the variable
count. Therefore, this function returns the value of this variable:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1094

| Chapter 16: Linked Lists

template <class Type>
int linkedListType<Type>::length() const
{
return count;
}

Retrieve the Data of the First Node
The function front returns the info contained in the first node, and its definition is
straightforward:
template <class Type>
Type linkedListType<Type>::front() const
{
assert(first != nullptr);
return first->info; //return the info of the first node
}//end front

Notice that if the list is empty, the assert statement terminates the program. Therefore,
before calling this function, check to see whether the list is nonempty.

Retrieve the Data of the Last Node
The function back returns the info contained in the last node, and its definition is
straightforward:
template <class Type>
Type linkedListType<Type>::back() const
{
assert(last != nullptr);
return last->info; //return the info of the last node
}//end back

Notice that if the list is empty, the assert statement terminates the program. Therefore,
before calling this function, check to see whether the list is nonempty.

Begin and End
The function begin returns an iterator to the first node in the linked list, and the
function end returns an iterator to one past the last node in the linked list. Their
definitions are:
template <class Type>
linkedListIterator<Type> linkedListType<Type>::begin()
{
linkedListIterator<Type> temp(first);
return temp;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked List as an ADT

|

1095

template <class Type>
linkedListIterator<Type> linkedListType<Type>::end()
{
linkedListIterator<Type> temp(nullptr);
return temp;
}

Copy the List
The function copyList makes an identical copy of a linked list. Therefore, we traverse
the list to be copied, starting at the first node. Corresponding to each node in the original
list, we:
a. Create a node, and call it newNode.
b. Copy the info of the node (in the original list) into newNode.
c. Insert newNode at the end of the list being created.
The definition of the function copyList is:
template <class Type>
void linkedListType<Type>::copyList
(const linkedListType<Type>& otherList)
{
nodeType<Type> *newNode; //pointer to create a node
nodeType<Type> *current; //pointer to traverse the list
if (first != nullptr) //if the list is nonempty, make it empty
destroyList();
if (otherList.first == nullptr) //otherList is empty
{
first = nullptr;
last = nullptr;
count = 0;
}
else
{
current = otherList.first; //current points to the
//list to be copied
count = otherList.count;
//copy the first node
first = new nodeType<Type>; //create the node
first->info = current->info; //copy the info
first->link = nullptr;
//set the link field of
//the node to nullptr
last = first;
//make last point to the
//first node
current = current->link;
//make current point to
//the next node

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1096

| Chapter 16: Linked Lists

//copy the remaining list
while (current != nullptr)
{
newNode = new nodeType<Type>; //create a node
newNode->info = current->info; //copy the info
newNode->link = nullptr;
//set the link of
//newNode to nullptr
last->link = newNode; //attach newNode after last
last = newNode;
//make last point to
//the actual last node
current = current->link;
//make current point
//to the next node
}//end while
}//end else
}//end copyList

Destructor
The destructor deallocates the memory occupied by the nodes of a list when the class object
goes out of scope. Because memory is allocated dynamically, resetting the pointers first and
last does not deallocate the memory occupied by the nodes in the list. We must traverse the
list, starting at the first node, and delete each node in the list. The list can be destroyed by
calling the function destroyList. Therefore, the definition of the destructor is:
template <class Type>
linkedListType<Type>:: ~linkedListType() //destructor
{
destroyList();
}

Copy Constructor
Because the class linkedListType contains pointer data members, the definition of
this class contains the copy constructor. Recall that if a formal parameter is a value
parameter, the copy constructor provides the formal parameter with its own copy of the
data. The copy constructor also executes when an object is declared and initialized using
another object. (For more information, see Chapter 12.)
The copy constructor makes an identical copy of the linked list. This can be done by
calling the function copyList. Because the function copyList checks whether the
original is empty by checking the value of first, we must first initialize the pointer
first to nullptr before calling the function copyList.
The definition of the copy constructor is:
template <class Type>
linkedListType<Type>::linkedListType
(const linkedListType<Type>& otherList)
{
first = nullptr;
copyList(otherList);
}//end copy constructor
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Unordered Linked Lists

|

1097

Overloading the Assignment Operator
The definition of the function to overload the assignment operator for the class
linkedListType is similar to the definition of the copy constructor. We give its
definition for the sake of completeness.
//overload the assignment operator
template <class Type>
const linkedListType<Type>& linkedListType<Type>::operator=
(const linkedListType<Type>& otherList)
{
if (this != &otherList) //avoid self-copy
{
copyList(otherList);
}//end else
return *this;
}

Unordered Linked Lists
As described in the preceding section, we derive the class unorderedLinkedList
from the abstract class linkedListType and implement the operations search,
insertFirst, insertLast, and deleteNode.
The following class defines an unordered linked list as an ADT:
template <class Type>
class unorderedLinkedList: public linkedListType<Type>
{
public:
bool search(const Type& searchItem) const;
//Function to determine whether searchItem is in the list.
//Postcondition: Returns true if searchItem is in the
//
list, otherwise the value false is
//
returned.
void insertFirst(const Type& newItem);
//Function to insert newItem at the beginning of the list.
//Postcondition: first points to the new list, newItem is
//
inserted at the beginning of the list,
//
last points to the last node in the
//
list, and count is incremented by 1.
void insertLast(const Type& newItem);
//Function to insert newItem at the end of the list.
//Postcondition: first points to the new list, newItem
//
is inserted at the end of the list,
//
last points to the last node in the
//
list, and count is incremented by 1.
void deleteNode(const Type& deleteItem);
//Function to delete deleteItem from the list.
//Postcondition: If found, the node containing

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1098

| Chapter 16: Linked Lists

//
//
//
//

deleteItem is deleted from the list.
first points to the first node, last
points to the last node of the updated
list, and count is decremented by 1.

};

Figure 16-21 shows a UML class diagram of the class unorderedLinkedList and the
inheritance hierarchy.

unorderedLinkedList<Type>
linkedListType
+search(const Type&) const: bool
+insertFirst(const Type&): void
+insertLast(const Type&): void
+deleteNode(const Type&): void

FIGURE 16-21

Next,

we

unorderedLinkedList

UML class diagram of the class unorderedLinkedList and inheritance
hierarchy

give

the

definitions

of

the

member

functions

of

the

class

unorderedLinkedList.

Search the List
The member function search searches the list for a given item. If the item is found, it
returns true; otherwise, it returns false. Because a linked list is not a random-access
data structure, we must sequentially search the list, starting from the first node.
This function has the following steps:
1. Compare the search item with the current node in the list. If the info of
the current node is the same as the search item, stop the search; otherwise, make the next node the current node.
2. Repeat Step 1 until either the item is found or no more data is left in the
list to compare with the search item.
template <class Type>
bool unorderedLinkedList<Type>::
search(const Type& searchItem) const
{
nodeType<Type> *current; //pointer to traverse the list
bool found = false;
current = first; //set current to point to the first
//node in the list

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Unordered Linked Lists

|

1099

while (current != nullptr && !found) //search the list
if (current->info == searchItem) //searchItem is found
found = true;
else
current = current->link; //make current point to
//the next node
return found;
}//end search
The function search can also be written as:

template <class Type>
bool unorderedLinkedList<Type>::search(const Type& searchItem)
const
{
nodeType<Type> *current; //pointer to traverse the list
current = first; //set current to point to the first
//node in the list
while (current != nullptr)
//search the list
if (current->info == searchItem) //searchItem is found
return true;
else
current = current->link; //make current point to
//the next node
return false; //searchItem is not in the list, return false
}//end search

Insert the First Node
The function insertFirst inserts the new item at the beginning of the list—that is,
before the node pointed to by first. The steps needed to implement this function are as
follows:
1.
2.
3.
4.

Create a new node.
Store the new item in the new node.
Insert the node before first.
Increment count by 1.

template <class Type>
void unorderedLinkedList<Type>::insertFirst(const Type& newItem)
{
nodeType<Type> *newNode; //pointer to create the new node
newNode = new nodeType<Type>; //create the new node
newNode->info = newItem;
//store the new item in the node

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1100

| Chapter 16: Linked Lists

newNode->link = first;
first = newNode;
count++;

//insert newNode before first
//make first point to the
//actual first node
//increment count

if (last == nullptr) //if the list was empty, newNode is also
//the last node in the list
last = newNode;
}//end insertFirst

Insert the Last Node
The definition of the member function insertLast is similar to the definition of the
member function insertFirst. Here, we insert the new node after last. Essentially,
the function insertLast is:
template <class Type>
void unorderedLinkedList<Type>::insertLast(const Type& newItem)
{
nodeType<Type> *newNode; //pointer to create the new node
newNode = new nodeType<Type>; //create the new node
newNode->info = newItem;
//store the new item in the node
newNode->link = nullptr;
//set the link field of newNode
//to nullptr
if (first == nullptr)

//if the list is empty, newNode is
//both the first and last node

{
first = newNode;
last = newNode;
count++;
//increment count
}
else
//the list is not empty, insert newNode after last
{
last->link = newNode; //insert newNode after last
last = newNode; //make last point to the actual
//last node in the list
count++;
//increment count
}
}//end insertLast

DELETE A NODE
Next, we discuss the implementation of the member function deleteNode,
which deletes a node from the list with a given info. We need to consider several
cases:

Case 1: The list is empty.
Case 2: The first node is the node with the given info. In this case, we need to adjust
the pointer first.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Unordered Linked Lists

|

1101

Case 3: The node with the given info is somewhere in the list. If the node to be
deleted is the last node, then we must adjust the pointer last.
Case 4: The list does not contain the node with the given info.
If list is empty, we can simply print a message indicating that the list is empty. If list is
not empty, we search the list for the node with the given info and, if such a node is
found, we delete this node. After deleting the node, count is decremented by 1. In
pseudocode, the algorithm is:
if list is empty
Output(cannot delete from an empty list);
else
{
if the first node is the node with the given info
adjust the head pointer, that is, first, and deallocate
the memory;
else
{
search the list for the node with the given info
if such a node is found, delete it and adjust the
values of last (if necessary) and count.
}
}

Case 1: The list is empty.
If the list is empty, output an error message as shown in the pseudocode.
Case 2: The list is not empty. The node to be deleted is the first node.
This case has two scenarios: list has only one node, and list has more than one node.
Consider the list with one node, as shown in Figure 16-22.

list
first
last

37

count 1

FIGURE 16-22

list with one node

Suppose that we want to delete 37. After deletion, the list becomes empty. Therefore,
after deletion, both first and last are set to nullptr, and count is set to 0.
Now consider the list of more than one node, as shown in Figure 16-23.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1102

| Chapter 16: Linked Lists

list
28

first

17

37

24

54

last
count 5

FIGURE 16-23

list with more than one node

Suppose that the node to be deleted is 28. After deleting this node, the second node
becomes the first node. Therefore, after deleting this node, the value of the pointer first
changes; that is, after deletion, first contains the address of the node with info 17, and
count is decremented by 1. Figure 16-24 shows the list after deleting 28.

list
17

first

37

24

54

last
count 4

FIGURE 16-24

list after deleting node with info 28

Case 3: The node to be deleted is not the first node but is somewhere in the list.
This case has two subcases: (a) the node to be deleted is not the last node, and (b) the
node to be deleted is the last node. Let us illustrate both cases.
Case 3a: The node to be deleted is not the last node.
Consider the list shown in Figure 16-25.

list
first

28

17

37

24

54

last
count 5

FIGURE 16-25

list before deleting 37

Suppose that the node to be deleted is 37. After deleting this node, the resulting list is as
shown in Figure 16-26. (Notice that the deletion of 37 does not require us to change the

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Unordered Linked Lists

|

1103

values of first and last. The link field of the previous node—that is, 17—changes.
After deletion, the node with info 17 contains the address of the node with 24.)

1
6

list
first

28

17

24

54

last
count 4

FIGURE 16-26

list after deleting 37

Case 3b: The node to be deleted is the last node.
Consider the list shown in Figure 16-27. Suppose that the node to be deleted is 54.

list
28

first

17

37

24

54

last
count 5

FIGURE 16-27

list before deleting 54

After deleting 54, the node with info 24 becomes the last node. Therefore, the
deletion of 54 requires us to change the value of the pointer last. After deleting 54,
last contains the address of the node with info 24. Also, count is decremented
by 1. Figure 16-28 shows the resulting list.

list
first

28

17

37

24

last
count 4

FIGURE 16-28

list after deleting 54

Case 4: The node to be deleted is not in the list. In this case, the list requires no
adjustment. We simply output an error message, indicating that the item to be
deleted is not in the list.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1104

| Chapter 16: Linked Lists

From Cases 2, 3, and 4, it follows that the deletion of a node requires us to traverse
the list. Because a linked list is not a random-access data structure, we must sequentially search the list. We handle Case 1 separately, because it does not require us to
traverse the list. We sequentially search the list, starting at the second node. If the node
to be deleted is in the middle of the list, we need to adjust the link field of the node just
before the node to be deleted. Thus, we need a pointer to the previous node. When we
search the list for the given info, we use two pointers: one to check the info of the
current node and one to keep track of the node just before the current node. If the node to
be deleted is the last node, we must adjust the pointer last.
The definition of the function deleteNode is:
template <class Type>
void unorderedLinkedList<Type>::deleteNode(const Type& deleteItem)
{
nodeType<Type> *current; //pointer to traverse the list
nodeType<Type> *trailCurrent; //pointer just before current
bool found;
if (first == nullptr)
//Case 1; the list is empty
cout << "Cannot delete from an empty list."
<< endl;
else
{
if (first->info == deleteItem) //Case 2
{
current = first;
first = first->link;
count--;
if (first == nullptr)
last = nullptr;

//the list has only one node

delete current;
}
else //search the list for the node with the given info
{
found = false;
trailCurrent = first; //set trailCurrent to point
//to the first node
current = first->link; //set current to point to
//the second node
while (current != nullptr && !found)
{
if (current->info != deleteItem)
{
trailCurrent = current;
current = current-> link;
}
else
found = true;
}//end while
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Unordered Linked Lists

|

1105

if (found) //Case 3; if found, delete the node
{
trailCurrent->link = current->link;
count--;
if (last == current)

//node to be deleted
//was the last node
last = trailCurrent; //update the value
//of last
delete current; //delete the node from the list

}
else
cout << "The item to be deleted is not in "
<< "the list." << endl;
}//end else
}//end else
}//end deleteNode

Header File of the Unordered Linked List
For the sake of completeness, we will show how to create the header file that defines the
class unorderedListType and the operations on such lists. (We assume that the
definition of the class linkedListType and the definitions of the functions to implement the operations are in the header file linkedlist.h.)
#ifndef H_UnorderedLinkedList
#define H_UnorderedLinkedList
#include "linkedList.h"
using namespace std;
template <class Type>
class unorderedLinkedList: public linkedListType<Type>
{
public:
bool search(const Type& searchItem) const;
//Function to determine whether searchItem is in the list.
//Postcondition: Returns true if searchItem is in the
//
list, otherwise the value false is
//
returned.
void insertFirst(const Type& newItem);
//Function to insert newItem at the beginning of the list.
//Postcondition: first points to the new list, newItem is
//
inserted at the beginning of the list,
//
last points to the last node in the
//
list, and count is incremented by 1.
void insertLast(const Type& newItem);
//Function to insert newItem at the end of the list.
//Postcondition: first points to the new list, newItem
//
is inserted at the end of the list,
//
last points to the last node in the
//
list, and count is incremented by 1.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1106

| Chapter 16: Linked Lists

void deleteNode(const Type& deleteItem);
//Function to delete deleteItem from the list.
//Postcondition: If found, the node containing
//
deleteItem is deleted from the list.
//
first points to the first node, last
//
points to the last node of the updated
//
list, and count is decremented by 1.
};
//Place the definitions of the functions search,
//insertFirst, insertLast, and deleteNode here.
.
.
.
#endif
The Web site accompanying this book contains several programs illustrating how to use
the class unorderedLinkedList.

Ordered Linked Lists
The preceding section described the operations on an unordered linked list. This section deals
with ordered linked lists. As noted earlier, we derive the class orderedLinkedList
from the class linkedListType and provide the definitions of the abstract functions
insertFirst, insertLast, search, and deleteNode to take advantage of the fact
that the elements of an ordered linked list are arranged using some ordering criteria. For
simplicity, we assume that elements of an ordered linked list are arranged in ascending order.
Because the elements of an ordered linked list are in order, we include the function
insert to insert an element in an ordered list at the proper place.

The following class defines an ordered linked list as an ADT:
template <class Type>
class orderedLinkedList: public linkedListType<Type>
{
public:
bool search(const Type& searchItem) const;
//Function to determine whether searchItem is in the list.
//Postcondition: Returns true if searchItem is in the list,
//
otherwise the value false is returned.
void insert(const Type& newItem);
//Function to insert newItem in the list.
//Postcondition: first points to the new list, newItem
//
is inserted at the proper place in the
//
list, and count is incremented by 1.
void insertFirst(const Type& newItem);
//Function to insert newItem at the beginning of the list.
//Postcondition: first points to the new list, newItem is

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Ordered Linked Lists

//
//
//

|

1107

inserted at the proper place in the list,
last points to the last node in the
list, and count is incremented by 1.

void insertLast(const Type& newItem);
//Function to insert newItem at the end of the list.
//Postcondition: first points to the new list, newItem is
//
inserted at the proper place in the list,
//
last points to the last node in the
//
list, and count is incremented by 1.
void deleteNode(const Type& deleteItem);
//Function to delete deleteItem from the list.
//Postcondition: If found, the node containing
//
deleteItem is deleted from the list;
//
first points to the first node of the
//
new list, and count is decremented by 1.
//
If deleteItem is not in the list, an
//
appropriate message is printed.
};

Figure 16-29 shows a UML class diagram of the class orderedLinkedList and the
inheritance hierarchy.

orderedLinkedList<Type>
linkedListType
+search(const Type&) const: bool
+insert(const Type&): void
+insertFirst(const Type&): void
+insertLast(const Type&): void
+deleteNode(const Type&): void

FIGURE 16-29

orderedLinkedList

UML class diagram of the class orderedLinkedList and the inheritance hierarchy

Next, we give the definitions of the member functions of the class orderedLinkedList.

Search the List
First, we discuss the search operation. The algorithm to implement the search operation is similar to the search algorithm for general lists discussed earlier. Here, because
the list is sorted, we can improve the search algorithm somewhat. As before, we start the
search at the first node in the list. We stop the search as soon as we find a node in
the list with info greater than or equal to the search item or when we have searched
the entire list.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1108

| Chapter 16: Linked Lists

The following steps describe this algorithm:
1. Compare the search item with the current node in the list. If the info of
the current node is greater than or equal to the search item, stop the
search; otherwise, make the next node the current node.
2. Repeat Step 1 until either an item in the list that is greater than or equal
to the search item is found or no more data is left in the list to compare
with the search item.
Note that the loop does not explicitly check whether the search item is equal to an item
in the list. Thus, after the loop executes, we must check whether the search item is equal
to the item in the list.
template <class Type>
bool orderedLinkedList<Type>::
search(const Type& searchItem) const
{
bool found = false;
nodeType<Type> *current; //pointer to traverse the list
current = first;

//start the search at the first node

while (current != nullptr && !found)
if (current->info >= searchItem)
found = true;
else
current = current->link;
if (found)
found = (current->info == searchItem); //test for equality
return found;
}//end search

Insert a Node
To insert an item in an ordered linked list, we first find the place where the new item is
supposed to go, and then we insert the item in the list. To find the place for the new item,
as before, we search the list. Here, we use two pointers, current and trailCurrent, to
search the list. The pointer current points to the node whose info is being compared
with the item to be inserted, and trailCurrent points to the node just before current.
Because the list is in order, the search algorithm is the same as before. The following cases
arise:
Case 1: The list is initially empty. The node containing the new item is the only node
and thus the first node in the list.
Case 2: The new item is smaller than the smallest item in the list. The new item goes at
the beginning of the list. In this case, we need to adjust the list’s head pointer—
that is, first. Also, count is incremented by 1.
Case 3: The item is to be inserted somewhere in the list.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Ordered Linked Lists

|

1109

3a: The new item is larger than all of the items in the list. In this case, the new item
is inserted at the end of the list. Thus, the value of current is nullptr, and the
new item is inserted after trailCurrent. Also, count is incremented by 1.
3b: The new item is to be inserted somewhere in the middle of the list. In this case,
the new item is inserted between trailCurrent and current. Also, count is
incremented by 1.
The following statements can accomplish both Cases 3a and 3b. Assume newNode points
to the new node.
trailCurrent->link = newNode;
newNode->link = current;

Let us next illustrate these cases.
Case 1: The list is empty.
Consider the list shown in Figure 16-30(a).
list

list
first

first

last

last
count 1

count 0
(a) Empty list

FIGURE 16-30

27

(b) After inserting 27

list

Suppose that we want to insert 27 in the list. To accomplish this task, we create a node, copy
27 into the node, set the link of the node to nullptr, and make first point to the node.
Figure 16-30(b) shows the resulting list. Notice that, after inserting 27, the values of both
first and count change.
Case 2: The list is not empty, and the item to be inserted is smaller than the smallest item
in the list. Consider the list shown in Figure 16-31.

list
first

17

27

38

54

last
count 4

FIGURE 16-31

Nonempty list before inserting 10

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1110

| Chapter 16: Linked Lists

Suppose that 10 is to be inserted. After inserting 10 in the list, the node with info 10
becomes the first node of list. This requires us to change the value of first. Also,
count is incremented by 1. Figure 16-32 shows the resulting list.
list
first

10

17

27

38

54

last
count 5

FIGURE 16-32

list after inserting 10

Case 3: The list is not empty, and the item to be inserted is larger than the first item in
the list. As indicated previously, this case has two scenarios.
Case 3a: The item to be inserted is larger than the largest item in the list; that is, it goes at
the end of the list. Consider the list shown in Figure 16-33.

list
first

17

27

38

54

last
count 4

FIGURE 16-33

list before inserting 65

Suppose that we want to insert 65 in the list. After inserting 65, the resulting list is as
shown in Figure 16-34.

list
first

17

27

38

54

65

last
count 5

FIGURE 16-34

list after inserting 65

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Ordered Linked Lists

|

1111

Case 3b: The item to be inserted goes somewhere in the middle of the list. Consider the
list shown in Figure 16-35.

1
6

list
first

17

38

45

54

last
count 4

FIGURE 16-35

list before inserting 27

Suppose that we want to insert 27 in this list. Clearly, 27 goes between 17 and 38, which
would require the link of the node with info 17 to be changed. After inserting 27, the
resulting list is as shown in Figure 16-36.

list
first

17

27

38

45

54

last
count 5

FIGURE 16-36

list after inserting 27

From Case 3, it follows that we must first traverse the list to find the place where the new
item is to be inserted. It also follows that we should traverse the list with two pointers—
say, current and trailCurrent. The pointer current is used to traverse the list and
compare the info of the node in the list with the item to be inserted. The pointer
trailCurrent points to the node just before current. For example, in Case 3b, when
the search stops, trailCurrent points to node 17 and current points to node 38. The
item is inserted after trailCurrent. In Case 3a, after searching the list to find the place
for 65, trailCurrent points to node 54 and current is nullptr.
Essentially, the function insert is as follows:
template <class Type>
void orderedLinkedList<Type>::insert(const Type& newItem)
{
nodeType<Type> *current; //pointer to traverse the list
nodeType<Type> *trailCurrent; //pointer just before current
nodeType<Type> *newNode; //pointer to create a node

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1112

| Chapter 16: Linked Lists

bool found;
newNode = new nodeType<Type>; //create the node
newNode->info = newItem;
//store newItem in the node
newNode->link = nullptr;
//set the link field of the node
//to nullptr
if (first == nullptr)
{
first = newNode;
last = newNode;
count++;
}
else
{
current = first;
found = false;

//Case 1

while (current != nullptr && !found) //search the list
if (current->info >= newItem)
found = true;
else
{
trailCurrent = current;
current = current->link;
}
if (current == first)
//Case 2
{
newNode->link = first;
first = newNode;
count++;
}
else
//Case 3
{
trailCurrent->link = newNode;
newNode->link = current;
if (current == nullptr)
last = newNode;
count++;
}
}//end else
}//end insert

Insert First and Insert Last
The function insertFirst inserts the new item at the beginning of the list. However,
because the resulting list must be sorted, the new item must be inserted at the proper
place. Similarly, the function insertLast must insert the new item at the proper place.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Ordered Linked Lists

|

1113

Therefore, we use the function insertNode to insert the new item at its proper place.
The definitions of these functions are:
template <class Type>
void orderedLinkedList<Type>::insertFirst(const Type& newItem)
{
insert(newItem);
}//end insertFirst
template <class Type>
void orderedLinkedList<Type>::insertLast(const Type& newItem)
{
insert(newItem);
}//end insertLast

Note that in reality, the functions insertFirst and insertLast do not apply to
ordered linked lists because the new item must be inserted at the proper place in the list.
However, you must provide its definition as these functions are declared as abstract in the
parent class.

Delete a Node
To delete a given item from an ordered linked list, first we search the list to see whether
the item to be deleted is in the list. The function to implement this operation is the same
as the delete operation on general linked lists. Here, because the list is sorted, we can
somewhat improve the algorithm for ordered linked lists.
As in the case of insertNode, we search the list with two pointers, current and
trailCurrent. Similar to the operation insertNode, several cases arise:
Case 1: The list is initially empty. We have an error. We cannot delete from an empty list.
Case 2: The item to be deleted is contained in the first node of the list. We must adjust
the head pointer of the list—that is, first.
Case 3: The item to be deleted is somewhere in the list. In this case, current points to
the node containing the item to be deleted, and trailCurrent points to the
node just before the node pointed to by current.
Case 4: The list is not empty, but the item to be deleted is not in the list.
After deleting a node, count is decremented by 1. The definition of the function
deleteNode is:
template <class Type>
void orderedLinkedList<Type>::deleteNode(const Type& deleteItem)
{
nodeType<Type> *current; //pointer to traverse the list
nodeType<Type> *trailCurrent; //pointer just before current
bool found;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1114

| Chapter 16: Linked Lists

if (first == nullptr) //Case 1
cout << "Cannot delete from an empty list." << endl;
else
{
current = first;
found = false;
while (current != nullptr && !found)
if (current->info >= deleteItem)
found = true;
else
{
trailCurrent = current;
current = current->link;
}

//search the list

if (current == nullptr)
//Case 4
cout << "The item to be deleted is not
<< "list." << endl;
else
if (current->info == deleteItem) //the
//deleted is in
{
if (first == current)
//Case
{
first = first->link;

in the "
item to be
the list
2

if (first == nullptr)
last = nullptr;
delete current;
}
else
//Case 3
{
trailCurrent->link = current->link;
if (current == last)
last = trailCurrent;
delete current;
}
count--;
}
else

//Case 4
cout << "The item to be deleted is not in the "
<< "list." << endl;

}
}//end deleteNode

Header File of the Ordered Linked List
For the sake of completeness, we will show how to create the header file that defines the
class orderedListType, as well as the operations on such lists. (We assume that the
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Ordered Linked Lists

|

1115

definition of the class linkedListType and the definitions of the functions to implement the operations are in the header file linkedlist.h.)
#ifndef H_orderedListType
#define H_orderedListType
#include "linkedList.h"
using namespace std;
template <class Type>
class orderedLinkedList: public linkedListType<Type>
{
public:
bool search(const Type& searchItem) const;
//Function to determine whether searchItem is in the list.
//Postcondition: Returns true if searchItem is in the list,
//
otherwise the value false is returned.
void insert(const Type& newItem);
//Function to insert newItem in the list.
//Postcondition: first points to the new list, newItem
//
is inserted at the proper place in the
//
list, and count is incremented by 1.
void insertFirst(const Type& newItem);
//Function to insert newItem in the list.
//Because the resulting list must be sorted, newItem is
//inserted at the proper place in the list.
//This function uses the function insert to insert newItem.
//Postcondition: first points to the new list, newItem is
//
inserted at the proper place in the list,
//
and count is incremented by 1.
void insertLast(const Type& newItem);
//Function to insert newItem in the list.
//Because the resulting list must be sorted, newItem is
//inserted at the proper place in the list.
//This function uses the function insert to insert newItem.
//Postcondition: first points to the new list, newItem is
//
inserted at the proper place in the list,
//
and count is incremented by 1.
void deleteNode(const Type& deleteItem);
//Function to delete deleteItem from the list.
//Postcondition: If found, the node containing
//
deleteItem is deleted from the list;
//
first points to the first node of the
//
new list, and count is decremented by 1.
//
If deleteItem is not in the list, an
//
appropriate message is printed.
};
//Place the definitions of the functions search, insert,
//insertFirst, insertLast, and deleteNode here.
.
.
.
#endif
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1116

| Chapter 16: Linked Lists

The following program tests various operations on an ordered linked list:
//Program to test the various operations on an ordered linked list
#include <iostream>
#include "orderedLinkedList.h"
using namespace std;
int main()
{
orderedLinkedList<int> list1, list2;
int num;
cout << "Line 3: Enter numbers ending "
<< "with -999." << endl;
cin >> num;
while (num != -999)
{
list1.insert(num);
cin >> num;
}

//Line 1
//Line 2
//Line 3
//Line 4
//Line 5
//Line 6
//Line 7

cout << endl;

//Line 8

cout << "Line 9: list1: ";
list1.print();
cout << endl;

//Line 9
//Line 10
//Line 11

list2 = list1; //test the assignment operator Line 12
cout << "Line 13: list2: ";
list2.print();
cout << endl;

//Line 13
//Line 14
//Line 15

cout << "Line 16: Enter the number to be "
<< "deleted: ";
cin >> num;
cout << endl;

//Line 16
//Line 17
//Line 18

list2.deleteNode(num);

//Line 19

cout << "Line 20: After deleting "
<< num << ", list2: " << endl;
list2.print();
cout<<endl;

//Line 20
//Line 21
//Line 22

return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Print a Linked List in Reverse Order (Recursion Revisited)

|

1117

Sample Run: In this sample run, the user input is shaded.
Line 3: Enter numbers ending with -999.
23 65 34 72 12 82 36 55 29 -999

1
6

Line 9: list1: 12 23 29 34 36 55 65 72 82
Line 13: list2: 12 23 29 34 36 55 65 72 82
Line 16: Enter the number to be deleted: 34
Line 20: After deleting 34, list2:
12 23 29 36 55 65 72 82

The preceding output is self-explanatory. The details are left as an exercise for you.
Notice that the function insert does not check whether the item to be inserted is
already in the list, that is, it does not check for duplicates. Programming Exercise 8 at
the end of this chapter asks you to revise the definition of the function insert so
that before inserting the item, it checks whether it is already in the list. If the item to
be inserted is already in the list, the function outputs an appropriate error message. In
other words, duplicates are not allowed.

Print a Linked List in Reverse Order
(Recursion Revisited)
The nodes of an ordered list (as constructed previously) are in ascending order. Certain
applications, however, might require the data to be printed in descending order, which
means that we must print the list backward. We now discuss the function reversePrint.
Given a pointer to a list, this function prints the elements of the list in reverse order.
Consider the linked list shown in Figure 16-37.

first

FIGURE 16-37

5

10

15

20

Linked list

For the list in Figure 16-37, the output should be in the following form:
20 15 10 5

Because the links are in only one direction, we cannot traverse the list backward starting
from the last node. Let us see how we can effectively use recursion to print the list in
reverse order.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1118

| Chapter 16: Linked Lists

Let us think in terms of recursion. We cannot print the info of the first node until we
have printed the remainder of the list (that is, the tail of the first node). Similarly, we
cannot print the info of the second node until we have printed the tail of the second
node, and so on. Every time we consider the tail of a node, we reduce the size of the list
by 1. Eventually, the size of the list will be reduced to zero, in which case the recursion
will stop. Let us first write the algorithm in pseudocode. (Suppose that current is a
pointer to a linked list.)
if (current != nullptr)
{
reversePrint(current->link);
//print the tail
cout << current->info << endl; //print the node
}

Here, we do not see the base case; it is hidden. The list is printed only if the pointer to
the list is not nullptr. Also, in the body of the if statement, the recursive call is on
the tail of the list. Because eventually the tail of the list will be empty, the if statement
in the next call will fail, and the recursion will stop. Also, note that statements (for
example, printing the info of the node) appear after the recursive call; thus, when the
transfer comes back to the calling function, we must execute the remaining statements.
Recall that the function exits only after the last statement executes. (By the ‘‘last
statement,’’ we do not mean the physical last statement, but rather the logical last
statement.)
Let us write the previous function in C++ and then apply it to a list.
template <class Type>
void linkedListType<Type>::reversePrint
(nodeType<Type> *current) const
{
if (current != nullptr)
{
reversePrint(current->link); //print the tail
cout << current->info << " "; //print the node
}
}

Consider the statement:
reversePrint(first);

in which first is a pointer of type nodeType<Type>.
Let us trace the execution of this statement, which is a function call, for the list shown in
Figure 16-37. Because the formal parameter is a value parameter, the value of the actual
parameter is passed to the formal parameter. See Figure 16-38.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Print a Linked List in Reverse Order (Recursion Revisited)

|

1119

reversePrint(first)
current->5
because(current != nullptr)
reversePrint(current->link)

execute the statement
cout << current->info;
Print 5
Now control goes back
to the caller

reversePrint(current->link)
current->10
because(current != nullptr)
reversePrint(current->link)

execute the statement
cout << current->info;
Print 10
Now control goes back
to the caller

reversePrint(current->link)
current->15
because(current != nullptr)
reversePrint(current->link)

reversePrint(current->link)
current->20
because(current != nullptr)
reversePrint(current->link)

execute the statement
cout << current->info;
Print 15
Now control goes back
to the caller

execute the statement
cout << current->info;
Print 20
Now control goes back
to the caller

reversePrint(current->link)
current is nullptr
because (current is nullptr)
the if statement fails
control goes back to the caller

FIGURE 16-38

Execution of the statement reversePrint(first);

printListReverse
Now that we have written the function reversePrint, we can write the definition of
the function printListReverse. Its definition is:
template <class Type>
void linkedListType<Type>::printListReverse() const
{
reversePrint(first);
cout << endl;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1120

| Chapter 16: Linked Lists

Doubly Linked Lists
A doubly linked list is a linked list in which every node has a next pointer and a back
pointer. In other words, every node contains the address of the next node (except the last
node), and every node contains the address of the previous node (except the first node)
(see Figure 16-39).

first
last

FIGURE 16-39

Doubly linked list

A doubly linked list can be traversed in either direction. That is, we can traverse the list
starting at the first node or, if a pointer to the last node is given, we can traverse the list
starting at the last node.
As before, the typical operations on a doubly linked list are:
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.

Initialize the list.
Destroy the list.
Determine whether the list is empty.
Search the list for a given item.
Retrieve the first element of the list.
Retrieve the last element of the list.
Insert an item in the list.
Delete an item from the list.
Find the length of the list.
Print the list.
Make a copy of the doubly linked list.

Next, we describe these operations for an ordered doubly linked list. The following class
defines a doubly linked list as an ADT:
//Definition of the node
template <class Type>
struct nodeType
{
Type info;
nodeType<Type> *next;
nodeType<Type> *back;
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Doubly Linked Lists

|

1121

template <class Type>
class doublyLinkedList
{
public:
const doublyLinkedList<Type>& operator=
(const doublyLinkedList<Type> &);
//Overload the assignment operator.
void initializeList();
//Function to initialize the list to an empty state.
//Postcondition: first = nullptr; last = nullptr; count = 0;
bool isEmptyList() const;
//Function to determine whether the list is empty.
//Postcondition: Returns true if the list is empty,
//
otherwise returns false.
void destroy();
//Function to delete all the nodes from the list.
//Postcondition: first = nullptr; last = nullptr; count = 0;
void print() const;
//Function to output the info contained in each node.
void reversePrint() const;
//Function to output the info contained in each node
//in reverse order.
int length() const;
//Function to return the number of nodes in the list.
//Postcondition: The value of count is returned.
Type front() const;
//Function to return the first element of the list.
//Precondition: The list must exist and must not be empty.
//Postcondition: If the list is empty, the program
//
terminates; otherwise, the first
//
element of the list is returned.
Type back() const;
//Function to return the last element of the list.
//Precondition: The list must exist and must not be empty.
//Postcondition: If the list is empty, the program
//
terminates; otherwise, the last
//
element of the list is returned.
bool search(const Type& searchItem) const;
//Function to determine whether searchItem is in the list.
//Postcondition: Returns true if searchItem is found in
//
the list, otherwise returns false.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1122

| Chapter 16: Linked Lists

void insert(const Type& insertItem);
//Function to insert insertItem in the list.
//Precondition: If the list is nonempty, it must be in
//
order.
//Postcondition: insertItem is inserted at the proper place
//
in the list, first points to the first
//
node, last points to the last node of the
//
new list, and count is incremented by 1.
void deleteNode(const Type& deleteItem);
//Function to delete deleteItem from the list.
//Postcondition: If found, the node containing deleteItem
//
is deleted from the list; first points
//
to the first node of the new list, last
//
points to the last node of the new list,
//
and count is decremented by 1; otherwise
//
an appropriate message is printed.
doublyLinkedList();
//default constructor
//Initializes the list to an empty state.
//Postcondition: first = nullptr; last = nullptr; count = 0;
doublyLinkedList(const doublyLinkedList<Type>& otherList);
//copy constructor
doublyLinkedList();
//destructor
//Postcondition: The list object is destroyed.
protected:
int count;
nodeType<Type> *first; //pointer to the first node
nodeType<Type> *last; //pointer to the last node
private:
void copyList(const doublyLinkedList<Type>& otherList);
//Function to make a copy of otherList.
//Postcondition: A copy of otherList is created and
//
assigned to this list.
};

We leave the UML class diagram of the class doublyLinkedList as an exercise for
you.
The functions to implement the operations of a doubly linked list are similar to the ones
discussed earlier. Here, because every node has two pointers, back and next, some of the
operations require the adjustment of two pointers in each node. For the insert and delete
operations, because we can traverse the list in either direction, we use only one pointer to
traverse the list. Let us call this pointer current. We can set the value of trailCurrent
by using both the current pointer and the back pointer of the node pointed to by
current. We give the definition of each function here, with four exceptions. Definitions

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Doubly Linked Lists

|

1123

of the functions copyList, the copy constructor, overloading the assignment operator,
and the destructor are left as exercises for you. (See Programming Exercise 11 at the end
of this chapter.) Moreover, the function copyList is used only to implement the copy
constructor and overload the assignment operator.

Default Constructor
The default constructor initializes the doubly linked list to an empty state. It sets first
and last to nullptr and count to 0.
template <class Type>
doublyLinkedList<Type>::doublyLinkedList()
{
first= nullptr;
last = nullptr;
count = 0;
}

isEmptyList
This operation returns true if the list is empty; otherwise, it returns false. The list is
empty if the pointer first is nullptr.
template <class Type>
bool doublyLinkedList<Type>::isEmptyList() const
{
return (first == nullptr);
}

Destroy the List
This operation deletes all of the nodes in the list, leaving the list in an empty state. We
traverse the list starting at the first node and then delete each node. Furthermore, count
is set to 0.
template <class Type>
void doublyLinkedList<Type>::destroy()
{
nodeType<Type> *temp; //pointer to delete the node
while (first != nullptr)
{
temp = first;
first = first->next;
delete temp;
}
last = nullptr;
count = 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1124

| Chapter 16: Linked Lists

Initialize the List
This operation reinitializes the doubly linked list to an empty state. This task can be done
by using the operation destroy. The definition of the function initializeList is:
template <class Type>
void doublyLinkedList<Type>::initializeList()
{
destroy();
}

Length of the List
The length of a linked list (that is, how many nodes are in the list) is stored in the variable
count. Therefore, this function returns the value of this variable.
template <class Type>
int doublyLinkedList<Type>::length() const
{
return count;
}

Print the List
The function print outputs the info contained in each node. We traverse the list,
starting from the first node.
template <class Type>
void doublyLinkedList<Type>::print() const
{
nodeType<Type> *current; //pointer to traverse the list
current = first;

//set current to point to the first node

while (current != nullptr)
{
cout << current->info << "
current = current->next;
}//end while
}//end print

";

//output info

Reverse Print the List
This function outputs the info contained in each node in reverse order. We traverse the
list in reverse order, starting from the last node. Its definition is:
template <class Type>
void doublyLinkedList<Type>::reversePrint() const
{
nodeType<Type> *current; //pointer to traverse
//the list

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Doubly Linked Lists

current = last;

|

1125

//set current to point to the
//last node

while (current != nullptr)
{
cout << current->info << "
current = current->back;
}//end while
}//end reversePrint

";

Search the List
The function search returns true if searchItem is found in the list; otherwise, it
returns false. The search algorithm is exactly the same as the search algorithm for an
ordered linked list.
template <class Type>
bool doublyLinkedList<Type>::
search(const Type& searchItem) const
{
bool found = false;
nodeType<Type> *current; //pointer to traverse the list
current = first;
while (current != nullptr && !found)
if (current->info >= searchItem)
found = true;
else
current = current->next;
if (found)
found = (current->info == searchItem); //test for
//equality
return found;
}//end search

First and Last Elements
The function front returns the first element of the list, and the function back returns
the last element of the list. If the list is empty, both functions terminate the program.
Their definitions are:
template <class Type>
Type doublyLinkedList<Type>::front() const
{
assert(first != nullptr);
return first->info;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1126

| Chapter 16: Linked Lists

template <class Type>
Type doublyLinkedList<Type>::back() const
{
assert(last != nullptr);
return last->info;
}

INSERT A NODE
Because we are inserting an item in a doubly linked list, the insertion of a node in the list
requires the adjustment of two pointers in certain nodes. As before, we find the place
where the new item is supposed to be inserted, create the node, store the new item, and
adjust the link fields of the new node and other particular nodes in the list. There are four
cases:

Case 1: Insertion in an empty list
Case 2: Insertion at the beginning of a nonempty list
Case 3: Insertion at the end of a nonempty list
Case 4: Insertion somewhere in a nonempty list
Both Cases 1 and 2 require us to change the value of the pointer first. Cases 3 and
4 are similar. After inserting an item, count is incremented by 1. Next, we show
Case 4.
Consider the doubly linked list shown in Figure 16-40.

first

8

15

24

40

last
count 4

FIGURE 16-40

Doubly linked list before inserting 20

Suppose that 20 is to be inserted in the list. After inserting 20, the resulting list is as
shown in Figure 16-41.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Doubly Linked Lists

first

8

15

24

|

1127

40

20

last
count 5

FIGURE 16-41

Doubly linked list after inserting 20

From Figure 16-41, it follows that the next pointer of node 15, the back pointer of
node 24, and both the next and back pointers of node 20 need to be adjusted.
The definition of the function insert is:
template <class Type>
void doublyLinkedList<Type>::insert(const Type& insertItem)
{
nodeType<Type> *current;
//pointer to traverse the list
nodeType<Type> *trailCurrent; //pointer just before current
nodeType<Type> *newNode;
//pointer to create a node
bool found;
newNode = new
newNode->info
newNode->next
newNode->back

nodeType<Type>; //create the node
= insertItem; //store the new item in the node
= nullptr;
= nullptr;

if (first == nullptr) //if the list is empty, newNode is
//the only node
{
first = newNode;
last = newNode;
count++;
}
else
{
found = false;
current = first;
while (current != nullptr && !found) //search the list
if (current->info >= insertItem)
found = true;
else
{
trailCurrent = current;
current = current->next;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1128

| Chapter 16: Linked Lists

if (current == first) //insert newNode before first
{
first->back = newNode;
newNode->next = first;
first = newNode;
count++;
}
else
{
//insert newNode between trailCurrent and current
if (current != nullptr)
{
trailCurrent->next = newNode;
newNode->back = trailCurrent;
newNode->next = current;
current->back = newNode;
}
else
{
trailCurrent->next = newNode;
newNode->back = trailCurrent;
last = newNode;
}
count++;
}//end else
}//end else
}//end insert

DELETE A NODE
This operation deletes a given item (if found) from the doubly linked list. As before, we
first search the list to see whether the item to be deleted is in the list. The search
algorithm is the same as before. Similar to the insertNode operation, this operation
(if the item to be deleted is in the list) requires the adjustment of two pointers in certain
nodes. The delete operation has several cases:

Case 1: The list is empty.
Case 2: The item to be deleted is in the first node of the list, which would require us to
change the value of the pointer first.
Case 3: The item to be deleted is somewhere in the list.
Case 4: The item to be deleted is not in the list.
After deleting a node, count is decremented by 1. Let us demonstrate Case 3. Consider
the list shown in Figure 16-42.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Doubly Linked Lists

first

5

17

44

|

1129

52

last

1
6

count 4

FIGURE 16-42

Doubly linked list before deleting 17

Suppose that the item to be deleted is 17. First, we search the list with two pointers
and find the node with info 17 and then adjust the link field of the affected nodes (see
Figure 16-43).

first

5

17

52

44

current
trailCurrent
last
count 4

FIGURE 16-43

List after adjusting the links of the nodes before and after the node with info 17

Next, we delete the node pointed to by current (see Figure 16-44).

first

5

44

52

last
count 3

FIGURE 16-44

List after deleting the node with info 17

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1130

| Chapter 16: Linked Lists

The definition of the function deleteNode is:
template <class Type>
void doublyLinkedList<Type>::deleteNode(const Type& deleteItem)
{
nodeType<Type> *current; //pointer to traverse the list
nodeType<Type> *trailCurrent; //pointer just before current
bool found;
if (first == nullptr)
cout << "Cannot delete from an empty list." << endl;
else if (first->info == deleteItem) //node to be deleted is
//the first node
{
current = first;
first = first->next;
if (first != nullptr)
first->back = nullptr;
else
last = nullptr;
count--;
delete current;
}
else
{
found = false;
current = first;
while (current != nullptr && !found)
if (current->info >= deleteItem)
found = true;
else
current = current->next;

//search the list

if (current == nullptr)
cout << "The item to be deleted is not in "
<< "the list." << endl;
else if (current->info == deleteItem) //check for
//equality
{
trailCurrent = current->back;
trailCurrent->next = current->next;
if (current->next != nullptr)
current->next->back = trailCurrent;
if (current == last)
last = trailCurrent;
count--;
delete current;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Circular Linked Lists

|

1131

else
cout << "The item to be deleted is not in list."
<< endl;
}//end else
}//end deleteNode

Circular Linked Lists
A linked list in which the last node points to the first node is called a circular linked list.
Figure 16-45 show various circular linked lists.

first
(a) Empty circular list

first
(b) Circular linked list with one node

first
(c) Circular linked list with more than one node

FIGURE 16-45

Circular linked lists

In a circular linked list with more than one node, as in Figure 16-45(c), it is convenient to
make the pointer first point to the last node of the list. Then, by using first, you can
access both the first and the last nodes of the list. For example, first points to the last
node, and first->link points to the first node.
As before, the usual operations on a circular list are:
1.
2.
3.
4.
5.
6.
7.
8.
9.

Initialize the list (to an empty state).
Determine if the list is empty.
Destroy the list.
Print the list.
Find the length of the list.
Search the list for a given item.
Insert an item in the list.
Delete an item from the list.
Copy the list.

We leave it as an exercise for you to design a class to implement a sorted circular linked
list. (See Programming Exercise 13 at the end of this chapter.)
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1132

| Chapter 16: Linked Lists

PROGRAMMING EXAMPLE:

Watch
the Video

DVD Store

For a family or an individual, a favorite place to go on weekends or holidays is to a
DVD store to rent movies. A new DVD store in your neighborhood is about to open.
However, it does not have a program to keep track of its DVDs and customers. The
store managers want someone to write a program for their system so that the DVD
store can function. The program should be able to perform the following operations:
1.
2.
3.
4.
5.
6.
7.
8.

Rent a DVD; that is, check out a DVD.
Return, or check in, a DVD.
Create a list of DVDs owned by the store.
Show the details of a particular DVD.
Print a list of all of the DVDs in the store.
Check whether a particular DVD is in the store.
Maintain a customer database.
Print a list of all of the DVDs rented by each customer.

Let us write a program for the DVD store. This example further illustrates the objectoriented design methodology and, in particular, inheritance and overloading.
The programming requirement tells us that the DVD store has two major components: DVDs and customers. We will describe these two components in detail. We
also need to maintain the following lists:
•
•
•

A list of all of the DVDs in the store
A list of all of the store’s customers
Lists of the DVDs currently rented by the customers

We will develop the program in two parts. In Part 1, we design, implement, and test
the DVD component. In Part 2, we design and implement the customer component,
which is then added to the DVD component developed in Part 1. That is, after
completing Parts 1 and 2, we can perform all of the operations listed previously.
PART 1: DVD
COMPONENT

DVD Object This is the first stage, wherein we discuss the DVD component. The common things

associated with a DVD are:
•
•
•
•

Name of the movie
Names of the stars
Name of the producer
Name of the director

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store

•
•

|

1133

Name of the production company
Number of copies in the store

From this list, we see that some of the operations to be performed on a DVD object are:
1. Set the DVD information—that is, the title, stars, production company, and so on.
2. Show the details of a particular DVD.
3. Check the number of copies in the store.
4. Check out (that is, rent) the DVD. In other words, if the number of
copies is greater than zero, decrement the number of copies by one.
5. Check in (that is, return) the DVD. To check in a DVD, first we
must check whether the store owns such a DVD and, if it does,
increment the number of copies by one.
6. Check whether a particular DVD is available—that is, check whether
the number of copies currently in the store is greater than zero.
The deletion of a DVD from the DVD list requires that the list be searched for the
DVD to be deleted. Thus, we need to check the title of a DVD to find out which
DVD is to be deleted from the list. For simplicity, we assume that two DVDs are the
same if they have the same title.
The following class defines the DVD object as an ADT.
//************************************************************
// Author: D.S. Malik
//
// class dvdType
// This class specifies the members to implement a DVD.
//************************************************************
#include <iostream>
#include <string>
using namespace std;
class dvdType
{
friend ostream& operator<< (ostream&, const dvdType&);
public:
void setDVDInfo(string title, string star1,
string star2, string producer,
string director, string productionCo,
int setInStock);
//Function to set the details of a DVD.
//The member variables are set according to the
//parameters.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1134

| Chapter 16: Linked Lists

//Postcondition: dvdTitle = title; movieStar1 = star1;
//
movieStar2 = star2; movieProducer = producer;
//
movieDirector = director;
//
movieProductionCo = productionCo;
//
copiesInStock = setInStock;
int getNoOfCopiesInStock() const;
//Function to check the number of copies in stock.
//Postcondition: The value of copiesInStock is returned.
void checkOut();
//Function to rent a DVD.
//Postcondition: The number of copies in stock is
//
decremented by one.
void checkIn();
//Function to check in a DVD.
//Postcondition: The number of copies in stock is
//
incremented by one.
void printTitle() const;
//Function to print the title of a movie.
void printInfo() const;
//Function to print the details of a DVD.
//Postcondition: The title of the movie, stars,
//
director, and so on are displayed
//
on the screen.
bool checkTitle(string title);
//Function to check whether the title is the same as the
//title of the DVD.
//Postcondition: Returns the value true if the title
//
is the same as the title of the DVD;
//
false otherwise.
void updateInStock(int num);
//Function to increment the number of copies in stock by
//adding the value of the parameter num.
//Postcondition: copiesInStock = copiesInStock + num;
void setCopiesInStock(int num);
//Function to set the number of copies in stock.
//Postcondition: copiesInStock = num;
string getTitle() const;
//Function to return the title of the DVD.
//Postcondition: The title of the DVD is returned.
dvdType(string title = "", string star1 = "",
string star2 = "", string producer = "",

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store

|

1135

string director = "", string productionCo = "",
int setInStock = 0);
//constructor
//The member variables are set according to the
//incoming parameters. If no values are specified, the
//default values are assigned.
//Postcondition: dvdTitle = title; movieStar1 = star1;
//
movieStar2 = star2;
//
movieProducer = producer;
//
movieDirector = director;
//
movieProductionCo = productionCo;
//
copiesInStock = setInStock;
//Overload the relational operators.
bool operator==(const dvdType&) const;
bool operator!=(const dvdType&) const;
private:
string dvdTitle;

//variable to store the name
//of the movie
string movieStar1; //variable to store the name
//of the star
string movieStar2; //variable to store the name
//of the star
string movieProducer; //variable to store the name
//of the producer
string movieDirector; //variable to store the name
//of the director
string movieProductionCo; //variable to store the name
//of the production company
int copiesInStock; //variable to store the number of
//copies in stock

};

We leave the UML diagram of the class dvdType as an exercise for you.
For easy output, we will overload the output stream insertion operator, <<, for the
class dvdType.
Next, we will write the definitions of each function in the class dvdType. The
definitions of these functions, as given below, are quite straightforward and easy to
follow.
void dvdType::setDVDInfo(string title, string star1,
string star2, string producer,
string director,
string productionCo,
int setInStock)
{
dvdTitle = title;
movieStar1 = star1;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1136

| Chapter 16: Linked Lists

movieStar2 = star2;
movieProducer = producer;
movieDirector = director;
movieProductionCo = productionCo;
copiesInStock = setInStock;
}
void dvdType::checkOut()
{
if (getNoOfCopiesInStock() > 0)
copiesInStock--;
else
cout << "Currently out of stock" << endl;
}
void dvdType::checkIn()
{
copiesInStock++;
}
int dvdType::getNoOfCopiesInStock() const
{
return copiesInStock;
}
void dvdType::printTitle() const
{
cout << "DVD Title: " << dvdTitle << endl;
}
void dvdType::printInfo() const
{
cout << "DVD Title: " << dvdTitle << endl;
cout << "Stars: " << movieStar1 << " and "
<< movieStar2 << endl;
cout << "Producer: " << movieProducer << endl;
cout << "Director: " << movieDirector << endl;
cout << "Production Company: " << movieProductionCo
<< endl;
cout << "Copies in stock: " << copiesInStock
<< endl;
}
bool dvdType::checkTitle(string title)
{
return(dvdTitle == title);
}
void dvdType::updateInStock(int num)
{
copiesInStock += num;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store

|

1137

void dvdType::setCopiesInStock(int num)
{
copiesInStock = num;
}
string dvdType::getTitle() const
{
return dvdTitle;
}
dvdType::dvdType(string title, string star1,
string star2, string producer,
string director,
string productionCo, int setInStock)
{
setDVDInfo(title, star1, star2, producer, director,
productionCo, setInStock);
}
bool dvdType::operator==(const dvdType& other) const
{
return (dvdTitle == other.dvdTitle);
}
bool dvdType::operator!=(const dvdType& other) const
{
return (dvdTitle != other.dvdTitle);
}
ostream& operator<< (ostream& osObject, const dvdType& dvd)
{
osObject << endl;
osObject << "DVD Title: " << dvd.dvdTitle << endl;
osObject << "Stars: " << dvd.movieStar1 << " and "
<< dvd.movieStar2 << endl;
osObject << "Producer: " << dvd.movieProducer << endl;
osObject << "Director: " << dvd.movieDirector << endl;
osObject << "Production Company: "
<< dvd.movieProductionCo << endl;
osObject << "Copies in stock: " << dvd.copiesInStock
<< endl;
osObject << "_____________________________________"
<< endl;
return osObject;
}

DVD List This program requires us to maintain a list of all of the DVDs in the store. We also

should be able to add a new DVD to our list. In general, we would not know how
many DVDs are in the store, and adding or deleting a DVD from the store would
change the number of DVDs in the store. Therefore, we will use a linked list to
create a list of DVDs (see Figure 16-46).
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1138

| Chapter 16: Linked Lists

first

DVD
info

DVD
info

...

DVD
info

last

FIGURE 16-46

dvdList

Earlier in this chapter, we defined the class unorderedLinkedList to
create a linked list of objects. We also defined the basic operations such as insertion
and deletion of a DVD in the list. However, some operations are very specific to
the DVD list, such as check out a DVD, check in a DVD, set the number of
copies of a DVD, and so on. These operations are not available in the class
unorderedLinkedList. We will, therefore, derive a class dvdListType from
the class unorderedLinkedList and add these operations.
The definition of the class dvdListType is:
//*************************************************************
// Author: D.S. Malik
//
// class dvdListType
// This class specifies the members to implement a list of
// DVDs.
//************************************************************
#include <string>
#include "unorderedLinkedList.h"
#include "dvdType.h"
using namespace std;
class dvdListType:public unorderedLinkedList<dvdType>
{
public:
bool dvdSearch(string title) const;
//Function to search the list to see whether a
//particular title, specified by the parameter title,
//is in the store.
//Postcondition: Returns true if the title is found,
//
and false otherwise.
bool isDVDAvailable(string title) const;
//Function to determine whether a copy of a particular
//DVD is in the store.
//Postcondition: Returns true if at least one copy of the
//
DVD specified by title is in the store,
//
and false otherwise.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store

|

1139

void dvdCheckOut(string title);
//Function to check out a DVD, that is, rent a DVD.
//Postcondition: copiesInStock is decremented by one.
void dvdCheckIn(string title);
//Function to check in a DVD returned by a customer.
//Postcondition: copiesInStock is incremented by one.
bool dvdCheckTitle(string title) const;
//Function to determine whether a particular DVD is in
//the store.
//Postcondition: Returns true if the DVD’s title is
//
the same as title, and false otherwise.
void dvdUpdateInStock(string title, int num);
//Function to update the number of copies of a DVD
//by adding the value of the parameter num. The
//parameter title specifies the name of the DVD for
//which the number of copies is to be updated.
//Postcondition: copiesInStock = copiesInStock + num;
void dvdSetCopiesInStock(string title, int num);
//Function to reset the number of copies of a DVD.
//The parameter title specifies the name of the DVD
//for which the number of copies is to be reset, and the
//parameter num specifies the number of copies.
//Postcondition: copiesInStock = num;
void dvdPrintTitle() const;
//Function to print the titles of all the DVDs in
//the store.
private:
void searchDVDList(string title, bool& found,
nodeType<dvdType>* &current) const;
//This function searches the DVD list for a
//particular DVD, specified by the parameter title.
//Postcondition: If the DVD is found, the parameter
//
found is set to true, otherwise it is set
//
to false. The parameter current points
//
to the node containing the DVD.
};

Note that the class dvdListType is derived from the class
unorderedLinkedList via a public inheritance. Furthermore,
unorderedLinkedList is a class template, and we have passed the class
dvdType as a parameter to this class. That is, the class dvdListType is not a

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1140

| Chapter 16: Linked Lists

template. Because we are now dealing with a very specific data type, the class
dvdListType is no longer required to be a template. Thus, the info type of
each node in the linked list is now dvdType. Through the member functions of
the class dvdType, certain members—such as dvdTitle and copiesInStock
of an object of type dvdType—can now be accessed.
The definitions of the functions to implement the operations of the class
dvdListType are given next.

The primary operations on the DVD list are to check in a DVD and to check out a
DVD. Both operations require the list to be searched and the location of the DVD
being checked in or checked out to be found in the DVD list. Other operations, such
as determining whether a particular DVD is in the store, updating the number of
copies of a DVD, and so on, also require the list to be searched. To simplify the
search process, we will write a function that searches the DVD list for a particular
DVD. If the DVD is found, it sets a parameter found to true and returns a pointer
to the DVD so that check-in, check-out, and other operations on the DVD object
can be performed. Note that the function searchDVDList is a private data
member of the class dvdListType because it is used only for internal manipulation. First, we describe the search procedure.
Consider the node of the DVD list shown in Figure 16-47.

DVD
info

FIGURE 16-47

Node of a DVD list

The component info is of type dvdType and contains the necessary information
about a DVD. In fact, the component info of the node has seven members:
dvdTitle, movieStar1, movieStar2, movieProducer, movieDirector,
movieProductionCo, and copiesInStock. (See the definition of the
class dvdType.) Therefore, the node of a DVD list has the form shown in
Figure 16-48.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store

|

1141

dvdTitle

1
6

movieStar1
movieStar2
movieProducer
movieDirector
movieProductionCo
copiesInStock
info

FIGURE 16-48

link

DVD list node showing components of info

These member variables are all private and cannot be accessed directly. The
member functions of the class dvdType will help us in checking and/or setting the
value of a particular component.
Suppose a pointer—say, current—points to a node in the DVD list (see Figure 16-49).

dvdTitle
movieStar1
current

movieStar2
movieProducer
movieDirector
movieProductionCo
copiesInStock
info

FIGURE 16-49

link

Pointer current and DVD list node

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1142

| Chapter 16: Linked Lists

Now:
current->info

refers to the info part of the node. Suppose that we want to know whether the title
of the DVD stored in this node is the same as the title specified by the variable
title. The expression:
current->info.checkTitle(title)

is true if the title of the DVD stored in this node is the same as the title specified by the
parameter title, and false otherwise. (Note that the member function checkTitle
is a value-returning function. See its declaration in the class dvdType.)
As another example, suppose that we want to set copiesInStock of this node to 10.
Because copiesInStock is a private member, it cannot be accessed directly.
Therefore, the statement:
current->info.copiesInStock = 10;

//illegal

is incorrect and will generate a compile-time error. We have to use the member
function setCopiesInStock as follows:
current->info.setCopiesInStock(10);

Now that we know how to access a member variable of a DVD stored in a node, let
us describe the algorithm to search the DVD list.
while (not found)
if the title of the current DVD is the same as the desired
title, stop the search
else
check the next node

The following function definition performs the desired search:
void dvdListType::searchDVDList(string title, bool& found,
nodeType<dvdType>* &current) const
{
found = false;
//set found to false
current = first; //set current to point to the first node
//in the list
while (current != nullptr && !found)
//search the list
if (current->info.checkTitle(title)) //the item is found
found = true;
else
current = current->link; //advance current to
//the next node
}//end searchDVDList

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store

|

1143

If the search is successful, the parameter found is set to true and the parameter
current points to the node containing the DVD info. If it is unsuccessful, found is
set to false and current will be nullptr.
The definitions of the other functions of the class dvdListType follow:
bool dvdListType::isDVDAvailable(string title) const
{
bool found;
nodeType<dvdType> *location;
searchDVDList(title, found, location);
if (found)
found = (location->info.getNoOfCopiesInStock() > 0);
else
found = false;
return found;
}
void dvdListType::dvdCheckIn(string title)
{
bool found = false;
nodeType<dvdType> *location;
searchDVDList(title, found, location); //search the list
if (found)
location->info.checkIn();
else
cout << "The store does not carry " << title
<< endl;
}
void dvdListType::dvdCheckOut(string title)
{
bool found = false;
nodeType<dvdType> *location;
searchDVDList(title, found, location); //search the list
if (found)
location->info.checkOut();
else
cout << "The store does not carry " << title
<< endl;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1144

| Chapter 16: Linked Lists

bool dvdListType::dvdCheckTitle(string title) const
{
bool found = false;
nodeType<dvdType> *location;
searchDVDList(title, found, location); //search the list
return found;
}
void dvdListType::dvdUpdateInStock(string title, int num)
{
bool found = false;
nodeType<dvdType> *location;
searchDVDList(title, found, location); //search the list
if (found)
location->info.updateInStock(num);
else
cout << "The store does not carry " << title
<< endl;
}
void dvdListType::dvdSetCopiesInStock(string title, int num)
{
bool found = false;
nodeType<dvdType> *location;
searchDVDList(title, found, location);
if (found)
location->info.setCopiesInStock(num);
else
cout << "The store does not carry " << title
<< endl;
}
bool dvdListType::dvdSearch(string title) const
{
bool found = false;
nodeType<dvdType> *location;
searchDVDList(title, found, location);
return found;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store

|

1145

void dvdListType::dvdPrintTitle() const
{
nodeType<dvdType>* current;
current = first;
while (current != nullptr)
{
current->info.printTitle();
current = current->link;
}
}
PART 2: CUSTOMER
COMPONENT

Customer The customer object stores information about a customer, such as the first name, last
Object name, account number, and a list of DVDs rented by the customer.

Every customer is a person. We have already designed the class personType in
Example 10-10 (Chapter 10) and described the necessary operations on the name of a
person. Therefore, we can derive the class customerType from the class personType and add the additional members that we need. First, however, we must
redefine the class personType to take advantage of the new features of objectoriented design that you have learned, such as operator overloading, and then derive
the class customerType.
Recall that the basic operations on an object of type personType are:
1.
2.
3.
4.

Print the name.
Set the name.
Show the first name.
Show the last name.

Similarly, the basic operations on an object of type customerType are:
1.
2.
3.
4.
5.

Print the name, account number, and the list of rented DVDs.
Set the name and the account number.
Rent a DVD; that is, add the rented DVD to the list.
Return a DVD; that is, delete the rented DVD from the list.
Show the account number.

The details of implementing the customer component are left as an exercise for you.
(See Programming Exercise 14 at the end of this chapter.)
Main Program We will now write the main program to test the DVD object. We assume that the

necessary data for the DVDs are stored in a file. We will open the file and create the

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1146

| Chapter 16: Linked Lists

list of DVDs owned by the DVD store. The data in the input file is in the following
form:
DVD title (that is, the name of the movie)
movie star1
movie star2
movie producer
movie director
movie production co.
number of copies
.
.
.

We will write a function, createDVDList, to read the data from the input file and
create the list of DVDs. We will also write a function, displayMenu, to show the
different choices—such as check in a movie or check out a movie—that the user can
make. The algorithm of the function main is:
1. Open the input file.
If the input file does not exist, exit the program.
2. Create the list of DVDs (createDVDList).
3. Show the menu (displayMenu).
4. While not done
Perform various operations.
Opening the input file is straightforward. Let us describe Steps 2 and 3, which
are accomplished by writing two separate functions: createDVDList and
displayMenu.
createDVDList

This function reads the data from the input file and creates a linked list of DVDs.
Because the data will be read from a file and the input file was opened in the function
main, we pass the input file pointer to this function. We also pass the DVD list pointer,
declared in the function main, to this function. Both parameters are reference
parameters. Next, we read the data for each DVD and then insert the DVD in the
list. The general algorithm is:
a. Read the data and store it in a DVD object.
b. Insert the DVD in the list.
c. Repeat steps a and b for each DVD’s data in the file.

displayMenu

This function informs the user what to do. It contains the following output statements:
Select one of the following:
1. To check whether the store carries a particular DVD
2. To check out a DVD

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store

3.
4.
5.
6.
9.

To
To
To
To
To

|

1147

check in a DVD
check whether a particular DVD is in stock
print only the titles of all the DVDs
print a list of all the DVDs
exit

In pseudocode, Step 4 (of the main program) is:
a. get choice
b.
while (choice != 9)
{
switch (choice)
{
case 1:
a. get the movie name
b. search the DVD list
c. if found, report success
else report "failure"
break;
case 2:
a. get the movie name
b. search the DVD list
c. if found, check out the DVD
else report "failure"
break;
case 3:
a. get the movie name
b. search the DVD list
c. if found, check in DVD
else report "failure"
break;
case 4:
a. get the movie name
b. search the DVD list
c. if found
if number of copies > 0
report "success"
else
report "currently out of stock"
else report "failure"
break;
case 5:
print the titles of the DVDs
break;
case 6:
print all the DVDs in the store
break;
default: invalid selection
} //end switch

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1148

| Chapter 16: Linked Lists

displayMenu();
get choice;
}//end while
PROGRAM
LISTING

/*************************************************************
// Author: D.S. Malik
//
// This program uses the classes dvdType and dvdListType to
// create a list of DVDs for a DVD store. It also performs
// basic operations such as check in and check out DVDs.
//*************************************************************
#include
#include
#include
#include
#include

<iostream>
<fstream>
<string>
"dvdType.h"
"dvdListType.h"

using namespace std;
void createDVDList(ifstream& infile,
dvdListType& dvdList);
void displayMenu();
int main()
{
dvdListType dvdList;
int choice;
char ch;
string title;
ifstream infile;
//open the input file
infile.open("dvdDat.txt");
if (!infile)
{
cout << "The input file does not exist. "
<< "The program terminates!!!" << endl;
return 1;
}
//create the DVD list
createDVDList(infile, dvdList);
infile.close();
//show the menu
displayMenu();
cout << "Enter your choice: ";
cin >> choice;
//get the request
cin.get(ch);
cout << endl;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store

|

1149

//process the requests
while (choice != 9)
{
switch (choice)
{
case 1:
cout << "Enter the title: ";
getline(cin, title);
cout << endl;
if (dvdList.dvdSearch(title))
cout << "The store carries " << title
<< endl;
else
cout << "The store does not carry "
<< title << endl;
break;
case 2:
cout << "Enter the title: ";
getline(cin, title);
cout << endl;
if (dvdList.dvdSearch(title))
{
if (dvdList.isDVDAvailable(title))
{
dvdList.dvdCheckOut(title);
cout << "Enjoy your movie: "
<< title << endl;
}
else
cout << "Currently " << title
<< " is out of stock." << endl;
}
else
cout << "The store does not carry "
<< title << endl;
break;
case 3:
cout << "Enter the title: ";
getline(cin, title);
cout << endl;
if (dvdList.dvdSearch(title))
{
dvdList.dvdCheckIn(title);
cout << "Thanks for returning "
<< title << endl;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1150

| Chapter 16: Linked Lists

else
cout << "The store does not carry "
<< title << endl;
break;
case 4:
cout << "Enter the title: ";
getline(cin, title);
cout << endl;
if (dvdList.dvdSearch(title))
{
if (dvdList.isDVDAvailable(title))
cout << title << " is currently in "
<< "stock." << endl;
else
cout << title << " is currently out "
<< "of stock." << endl;
}
else
cout << "The store does not carry "
<< title << endl;
break;
case 5:
dvdList.dvdPrintTitle();
break;
case 6:
dvdList.print();
break;
default:
cout << "Invalid selection." << endl;
}//end switch
displayMenu();

//display menu

cout << "Enter your choice: ";
cin >> choice;
//get the next request
cin.get(ch);
cout << endl;
}//end while
return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store

|

1151

void createDVDList(ifstream& infile,
dvdListType& dvdList)
{
string title;
string star1;
string star2;
string producer;
string director;
string productionCo;
char ch;
int inStock;
dvdType newDVD;
getline(infile, title);
while (infile)
{
getline(infile, star1);
getline(infile, star2);
getline(infile, producer);
getline(infile, director);
getline(infile, productionCo);
infile >> inStock;
infile.get(ch);
newDVD.setDVDInfo(title, star1, star2, producer,
director, productionCo, inStock);
dvdList.insertFirst(newDVD);
getline(infile, title);
}//end while
}//end createDVDList
void displayMenu()
{
cout << "Select one of the following:" << endl;
cout << "1: To check whether the store carries a "
<< "particular DVD." << endl;
cout << "2: To check out a DVD." << endl;
cout << "3: To check in a DVD." << endl;
cout << "4: To check whether a particular DVD is "
<< "in stock." << endl;
cout << "5: To print only the titles of all the DVDs."
<< endl;
cout << "6: To print a list of all the DVDs." << endl;
cout << "9: To exit" << endl;
}//end displayMenu

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1152

| Chapter 16: Linked Lists

QUICK REVIEW
1.

A linked list is a list of items, called nodes, in which the order of the nodes
is determined by the address, called a link, stored in each node.
The pointer to a linked list—that is, the pointer to the first node in the
list—is stored in a separate location called the head or first.
A linked list is a dynamic data structure.
The length of a linked list is the number of nodes in the list.
Item insertion and deletion from a linked list do not require data
movement; only the pointers are adjusted.
A (single) linked list is traversed in only one direction.
The search on a linked list is sequential.
The first (or head) pointer of a linked list is always fixed, pointing to the
first node in the list.
To traverse a linked list, the program must use a pointer different than the
head pointer of the list, initialized to the first node in the list.
In a doubly linked list, every node has two links: one points to the next
node and one points to the previous node.
A doubly linked list can be traversed in either direction.
In a doubly linked list, item insertion and deletion require the adjustment of
two pointers in a node.
A linked list in which the last node points to the first node is called a
circular linked list.

2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.

b.

c.
d.
e.

f.

g.

Every node in a linked list has two components: one to store the relevant
information and one to store the address. (1)
In a linked list, the order of the elements is determined by the order in
which the nodes were created to store the elements. (1)
In a linked list, memory allocated for the nodes is sequential. (1, 2)
In a linked list, typically, the link field of the last node points to itself. (1, 2)
Suppose the nodes of a linked list are in the usual info-link form and
current points to a node of the linked list. Then current = current.link;
advances current to the next node in the linked list. (2)
To insert a new item in a linked list, create a node, store the new item in
the node, and insert the node in the linked list. (3)
To build a linked list forward, the new node is inserted at the end of the list. (4)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

1153

A single linked list can be traversed in either direction. (2, 4, 5)
In a linked list, nodes are always inserted either at the beginning or the end
because a linked list is not a random-access data structure. (4, 5, 8, 9)
j. The head pointer of a linked list should not be used to traverse the list. (2, 4, 7)
k. The two most common operations on iterators are ++ and * (the
dereferencing operator). (6)
l.
The function initializeList of the class linkedListType initializes the list by only setting the pointers first and last to nullptr. (7)
m. The function search of the class unorderedLinkedList searches
the linked list sequentially, while the function search of the class
orderedLinkedList searches the list using a binary search algorithm
because the data in an orderedLinkedList object is sorted. (8, 9)
n. A doubly linked list can be traversed in either direction. (10)
2.
Describe the two typical components of a single linked list node. (1)
3.
What is stored in the link field of the last node of a nonempty single linked list? (2)
4.
Suppose that first is a pointer to a linked list. What is stored in first? (2)
5.
Suppose that the fourth node of a linked list is to be deleted, and p points to the fourth
node. Why do you need a pointer to the third node of the linked list? (3)
Consider the linked list shown in Figure 16-50. Assume that the nodes are in the usual
info-link form. Use this list to answer Exercises 6 through 14. If necessary, declare
additional variables. (Assume that list, current, temp, trail, and last
h.
i.

are pointers of type

nodeType.)

list
75
current

FIGURE 16-50
6.

35

86

10

temp

50

28
trail

65

39

last

Linked list for Exercises 6 through 14

What is the output, if any, of each of the following C++ statements? (3, 4)
a.

cout << current->info;

b.

current ¼ current->link;
cout << current->info;

c.

cout << temp->link->link->info;

d.

trail->link ¼ nullptr;
cout << trail->info;

e.

cout << last->link->info;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1154

7.

8.

9.

| Chapter 16: Linked Lists

What is the value of each of the following relational expressions? (3, 4)
a.

current->link ¼¼ temp

b.

temp->link->link->info ¼¼ 50

c.

trail->link->link ¼¼ 0

d.

last->link ¼¼ nullptr

e.

list ¼¼ current

What are the effects, if any, of each of the following C++ statements? (3, 4)
a.

trail->link ¼ nullptr;
delete last;

b.

temp->link ¼ trail;

c.

list->info ¼ 19;

d.

current ¼ current->link;
current->link ¼ temp->link;

Write C++ statements to do the following: (3, 4)
Set the info of the second node to 52.
Make current point to the node with info 10.
c. Make trail point to the node before temp.
d. Make temp point to an empty list.
e. Set the value of the node before trail to 36.
f.
Write a while loop to make current point to the node with info 10.
Mark each of the following statements as valid or invalid. If a statement is
invalid, explain why. (3, 4)
a.
b.

10.

11.

a.

current ¼ list;

b.

temp->link->link ¼ nullptr;

c.

trail->link ¼ 0;

d.

*temp ¼ last;

e.

list ¼ 75;

f.

temp->link->info ¼ 75;

g.

current->info ¼ trail->link;

h.

*list ¼ *last;

i.

current ¼ last;

j.

cout << trail->link->link->info;

Write C++ statements to do the following: (3, 4)
a.
b.

Write a C++ code so that current traverses the entire list.
Create the node with info 68 and insert it between trail and last.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

1155

Delete the last node of the list and also deallocate the memory occupied
by this node. After deleting the node, make last point to the last node
of the list and the link of the last node must be nullptr.
d. Delete the node with info 10. Also, deallocate the memory occupied
by this node.
What is the output of the following C++ code? (3, 4)
c.

12.

13.

a.

while (current != nullptr)
cout << current->info << " ";
current = current->link;
cout << endl;

b.

while (current != last)
current = current->link;
cout << current->info << " ";
cout << endl;

If the following C++ code is valid, show the output. If it is invalid, explain
why. (3, 4)
temp = current;
current = current->link;
current->link = last;
trail = current->link;
trail = trail->link;
cout << current->info << " "
<< trail->info << endl;

14.

//Line
//Line
//Line
//Line
//Line

1
2
3
4
5

//Line 6

If the following C++ code is valid, show the output. If it is invalid, explain
why. (3, 4)
current = temp->link;
trail = list;
temp = list->link;
trail = temp;
temp->link = current->link;
current = trail->link;
cout << trail->info << " " << current->info << endl;

15.

Show what is produced by the following C++ code. Assume the node is in
the usual info-link form with the info of the type int. (list, trail,
and current are pointers of type nodeType.) (3, 4)
list = new nodeType;
list->info = 28;
trail = new nodeType;
trail->info = 33;
trail->link = list;
list->link = nullptr;
current = new nodeType;
current->info = 62;
trail->link = current;
current->link = list;
list = trail;
current = list->link;
trail = current->link;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1156

| Chapter 16: Linked Lists

cout << list->info << " " << current->info << " "
<< trail->info << endl;
16.

Show what is produced by the following C++ code. Assume the node is in
the usual info-link form with the info of the type int. (list, trail,
and current are pointers of type nodeType.) (3, 4)
current = new nodeType;
current->info = 72;
current->link = nullptr;
trail = current;
current = new nodeType;
current->info = 46;
current->link = trail;
list = current;
current = new nodeType;
current->info = 52;
list->link = current;
current->link = trail;
trail = current;
current = new nodeType;
current->info = 91;
current->link = trail->link;
trail->link = current;
current = list;
while (current!= nullptr)
{
cout << current->info << " ";
current = current->link;
}
cout << endl;

17.

Assume that the node of a linked list is in the usual info-link form with
the info of type int. The following data, as described in parts (a) to (d), is
to be inserted into an initially linked list: 72, 43, 8, 12. Suppose that head is
a pointer of type nodeType. After the linked list is created, head should point
to the first node of the list. Declare additional variables as you need them.
Write the C++ code to create the linked list. After the linked list is created,
write a code to print the list. What is the output of your code? (3, 4)
Insert 72 into an empty linked list.
b. Insert 43 before 72.
c. Insert 8 at the end of the list.
d. Insert 12 after 43.
Assume that the node of a linked list is in the usual info-link form with
the info of type int. (list and ptr are pointers of type nodeType.) The
following code creates a linked list:
a.

18.

ptr = new nodeType;
ptr->info = 16;
list = new nodeType;
list->info = 25;
list->link = ptr;
ptr = new nodeType;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

1157

ptr->info = 12;
ptr->link = nullptr;
list->link->link = ptr;

Use the linked list created by this code to answer the following questions.
(These questions are independent of each other.) Declare additional pointers
if you need them. (3, 4)
Which pointer points to the first node of the linked list?
Determine the order of the nodes of the linked list.
c. Write a C++ code that creates and inserts a node with info 45 after
the node with info 16.
d. Write a C++ code that creates and inserts a node with info 58 before
the node with info 25. Does this require you to the change the value
of the pointer that was pointing to the first node of the linked list?
e. Write a C++ code that deletes the node with info 25. Does this
require you to the change the value of the pointer that was pointing to
the first node of the linked list?
a. What does the function begin of the class linkedListType do? (5, 6)
b. What does the function end of the class linkedListType do? (5, 6)
How does the function insertFirst of the class unorderedLinkedList differ
from the function insertFirst of the class orderedLinkedList? (7, 8)
Consider the following C++ statements. (The class unorderedLinkedList is as
defined in this chapter.) (6, 8)
a.
b.

19.

20.

21.

unorderedLinkedList<int> list;
list.insertFirst(26);
list.insertFirst(36);
list.insertLast(15);
list.insertFirst(72);
list.insertLast(48);
list.insertLast(45);
list.insertFirst(88);
list.deleteNode(66);
list.insertFirst(82);
list.deleteNode(15);
list.deleteNode(82);
linkedListIterator <int> it;
for (it = list.begin(); it != list.end(); ++it)
cout << *it << " ";
cout << endl;

22.

What is the output of this program segment?
Suppose the input is:
45 35 12 83 40 23 11 98 64 120 16 -999

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1158

| Chapter 16: Linked Lists

What is the output of the following C++ code? (The class unorderedLinkedList
is as defined in this chapter.) (8)
unorderedLinkedList<int> list;
unorderedLinkedList<int> copyList;
int num;
cin >> num;
while (num != -999)
{
if (num % 4 == 0 || num % 3 == 0)
list.insertFirst(num);
else
list.insertLast(num);
cin >> num;
}
cout << "list = ";
list.print();
cout << endl;
copyList = list;
copyList.deleteNode(33);
copyList.deleteNode(58);
cout << "copyList = ";
copyList.print();
cout << endl;
23.

24.

25.

Draw the UML diagram of the class doublyLinkedList as discussed in
this chapter. (10)
Draw the UML diagram of the class dvdType of the DVD Store
programming example.
Draw the UML diagram of the class dvdListType of the DVD Store
programming example.

PROGRAMMING EXERCISES
1.

(Online Address Book revisited) Programming Exercise 5 in Chapter 11
could handle a maximum of only 500 entries. Using linked lists, redo the
program to handle as many entries as required. Add the following operations
to your program:
Add or delete a new entry to the address book.
b. Allow the user to save the data in the address book.
Extend the class linkedListType by adding the following operations:
a.

2.

a.

Find and delete the node with the smallest info in the list. (Delete only
the first occurrence and traverse the list only once.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

b.

3.

|

1159

Find and delete all occurrences of a given info from the list. (Traverse
the list only once.)

Add these as abstract functions in the class linkedListType and provide
the definitions of these functions in the class unorderedLinkedList.
Also, write a program to test these functions.
Extend the class linkedListType by adding the following operations:
Write a function that returns the info of the kth element of the linked
list. If no such element exists, terminate the program.
th
b. Write a function that deletes the k element of the linked list. If no such
element exists, terminate the program.
Provide the definitions of these functions in the class linkedListType.
Also, write a program to test these functions. (Use either the class
unorderedLinkedList or the class orderedLinkedList to test your
function.)
(Printing a single linked list backward) Include the functions
reversePrint and recursiveReversePrint, as discussed in this chapter,
in the class linkedListType. Also, write a program function to print a
(single) linked list backward. (Use either the class unorderedLinkedList or
the class orderedLinkedList to test your function.)
(Dividing a linked list into two sublists of almost equal sizes)
a.

4.

5.

a.

Add the operation divideMid to the class linkedListType as
follows:
void divideMid(linkedListType<Type> &sublist);
//This operation divides the given list into two sublists
//of (almost) equal sizes.
//Postcondition: first points to the first node and last
//
points to the last node of the first
//
sublist.
//
sublist.first points to the first node
//
and sublist.last points to the last node
//
of the second sublist.

Consider the following statements:
unorderedLinkedList<int> myList;
unorderedLinkedList<int> subList;

Suppose myList points to the list with elements 34 65 27 89 12 (in this
order). The statement:
myList.divideMid(subList);

b.

divides myList into two sublists: myList points to the list with the elements
34 65 27, and subList points to the sublist with the elements 89 12.
Write the definition of the function template to implement the operation
divideMid. Also, write a program to test your function.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1160

6.

| Chapter 16: Linked Lists

(Splitting a linked list, at a given node, into two sublists)
a.

Add the following operation to the class linkedListType:
void divideAt(linkedListType<Type> &secondList,
const Type& item);
//Divide the list at the node with the info item into two
//sublists.
//Postcondition: first and last point to the first and
//
last nodes of the first sublist.
//
secondList.first and secondList.last
//
point to the first and last nodes of the
//
second sublist.

Consider the following statements:
unorderedLinkedList<int> myList;
unorderedLinkedList<int> otherList;

Suppose myList points to the list with the elements 34 65 18 39 27 89 12
(in this order). The statement:
myList.divideAt(otherList, 18);

b.

7.

a.

divides myList into two sublists: myList points to the list with the
elements 34 65, and otherList points to the sublist with the elements
18 39 27 89 12.
Write the definition of the function template to implement the operation divideAt. Also, write a program to test your function.
Add the following operation to the class orderedLinkedList:
void mergeLists(orderedLinkedList<Type> &list1,
orderedLinkedList<Type> &list2);
//This function creates a new list by merging the
//elements of list1 and list2.
//Postcondition: first points to the merged list
//
list1 and list2 are empty

Consider the following statements:
orderedLinkedList<int> newList;
orderedLinkedList<int> list1;
orderedLinkedList<int> list2;

Suppose list1 points to the list with the elements 2 6 7, and list2
points to the list with the elements 3 5 8. The statement:
newList.mergeLists(list1, list2);

b.

creates a new linked list with the elements in the order 2 3 5 6 7 8, and
the object newList points to this list. Also, after the preceding statement
executes, list1 and list2 are empty.
Write the definition of the function template mergeLists to implement the operation mergeLists.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

8.

9.

|

1161

The function insert of the class orderedLinkedList does not check if
the item to be inserted is already in the list; that is, it does not check for
duplicates. Rewrite the definition of the function insert so that before
inserting the item, it checks whether the item to be inserted is already in the
list. If the item to be inserted is already in the list, the function outputs an
appropriate error message. Also, write a program to test your function.
In this chapter, the class to implement the nodes of a linked list is defined as a
struct. The following rewrites the definition of the struct nodeType so
that it is declared as a class and the member variables are private.
template <class Type>
class nodeType
{
public:
const nodeType<Type>& operator=(const nodeType<Type>&);
//Overload the assignment operator.
void setInfo(const Type& elem);
//Function to set the info of the node.
//Postcondition: info = elem;
Type getInfo() const;
//Function to return the info of the node.
//Postcondition: The value of info is returned.
void setLink(nodeType<Type> *ptr);
//Function to set the link of the node.
//Postcondition: link = ptr;
nodeType<Type>* getLink() const;
//Function to return the link of the node.
//Postcondition: The value of link is returned.
nodeType();
//Default constructor
//Postcondition: link = nullptr;
nodeType(const Type& elem, nodeType<Type> *ptr);
//Constructor with parameters
//Sets info to point to the object elem points to, and
//link is set to point to the object ptr points to.
//Postcondition: info = elem; link = ptr
nodeType(const nodeType<Type> &otherNode);
//Copy constructor
nodeType();
//Destructor
private:
Type info;
nodeType<Type> *link;
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

1162

10.

11.

12.
13.

| Chapter 16: Linked Lists

Write the definitions of the member functions of the class nodeType.
Also, write a program to test your class.
Programming Exercise 9 asks you to redefine the class to implement the nodes
of a linked list so that the instance variables are private. Therefore, the class
linkedListType and its derived classes unorderedLinkedList and
orderedLinkedList can no longer directly access the instance variables of
the class nodeType. Rewrite the definitions of these classes so that they use
the member functions of the class nodeType to access the info and link
fields of a node. Also, write programs to test various operations of the classes
unorderedLinkedList and orderedLinkedList.
Write the definitions of the function copyList, the copy constructor,
and the function to overload the assignment operator for the class
doublyLinkedList.
Write a program to test various operations of the class doublyLinkedList.
(Circular linked lists) This chapter defined and identified various
operations on a circular linked list.
Write the definitions of the class circularLinkedList and its
member functions. (You may assume that the elements of the circular
linked list are in ascending order.)
b. Write a program to test various operations of the class defined in (a).
(DVD Store programming example)
a.

14.

Complete the design and implementation of the class customerType
defined in the DVD Store programming example.
b. Design and implement the class customerListType to create and
maintain a list of customers for the DVD store.
(DVD Store programming example) Complete the design and implementation of the DVD store program. In other words, write a program that
uses the classes designed in the DVD Store programming example and in
Programming Exercise 14 to make a DVD store operational.
Extend the class linkedListType by adding the following function:
a.

15.

16.

void rotate();
//Function to remove the first node of a linked list and put it
//at the end of the linked list.

17.

Also write a program to test your function. Use the class
unorderedLinkedList to create a linked list.
Write a program that prompts the user to input a string and then outputs
the string in the pig Latin form. The rules for converting a string into pig
Latin form are described in Programming Example: Pig Latin Strings of
Chapter 7. Your program must store the characters of a string into a linked
list and use the function rotate, as described in Programming Exercise 16,
to rotate the string.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

18.

a.

|

1163

Derive the class intLinkedList from the class unorderedLinkedList
as follows:
class intLinkedList: public unorderedLinkedList<int>
{
public:
void splitEvensOddsList(intLinkedList &evensList,
intLinkedList &oddsList);
//Function to rearrange the nodes of the linked list so
//that evensList consists of even integers and oddsList
//consists of odd integers.
//Postcondition: evensList consists of even integers.
//
oddsList consists of odd integers.
//
The original list is empty.
};

b.

Also write the definition of the function splitEvensOddsList. Note
that this function does not create any new node, it only rearranges
the nodes of the original list so that nodes with even integers are in
evensList and nodes with odd integers are in oddsList.
Write a program that uses class intLinkedList to create a linked list
of integers and then uses the function splitEvensOddsList to split
the list into two sublists.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
6

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

17
CHAPTER

ª HunThomas/Shutterstock

S TACKS

AND

Q UEUES

I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about stacks

2.

Examine various stack operations

3.

Learn how to implement a stack as an array

4.

Learn how to implement a stack as a linked list

5.

Learn about infix, prefix, and postfix expressions, and how to use a stack to evaluate postfix expressions

6.

Learn how to use a stack to remove recursion

7.

Learn about queues

8.

Examine various queue operations

9.

Learn how to implement a queue as an array

10.

Learn how to implement a queue as a linked list

11.

Discover how to use queues to solve simulation problems

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1166

| Chapter 17: Stacks and Queues

This chapter discusses two very useful data structures: stacks and queues. Both stacks and
queues have numerous applications in computer science.

Stacks
Suppose that you have a program with several functions. To be specific, suppose that you
have functions A, B, C, and D in your program. Now suppose that function A calls
function B, function B calls function C, and function C calls function D. When function
D terminates, control goes back to function C; when function C terminates, control goes
back to function B; and when function B terminates, control goes back to function A.
During program execution, how do you think the computer keeps track of the function
calls? What about recursive functions? How does the computer keep track of the
recursive calls? In Chapter 16, we designed a recursive function to print a linked list
backward. What if you want to write a nonrecursive algorithm to print a linked list
backward?
This section discusses the data structure called the stack, which the computer uses to
implement function calls. You can also use stacks to convert recursive algorithms into
nonrecursive algorithms, especially recursive algorithms that are not tail recursive. Stacks
have numerous applications in computer science. After developing the tools necessary to
implement a stack, we will examine some applications of stacks.
A stack is a list of homogeneous elements in which the addition and deletion of elements
occur only at one end, called the top of the stack. For example, in a cafeteria, the second
tray in a stack of trays can be removed only if the first tray has been removed. For another
example, to get to your favorite computer science book, which is underneath your math
and history books, you must first remove the math and history books. After removing
these books, the computer science book becomes the top book—that is, the top element
of the stack. Figure 17-1 shows some examples of stacks.

Stack of
boxes
Stack of
coins

Stack of
books

Stack of
trays

5

Applied Math
World History
C++ Programming
English
Chemistry

FIGURE 17-1

Various types of stacks

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Stacks

|

1167

The elements at the bottom of the stack have been in the stack the longest. The top element
of the stack is the last element added to the stack. Because the elements are added and
removed from one end (that is, the top), it follows that the item that is added last will be
removed first. For this reason, a stack is also called a Last In First Out (LIFO) data structure.
Stack: A data structure in which the elements are added and removed from one end
only; a Last In First Out (LIFO) data structure.
Now that you know what a stack is, let us see what kinds of operations can be performed on
a stack. Because new items can be added to the stack, we can perform the add operation,
called push, to add an element onto the stack. Similarly, because the top item can be
retrieved and/or removed from the stack, we can perform the operation top to retrieve the
top element of the stack and the operation pop to remove the top element from the stack.
The push, top, and pop operations work as follows: Suppose there are boxes lying on
the floor that need to be stacked on a table. Initially, all of the boxes are on the floor, and
the stack is empty (see Figure 17-2).
A

D

B

C
Empty stack

E

FIGURE 17-2

Empty stack

First, we push box A onto the stack. After the push operation, the stack is as shown in
Figure 17-3(a).

FIGURE 17-3

A

B

C

Push Box A

Push Box B

Push Box C

(a)

(b)

(c)

C

D

Peek at the
top element
(d)

Push Box D

Pop stack

(e)

(f)

C

Stack operations

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1168

| Chapter 17: Stacks and Queues

We then push box B onto the stack. After this push operation, the stack is as shown in
Figure 17-3(b). Next, we push box C onto the stack. After this push operation, the stack is
as shown in Figure 17-3(c). Next, we look, that is, peek, at the top element of the stack.
After this operation, the stack is unchanged and shown in Figure 17-3(d). We then push
box D onto the stack. After this push operation, the stack is as shown in Figure 17-3(e).
Next, we pop the stack. After the pop operation, the stack is as shown in Figure 17-3(f ).
An element can be removed from the stack only if there is something in the stack, and an
element can be added to the stack only if there is room. The two operations that
immediately follow from push, top, and pop are isFullStack (checks whether the
stack is full) and isEmptyStack (checks whether the stack is empty). Because a stack
keeps changing as we add and remove elements, the stack must be empty before we first
start using it. Thus, we need another operation, called initializeStack, which
initializes the stack to an empty state. Therefore, to successfully implement a stack, we
need at least these six operations, which are described in the next section. We might also
need other operations on a stack, depending on the specific implementation.

Stack Operations
•
•

initializeStack: Initializes the stack to an empty state.

•

isFullStack: Determines whether the stack is full. If the stack is full, it
returns the value true; otherwise, it returns the value false.

isEmptyStack: Determines whether the stack is empty. If the stack is
empty, it returns the value true; otherwise, it returns the value false.

•

push: Adds a new element to the top of the stack. The input to this
operation consists of the stack and the new element. Prior to this operation, the stack must exist and must not be full.
• top: Returns the top element of the stack. Prior to this operation, the
stack must exist and must not be full.
• pop: Removes the top element of the stack. Prior to this operation, the
stack must exist and must not be empty.

The following abstract class stackADT defines these operations as an ADT:
template <class Type>
class stackADT
{
public:
virtual void initializeStack() = 0;
//Method to initialize the stack to an empty state.
//Postcondition: Stack is empty.
virtual bool isEmptyStack() const = 0;
//Function to determine whether the stack is empty.
//Postcondition: Returns true if the stack is empty,
//
otherwise returns false.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Stacks

|

1169

virtual bool isFullStack() const = 0;
//Function to determine whether the stack is full.
//Postcondition: Returns true if the stack is full,
//
otherwise returns false.
virtual void push(const Type& newItem) = 0;
//Function to add newItem to the stack.
//Precondition: The stack exists and is not full.
//Postcondition: The stack is changed and newItem
//
is added to the top of the stack.
virtual Type top() const = 0;
//Function to return the top element of the
//Precondition: The stack exists and is not
//Postcondition: If the stack is empty, the
//
terminates; otherwise, the
//
of the stack is returned.

stack.
empty.
program
top element

virtual void pop() = 0;
//Function to remove the top element of the stack.
//Precondition: The stack exists and is not empty.
//Postcondition: The stack is changed and the top
//
element is removed from the stack.
};

Figure 17-4 shows the UML class diagram of the class stackADT.

stackADT<Type>

+initializeStack(): void
+isEmptyStack(): boolean
+isFullStack(): boolean
+push(Type): void
+top(): Type
+pop(): void

FIGURE 17-4

UML class diagram of the class stackADT

We now consider the implementation of our abstract stack data structure. Because all
of the elements of a stack are of the same type, a stack can be implemented as either an
array or a linked structure. Both implementations are useful and are discussed in this
chapter.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1170

| Chapter 17: Stacks and Queues

Implementation of Stacks as Arrays
Because all of the elements of a stack are of the same type, you can use an array to
implement a stack. The first element of the stack can be put in the first array slot, the
second element of the stack in the second array slot, and so on. The top of the stack is the
index of the last element added to the stack.
In this implementation of a stack, stack elements are stored in an array, and an array is a
random access data structure; that is, you can directly access any element of the array.
However, by definition, a stack is a data structure in which the elements are accessed
(popped or pushed) at only one end—that is, a Last In First Out data structure. Thus, a
stack element is accessed only through the top, not through the bottom or middle. This
feature of a stack is extremely important and must be recognized in the beginning.
To keep track of the top position of the array, we can simply declare another variable
called stackTop.
The following class, stackType, implements the functions of the abstract class
stackADT. By using a pointer, we can dynamically allocate arrays, so we will leave it
for the user to specify the size of the array (that is, the stack size). We assume that the
default stack size is 100. Because the class stackType has a pointer member variable
(the pointer to the array to store the stack elements), we must overload the assignment
operator and include the copy constructor and destructor. Moreover, we give a generic
definition of the stack. Depending on the specific application, we can pass the stack
element type when we declare a stack object.
template <class Type>
class stackType: public stackADT<Type>
{
public:
const stackType<Type>& operator=(const stackType<Type>&);
//Overload the assignment operator.
void initializeStack();
//Function to initialize the stack to an empty state.
//Postcondition: stackTop = 0;
bool isEmptyStack() const;
//Function to determine whether the stack is empty.
//Postcondition: Returns true if the stack is empty,
//
otherwise returns false.
bool isFullStack() const;
//Function to determine whether the stack is full.
//Postcondition: Returns true if the stack is full,
//
otherwise returns false.
void push(const Type& newItem);
//Function to add newItem to the stack.
//Precondition: The stack exists and is not full.
//Postcondition: The stack is changed and newItem
//
is added to the top of the stack.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Implementation of Stacks as Arrays

Type top() const;
//Function to return the top element of the
//Precondition: The stack exists and is not
//Postcondition: If the stack is empty, the
//
terminates; otherwise, the
//
of the stack is returned.

|

1171

stack.
empty.
program
top element

void pop();
//Function to remove the top element of the stack.
//Precondition: The stack exists and is not empty.
//Postcondition: The stack is changed and the top
//
element is removed from the stack.
stackType(int stackSize = 100);
//Constructor
//Create an array of the size stackSize to hold
//the stack elements. The default stack size is 100.
//Postcondition: The variable list contains the base
//
address of the array, stackTop = 0, and
//
maxStackSize = stackSize.
stackType(const stackType<Type>& otherStack);
//Copy constructor
~stackType();
//Destructor
//Remove all the elements from the stack.
//Postcondition: The array (list) holding the stack
//
elements is deleted.
private:
int maxStackSize; //variable to store the maximum stack size
int stackTop;
//variable to point to the top of the stack
Type *list;
//pointer to the array that holds the
//stack elements
void copyStack(const stackType<Type>& otherStack);
//Function to make a copy of otherStack.
//Postcondition: A copy of otherStack is created and
//
assigned to this stack.
};

Figure 17-5 shows the UML class diagram of the class stackType.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1172

| Chapter 17: Stacks and Queues

stackType<Type>
-maxStackSize: int
-stackTop: int
-*list: Type
+operator=(const stackType<Type>&):
const stackType<Type>&
+initializeStack(): void
+isEmptyStack() const: bool
+isFullStack() const: bool
+push(const Type&): void
+top() const: Type
+pop(): void
-copyStack(const stackType<Type>&): void
+stackType(int = 100)
+stackType(const stackType<Type>&)
+~stackType()

FIGURE 17-5

UML class diagram of the class stackType

Because C++ arrays begin with the index 0, we need to distinguish between the value of
stackTop and the array position indicated by stackTop. If stackTop is 0, the stack
is empty; if stackTop is nonzero, then the stack is nonempty and the top element of the
stack is given by stackTop - 1.
Notice that the function copyStack is included as a private member. This is
because we want to use this function only to implement the copy constructor and overload
the assignment operator. To copy a stack into another stack, the program can use the
assignment operator.

Figure 17-6 shows this data structure, wherein stack is an object of type stackType.
Note that stackTop can range from 0 to maxStackSize. If stackTop is nonzero, then
stackTop - 1 is the index of the stackTop element of the stack. Suppose that
maxStackSize = 100.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Implementation of Stacks as Arrays

|

1173

[99]
.
.
.
.
.
stack
maxStackSize
stackTop

100
4

list

FIGURE 17-6

[3]

D

[2]

C

[1]

B

[0]

A

1
7
stack
elements

Example of a stack

Note that the pointer list contains the base address of the array (holding the stack
elements)—that is, the address of the first array component. Next, we discuss how to
implement the member functions of the class stackType.

Initialize Stack
Let us consider the initializeStack operation. Because the value of stackTop
indicates whether the stack is empty, we can simply set stackTop to 0 to initialize the
stack (see Figure 17-7).

[99]
.
.
.
.
.
stack
maxStackSize
stackTop
list

FIGURE 17-7

100
0

[3]

D

[2]

C

[1]

B

[0]

A

unused
stack

Empty stack

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1174

| Chapter 17: Stacks and Queues

The definition of the function initializeStack is:
template <class Type>
void stackType<Type>::initializeStack()
{
stackTop = 0;
}//end initializeStack

Empty Stack
We have seen that the value of stackTop indicates whether the stack is empty. If
stackTop is 0, the stack is empty; otherwise, the stack is not empty. The definition of
the function isEmptyStack is:
template <class Type>
bool stackType<Type>::isEmptyStack() const
{
return(stackTop == 0);
}//end isEmptyStack

Full Stack
Next, we consider the operation isFullStack. It follows that the stack is full if stackTop is equal to maxStackSize. The definition of the function isFullStack is:
template <class Type>
bool stackType<Type>::isFullStack() const
{
return (stackTop == maxStackSize);
} //end isFullStack

Push
Adding, or pushing, an element onto the stack is a two-step process. Recall that the value
of stackTop indicates the number of elements in the stack, and stackTop - 1 gives the
position of the top element of the stack. Therefore, the push operation is as follows:
1. Store the newItem in the array component indicated by stackTop.
2. Increment stackTop.
Figures 17-8 and 17-9 illustrate the push operation.
Suppose that before the push operation, the stack is as shown in Figure 17-8.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Implementation of Stacks as Arrays

|

1175

[99]
.
.
.
.
.
stack
maxStackSize
stackTop

100
4

list

FIGURE 17-8

n

[3]

n

[2]

u

[1]

S

[0]

1
7
stack
elements

Stack before pushing y

Assume newItem is 'y'. After the push operation, the stack is as shown in Figure 17-9.

[99]
.
.
.
.

stack
maxStackSize
stackTo p
list

FIGURE 17-9

100
5

y

[4]

n

[3]

u

stack
[2] elements
[1]

S

[0]

n

Stack after pushing y

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1176

| Chapter 17: Stacks and Queues

Using the previous algorithm, the definition of the function push is:
template <class Type>
void stackType<Type>::push(const Type& newItem)
{
if (!isFullStack())
{
list[stackTop] = newItem;
//add newItem to the
//top of the stack
stackTop++; //increment stackTop
}
else
cout << "Cannot add to a full stack." << endl;
}//end push

If we try to add a new item to a full stack, the resulting condition is called an overflow.
Error checking for an overflow can be handled in different ways. One way is as shown
previously. Or, we can check for an overflow before calling the function push, as shown
next (assuming stack is an object of type stackType).
if (!stack.isFullStack())
stack.push(newItem);

Return the Top Element
The operation top returns the top element of the stack. Its definition is:
template <class Type>
Type stackType<Type>::top() const
{
assert(stackTop != 0);
return list[stackTop - 1];

//if stack is empty,
//terminate the program
//return the element of the
//stack indicated by
//stackTop - 1

}//end top

Pop
To remove, or pop, an element from the stack, we simply decrement stackTop by 1.
Figures 17-10 and 17-11 illustrate the pop operation.
Suppose that before the pop operation, the stack is as shown in Figure 17-10.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Implementation of Stacks as Arrays

|

1177

[99]
.
.
.
.
.
stack
maxStackSize 100
stackTop

4

list

FIGURE 17-10

D

[3]

L

[2]

O

[1]

B

[0]

1
7
stack
elements

Stack before popping D

After the pop operation, the stack is as shown in Figure 17-11.

[99]
.
.
.
.
.
stack
maxStackSize
stackTop
list

FIGURE 17-11

100
3

D

[3]

L

[2]

O

stack
[1] elements

B

[0]

Stack after popping D

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1178

| Chapter 17: Stacks and Queues

The definition of the function pop is:
template <class Type>
void stackType<Type>::pop()
{
if (!isEmptyStack())
stackTop--;
//decrement stackTop
else
cout << "Cannot remove from an empty stack." << endl;
}//end pop

If we try to remove an item from an empty stack, the resulting condition is called an
underflow. Error checking for an underflow can be handled in different ways. One way
is as shown in the definition of the function pop. Or, we can check for an underflow
before calling the function pop, as shown next (assuming stack is an object of type
stackType).
if (!stack.isEmptyStack())
stack.pop();

Copy Stack
The function copyStack makes a copy of a stack. The stack to be copied is passed as a
parameter to the function copyStack. We will, in fact, use this function to implement
the copy constructor and overload the assignment operator. The definition of this
function is:
template <class Type>
void stackType<Type>::copyStack(const stackType<Type>& otherStack)
{
delete [] list;
maxStackSize = otherStack.maxStackSize;
stackTop = otherStack.stackTop;
list = new Type[maxStackSize];
//copy otherStack into this stack
for (int j = 0; j < stackTop; j++)
list[j] = otherStack.list[j];
} //end copyStack

Constructor and Destructor
The functions to implement the constructor and the destructor are straightforward. The
constructor with parameters sets the stack size to the size specified by the user, sets
stackTop to 0, and creates an appropriate array in which to store the stack elements. If
the user does not specify the size of the array in which to store the stack elements, the
constructor uses the default value, which is 100, to create an array of size 100. The
destructor simply deallocates the memory occupied by the array (that is, the stack) and
sets stackTop to 0. The definitions of the constructor and destructor are:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Implementation of Stacks as Arrays

|

1179

template <class Type>
stackType<Type>::stackType(int stackSize)
{
if (stackSize <= 0)
{
cout << "Size of the array to hold the stack must "
<< "be positive." << endl;
cout << "Creating an array of size 100." << endl;
maxStackSize = 100;
}
else
maxStackSize = stackSize;

stackTop = 0;
list = new Type[maxStackSize];

//set the stack size to
//the value specified by
//the parameter stackSize
//set stackTop to 0
//create the array to
//hold the stack elements

}//end constructor
template <class Type>
stackType<Type>::~stackType() //destructor
{
delete [] list; //deallocate the memory occupied
//by the array
}//end destructor

Copy Constructor
The copy constructor is called when a stack object is passed as a (value) parameter to a
function. It copies the values of the member variables of the actual parameter into the
corresponding member variables of the formal parameter. Its definition is:
template <class Type>
stackType<Type>::stackType(const stackType<Type>& otherStack)
{
list = nullptr;
copyStack(otherStack);
}//end copy constructor

Overloading the Assignment Operator (=)
Recall that for classes with pointer member variables, the assignment operator must be
explicitly overloaded. The definition of the function to overload the assignment operator
for the class stackType is:
template <class Type>
const stackType<Type>& stackType<Type>::operator=
(const stackType<Type>& otherStack)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1180

| Chapter 17: Stacks and Queues

{
if (this != &otherStack) //avoid self-copy
copyStack(otherStack);
return *this;
} //end operator=

Stack Header File
Now that you know how to implement the stack operations, you can put the definitions
of the class and the functions to implement the stack operations together to create the
stack header file. For the sake of completeness, we next describe the header file. (To save
space, only the definition of the class is shown; no documentation is provided.) Suppose
that the name of the header file containing the definition of the class stackType is
myStack.h. We will refer to this header file in any program that uses a stack.
//Header file: myStack.h
#ifndef H_StackType
#define H_StackType
#include <iostream>
#include <cassert>
#include "stackADT.h"
using namespace std;
template <class Type>
class stackType: public stackADT<Type>
{
public:
const stackType<Type>& operator=(const stackType<Type>&);
void initializeStack();
bool isEmptyStack() const;
bool isFullStack() const;
void push(const Type& newItem);
Type top() const;
void pop();
stackType(int stackSize = 100);
stackType(const stackType<Type>& otherStack);
~stackType();

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Implementation of Stacks as Arrays

|

1181

private:
int maxStackSize; //variable to store the maximum stack size
int stackTop;
//variable to point to the top of the stack
Type *list;
//pointer to the array that holds the
//stack elements
void copyStack(const stackType<Type>& otherStack);
};
template <class Type>
void stackType<Type>::initializeStack()
{
stackTop = 0;
}//end initializeStack
template <class Type>
bool stackType<Type>::isEmptyStack() const
{
return (stackTop == 0);
}//end isEmptyStack
template <class Type>
bool stackType<Type>::isFullStack() const
{
return (stackTop == maxStackSize);
} //end isFullStack
template <class Type>
void stackType<Type>::push(const Type& newItem)
{
if (!isFullStack())
{
list[stackTop] = newItem;
//add newItem to the
//top of the stack
stackTop++; //increment stackTop
}
else
cout << "Cannot add to a full stack." << endl;
}//end push
template <class Type>
Type stackType<Type>::top() const
{
assert(stackTop != 0);
//if stack is empty,
//terminate the program
return list[stackTop - 1];
//return the element of the
//stack indicated by
//stackTop - 1
}//end top
template <class Type>
void stackType<Type>::pop()
{
if (!isEmptyStack())
stackTop--;
//decrement stackTop
else
cout << "Cannot remove from an empty stack." << endl;
}//end pop

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1182

| Chapter 17: Stacks and Queues

template <class Type>
stackType<Type>::stackType(int stackSize)
{
if (stackSize <= 0)
{
cout << "Size of the array to hold the stack must "
<< "be positive." << endl;
cout << "Creating an array of size 100." << endl;
maxStackSize = 100;
}
else
maxStackSize = stackSize;

stackTop = 0;
list = new Type[maxStackSize];

//set the stack size to
//the value specified by
//the parameter stackSize
//set stackTop to 0
//create the array to
//hold the stack elements

}//end constructor
template <class Type>
stackType<Type>::~stackType() //destructor
{
delete [] list; //deallocate the memory occupied
//by the array
}//end destructor
template <class Type>
void stackType<Type>::copyStack(const stackType<Type>& otherStack)
{
delete [] list;
maxStackSize = otherStack.maxStackSize;
stackTop = otherStack.stackTop;
list = new Type[maxStackSize];
//copy otherStack into this stack
for (int j = 0; j < stackTop; j++)
list[j] = otherStack.list[j];
} //end copyStack
template <class Type>
stackType<Type>::stackType(const stackType<Type>& otherStack)
{
list = nullptr;
copyStack(otherStack);
}//end copy constructor
template <class Type>
const stackType<Type>& stackType<Type>::operator=
(const stackType<Type>& otherStack)
{
if (this != &otherStack) //avoid self-copy
copyStack(otherStack);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Implementation of Stacks as Arrays

|

1183

return *this;
} //end operator=
#endif

EXAMPLE 17-1
Before we give a programming example, let us first write a simple program that uses the
class stackType and tests some of the stack operations. Among others, we will test the
assignment operator and the copy constructor. The program and its output are as follows:
//Program to test the various operations of a stack
#include <iostream>
#include "myStack.h"
using namespace std;
void testCopyConstructor(stackType<int> otherStack);
int main()
{
stackType<int> stack(50);
stackType<int> copyStack(50);
stackType<int> dummyStack(100);
stack.initializeStack();
stack.push(23);
stack.push(45);
stack.push(38);
copyStack = stack; //copy stack into copyStack
cout << "The elements of copyStack: ";
while (!copyStack.isEmptyStack()) //print copyStack
{
cout << copyStack.top() << " ";
copyStack.pop();
}
cout << endl;
copyStack = stack;
testCopyConstructor(stack);

//test the copy constructor

if (!stack.isEmptyStack())
cout << "The original stack is not empty." << endl
<< "The top element of the original stack: "
<< copyStack.top() << endl;
dummyStack = stack; //copy stack into dummyStack
cout << "The elements of dummyStack: ";

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1184

| Chapter 17: Stacks and Queues

while (!dummyStack.isEmptyStack()) //print dummyStack
{
cout << dummyStack.top() << " ";
dummyStack.pop();
}
cout << endl;
return 0;
}
void testCopyConstructor(stackType<int> otherStack)
{
if (!otherStack.isEmptyStack())
cout << "otherStack is not empty." << endl
<< "The top element of otherStack: "
<< otherStack.top() << endl;
}

Sample Run:
The elements of copyStack: 38 45 23
otherStack is not empty.
The top element of otherStack: 38
The original stack is not empty.
The top element of the original stack: 38
The elements of dummyStack: 38 45 23

It is recommended that you do a walk-through of this program.

PROGRAMMING EXAMPLE:

Watch
the Video

Highest GPA

In this example, we write a C++ program that reads a data file consisting of each
student’s GPA followed by the student’s name. The program then prints the highest
GPA and the names of all of the students who received that GPA. The program scans
the input file only once. Moreover, we assume that there is a maximum of 100
students in the class.
Input

3.4
3.2
2.5
3.4
3.8
3.8
3.6

The program reads an input file consisting of each student’s GPA, followed
by the student’s name. Sample data is:
Randy
Kathy
Colt
Tom
Ron
Mickey
Peter

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Highest GPA

Output

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

|

1185

The highest GPA and all of the names associated with the highest GPA.
For example, for the above data, the highest GPA is 3.8, and the students
with that GPA are Ron and Mickey.

We read the first GPA and the name of the student. Because this data is the first item
read, it is the highest GPA so far. Next, we read the second GPA and the name of the
student. We then compare this (second) GPA with the highest GPA so far. Three
cases arise:
1. The new GPA is greater than the highest GPA so far. In this case, we:
a. Update the value of the highest GPA so far.
b. Initialize the stack—that is, remove the names of the students
from the stack.
c. Save the name of the student having the highest GPA so far in
the stack.
2. The new GPA is equal to the highest GPA so far. In this case, we
add the name of the new student to the stack.
3. The new GPA is smaller than the highest GPA so far. In this case,
we discard the name of the student having this grade.
We then read the next GPA and the name of the student and repeat Steps 1 through 3.
We continue this process until we reach the end of the input file.
From this discussion, it is clear that we need the following variables:
double GPA;
//variable to hold
double highestGPA; //variable to hold
string name;
//variable to hold
stackType<string> stack(100); //object

the current GPA
the highest GPA
the name of the student
to implement the stack

The preceding discussion translates into the following algorithm:
1.
2.
3.
4.

Declare the variables and initialize stack.
Open the input file.
If the input file does not exist, exit the program.
Set the output of the floating-point numbers to a fixed decimal
format with a decimal point and trailing zeroes. Also, set the
precision to two decimal places.
5. Read the GPA and the student name.
6. highestGPA = GPA;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1186

| Chapter 17: Stacks and Queues

7. while (not end of file)
{

7.1.

if (GPA > highestGPA)
{

7.1.1.
7.1.2.
7.1.3.
}

clearstack(stack);
push(stack, student name);
highestGPA = GPA;

7.2.

else
if (GPA is equal to highestGPA)
push(stack, student name);

7.3.

Read GPA and student name;

}

8. Output the highest GPA.
9. Output the names of the students having the highest GPA.
PROGRAM LISTING
//*********************************************************
// Author: D.S. Malik
//
// This program uses the class myStack to determine the
// highest GPA from a list of students with their GPA.
// The program also outputs the names of the students
// who received the highest GPA.
//*********************************************************
#include
#include
#include
#include

<iostream>
<iomanip>
<fstream>
<string>

#include "myStack.h"
using namespace std;
int main()
{
//Step 1
double GPA;
double highestGPA;
string name;
stackType<string> stack(100);
ifstream infile;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Highest GPA

infile.open("HighestGPAData.txt");

//Step 2

if (!infile)
{
cout << "The input file does not "
<< "exist. Program terminates!"
<< endl;
return 1;
}

//Step 3

cout << fixed << showpoint;
cout << setprecision(2);

//Step 4
//Step 4

infile >> GPA >> name;

//Step 5

highestGPA = GPA;

//Step 6

while (infile)
{
if (GPA > highestGPA)
{
stack.initializeStack();

//Step 7

if (!stack.isFullStack())
stack.push(name);
highestGPA = GPA;
}
else if (GPA == highestGPA)
if (!stack.isFullStack())
stack.push(name);
else
{
cout << "Stack overflows. "
<< "Program terminates!"
<< endl;
return 1; //exit program
}
infile >> GPA >> name;

|

1187

1
7

//Step 7.1
//Step 7.1.1
//Step 7.1.2
//Step 7.1.3
//Step 7.2

//Step 7.3

}
cout <<
<<
cout <<
<<

"Highest GPA = " << highestGPA
endl;
"The students holding the "
"highest GPA are:" << endl;

while (!stack.isEmptyStack())
{
cout << stack.top() << endl;
stack.pop();
}

//Step 8

//Step 9

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1188

| Chapter 17: Stacks and Queues

cout << endl;
return 0;
}

Sample Run:
Input File (HighestGPAData.txt)
3.4
3.2
2.5
3.4
3.8
3.8
3.6
3.5
3.8
3.7
3.9
3.8
3.9
2.7
3.9
3.4

Randy
Kathy
Colt
Tom
Ron
Mickey
Peter
Donald
Cindy
Dome
Andy
Fox
Minnie
Gilda
Vinay
Danny

Output
Highest GPA = 3.90
The students holding the highest GPA are:
Vinay
Minnie
Andy

Note that the names of the students with the highest GPA are output in the reverse
order, relative to the order they appear in the input, due to the fact that the top
element of the stack is the last element added to the stack.

Linked Implementation of Stacks
Because an array size is fixed, in the array (linear) representation of a stack, only a fixed
number of elements can be pushed onto the stack. If in a program the number of
elements to be pushed exceeds the size of the array, the program may terminate in an
error. We must overcome these problems.
We have seen that by using pointer variables, we can dynamically allocate and deallocate
memory, and by using linked lists, we can dynamically organize data (such as an ordered
list). Next, we will use these concepts to implement a stack dynamically.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Implementation of Stacks

|

1189

Recall that in the linear representation of a stack, the value of stackTop indicates the
number of elements in the stack, and the value of stackTop - 1 points to the top item in
the stack. With the help of stackTop, we can do several things: find the top element,
check whether the stack is empty, and so on.
Similar to the linear representation, in a linked representation, stackTop is used to locate
the top element in the stack. However, there is a slight difference. In the former case,
stackTop gives the index of the array. In the latter case, stackTop gives the address
(memory location) of the top element of the stack.
The following class implements the functions of the abstract class stackADT:
//Definition of the node
template <class Type>
struct nodeType
{
Type info;
nodeType<Type> *link;
};
template <class Type>
class linkedStackType: public stackADT<Type>
{
public:
const linkedStackType<Type>& operator=
(const linkedStackType<Type>&);
//Overload the assignment operator.
bool isEmptyStack() const;
//Function to determine whether the stack is empty.
//Postcondition: Returns true if the stack is empty;
//
otherwise returns false.
bool isFullStack() const;
//Function to determine whether the stack is full.
//Postcondition: Returns false.
void initializeStack();
//Function to initialize the stack to an empty state.
//Postcondition: The stack elements are removed;
//
stackTop = nullptr;
void push(const Type& newItem);
//Function to add newItem to the stack.
//Precondition: The stack exists and is not full.
//Postcondition: The stack is changed and newItem
//
is added to the top of the stack.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1190

| Chapter 17: Stacks and Queues

Type top() const;
//Function to return the top element of the stack.
//Precondition: The stack exists and is not empty.
//Postcondition: If the stack is empty, the program
//
terminates; otherwise, the top
//
element of the stack is returned.
void pop();
//Function to remove the top element of the stack.
//Precondition: The stack exists and is not empty.
//Postcondition: The stack is changed and the top
//
element is removed from the stack.
linkedStackType();
//Default constructor
//Postcondition: stackTop = nullptr;
linkedStackType(const linkedStackType<Type>& otherStack);
//Copy constructor
~linkedStackType();
//Destructor
//Postcondition: All the elements of the stack are
//
removed from the stack.
private:
nodeType<Type> *stackTop; //pointer to the stack
void copyStack(const linkedStackType<Type>& otherStack);
//Function to make a copy of otherStack.
//Postcondition: A copy of otherStack is created and
//
assigned to this stack.
};
In this linked implementation of stacks, the memory to store the stack elements is
allocated dynamically. Logically, the stack is never full. The stack is full only if we run out
of memory space. Therefore, in reality, the function isFullStack does not apply to
linked implementation of stacks. However, the class linkedStackType must provide the definition of the function isFullStack, because it is defined in the parent
abstract class stackADT.

We leave the UML class diagram of the class linkedStackType as an exercise for you.
(See Exercise 32 at the end of this chapter.)
EXAMPLE 17-2
Suppose that stack is an object of type linkedStackType. Figure 17-12(a) shows an
empty stack, and Figure 17-12(b) shows a nonempty stack.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Implementation of Stacks

stack

stack

stackTop

stackTop

(a) Empty stack

|

1191

C
B
A

(b) Nonempty stack

FIGURE 17-12

Empty and nonempty linked stack

In Figure 17-12(b), the top element of the stack is C; that is, the last element pushed onto
the stack is C.
Next, we discuss the definitions of the functions to implement the operations of a linked
stack.

Default Constructor
The first operation that we consider is the default constructor. The default constructor
initializes the stack to an empty state when a stack object is declared. Thus, this function
sets stackTop to nullptr. The definition of this function is:
template <class Type>
linkedStackType<Type>::linkedStackType()
{
stackTop = nullptr;
}

Empty Stack and Full Stack
The operations isEmptyStack and isFullStack are quite straightforward. The stack is
empty if stackTop is nullptr. Also, because the memory for a stack element is allocated
and deallocated dynamically, the stack is never full. (The stack is full only if we run out of
memory.) Thus, the function isFullStack always returns the value false. The
definitions of the functions to implement these operations are:
template <class Type>
bool linkedStackType<Type>::isEmptyStack() const

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1192

| Chapter 17: Stacks and Queues

{
return (stackTop == nullptr);
} //end isEmptyStack
template <class Type>
bool linkedStackType<Type>:: isFullStack() const
{
return false;
} //end isFullStack

Recall that in the linked implementation of stacks, the function isFullStack does not
apply because, logically, the stack is never full. However, you must provide its definition
because it is included as an abstract function in the parent class stackADT.

Initialize Stack
The operation initializeStack reinitializes the stack to an empty state. Because the
stack may contain some elements and we are using a linked implementation of a stack, we
must deallocate the memory occupied by the stack elements and set stackTop to
nullptr. The definition of this function is:
template <class Type>
void linkedStackType<Type>:: initializeStack()
{
nodeType<Type> *temp; //pointer to delete the node
while (stackTop != nullptr)

//while there are elements in
//the stack

{
//set temp to point to the
//current node
stackTop = stackTop->link; //advance stackTop to the
//next node
delete temp;
//deallocate memory occupied by temp
temp = stackTop;

}
} //end initializeStack

Next, we consider the push, top, and pop operations. From Figure 17-12(b), it is clear
that the newElement will be added (in the case of push) at the beginning of the linked
list pointed to by stackTop. In the case of pop, the node pointed to by stackTop will
be removed. In both cases, the value of the pointer stackTop is updated. The operation
top returns the info of the node that stackTop is pointing to.

Push
Consider the stack shown in Figure 17-13.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Implementation of Stacks

|

1193

stack
stackTop

C

1
7

B
A

FIGURE 17-13

Stack before the push operation

Figure 17-14 shows the steps of the push operation. (Assume that the new element to be
pushed is 'D'.)

newNode

newNode
D

stack
stackTop

C

stackTop

newNode
stack

C

B

B

A

A

(a) Create newNode
and store D

FIGURE 17-14

D

stack

stackTop

D

C

B

A
(b) Put newNode on
the top of stack

(c) Make stackTop point
to the top element

Push operation

The statements:
newNode = new nodeType<Type>; //create the new node
newNode->info = newElement;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1194

| Chapter 17: Stacks and Queues

create a node, store the address of the node into the variable newNode, and store
newElement into the info field of newNode. See Figure 17-14(a).
The statement:
newNode->link = stackTop;

inserts newNode at the top of the stack, as shown in Figure 17-14(b).
Finally, the statement:
stackTop = newNode;

updates the value of stackTop, which results in Figure 17-14(c).
The definition of the function push is:
template <class Type>
void linkedStackType<Type>::push(const Type& newElement)
{
nodeType<Type> *newNode; //pointer to create the new node
newNode = new nodeType<Type>; //create the node
newNode->info = newElement; //store newElement in the node
newNode->link = stackTop; //insert newNode before stackTop
stackTop = newNode;
//set stackTop to point to the
//top node
} //end push

We do not need to check whether the stack is full before we push an element onto the
stack because in this implementation, logically, the stack is never full.

Return the Top Element
The operation to return the top element of the stack is quite straightforward. Its
definition is:
template <class Type>
Type linkedStackType<Type>::top() const
{
assert(stackTop != nullptr); //if stack is empty,
//terminate the program
return stackTop->info;
//return the top element
}//end top

Pop
Now we consider the pop operation, which removes the top element of the stack.
Consider the stack shown in Figure 17-15.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Implementation of Stacks

|

1195

stack
stackTop

C
B

1
7

A

FIGURE 17-15

Stack before the pop operation

Figure 17-16 shows the pop operation.

temp
stack
temp

C

stackTop

C

stack
B

stackTop

FIGURE 17-16

stackTop

A

A

(a) Make temp point to the
top element

B

(b) Make stackTop point to
the next element

B

A

(c) Delete temp

Pop operation

The statement:
temp = stackTop;

makes temp point to the top of the stack. See Figure 17-16(a). Next, the statement:
stackTop = stackTop->link;

makes the second element of the stack become the top element of the stack.
See Figure 17-16(b).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1196

| Chapter 17: Stacks and Queues

Finally, the statement:
delete temp;

deallocates the memory pointed to by temp. See Figure 17-16(c).
The definition of the function pop is:
template <class Type>
void linkedStackType<Type>::pop()
{
nodeType<Type> *temp;
//pointer to deallocate memory
if (stackTop != nullptr)
{
temp = stackTop; //set temp to point to the top node
//advance stackTop to the
//next node
//delete the top node

stackTop = stackTop->link;

delete temp;
}
else
cout << "Cannot remove from an empty stack." << endl;
}//end pop

Copy Stack
The function copyStack makes an identical copy of a stack. Its definition is similar to the
definition of copyList for linked lists, given in Chapter 16. The definition of the
function copyStack is:
template <class Type>
void linkedStackType<Type>::copyStack
(const linkedStackType<Type>& otherStack)
{
nodeType<Type> *newNode, *current, *last;
if (stackTop != nullptr) //if stack is nonempty, make it empty
initializeStack();
if (otherStack.stackTop == nullptr)
stackTop = nullptr;
else
{
current = otherStack.stackTop; //set current to point
//to the stack to be copied
//copy the stackTop element of the stack
stackTop = new nodeType<Type>; //create the node
stackTop->info = current->info; //copy the info

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Implementation of Stacks

stackTop->link = nullptr;
last = stackTop;
current = current->link;

|

1197

//set the link field of the
//node to nullptr
//set last to point to the node
//set current to point to
//the next node

//copy the remaining stack
while (current != nullptr)
{
newNode = new nodeType<Type>;
newNode->info = current->info;
newNode->link = nullptr;
last->link = newNode;
last = newNode;
current = current->link;
}//end while
}//end else
} //end copyStack

Constructors and Destructors
We have already discussed the default constructor. To complete the implementation of
the stack operations, next we give the definitions of the functions to implement the copy
constructor and the destructor and to overload the assignment operator. (These functions
are similar to those discussed for linked lists in Chapter 16.)
//copy constructor
template <class Type>
linkedStackType<Type>::linkedStackType(
const linkedStackType<Type>& otherStack)
{
stackTop = nullptr;
copyStack(otherStack);
}//end copy constructor
//destructor
template <class Type>
linkedStackType<Type>::~linkedStackType()
{
initializeStack();
}//end destructor

Overloading the Assignment Operator (=)
The definition of the function to overload the assignment operator for the class
linkedStackType is:
template <class Type>
const linkedStackType<Type>& linkedStackType<Type>::operator=
(const linkedStackType<Type>& otherStack)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1198

| Chapter 17: Stacks and Queues

{
if (this != &otherStack) //avoid self-copy
copyStack(otherStack);
return *this;
}//end operator=

The definition of a stack and the functions to implement the stack operations discussed
previously are generic. Also, as in the case of an array representation of a stack, in the
linked representation of a stack, we must put the definition of the stack and the functions
to implement the stack operations together in a (header) file. A client’s program can
include this header file via the include statement.
Example 17-3 illustrates how a linkedStack object is used in a program.
EXAMPLE 17-3
We assume that the definition of the class linkedStackType and the functions to
implement the stack operations are included in the header file "linkedStack.h".
//This program tests various operations of a linked stack
#include <iostream>
#include "linkedStack.h"
using namespace std;
void testCopy(linkedStackType<int> OStack);
int main()
{
linkedStackType<int> stack;
linkedStackType<int> otherStack;
linkedStackType<int> newStack;
//Add elements into stack
stack.push(34);
stack.push(43);
stack.push(27);
//Use the assignment operator to copy the elements
//of stack into newStack
newStack = stack;
cout << "After the assignment operator, newStack: "
<< endl;
//Output the elements of newStack
while (!newStack.isEmptyStack())
{
cout << newStack.top() << endl;
newStack.pop();
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Linked Implementation of Stacks

|

1199

//Use the assignment operator to copy the elements
//of stack into otherStack
otherStack = stack;
cout << "Testing the copy constructor." << endl;
testCopy(otherStack);
cout << "After the copy constructor, otherStack: " << endl;
while (!otherStack.isEmptyStack())
{
cout << otherStack.top() << endl;
otherStack.pop();
}
return 0;
}
//Function to test the copy constructor
void testCopy(linkedStackType<int> OStack)
{
cout << "Stack in the function testCopy:" << endl;
while (!OStack.isEmptyStack())
{
cout << OStack.top() << endl;
OStack.pop();
}
}

Sample Run:
After the assignment operator, newStack:
27
43
34
Testing the copy constructor.
Stack in the function testCopy:
27
43
34
After the copy constructor, otherStack:
27
43
34

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1200

| Chapter 17: Stacks and Queues

Stack as Derived from the class unorderedLinkedList
If we compare the push function of the stack with the insertFirst function
discussed for general lists in Chapter 16, we see that the algorithms to implement these
operations are similar. A comparison of other functions—such as initializeStack and
initializeList, isEmptyList and isEmptyStack, and so on—suggests that the
class linkedStackType can be derived from the class linkedListType. Moreover, the functions pop and isFullStack can be implemented as in the previous section.
Note that the class linkedListType is an abstract and does not implement all of the
operations. However, the class unorderedLinkedListType is derived from the
class linkedListType and provides the definitions of the abstract functions of
the class linkedListType. Therefore, we can derive the class linkedStackType
from the class unorderedLinkedListType.
Next, we define the class linkedStackType that is derived from the class
unorderedLinkedList. The definitions of the functions to implement the stack operations are also given.
#include <iostream>
#include "unorderedLinkedList.h"
using namespace std;
template <class Type>
class linkedStackType: public unorderedLinkedList<Type>
{
public:
void initializeStack();
bool isEmptyStack() const;
bool isFullStack() const;
void push(const Type& newItem);
Type top() const;
void pop();
};
template <class Type>
void linkedStackType<Type>::initializeStack()
{
unorderedLinkedList<Type>::initializeList();
}
template <class Type>
bool linkedStackType<Type>::isEmptyStack() const
{
return unorderedLinkedList<Type>::isEmptyList();
}
template <class Type>
bool linkedStackType<Type>::isFullStack() const
{
return false;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Stacks: Postfix Expressions Calculator |

1201

template <class Type>
void linkedStackType<Type>::push(const Type& newElement)
{
unorderedLinkedList<Type>::insertFirst(newElement);
}
template <class Type>
Type linkedStackType<Type>::top() const
{
return unorderedLinkedList<Type>::front();
}
template <class Type>
void linkedStackType<Type>::pop()
{
nodeType<Type> *temp;
temp = first;
first = first->link;
delete temp;
}

Application of Stacks: Postfix Expressions
Calculator
The usual notation for writing arithmetic expressions (the notation we learned in elementary school) is called infix notation, in which the operator is written between the operands.
For example, in the expression a + b, the operator + is between the operands a and b. In
infix notation, the operators have precedence. That is, we must evaluate expressions from
left to right, and multiplication and division have higher precedence than do addition and
subtraction. If we want to evaluate the expression in a different order, we must include
parentheses. For example, in the expression a + b * c, we first evaluate * using the operands
b and c, and then we evaluate + using the operand a and the result of b * c.
In the early 1920s, the Polish mathematician Jan Lukasiewicz discovered that if operators
were written before the operands (prefix or Polish notation; for example, + a b), the
parentheses could be omitted. In the late 1950s, the Australian philosopher and early
computer scientist Charles L. Hamblin proposed a scheme in which the operators follow
the operands (postfix operators), resulting in the Reverse Polish notation. This has the
advantage that the operators appear in the order required for computation.
For example, the expression:
a+b*c
in a postfix expression is:
abc*+
The following example shows various infix expressions and their equivalent postfix
expressions.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1202

| Chapter 17: Stacks and Queues

EXAMPLE 17-4
Infix Expression

Equivalent Postfix Expression

a+b

ab+

a+b*c

abc*+

a*b+c

ab*c+

(a + b ) * c

ab+c*

(a  b) * (c + d)

abcd+*

(a + b) * (c  d / e) + f

ab+cde/*f+

Shortly after Lukasiewicz’s discovery, it was realized that postfix notation had important
applications in computer science. In fact, many compilers now first translate arithmetic
expressions into some form of postfix notation and then translate this postfix expression
into machine code. Postfix expressions can be evaluated using the following algorithm:
Scan the expression from left to right. When an operator is found, back up to get the
required number of operands, perform the operation, and continue.
Consider the following postfix expression:
63+2*=

Let us evaluate this expression using a stack and the previous algorithm. Figure 17-17
shows how this expression gets evaluated.

Expression: 6 3 + 2 * =
Push
6
into
stack 6
(a)

Push
2
into
stack

2
9
(e)

FIGURE 17-17

Push
3
into
stack

3
6
(b)

*
Pop
stack
twice
op2 = 2;
op1 = 9;
(f)

+
Pop
stack
twice
op2 = 3;
op1 = 6;
(c)

op1 + op2
= 9
Push 9
into
stack
9
(d)

op1 * op2
= 18
Push 18
into
stack
18
(g)

=
Pop
stack
and
print:
18
(h)

Evaluating the postfix expression: 6 3 + 2 * ¼

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Stacks: Postfix Expressions Calculator |

1203

Read the first symbol, 6, which is a number. Push the number onto the stack
(see Figure 17-17(a)). Read the next symbol, 3, which is a number. Push the number
onto the stack (see Figure 17-17(b)). Read the next symbol, +, which is an operator.
Because an operator requires two operands to be evaluated, pop the stack twice
(see Figure 17-17(c)). Perform the operation and put the result back onto the stack
(see Figure 17-17(d)).
Read the next symbol, 2, which is a number. Push the number onto the stack
(see Figure 17-17(e)). Read the next symbol, *, which is an operator. Because an
operator requires two operands to be evaluated, pop the stack twice (see Figure 17-17(f )).
Perform the operation, and put the result back onto the stack (see Figure 17-17(g)).
Scan the next symbol, =, which is the equal sign, indicating the end of the expression. Therefore,
print the result. The result of the expression is in the stack, so pop and print (see Figure 17-17(h)).
The value of the expression 6 3 + 2 * = 18.
From this discussion, it is clear that when we read a symbol other than a number, the
following cases arise:
1. The symbol we read is one of the following: +, -, *, /, or =.
If the symbol is +, -, *, or /, the symbol is an operator, so we must
evaluate it. Because an operator requires two operands, the stack must
have at least two elements; otherwise, the expression has an error.
b. If the symbol is = (an equal sign), the expression ends and we must
print the answer. At this step, the stack must contain exactly one
element; otherwise, the expression has an error.
2. The symbol we read is something other than +, -, *, /, or =. In this
case, the expression contains an illegal operator.
a.

It is also clear that when an operand (number) is encountered in an expression, it is
pushed onto the stack because the operator comes after the operands.
Consider the following expressions:
a. 7 6 + 3 ; 6 - =
b. 14 + 2 3 * =
c. 14 2 3 + =
Expression (a) has an illegal operator, expression (b) does not have enough operands for +,
and expression (c) has too many operands. In the case of expression (c), when we
encounter the equal sign (=), the stack will have two elements, and this error cannot be
discovered until we are ready to print the value of the expression.
To make the input easier to read, we assume that the postfix expressions are in the
following form:
#6 #3 + #2 * =

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1204

| Chapter 17: Stacks and Queues

The symbol # precedes each number in the expression. If the symbol scanned is #, then
the next input is a number (that is, an operand). If the symbol scanned is not #, then it is
either an operator (may be illegal) or an equal sign (indicating the end of the expression).
Furthermore, we assume that each expression contains only the +, -, *, and / operators.
This program outputs the entire postfix expression together with the answer. If the
expression has an error, the expression is discarded. In this case, the program outputs
the expression together with an appropriate error message. Because an expression may
contain an error, we must clear the stack before processing the next expression. Also, the
stack must be initialized; that is, the stack must be empty.

Main Algorithm
Following the previous discussion, the main algorithm in pseudocode is:
Read the first character
while not the end of input data
{
a. initialize the stack
b. process the expression
c. output result
d. get the next expression
}

To simplify the complexity of the function main, we write four functions:
evaluateExpression, evaluateOpr, discardExp, and printResult. The function
evaluateExpression, if possible, evaluates the expression and leaves the result in the
stack. If the postfix expression is error free, the function printResult outputs the result.
The function evaluateOpr evaluates an operator, and the function discardExp discards
the current expression if there is any error in the expression.

Function evaluateExpression
The function evaluateExpression evaluates each postfix expression. Each expression
ends with the symbol =. The general algorithm is:
while (ch is not = '=') //process each expression
//= marks the end of an expression
{
switch (ch)
{
case '#':
read a number
output the number;
push the number onto the stack;
break;
default:
assume that ch is an operation
evaluate the operation;
} //end switch

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Stacks: Postfix Expressions Calculator |

1205

if no error was found, then
{
read next ch;
output ch;
}
else
Discard the expression
} //end while

From this algorithm, it follows that this method has five parameters—one to access the input file,
one to access the output file, one to access the stack, one to pass a character of the expression,
and one to indicate whether there is an error in the expression. The definition of this function is:
void evaluateExpression(ifstream& inpF, ofstream& outF,
stackType<double>& stack,
char& ch, bool& isExpOk)
{
double num;
while (ch != '=')
{
switch (ch)
{
case '#':
inpF >> num;
outF << num << " ";
if (!stack.isFullStack())
stack.push(num);
else
{
cout << "Stack overflow. "
<< "Program terminates!" << endl;
exit(0); //terminate the program
}
break;
default:
evaluateOpr(outF, stack, ch, isExpOk);
}//end switch
if (isExpOk) //if no error
{
inpF >> ch;
outF << ch;
if (ch != '#')
outF << " ";
}
else
discardExp(inpF, outF, ch);
} //end while (!= '=')
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1206

| Chapter 17: Stacks and Queues

Note that the function exit terminates the program.

Function evaluateOpr
This function (if possible) evaluates an expression. Two operands are needed to evaluate an
operation, and operands are saved in the stack. Therefore, the stack must contain at least two
numbers. If the stack contains fewer than two numbers, then the expression has an error. In
this case, the entire expression is discarded, and an appropriate message is printed. This
function also checks for any illegal operations. In pseudocode, this function is:
if stack is empty
{
error in the expression
set expressionOk to false
}
else
{
retrieve the top element of stack into op2
pop stack
if stack is empty
{
error in the expression
set expressionOk to false
}
else
{
retrieve the top element of stack into op1
pop stack
//If the operation is legal, perform the
//operation and push the result onto the stack.
switch (ch)
{
case '+':
//Perform the operation and push the result
//onto the stack.
stack.push(op1 + op2);
break;
case '-':
//Perform the operation and push the result
//onto the stack.
stack.push(op1 – op2);
break;
case '*':
//Perform the operation and push the
//result onto the stack.
stack.push(op1 * op2);
break;
case '/':
//If (op2 != 0), perform the operation and
//push the result onto the stack.
stack.push(op1 / op2);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Stacks: Postfix Expressions Calculator |

1207

//Otherwise, report the error.
//Set expressionOk to false.
break;
otherwise operation is illegal
{
output an appropriate message;
set expressionOk to false
}
} //end switch
}

Following this pseudocode, the definition of the function evaluateOpr is:
void evaluateOpr(ofstream& out, stackType<double>& stack,
char& ch, bool& isExpOk)
{
double op1, op2;
if (stack.isEmptyStack())
{
out << " (Not enough operands)";
isExpOk = false;
}
else
{
op2 = stack.top();
stack.pop();
if (stack.isEmptyStack())
{
out << " (Not enough operands)";
isExpOk = false;
}
else
{
op1 = stack.top();
stack.pop();
switch (ch)
{
case '+':
stack.push(op1 + op2);
break;
case '-':
stack.push(op1 - op2);
break;
case '*':
stack.push(op1 * op2);
break;
case '/':
if (op2 != 0)
stack.push(op1 / op2);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1208

| Chapter 17: Stacks and Queues

else
{
out << " (Division by 0)";
isExpOk = false;
}
break;
default:
out << " (Illegal operator)";
isExpOk = false;
}//end switch
} //end else
} //end else
} //end evaluateOpr

Function discardExp
This function is called whenever an error is discovered in the expression. It reads and
writes the input data only until the input is '=', the end of the expression. The def inition
of this function is:
void discardExp(ifstream& in, ofstream& out, char& ch)
{
while (ch != '=')
{
in.get(ch);
out << ch;
}
} //end discardExp

Function printResult
If the postfix expression contains no errors, the function printResult prints the
result; otherwise, it outputs an appropriate message. The result of the expression is in
the stack, and the output is sent to a file. Therefore, this function must have access to
the stack and the output file. Suppose that no errors were encountered by the
method evaluateExpression. If the stack has only one element, then the expression is error free and the top element of the stack is printed. If either the stack is
empty or it has more than one element, then there is an error in the postfix
expression. In this case, this method outputs an appropriate error message. The
definition of this method is:
void printResult(ofstream& outF, stackType<double>& stack,
bool isExpOk)
{
double result;
if (isExpOk) //if no error, print the result

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Stacks: Postfix Expressions Calculator |

1209

{
if (!stack.isEmptyStack())
{
result = stack.top();
stack.pop();
if (stack.isEmptyStack())
outF << result << endl;
else
outF << " (Error: Too many operands)" << endl;
} //end if
else
outF << " (Error in the expression)" << endl;
}
else
outF << " (Error in the expression)" << endl;
outF << "_________________________________"
<< endl << endl;
} //end printResult

PROGRAM LISTING
//***********************************************************
// Author: D.S. Malik
//
// Program: Postfix Calculator
// This program evaluates postfix expressions.
//***********************************************************
#include
#include
#include
#include

<iostream>
<iomanip>
<fstream>
"mystack.h"

using namespace std;
void evaluateExpression(ifstream& inpF, ofstream& outF,
stackType<double>& stack,
char& ch, bool& isExpOk);
void evaluateOpr(ofstream& out, stackType<double>& stack,
char& ch, bool& isExpOk);
void discardExp(ifstream& in, ofstream& out, char& ch);
void printResult(ofstream& outF, stackType<double>& stack,
bool isExpOk);
int main()
{
bool expressionOk;
char ch;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1210

| Chapter 17: Stacks and Queues

stackType<double> stack(100);
ifstream infile;
ofstream outfile;
infile.open("RpnData.txt");
if (!infile)
{
cout << "Cannot open the input file. "
<< "Program terminates!" << endl;
return 1;
}
outfile.open("RpnOutput.txt");
outfile << fixed << showpoint;
outfile << setprecision(2);
infile >> ch;
while (infile)
{
stack.initializeStack();
expressionOk = true;
outfile << ch;
evaluateExpression(infile, outfile, stack, ch,
expressionOk);
printResult(outfile, stack, expressionOk);
infile >> ch; //begin processing the next expression
} //end while
infile.close();
outfile.close();
return 0;
} //end main
//Place the definitions of the function evaluateExpression,
//evaluateOpr, discardExp, and printResult as described
//previously here.

Sample Run:
Input File
#35 #27 + #3 * =
#26 #28 + #32 #2 ; - #5 / =
#23 #30 #15 * / =
#2 #3 #4 + =
#20 #29 #9 * ; =
#25 #23 - + =
#34 #24 #12 #7 / * + #23 - =

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Removing Recursion: Nonrecursive Algorithm to Print a Linked List Backward |

1211

Output
#35.00 #27.00 + #3.00 * = 186.00
_________________________________
#26.00 #28.00 + #32.00 #2.00 ; (Illegal operator) - #5 / = (Error in the expression)
_________________________________
#23.00 #30.00 #15.00 * / = 0.05
_________________________________

1
7

#2.00 #3.00 #4.00 + = (Error: Too many operands)
_________________________________
#20.00 #29.00 #9.00 * ; (Illegal operator) = (Error in the expression)
_________________________________
#25.00 #23.00 - + (Not enough operands) = (Error in the expression)
_________________________________
#34.00 #24.00 #12.00 #7.00 / * + #23.00 - = 52.14
_________________________________

Removing Recursion: Nonrecursive Algorithm
to Print a Linked List Backward
In Chapter 16, we used recursion to print a linked list backward. In this section, you will
learn how a stack can be used to design a nonrecursive algorithm to print a linked list
backward.
Consider the linked list shown in Figure 17-18.

first

FIGURE 17-18

5

10

15

Linked list

To print the list backward, first we need to get to the last node of the list, which we can do by
traversing the linked list starting at the first node. However, once we are at the last node, how
do we get back to the previous node, especially given that links go in only one direction?
You can again traverse the linked list with the appropriate loop termination condition, but
this approach might waste a considerable amount of computer time, especially if the list is
very large. Moreover, if we do this for every node in the list, the program might execute very
slowly. Next, we show how to use a stack effectively to print the list backward.
After printing the info of a particular node, we need to move to the node immediately
behind this node. For example, after printing 15, we need to move to the node with

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1212

| Chapter 17: Stacks and Queues

info 10. Thus, while initially traversing the list to move to the last node, we must save a
pointer to each node. For example, for the list in Figure 17-18, we must save a pointer to
each of the nodes with info 5 and 10. After printing 15, we go back to the node with
info 10; after printing 10, we go back to the node with info 5. From this, it follows
that we must save pointers to each node in a stack, so as to implement the Last In First
Out principle.

Because the number of nodes in a linked list is usually not known, we will use the linked
implementation of a stack. Suppose that stack is an object of type linkedListType,
and current is a pointer of the same type as the pointer first. Consider the following
statements:
current = first;

//Line 1

while (current != nullptr)
{
stack.push(current);
current = current->link;
}

//Line 2
//Line 3
//Line 4

After the statement in Line 1 executes, current points to the first node (see Figure 17-19).

stack
first

5

10

15

stackTop

current

FIGURE 17-19

List after the statement current ¼ first; executes

Because current is not nullptr, the statements in Lines 3 and 4 execute (see Figure 17-20).

stack
first

5

10

current

FIGURE 17-20

15

stackTop

5

List and stack after the statements stack.push(current); and current ¼

current->link; execute

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Removing Recursion: Nonrecursive Algorithm to Print a Linked List Backward |

1213

After the statement in Line 4 executes, the loop condition in Line 2 is reevaluated.
Because current is not nullptr, the loop condition evaluates to true, so the statements in Lines 3 and 4 execute (see Figure 17-21).

stack
first

5

10

15

current

stackTop

10

5

FIGURE 17-21

List and stack after the statements stack.push(current); and current =
current->link; execute

After the statement in Line 4 executes, the loop condition, in Line 2, is evaluated again.
Because current is not nullptr, the loop condition evaluates to true, so the statements in Lines 3 and 4 execute (see Figure 17-22).

stack
first

5

10

15

stackTop

15

current
10

5

FIGURE 17-22

List and stack after the statements stack.push(current); and current =
current->link; execute

After the statement in Line 4 executes, the loop condition in Line 2 is evaluated again.
Because current is nullptr, the loop condition evaluates to false, and the while loop

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1214

| Chapter 17: Stacks and Queues

in Line 2 terminates. From Figure 17-22, it follows that a pointer to each node in the
linked list is saved in the stack. The top element of the stack contains a pointer to the last
node in the list, and so on. Let us now execute the following statements:
while (!stack.isEmptyStack())
{
current = stack.top();
stack.pop();
cout << current->info << " ";
}

//Line 5
//Line 6
//Line 7
//Line 8

The loop condition in Line 5 evaluates to true because the stack is nonempty. Therefore, the statements in Lines 6, 7, and 8 execute. After the statement in Line 6 executes,
current points to the last node. The statement in Line 7 removes the top element of the
stack (see Figure 17-23).

stack
first

5

10

15

current

stackTop

10

5

FIGURE 17-23

List and stack after the statements current = stack.top(); and stack. pop();
execute

The statement in Line 8 outputs current->info, which is 15. Next, the loop condition in
Line 5 is evaluated. Because the loop condition evaluates to true, the statements in Lines 6,
7, and 8 execute. After the statements in Lines 6 and 7 execute, Figure 17-24 results.

stack
first

5
current

FIGURE 17-24

10

15

stackTop

5

List and stack after the statements current = stack.top(); and stack. pop();
execute

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Queues

|

1215

The statement in Line 8 outputs current->info, which is 10. Next, the loop condition in
Line 5 is evaluated. Because the loop condition evaluates to true, the statements in Lines 6,
7, and 8 execute. After the statements in Lines 6 and 7 execute, Figure 17-25 results.

stack
first

5

10

15

stackTop

current

FIGURE 17-25

List and stack after the statements current = stack.top(); and stack. pop();
execute

The statement in Line 8 outputs current->info, which is 5. Next, the loop condition
in Line 5 is evaluated. Because the loop condition evaluates to false, the while loop
terminates. The while loop in Line 5 produces the following output:
15 10 5

Queues
This section discusses another important data structure called a queue. The notion of a
queue in computer science is the same as the notion of the queues to which you are
accustomed in everyday life. There are queues of customers in a bank or in a grocery store
and queues of cars waiting to pass through a tollbooth. Similarly, because a computer can
send a print request faster than a printer can print, a queue of documents is often waiting to
be printed at a printer. The general rule to process elements in a queue is that the customer
at the front of the queue is served next, and when a new customer arrives, he or she stands
at the end of the queue. That is, a queue is a First In First Out data structure.
Queues have numerous applications in computer science. Whenever a system is modeled
on the First In First Out principle, queues are used. At the end of this section, we will
discuss one of the most widely used applications of queues, computer simulation. First,
however, we need to develop the tools necessary to implement a queue. The next few
sections discuss how to design classes to implement queues as an ADT.
A queue is a set of elements of the same type in which the elements are added at one end,
called the back or rear, and deleted from the other end, called the front. For example,
consider a line of customers in a bank, wherein the customers are waiting to withdraw/
deposit money or to conduct some other business. Each new customer gets in the line at
the rear. Whenever a teller is ready for a new customer, the customer at the front of the
line is served.
The rear of the queue is accessed whenever a new element is added to the queue, and the
front of the queue is accessed whenever an element is deleted from the queue. As in a

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1216

| Chapter 17: Stacks and Queues

stack, the middle elements of the queue are inaccessible, even if the queue elements are
stored in an array.
Queue: A data structure in which the elements are added at one end, called the rear, and

deleted from the other end, called the front; a First In First Out (FIFO) data structure.

Queue Operations
From the definition of queues, we see that the two key operations are add and delete. We
call the add operation addQueue and the delete operation deleteQueue. Because
elements can be neither deleted from an empty queue nor added to a full queue, we
need two more operations to successfully implement the addQueue and deleteQueue
operations: isEmptyQueue (checks whether the queue is empty) and isFullQueue
(checks whether a queue is full).
We also need an operation, initializeQueue, to initialize the queue to an empty state.
Moreover, to retrieve the first and last elements of the queue, we include the operations
front and back, as described in the following list. Some of the queue operations are:
•
•

initializeQueue: Initializes the queue to an empty state.

•

isFullQueue: Determines whether the queue is full. If the queue is full,
it returns the value true; otherwise, it returns the value false.

•

front: Returns the front, that is, the first element of the queue. Input to

isEmptyQueue: Determines whether the queue is empty. If the queue is
empty, it returns the value true; otherwise, it returns the value false.

this operation consists of the queue. Prior to this operation, the queue
must exist and must not be empty.
• back: Returns the last element of the queue. Input to this operation
consists of the queue. Prior to this operation, the queue must exist and
must not be empty.
• addQueue: Adds a new element to the rear of the queue. Input to this
operation consists of the queue and the new element. Prior to this
operation, the queue must exist and must not be full.
• deleteQueue: Removes the front element from the queue. Input to this
operation consists of the queue. Prior to this operation, the queue must
exist and must not be empty.
As in the case of a stack, a queue can be stored in an array or in a linked structure. We will
consider both implementations. Because elements are added at one end and removed
from the other end, we need two pointers to keep track of the front and rear of the
queue, called queueFront and queueRear.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Queues

|

1217

The following abstract class queueADT defines these operations as an ADT:
template <class Type>
class queueADT
{
public:
virtual bool isEmptyQueue() const = 0;
//Function to determine whether the queue is empty.
//Postcondition: Returns true if the queue is empty,
//
otherwise returns false.
virtual bool isFullQueue() const = 0;
//Function to determine whether the queue is full.
//Postcondition: Returns true if the queue is full,
//
otherwise returns false.
virtual void initializeQueue() = 0;
//Function to initialize the queue to an empty state.
//Postcondition: The queue is empty.
virtual Type front() const = 0;
//Function to return the first element of the queue.
//Precondition: The queue exists and is not empty.
//Postcondition: If the queue is empty, the program
//
terminates; otherwise, the first
//
element of the queue is returned.
virtual Type back() const = 0;
//Function to return the last element of the queue.
//Precondition: The queue exists and is not empty.
//Postcondition: If the queue is empty, the program
//
terminates; otherwise, the last
//
element of the queue is returned.
virtual void addQueue(const Type& queueElement) = 0;
//Function to add queueElement to the queue.
//Precondition: The queue exists and is not full.
//Postcondition: The queue is changed and queueElement
//
is added to the queue.
virtual void deleteQueue() = 0;
//Function to remove the first element of the queue.
//Precondition: The queue exists and is not empty.
//Postcondition: The queue is changed and the first
//
element is removed from the queue.
};

We leave it as an exercise for you to draw the UML class diagram of the class
queueADT.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1218

| Chapter 17: Stacks and Queues

Implementation of Queues as Arrays
Before giving the definition of the class to implement a queue as an ADT, we need to
decide how many member variables are needed to implement the queue. Of course, we
need an array to store the queue elements, the variables queueFront and queueRear to
keep track of the first and last elements of the queue and the variable maxQueueSize to
specify the maximum size of the queue. Thus, we need at least four member variables.
Before writing the algorithms to implement the queue operations, we need to decide
how to use queueFront and queueRear to access the queue elements. How do
queueFront and queueRear indicate that the queue is empty or full? Suppose that
queueFront gives the index of the first element of the queue, and queueRear gives the
index of the last element of the queue. To add an element to the queue, first we advance
queueRear to the next array position, and then we add the element to the position that
queueRear is pointing to. To delete an element from the queue, first we retrieve the
element that queueFront is pointing to, and then we advance queueFront to the next
element of the queue. Thus, queueFront changes after each deleteQueue operation,
and queueRear changes after each addQueue operation.
Let’s see what happens when queueFront changes after a deleteQueue operation and
queueRear changes after an addQueue operation. Assume that the array to hold the
queue elements is of size 100.
Initially, the queue is empty. After the operation:
addQueue(Queue,'A');

the array is as shown in Figure 17-26.

[0] [1] [2] [3]

FIGURE 17-26

[97] [98] [99]
......

A
queueFront

0

queueRear

0

Queue after the first addQueue operation

After two more addQueue operations:
addQueue(Queue,'B');
addQueue(Queue,'C');

the array is as shown in Figure 17-27.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Queues

[0] [1] [2] [3]
A

FIGURE 17-27

B

|

1219

[97] [98] [99]
......

C

queueFront

0

queueRear

2

1
7

Queue after two more addQueue operations

Now consider the deleteQueue operation:
deleteQueue();

After this operation, the array containing the queue is as shown in Figure 17-28.
[0] [1] [2] [3]
A

FIGURE 17-28

B

[97] [98] [99]
......

C

queueFront

1

queueRear

2

Queue after the deleteQueue operation

Will this queue design work? Suppose A stands for adding (that is, addQueue) an element
to the queue, and D stands for deleting (that is, deleteQueue) an element from the
queue. Consider the following sequence of operations:
AAADADADADADADADA...

This sequence of operations would eventually set the index queueRear to point to the
last array position, giving the impression that the queue is full. However, the queue has
only two or three elements, and the front of the array is empty (see Figure 17-29).

[0] [1] [2] [3]

[97] [98] [99]
......

FIGURE 17-29

queueFront

97

queueRear

99

Queue after the sequence of operations AAADADADADADA. . .

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1220

| Chapter 17: Stacks and Queues

One solution to this problem is that when the queue overflows to the rear (that is, queueRear
points to the last array position), we can check the value of the index queueFront. If the value
of queueFront indicates that there is room in the front of the array, then when queueRear
gets to the last array position, we can slide all of the queue elements toward the first array
position. This solution is good if the queue size is very small; otherwise, the program may
execute more slowly.
Another solution to this problem is to assume that the array is circular—that is, the first
array position immediately follows the last array position (see Figure 17-30).

FIGURE 17-30

Circular queue

We will consider the array containing the queue to be circular, although we will draw the
figures of the array holding the queue elements as before.
Suppose that we have the queue as shown in Figure 17-31(a).

[0] [1]
.....

[98][99]
X
Y

queueFront 98 queueRear 99
(a) Before addQueue(Queue,'Z');

FIGURE 17-31

[0] [1]
[98][99]
Z
..... X
Y
queueFront 98 queueRear 0
(b) After addQueue(Queue,'Z');

Queue before and after the add operation

After the operation addQueue(Queue,'Z');, the queue is as shown in Figure 17-31(b).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Queues

|

1221

Because the array containing the queue is circular, we can use the following statement to
advance queueRear (queueFront) to the next array position:
queueRear = (queueRear + 1) % maxQueueSize;

If queueRear < maxQueueSize - 1, then queueRear + 1 <= maxQueueSize - 1, so
(queueRear + 1) % maxQueueSize = queueRear + 1. If queueRear == maxQueueSize - 1
(that is, queueRear points to the last array position), queueRear + 1 == maxQueueSize, so
(queueRear + 1) % maxQueueSize = 0. In this case, queueRear will be set to 0, which is the
first array position.
This queue design seems to work well. Before we write the algorithms to implement the
queue operations, consider the following two cases.
Case 1: Suppose that after certain operations, the array containing the queue is as shown
in Figure 17-32(a).

[0]

[97] [98][99]
.....
X

queueFront 98 queueRear 98

[0]

queueFront 99 queueRear 98
(b) After deleteQueue();

(a) Before deleteQueue();

FIGURE 17-32

[97] [98][99]
.....

Queue before and after the delete operation

After the operation deleteQueue();, the resulting array is as shown in Figure 17-32(b).
Case 2: Let us now consider the queue shown in Figure 17-33(a).

[0]

[97] [98][99]
.....
queue
elements

[0]

[97] [98][99]
.....
Z
queue elements

queueFront 99 queueRear 97

queueFront 99 queueRear 98

(a) Before addQueue(Queue,'Z');

(b) After addQueue(Queue,'Z');

FIGURE 17-33

Queue before and after the add operation

After the operation addQueue(Queue,'Z');, the resulting array is as shown in
Figure 17-33(b).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1222

| Chapter 17: Stacks and Queues

The arrays in Figures 17-32(b) and 17-33(b) have identical values for queueFront and
queueRear. However, the resulting array in Figure 17-32(b) represents an empty queue,
whereas the resulting array in Figure 17-33(b) represents a full queue. This latest queue
design has brought up another problem of distinguishing between an empty and a full queue.
This problem has several solutions. One solution is to keep a count. In addition to the
member variables queueFront and queueRear, we need another variable, count, to
implement the queue. The value of count is incremented whenever a new element is
added to the queue, and it is decremented whenever an element is removed from the
queue. In this case, the function initializeQueue initializes count to 0. This solution
is very useful if the user of the queue frequently needs to know the number of elements in
the queue.
Another solution is to let queueFront indicate the index of the array position preceding
the first element of the queue, rather than the index of the (actual) first element itself. In
this case, assuming queueRear still indicates the index of the last element in the queue,
the queue is empty if queueFront == queueRear. In this solution, the slot indicated by
the index queueFront (that is, the slot preceding the first true element) is reserved. The
queue will be full if the next available space is the special reserved slot indicated by
queueFront. Finally, because the array position indicated by queueFront is to be kept
empty, if the array size is, say, 100, then 99 elements can be stored in the queue
(see Figure 17-34).

reserved slot
[0] [1] [2]

[97] [98][99]
.....
queue
elements

queueFront 1

FIGURE 17-34

queueRear 97

Array to store the queue elements with a reserved slot

Let us implement the queue using the first solution. That is, we use the variable count to
indicate whether the queue is empty or full.The following class implements the functions
of the abstract class queueADT. Because arrays can be allocated dynamically, we will
leave it for the user to specify the size of the array to implement the queue. The default
size of the array is 100.
template <class Type>
class queueType: public queueADT<Type>
{
public:
const queueType<Type>& operator=(const queueType<Type>&);
//Overload the assignment operator.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Queues

|

1223

bool isEmptyQueue() const;
//Function to determine whether the queue is empty.
//Postcondition: Returns true if the queue is empty,
//
otherwise returns false.
bool isFullQueue() const;
//Function to determine whether the queue is full.
//Postcondition: Returns true if the queue is full,
//
otherwise returns false.
void initializeQueue();
//Function to initialize the queue to an empty state.
//Postcondition: The queue is empty.
Type front() const;
//Function to return the first element of the queue.
//Precondition: The queue exists and is not empty.
//Postcondition: If the queue is empty, the program
//
terminates; otherwise, the first
//
element of the queue is returned.
Type back() const;
//Function to return the last element of the queue.
//Precondition: The queue exists and is not empty.
//Postcondition: If the queue is empty, the program
//
terminates; otherwise, the last
//
element of the queue is returned.
void addQueue(const Type& queueElement);
//Function to add queueElement to the queue.
//Precondition: The queue exists and is not full.
//Postcondition: The queue is changed and queueElement
//
is added to the queue.
void deleteQueue();
//Function to remove the first element of the queue.
//Precondition: The queue exists and is not empty.
//Postcondition: The queue is changed and the first
//
element is removed from the queue.
queueType(int queueSize = 100);
//Constructor
queueType(const queueType<Type>& otherQueue);
//Copy constructor
queueType();
//Destructor
private:
int maxQueueSize; //variable to store the maximum queue size
int count;
//variable to store the number of
//elements in the queue
int queueFront;
//variable to point to the first
//element of the queue
int queueRear;
//variable to point to the last
//element of the queue
Type *list;
//pointer to the array that holds
//the queue elements
};
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1224

| Chapter 17: Stacks and Queues

We leave the UML class diagram of the class queueType as an exercise for you.
(See Exercise 34 at the end of this chapter.)
Next, we consider the implementation of the queue operations.
EMPTY QUEUE AND FULL QUEUE
As discussed earlier, the queue is empty if count == 0, and the queue is full if count ==
maxQueueSize. So the functions to implement these operations are:
template <class Type>
bool queueType<Type>::isEmptyQueue() const
{
return (count == 0);
} //end isEmptyQueue
template <class Type>
bool queueType<Type>::isFullQueue() const
{
return (count == maxQueueSize);
} //end isFullQueue

INITIALIZE QUEUE
This operation initializes a queue to an empty state. The first element is added at
the first array position. Therefore, we initialize queueFront to 0, queueRear to
maxQueueSize - 1, and count to 0 (see Figure 17-35).

[0] [1] [2]

[97] [98][99]
.....

queueFront 0

FIGURE 17-35

queueRear 99

count 0

Empty queue

The definition of the function initializeQueue is:
template <class Type>
void queueType<Type>::initializeQueue()
{
queueFront = 0;
queueRear = maxQueueSize - 1;
count = 0;
} //end initializeQueue

FRONT
This operation returns the first element of the queue. If the queue is nonempty, the
element of the queue indicated by the index queueFront is returned; otherwise, the
program terminates.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Queues

|

1225

template <class Type>
Type queueType<Type>::front() const
{
assert(!isEmptyQueue());
return list[queueFront];
} //end front

BACK
This operation returns the last element of the queue. If the queue is nonempty, the
element of the queue indicated by the index queueRear is returned; otherwise, the
program terminates.
template <class Type>
Type queueType<Type>::back() const
{
assert(!isEmptyQueue());
return list[queueRear];
} //end back

addQueue
Next, we implement the addQueue operation. Because queueRear points to the last
element of the queue, to add a new element to the queue, we first advance
queueRear to the next array position and then add the new element to the array
position indicated by queueRear. We also increment count by 1. So the function
addQueue is:
template <class Type>
void queueType<Type>::addQueue(const Type& newElement)
{
if (!isFullQueue())
{
queueRear = (queueRear + 1) % maxQueueSize; //use the
//mod operator to advance queueRear
//because the array is circular
count++;
list[queueRear] = newElement;
}
else
cout << "Cannot add to a full queue." << endl;
} //end addQueue

deleteQueue
To implement the deleteQueue operation, we access the index queueFront. Because
queueFront points to the array position containing the first element of the queue, in
order to remove the first queue element, we decrement count by 1 and advance
queueFront to the next queue element. So the function deleteQueue is:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1226

| Chapter 17: Stacks and Queues

template <class Type>
void queueType<Type>::deleteQueue()
{
if (!isEmptyQueue())
{
count--;
queueFront = (queueFront + 1) % maxQueueSize; //use the
//mod operator to advance queueFront
//because the array is circular
}
else
cout << "Cannot remove from an empty queue." << endl;
} //end deleteQueue

CONSTRUCTORS AND DESTRUCTORS
To complete the implementation of the queue operations, we next consider the
implementation of the constructor and the destructor. The constructor gets the
maxQueueSize from the user, sets the variable maxQueueSize to the value specified
by the user, and creates an array of size maxQueueSize. If the user does not specify
the queue size, the constructor uses the default value, which is 100, to create an array
of size 100. The constructor also initializes queueFront and queueRear to indicate
that the queue is empty. The definition of the function to implement the constructor
is:
template <class Type>
queueType<Type>::queueType(int queueSize)
{
if (queueSize <= 0)
{
cout << "Size of the array to hold the queue must "
<< "be positive." << endl;
cout << "Creating an array of size 100." << endl;
maxQueueSize = 100;
}
else
maxQueueSize = queueSize;

queueFront = 0;
queueRear = maxQueueSize - 1;
count = 0;
list = new Type[maxQueueSize];

//set maxQueueSize to
//queueSize
//initialize queueFront
//initialize queueRear
//create the array to
//hold the queue elements

} //end constructor

The array to store the queue elements is created dynamically. Therefore, when the queue
object goes out of scope, the destructor simply deallocates the memory occupied by the
array that stores the queue elements. The definition of the function to implement the
destructor is:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Queues

|

1227

template <class Type>
queueType<Type>::~queueType()
{
delete [] list;
}

The implementation of the copy constructor and overloading the assignment operator are
left as exercises for you. (The definitions of these functions are similar to those discussed
for linked lists and stacks.)

Linked Implementation of Queues
Because the size of the array to store the queue elements is fixed, only a finite number of
queue elements can be stored in the array. Also, the array implementation of the queue
requires the array to be treated in a special way together with the values of the indices
queueFront and queueRear. The linked implementation of a queue simplifies many of
the special cases of the array implementation and, because the memory to store a queue
element is allocated dynamically, the queue is never full. This section discusses the linked
implementation of a queue.
Because elements are added at one end and removed from the other end, we need to
know the front of the queue and the rear of the queue. Thus, we need two pointers,
queueFront and queueRear, to maintain the queue. The following class implements
the functions of the abstract class queueADT:
//Definition of the node
template <class Type>
struct nodeType
{
Type info;
nodeType<Type> *link;
};
template <class Type>
class linkedQueueType: public queueADT<Type>
{
public:
const linkedQueueType<Type>& operator=
(const linkedQueueType<Type>&);
//Overload the assignment operator.
bool isEmptyQueue() const;
//Function to determine whether the queue is empty.
//Postcondition: Returns true if the queue is empty,
//
otherwise returns false.
bool isFullQueue() const;
//Function to determine whether the queue is full.
//Postcondition: Returns true if the queue is full,
//
otherwise returns false.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1228

| Chapter 17: Stacks and Queues

void initializeQueue();
//Function to initialize the queue to an empty state.
//Postcondition: queueFront = nullptr; queueRear = nullptr
Type front() const;
//Function to return the first element of the queue.
//Precondition: The queue exists and is not empty.
//Postcondition: If the queue is empty, the program
//
terminates; otherwise, the first
//
element of the queue is returned.
Type back() const;
//Function to return the last element of the queue.
//Precondition: The queue exists and is not empty.
//Postcondition: If the queue is empty, the program
//
terminates; otherwise, the last
//
element of the queue is returned.
void addQueue(const Type& queueElement);
//Function to add queueElement to the queue.
//Precondition: The queue exists and is not full.
//Postcondition: The queue is changed and queueElement
//
is added to the queue.
void deleteQueue();
//Function to remove the first element of the queue.
//Precondition: The queue exists and is not empty.
//Postcondition: The queue is changed and the first
//
element is removed from the queue.
linkedQueueType();
//Default constructor
linkedQueueType(const linkedQueueType<Type>& otherQueue);
//Copy constructor
~linkedQueueType();
//Destructor
private:
nodeType<Type> *queueFront; //pointer to the front of
//the queue
nodeType<Type> *queueRear; //pointer to the rear of
//the queue
};

The UML class diagram of the class linkedQueueType is left as an exercise for you.
(See Exercise 35 at the end of this chapter.)
Next, we write the definitions of the functions of the class linkedQueueType.
EMPTY AND FULL QUEUE
The queue is empty if queueFront is nullptr. Memory to store the queue elements
is allocated dynamically. Therefore, the queue is never full, so the function to implement

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Queues

|

1229

the isFullQueue operation returns the value false. (The queue is full only if we run
out of memory.)
template <class Type>
bool linkedQueueType<Type>::isEmptyQueue() const
{
return (queueFront == nullptr);
} //end
template <class Type>
bool linkedQueueType<Type>::isFullQueue() const
{
return false;
} //end isFullQueue

Note that in reality, in the linked implementation of queues, the function isFullQueue
does not apply because, logically, the queue is never full. However, you must provide its
definition because it is included as an abstract function in the parent class queueADT.
INITIALIZE QUEUE
The operation initializeQueue initializes the queue to an empty state. The queue is
empty if there are no elements in the queue. Note that the constructor initializes the
queue when the queue object is declared. So this operation must remove all of the
elements, if any, from the queue. Therefore, this operation traverses the list containing
the queue starting at the first node, and it deallocates the memory occupied by the queue
elements. The definition of this function is:
template <class Type>
void linkedQueueType<Type>::initializeQueue()
{
nodeType<Type> *temp;
while (queueFront!= nullptr)

//while there are elements left
//in the queue

{
//set temp to point to the
//current node
queueFront = queueFront->link; //advance first to
//the next node
delete temp;
//deallocate memory occupied by temp
temp = queueFront;

}
queueRear = nullptr;
} //end initializeQueue

//set rear to nullptr

addQueue, front, back, AND deleteQueue OPERATIONS
The addQueue operation adds a new element at the end of the queue. To implement this
operation, we access the pointer queueRear.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1230

| Chapter 17: Stacks and Queues

If the queue is nonempty, the operation front returns the first element of the queue, and
so the element of the queue indicated by the pointer queueFront is returned. If the
queue is empty, the function front terminates the program.
If the queue is nonempty, the operation back returns the last element of the queue, so
the element of the queue indicated by the pointer queueRear is returned. If the queue is
empty, the function back terminates the program. Similarly, if the queue is nonempty,
the operation deleteQueue removes the first element of the queue, so we access the
pointer queueFront.
The definitions of the functions to implement these operations are:
template <class Type>
void linkedQueueType<Type>::addQueue(const Type& newElement)
{
nodeType<Type> *newNode;
newNode = new nodeType<Type>;

//create the node

newNode->info = newElement; //store the info
newNode->link = nullptr; //initialize the link field to nullptr
if (queueFront == nullptr) //if initially the queue is empty
{
queueFront = newNode;
queueRear = newNode;
}
else
//add newNode at the end
{
queueRear->link = newNode;
queueRear = queueRear->link;
}
}//end addQueue
template <class Type>
Type linkedQueueType<Type>::front() const
{
assert(queueFront != nullptr);
return queueFront->info;
} //end front
template <class Type>
Type linkedQueueType<Type>::back() const
{
assert(queueRear!= nullptr);
return queueRear->info;
} //end back

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Queues

|

1231

template <class Type>
void linkedQueueType<Type>::deleteQueue()
{
nodeType<Type> *temp;
if (!isEmptyQueue())
{
temp = queueFront;

//make temp point to the
//first node
queueFront = queueFront->link; //advance queueFront
delete temp;

//delete the first node

if (queueFront == nullptr) //if after deletion the
//queue is empty
queueRear = nullptr;
//set queueRear to nullptr
}
else
cout << "Cannot remove from an empty queue" << endl;
}//end deleteQueue

The definition of the default constructor is:
template<class Type>
linkedQueueType<Type>::linkedQueueType()
{
queueFront = nullptr; //set front to nullptr
queueRear = nullptr; //set rear to nullptr
} //end default constructor

When the queue object goes out of scope, the destructor destroys the queue; that is, it
deallocates the memory occupied by the elements of the queue. The definition of
the function to implement the destructor is similar to the definition of the function
initializeQueue. Also, the functions to implement the copy constructor and overload
the assignment operators are similar to the corresponding functions for stacks. Implementing these operations is left as an exercise for you.

EXAMPLE 17-5
The following program tests various operations on a queue. It uses the class
linkedQueueType to implement a queue.
//Test Program linked queue
#include <iostream>
#include "linkedQueue.h"
using namespace std;
int main()

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1232

| Chapter 17: Stacks and Queues

{
linkedQueueType<int> queue;
int x, y;
queue.initializeQueue();
x = 4;
y = 5;
queue.addQueue(x);
queue.addQueue(y);
x = queue.front();
queue.deleteQueue();
queue.addQueue(x + 5);
queue.addQueue(16);
queue.addQueue(x);
queue.addQueue(y - 3);
cout << "Queue Elements: ";
while (!queue.isEmptyQueue())
{
cout << queue.front() << " ";
queue.deleteQueue();
}
cout << endl;
return 0;
}

Sample Run:
Queue Elements: 5 9 16 4 2

Queue Derived from the class unorderedLinkedListType
From the definitions of the functions to implement the queue operations, it is clear that the
linked implementation of a queue is similar to the implementation of a linked list created in a
forward manner (see Chapter 16). The addQueue operation is similar to the operation
insertFirst. Likewise, the operations initializeQueue and initializeList and
isEmptyQueue and isEmptyList are similar. The deleteQueue operation can be implemented as before. The pointer queueFront is the same as the pointer first, and the
pointer queueRear is the same as the pointer last. This correspondence suggests that we
can derive the class to implement the queue from the class linkedListType (see Chapter 16).
Note that the class linkedListType is an abstract class and does not implement all
of the operations. However, the class unorderedLinkedListType is derived from
the class linkedListType and provides the definitions of the abstract functions of the
class linkedListType. Therefore, we can derive the class linkedQueueType from
the class unorderedLinkedListType.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Queues: Simulation

|

1233

We leave it as an exercise for you to write the definition of the class linkedQueueType
that is derived from the class unorderedLinkedListType. See Programming Exercise 17 at the end of this chapter.

Application of Queues: Simulation
A technique in which one system models the behavior of another system is called
simulation. For example, physical simulators include wind tunnels used to experiment
with the design of car bodies and flight simulators used to train airline pilots. Simulation
techniques are used when it is too expensive or dangerous to experiment with real
systems. You can also design computer models to study the behavior of real systems.
(We will describe some real systems modeled by computers shortly.)
Simulating the behavior of an expensive or dangerous experiment using a computer
model is usually less expensive than using the real system and is a good way to gain insight
without putting human life in danger. Moreover, computer simulations are particularly
useful for complex systems when it is difficult to construct a mathematical model. For
such systems, computer models can retain descriptive accuracy. In computer simulations,
the steps of a program are used to model the behavior of a real system. Let us consider one
such problem.
The manager of a local movie theater is hearing complaints from customers about the
length of time they have to wait in line to buy tickets. The theater currently has only one
cashier. Another theater is preparing to open in the neighborhood, and the manager is
afraid of losing customers. The manager wants to hire enough cashiers so that a customer
does not have to wait too long to buy a ticket but does not want to hire extra cashiers on
a trial basis and potentially waste time and money. One thing that the manager would like
to know is the average time a customer has to wait for service. The manager wants
someone to write a program to simulate the behavior of the theater.
In computer simulation, the objects being studied are usually represented as data. For the
theater problem, some of the objects are the customers and the cashier. The cashier serves
the customers, and we want to determine a customer’s average waiting time. Actions are
implemented by writing algorithms, which in a programming language are implemented
with the help of functions. Thus, functions are used to implement the actions of the
objects. In C++, we can combine the data and the operations on that data into a single
unit with the help of classes. Thus, objects can be represented as classes. The member
variables of the class describe the properties of the objects, and the function members
describe the actions on that data. This change in simulation results can also occur if we
change the values of the data or modify the definitions of the functions (that is, modify
the algorithms implementing the actions). The main goal of a computer simulation is to
either generate results showing the performance of an existing system or predict the
performance of a proposed system.
In the theater problem, when the cashier is serving a customer, the other customers must
wait. Because customers are served on a first come, first served basis and queues are an

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1234

| Chapter 17: Stacks and Queues

effective way to implement a First In First Out system, queues are important data
structures for use in computer simulations. This section examines computer simulations
in which queues are the basic data structure. These simulations model the behavior of
systems, called queuing systems, in which queues of objects are waiting to be served by
various servers. In other words, a queuing system consists of servers and queues of objects
waiting to be served. We deal with a variety of queuing systems on a daily basis. For
example, a grocery store and a banking system are both queuing systems. Furthermore,
when you send a print request to a networked printer that is shared by many people, your
print request goes in a queue. Print requests that arrived before your print request are
usually completed before yours. Thus, the printer acts as the server when a queue of
documents is waiting to be printed.

Designing a Queuing System
In this section, we describe a queuing system that can be used in a variety of applications,
such as a bank, grocery store, movie theater, printer, or a mainframe environment in
which several people are trying to use the same processors to execute their programs. To
describe a queuing system, we use the term server for the object that provides the
service. For example, in a bank, a teller is a server; in a grocery store or movie theater, a
cashier is a server. We will call the object receiving the service the customer, and the
service time—the time it takes to serve a customer—the transaction time.
Because a queuing system consists of servers and a queue of waiting objects, we will
model a system that consists of a list of servers and a waiting queue holding the customers
to be served. The customer at the front of the queue waits for the next available server.
When a server becomes free, the customer at the front of the queue moves to the free
server to be served.
When the first customer arrives, all servers are free and the customer moves to the first
server. When the next customer arrives, if a server is available, the customer immediately
moves to the available server; otherwise, the customer waits in the queue. To model a
queuing system, we need to know the number of servers, the expected arrival time of a
customer, the time between the arrivals of customers, and the number of events affecting
the system.
Let us again consider the movie theater system. The performance of the system depends
on how many servers are available, how long it takes to serve a customer, and how often a
customer arrives. If it takes too long to serve a customer and customers arrive frequently,
then more servers are needed. This system can be modeled as a time-driven simulation. In
a time-driven simulation, the clock is implemented as a counter, and the passage of,
say, one minute can be implemented by incrementing the counter by 1. The simulation is
run for a fixed amount of time. If the simulation needs to be run for 100 minutes, the
counter starts at 1 and goes up to 100, which can be implemented by using a loop.
For the simulation described in this section, we want to determine the average wait time for
a customer. To calculate the average wait time for a customer, we need to add the waiting

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Queues: Simulation

|

1235

time of each customer and then divide the sum by the number of customers who have
arrived. When a customer arrives, he or she goes to the end of the queue and the
customer’s waiting time begins. If the queue is empty and a server is free, the customer
is served immediately, so this customer’s waiting time is zero. On the other hand, if a
customer arrives and either the queue is nonempty or all of the servers are busy, the customer
must wait for the next available server and, therefore, this customer’s waiting time begins.
We can keep track of the customer’s waiting time by using a timer for each customer. When
a customer arrives, the timer is set to 0, which is incremented after each time unit.
Suppose that, on average, it takes five minutes for a server to serve a customer. When a
server becomes free and the waiting customer’s queue is nonempty, the customer at the
front of the queue proceeds to begin the transaction. Thus, we must keep track of the
time a customer is with a server. When the customer arrives at a server, the transaction
time is set to five and is decremented after each time unit. When the transaction time
becomes zero, the server is marked free. Hence, the two objects needed to implement a
time-driven computer simulation of a queuing system are the customer and the server.
Next, before designing the main algorithm to implement the simulation, we design classes
to implement each of the two objects: customer and server.

Customer
Every customer has a customer number, arrival time, waiting time, transaction time, and
departure time. If we know the arrival time, waiting time, and transaction time, we can
determine the departure time by adding these three times. Let us call the class to
implement the customer object customerType. It follows that the class
customerType has four member variables: the customerNumber, arrivalTime,
waitingTime, and transactionTime, each of the data type int. The basic operations
that must be performed on an object of type customerType are as follows: set the
customer’s number, arrival time, and waiting time; increment the waiting time by one
time unit; return the waiting time; return the arrival time; return the transaction time;
and return the customer number. The following class, customerType, implements the
customer as an ADT:
class customerType
{
public:
customerType(int cN = 0, int arrvTime = 0, int wTime = 0,
int tTime = 0);
//Constructor to initialize the instance variables
//according to the parameters.
//If no value is specified in the object declaration,
//the default values are assigned.
//Postcondition: customerNumber = cN;
//
arrivalTime = arrvTime;
//
waitingTime = wTime;
//
transactionTime = tTime;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1236

| Chapter 17: Stacks and Queues

void setCustomerInfo(int customerN = 0, int inTime = 0,
int wTime = 0, int tTime = 0);
//Function to initialize the instance variables.
//Instance variables are set according to the parameters.
//Postcondition: customerNumber = customerN;
//
arrivalTime = arrvTime;
//
waitingTime = wTime;
//
transactionTime = tTime;
int getWaitingTime() const;
//Function to return the waiting time of a customer.
//Postcondition: The value of waitingTime is returned.
void setWaitingTime(int time);
//Function to set the waiting time of a customer.
//Postcondition: waitingTime = time;
void incrementWaitingTime();
//Function to increment the waiting time by one time unit.
//Postcondition: waitingTime++;
int getArrivalTime() const;
//Function to return the arrival time of a customer.
//Postcondition: The value of arrivalTime is returned.
int getTransactionTime() const;
//Function to return the transaction time of a customer.
//Postcondition: The value of transactionTime is returned.
int getCustomerNumber() const;
//Function to return the customer number.
//Postcondition: The value of customerNumber is returned.
private:
int customerNumber;
int arrivalTime;
int waitingTime;
int transactionTime;
};

Figure 17-36 shows the UML class diagram of the class customerType.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Queues: Simulation

|

1237

customerType
-customerNumber: int
-arrivalTime: int
-waitingTime: int
-transactionTime: int
+setCustomerInfo(int = 0, int = 0, int = 0,
int = 0): void
+getWaitingTime() const: int
+setWaitingTime(int): void
+incrementWaitingTime(): void
+getArrivalTime() const: int
+getTransactionTime() const: int
+getCustomerNumber() const: int
+customerType(int = 0, int = 0, int = 0,
int = 0)

FIGURE 17-36

UML class diagram of the class customerType

The definitions of the member functions of the class customerType follow easily from
their descriptions. Next, we give the definitions of the member functions of the class
customerType.
The function setCustomerInfo uses the values of the parameters to initialize
customerNumber, arrivalTime, waitingTime, and transactionTime. The definition
of setCustomerInfo is:
void customerType::setCustomerInfo(int customerN, int arrvTime,
int wTime, int tTime)
{
customerNumber = customerN;
arrivalTime = arrvTime;
waitingTime = wTime;
transactionTime = tTime;
}

The definition of the constructor is similar to the definition of the function
setCustomerInfo. It uses the values of the parameters to initialize customerNumber,
arrivalTime, waitingTime, and transactionTime. To make debugging easier, we
use the function setCustomerInfo to write the definition of the constructor, which is
given next, as follows:
customerType::customerType(int customerN, int arrvTime,
int wTime, int tTime)
{
setCustomerInfo(customerN, arrvTime, wTime, tTime);
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1238

| Chapter 17: Stacks and Queues

The function getWaitingTime returns the current waiting time. The definition of the
function getWaitingTime is:
int customerType::getWaitingTime() const
{
return waitingTime;
}

The function incrementWaitingTime increments the value of waitingTime. Its
definition is:
void customerType::incrementWaitingTime()
{
waitingTime++;
}

The

definitions of the functions setWaitingTime, getArrivalTime,
getTransactionTime, and getCustomerNumber are left as an exercise for you.

Server
At any given time unit, the server is either busy serving a customer or is free. We use a
string variable to set the status of the server. Every server has a timer and, because the
program might need to know which customer is served by which server, the server also
stores the information of the customer being served. Thus, three member variables are
associated with a server: the status, the transactionTime, and the currentCustomer.
Some of the basic operations that must be performed on a server are as follows: check
whether the server is free; set the server as free; set the server as busy; set the transaction
time (that is, how long it takes to serve the customer); return the remaining transaction
time (to determine whether the server should be set to free); if the server is busy after each
time unit, decrement the transaction time by one time unit; and so on. The following
class, serverType, implements the server as an ADT:
class serverType
{
public:
serverType();
//Default constructor
//Sets the values of the instance variables to their default
//values.
//Postcondition: currentCustomer is initialized by its
//
default constructor; status = "free"; and
//
the transaction time is initialized to 0.
bool isFree() const;
//Function to determine if the server is free.
//Postcondition: Returns true if the server is free,
//
otherwise returns false.
void setBusy();
//Function to set the status of the server to busy.
//Postcondition: status = "busy";
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Queues: Simulation

|

1239

void setFree();
//Function to set the status of the server to "free".
//Postcondition: status = "free";
void setTransactionTime(int t);
//Function to set the transaction time according to the
//parameter t.
//Postcondition: transactionTime = t;
void setTransactionTime();
//Function to set the transaction time according to
//the transaction time of the current customer.
//Postcondition:
//
transactionTime = currentCustomer.transactionTime;
int getRemainingTransactionTime() const;
//Function to return the remaining transaction time.
//Postcondition: The value of transactionTime is returned.
void decreaseTransactionTime();
//Function to decrease the transactionTime by one unit.
//Postcondition: transactionTime--;
void setCurrentCustomer(customerType cCustomer);
//Function to set the info of the current customer
//according to the parameter cCustomer.
//Postcondition: currentCustomer = cCustomer;
int getCurrentCustomerNumber() const;
//Function to return the customer number of the current
//customer.
//Postcondition: The value of customerNumber of the
//
current customer is returned.
int getCurrentCustomerArrivalTime() const;
//Function to return the arrival time of the current
//customer.
//Postcondition: The value of arrivalTime of the current
//
customer is returned.
int getCurrentCustomerWaitingTime() const;
//Function to return the current waiting time of the
//current customer.
//Postcondition: The value of transactionTime is
//
returned.
int getCurrentCustomerTransactionTime() const;
//Function to return the transaction time of the
//current customer.
//Postcondition: The value of transactionTime of the
//
current customer is returned.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1240

| Chapter 17: Stacks and Queues

private:
customerType currentCustomer;
string status;
int transactionTime;
};

Figure 17-37 shows the UML class diagram of the class serverType.

serverType
-currentCustomer: customerType
-status: string
-transactionTime: int
+isFree() const: bool
+setBusy(): void
+setFree(): void
+setTransactionTime(int): void
+setTransactionTime(): void
+getRemainingTransactionTime() const: int
+decreaseTransactionTime(): void
+setCurrentCustomer(customerType): void
+getCurrentCustomerNumber() const: int
+getCurrentCustomerArrivalTime() const: int
+getCurrentCustomerWaitingTime() const: int
+getCurrentCustomerTransactionTime() const: int
+serverType()

FIGURE 17-37

UML class diagram of the class serverType

The definitions of some of the member functions of the class serverType are:
serverType::serverType()
{
status = "free";
transactionTime = 0;
}
bool serverType::isFree() const
{
return (status == "free");
}
void serverType::setBusy()
{
status = "busy";
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Queues: Simulation

|

1241

void serverType::setFree()
{
status = "free";
}
void serverType::setTransactionTime(int t)
{
transactionTime = t;
}
void serverType::setTransactionTime()
{
int time;
time = currentCustomer.getTransactionTime();
transactionTime = time;
}
void serverType::decreaseTransactionTime()
{
transactionTime--;
}

We

leave the definitions of the functions getRemainingTransactionTime,
setCurrentCustomer, getCurrentCustomerNumber, getCurrentCustomerArrivalTime,
getCurrentCustomerWaitingTime, and getCurrentCustomerTransactionTime as an
exercise for you.
Because we are designing a simulation program that can be used in a variety of applications, we need to design two more classes: one to create and process a list of servers and
one to create and process a queue of waiting customers. The next two sections describe
each of these classes.

Server List
A server list is a set of servers. At any given time, a server is either free or busy. For the
customer at the front of the queue, we need to find a server in the list that is free. If all of
the servers are busy, then the customer must wait until one of the servers becomes free.
Thus, the class that implements a list of servers has two member variables: one to store the
number of servers and one to maintain a list of servers. Using dynamic arrays, depending
on the number of servers specified by the user, a list of servers is created during
program execution. Some of the operations that must be performed on a server list are
as follows: return the server number of a free server; when a customer gets ready to do
business and a server is available, set the server to busy; when the simulation ends, some of
the servers might still be busy, so return the number of busy servers; after each time unit,
reduce the transactionTime of each busy server by one time unit; and if the transactionTime of a server becomes zero, set the server to free. The following class,
serverListType, implements the list of servers as an ADT:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1242

| Chapter 17: Stacks and Queues

class serverListType
{
public:
serverListType(int
//Constructor to
//Postcondition:
//
//
//

num = 1);
initialize a list of servers
numOfServers = num
A list of servers, specified by num,
is created and each server is
initialized to "free".

~serverListType();
//Destructor
//Postcondition: The list of servers is destroyed.
int getFreeServerID() const;
//Function to search the list of servers.
//Postcondition: If a free server is found, returns
//
its ID; otherwise, returns -1.
int getNumberOfBusyServers() const;
//Function to return the number of busy servers.
//Postcondition: The number of busy servers is returned.
void setServerBusy(int serverID, customerType cCustomer,
int tTime);
//Function to set a server as busy.
//Postcondition: The server specified by serverID is set
//
to "busy", to serve the customer
//
specified by cCustomer, and the
//
transaction time is set according to the
//
parameter tTime.
void setServerBusy(int serverID, customerType cCustomer);
//Function to set a server as busy.
//Postcondition: The server specified by serverID is set
//
to "busy", to serve the customer
//
specified by cCustomer.
void updateServers(ostream& outFile);
//Function to update the status of a server.
//Postcondition: The transaction time of each busy
//
server is decremented by one unit. If
//
the transaction time of a busy server
//
is reduced to zero, the server is set
//
to "free". Moreover, if the actual
//
parameter corresponding to outFile is
//
cout, a message indicating which customer
//
has been served is printed on the screen,
//
together with the customer's departing
//
time. Otherwise, the output is sent to
//
a file specified by the user.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Queues: Simulation

|

1243

private:
int numOfServers;
serverType *servers;
};

Figure 17-38 shows the UML class diagram of the class serverListType.

serverListType
-numOfServers: int
-*servers: serverType
+getFreeServerID() const: int
+getNumberOfBusyServers() const: int
+setServerBusy(int, customerType, int): void
+setServerBusy(int, customerType): void
+updateServers(ostream&): void
+serverListType(int = 1)
+~serverListType()

FIGURE 17-38

UML class diagram of the class serverListType

Following are the definitions of the member functions of the class serverListType.
The definitions of the constructor and destructor are straightforward.
serverListType::serverListType(int num)
{
numOfServers = num;
servers = new serverType[num];
}
serverListType::~serverListType()
{
delete [] servers;
}

The function getFreeServerID searches the list of servers. If a free server is found, it
returns the server’s ID; otherwise, the value -1 is returned, which indicates that all of the
servers are busy. The definition of this function is:
int serverListType::getFreeServerID() const
{
int serverID = -1;
int i;
for (i = 0; i < numOfServers; i++)
if (servers[i].isFree())

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1244

| Chapter 17: Stacks and Queues

{
serverID = i;
break;
}
return serverID;
}

The function getNumberOfBusyServers searches the list of servers and determines and
returns the number of busy servers. The definition of this function is:
int serverListType::getNumberOfBusyServers() const
{
int busyServers = 0;
int i;
for (i = 0; i < numOfServers; i++)
if (!servers[i].isFree())
busyServers++;
return busyServers;
}

The function setServerBusy sets a server to busy. This function is overloaded. The
serverID of the server that is set to busy is passed as a parameter to this function. One
function sets the server’s transaction time according to the parameter tTime; the other
function sets it by using the transaction time stored in the object cCustomer. The transaction
time is later needed to determine the average wait time. The definitions of these functions are:
void serverListType::setServerBusy(int serverID,
customerType cCustomer,
int tTime)
{
servers[serverID].setBusy();
servers[serverID].setTransactionTime(tTime);
servers[serverID].setCurrentCustomer(cCustomer);
}
void serverListType::setServerBusy(int serverID,
customerType cCustomer)
{
int time;
time = cCustomer.getTransactionTime();
servers[serverID].setBusy();
servers[serverID].setTransactionTime(time);
servers[serverID].setCurrentCustomer(cCustomer);
}

The definition of the function updateServers is quite straightforward. Starting at the
first server, it searches the list of servers for busy servers. When a busy server is found, its
transactionTime is decremented by 1. If the transactionTime reduces to zero, the
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Queues: Simulation

|

1245

server is set to free. If the transactionTime of a busy server reduces to zero, then the
transaction of the customer being served by the server is complete. If the actual parameter
corresponding to outFile is cout, a message indicating which customer has been served
is printed on the screen, together with the customer’s departing time. Otherwise, the
output is sent to a file specified by the user. The definition of this function is as follows:
void serverListType::updateServers(ostream& outFile)
{
int i;
for (i = 0; i < numOfServers; i++)
if (!servers[i].isFree())
{
servers[i].decreaseTransactionTime();
if (servers[i].getRemainingTransactionTime() == 0)
{
outFile << "From server number " << (i + 1)
<< " customer number "
<< servers[i].getCurrentCustomerNumber()
<< "\n
departed at time unit "
<< servers[i].
getCurrentCustomerArrivalTime()
+ servers[i].
getCurrentCustomerWaitingTime()
+ servers[i].
getCurrentCustomerTransactionTime()
<< endl;
servers[i].setFree();
}
}
}

Waiting Customers Queue
When a customer arrives, he or she goes to the end of the queue. When a server becomes
available, the customer at the front of the queue leaves to conduct the transaction. After
each time unit, the waiting time of each customer in the queue is incremented by 1. The
ADT queueType designed in this chapter has all the operations needed to implement a
queue, except the operation of incrementing the waiting time of each customer in the
queue by one time unit. We will derive a class, waitingCustomerQueueType, from
the class queueType and add the additional operations to implement the customer
queue. The definition of the class waitingCustomerQueueType is as follows:
class waitingCustomerQueueType: public queueType<customerType>
{
public:
waitingCustomerQueueType(int size = 100);
//Constructor
//Postcondition: The queue is initialized according to
//
the parameter size. The value of size
//
is passed to the constructor of queueType.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1246

| Chapter 17: Stacks and Queues

void updateWaitingQueue();
//Function to increment the waiting time of each
//customer in the queue by one time unit.
};
Notice that the class waitingCustomerQueueType is derived from the class
queueType, which implements the queue in an array. You can also derive it from the
class linkedQueueType, which implements the queue in a linked list. We leave the
details as an exercise for you.

The definitions of the member functions are given next. The definition of the constructor
is as follows:
waitingCustomerQueueType::waitingCustomerQueueType(int size)
:queueType<customerType>(size)
{
}

The function updateWaitingQueue increments the waiting time of each customer in
the queue by one time unit. The class waitingCustomerQueueType is derived from
the class queueType. Because the member variables of queueType are private, the
function updateWaitingQueue cannot directly access the elements of the queue. The
only way to access the elements of the queue is to use the deleteQueue operation. After
incrementing the waiting time, the element can be put back into the queue by using the
addQueue operation.
The addQueue operation inserts the element at the end of the queue. If we perform the
deleteQueue operation followed by the addQueue operation for each element of the
queue, then eventually the front element again becomes the front element. Given that
each deleteQueue operation is followed by an addQueue operation, how do we
determine that all of the elements of the queue have been processed? We cannot use
the isEmptyQueue or isFullQueue operations on the queue, because the queue will
never be empty or full.
One solution to this problem is to create a temporary queue. Every element of the
original queue is removed, processed, and inserted into the temporary queue. When the
original queue becomes empty, all of the elements in the queue are processed. We can
then copy the elements from the temporary queue back into the original queue.
However, this solution requires us to use extra memory space, which could be significant.
Also, if the queue is large, extra computer time is needed to copy the elements from the
temporary queue back into the original queue. Let us look into another solution.
In the second solution, before starting to update the elements of the queue, we can insert
a dummy customer with a wait time of, say, -1. During the update process, when we
arrive at the customer with the wait time of -1, we can stop the update process without
processing the customer with the wait time of -1. If we do not process the customer with
the wait time of -1, this customer is removed from the queue and, after processing all of

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Queues: Simulation

|

1247

the elements of the queue, the queue will contain no extra elements. This solution does
not require us to create a temporary queue, so we do not need extra computer time to
copy the elements back into the original queue. We will use this solution to update the
queue. Therefore, the definition of the function updateWaitingQueue is:
void waitingCustomerQueueType::updateWaitingQueue()
{
customerType cust;
cust.setWaitingTime(-1);
int wTime = 0;
addQueue(cust);
while (wTime != -1)
{
cust = front();
deleteQueue();
wTime = cust.getWaitingTime();
if (wTime == -1)
break;
cust.incrementWaitingTime();
addQueue(cust);
}
}

Main Program
To run the simulation, we first need to get the following information:
•

The number of time units the simulation should run. Assume that each
time unit is one minute.
• The number of servers.
• The amount of time it takes to serve a customer—that is, the transaction time.
• The approximate time between customer arrivals.
These pieces of information are called simulation parameters. By changing the values of
these parameters, we can observe the changes in the performance of the system. We can
write a function, setSimulationParameters, to prompt the user to specify these
values. The definition of this function is:
void setSimulationParameters(int&
int&
int&
{
cout << "Enter the simulation
cin >> sTime;
cout << endl;

sTime, int& numOfServers,
transTime,
tBetweenCArrival)
time: ";

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1248

| Chapter 17: Stacks and Queues

cout << "Enter the number of servers: ";
cin >> numOfServers;
cout << endl;
cout << "Enter the transaction time: ";
cin >> transTime;
cout << endl;
cout << "Enter the time between customer arrivals: ";
cin >> tBetweenCArrival;
cout << endl;
}

When a server becomes free and the customer queue is nonempty, we can move the
customer at the front of the queue to the free server to be served. Moreover, when a
customer starts the transaction, the waiting time ends. The waiting time of the customer
is added to the total waiting time. The general algorithm to start the transaction
(supposing that serverID denotes the ID of the free server) is:
1. Remove the customer from the front of the queue.
customer = customerQueue.front();
customerQueue.deleteQueue();

2. Update the total wait time by adding the current customer’s wait time to
the previous total wait time.
totalWait = totalWait + customer.getWaitingTime();

3. Set the free server to begin the transaction.
serverList.setServerBusy(serverID, customer, transTime);

To run the simulation, we need to know the number of customers arriving at a given
time unit and how long it takes to serve the customer. We use the Poisson distribution
from statistics, which says that the probability of y events occurring at a given time is
given by the formula:
PðyÞ ¼

y e
; y ¼ 0; 1; 2; . . . ;
y!

in which l is the expected value that y events occur at that time. Suppose that, on
average, a customer arrives every four minutes. During this four-minute period, the
customer can arrive at any one of the four minutes. Assuming an equal likelihood of each
of the four minutes, the expected value that a customer arrives in each of the four minutes
is, therefore, 1 / 4 = .25. Next, we need to determine whether or not the customer
actually arrives at a given minute.
Now, P(0) = e-l is the probability that no event occurs at a given time. One of the basic
assumptions of the Poisson distribution is that the probability of more than one outcome
occurring in a short time interval is negligible. For simplicity, we assume that only one

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Application of Queues: Simulation

|

1249

customer arrives at a given time unit. Thus, we use e-l as the cutoff point to determine
whether a customer arrives at a given time unit. Suppose that, on average, a customer arrives
every four minutes. Then, l = 0.25. We can use an algorithm to generate a number between
0 and 1. If the value of the number generated is > e-0.25, we can assume that the customer
arrived at a particular time unit. For example, suppose that rNum is a random number such
that 0  rNum  1. If rNum > e-0.25, the customer arrived at the given time unit.
We now describe the function runSimulation to implement the simulation. Suppose
that we run the simulation for 100 time units and customers arrive at time units 93, 96, and
100. The average transaction time is five minutes—that is, five time units. For simplicity,
assume that we have only one server and that the server becomes free at time unit 97, and
that all customers arriving before time unit 93 have been served. When the server becomes
free at time unit 97, the customer arriving at time unit 93 starts the transaction. Because the
transaction of the customer arriving at time unit 93 starts at time unit 97 and it takes five
minutes to complete a transaction, when the simulation loop ends, the customer arriving at
time unit 93 is still at the server. Moreover, customers arriving at time units 96 and 100 are
in the queue. For simplicity, we assume that when the simulation loop ends, the customers
at the servers are considered served. The general algorithm for this function is:
1. Declare and initialize the variables, such as the simulation parameters,
customer number, clock, total and average waiting times, number of
customers arrived, number of customers served, number of customers
left in the waiting queue, number of customers left with the servers,
waitingCustomersQueue, and a list of servers.
2. The main loop is:
for (clock = 1; clock <= simulationTime; clock++)
{

2.1.

Update the server list to decrement the transaction time of each busy server
by one time unit.

2.2.

If the customer’s queue is nonempty, increment the waiting time of each
customer by one time unit.

2.3.

If a customer arrives, increment the number of customers by 1 and add the
new customer to the queue.

2.4.

If a server is free and the customer’s queue is nonempty, remove a
customer from the front of the queue and send the customer to
the free server.

}

3. Print the appropriate results. Your results must include the number of
customers left in the queue, the number of customers still with servers,
the number of customers arrived, and the number of customers who
actually completed a transaction.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1250

| Chapter 17: Stacks and Queues

Once you have designed the function runSimulation, the definition of the function
main is simple and straightforward because the function main calls only the function
runSimulation. Programming Exercise 18 asks you to write the definition of the
function runSimulation.
When we tested our version of the simulation program, we generated the following
results. (The program was executed two times.) We assumed that the average transaction
time is five minutes and that, on average, a customer arrives every four minutes, and we
used a random number generator to generate a number between 0 and 1 to decide
whether a customer arrived at a given time unit.
Sample Run:
Customer number 1 arrived at time unit 4
Customer number 2 arrived at time unit 8
From server number 1 customer number 1
departed at time unit 9
Customer number 3 arrived at time unit 9
Customer number 4 arrived at time unit 12
From server number 1 customer number 2
departed at time unit 14
From server number 1 customer number 3
departed at time unit 19
Customer number 5 arrived at time unit 21
From server number 1 customer number 4
departed at time unit 24
From server number 1 customer number 5
departed at time unit 29
Customer number 6 arrived at time unit 37
Customer number 7 arrived at time unit 38
Customer number 8 arrived at time unit 41
From server number 1 customer number 6
departed at time unit 42
Customer number 9 arrived at time unit 43
Customer number 10 arrived at time unit 44
From server number 1 customer number 7
departed at time unit 47
Customer number 11 arrived at time unit 49
Customer number 12 arrived at time unit 51
From server number 1 customer number 8
departed at time unit 52
Customer number 13 arrived at time unit 52
Customer number 14 arrived at time unit 53
Customer number 15 arrived at time unit 54
From server number 1 customer number 9
departed at time unit 57
Customer number 16 arrived at time unit 59
From server number 1 customer number 10
departed at time unit 62
Customer number 17 arrived at time unit 66
From server number 1 customer number 11
departed at time unit 67
Customer number 18 arrived at time unit 71
From server number 1 customer number 12
departed at time unit 72
From server number 1 customer number 13
departed at time unit 77

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

Customer number 19 arrived at
From server number 1 customer
departed at time unit 82
From server number 1 customer
departed at time unit 87
Customer number 20 arrived at
From server number 1 customer
departed at time unit 92
Customer number 21 arrived at
From server number 1 customer
departed at time unit 97

1251

time unit 78
number 14
number 15
time unit 90
number 16
time unit 92
number 17

The simulation ran for 100 time units
Number of servers: 1
Average transaction time: 5
Average arrival time difference between customers: 4
Total waiting time: 269
Number of customers that completed a transaction: 17
Number of customers left in the servers: 1
The number of customers left in queue: 3
Average waiting time: 12.81
************** END SIMULATION *************

QUICK REVIEW
1.
2.
3.

4.
5.
6.
7.
8.
9.

A stack is a data structure in which the items are added and deleted from
one end only.
A stack is a Last In First Out (LIFO) data structure.
The basic operations on a stack are as follows: push an item onto the stack, pop
an item from the stack, retrieve the top element of the stack, initialize the
stack, check whether the stack is empty, and check whether the stack is full.
A stack can be implemented as an array or a linked list.
The middle elements of a stack should not be accessed directly.
Stacks are restricted versions of arrays and linked lists.
Postfix notation does not require the use of parentheses to enforce operator
precedence.
In postfix notation, the operators are written after the operands.
Postfix expressions are evaluated according to the following rules:
Scan the expression from left to right.
b. If an operator is found, back up to get the required number of
operands, evaluate the operator, and continue.
A queue is a data structure in which the items are added at one end and
removed from the other end.
A queue is a First In First Out (FIFO) data structure.
The basic operations on a queue are as follows: add an item to the queue,
remove an item from the queue, retrieve the first or last element of the
a.

10.
11.
12.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1252

13.
14.
15.

| Chapter 17: Stacks and Queues

queue, initialize the queue, check whether the queue is empty, and check
whether the queue is full.
A queue can be implemented as an array or a linked list.
The middle elements of a queue should not be accessed directly.
Queues are restricted versions of arrays and linked lists.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
A stack is a list of homogenous elements in which the addition and
deletion of elements occurs only at one end. (1)
b. A stack is a First In Last Out data structure. (1)
c. In the array implementation of a stack, stackTop contains the index of
the top element in the stack. (2)
d.
In the array implementation of a stack, to remove the top element of
the stack, the operation pop decrements the value of stackTop by 1 if
the stack is nonempty. (3)
e. In the array implementation of a stack, the operation top returns the
index of the top element of the stack. (3)
f.
In the linked implementation of a stack, stackTop contains the address
of the top element in the stack. (4)
g.
In the linked implementation of a stack, the operation isFullStack
returns true if the stack is full. (4)
h.
In a postfix expression, operands are written after the operations. (5)
i.
A queue is a First In First Out data structure. (7)
j.
In a queue, the new element is added at the end of the queue. (8)
k. In the array implementation of a queue, the operation deleteQueue
decrements count by 1 and advances queueFront to the next element. (9)
l.
In the linked implementation of a queue, the queue is empty if
queueFront == queueRear. (10)
m. In a computer simulation, the objects being studied are usually represented as operations. (11)
n. Simulation problems are solved using a stack. (11)
Suppose that stack is an object of type stackType<int>. What is the
difference between stack.top and stack.top - 1? (3)
Suppose that stack is an object of type stackType<double> and the value
of stack.top is 5. What is the index of the top element of the stack? (3)
a.

2.

3.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

4.

5.

|

1253

Suppose that stack is an object of type stackType<string> and the
value of stack.top - 1 is 2. How many elements are in the stack? (3)
Consider the following statements: (3)
stackType<int> stack;
int num1, num2;

Show what is output by the following segment of code:
stack.push(12);
stack.push(5);
num1 = stack.top() + 3;
stack.push(num1 + 5);
num2 = stack.top();
stack.push(num1 + num2);
num2 = stack.top();
stack.pop();
stack.push(15);
num1 = stack.top();
stack.pop();
while (!stack.isEmptyStack())
{
cout << stack.top() << " ";
stack.pop();
}
cout << endl;
cout << "num1 = " << num1 << endl;
cout << "num2 = " << num2 << endl;
6.

Consider the following statements: (3)
stackType<int> stack(50);
int num;

Suppose that the input is:
31 47 86 39 62 71 15 63

Show what is output by the following segment of code:
cin >> num;
while (cin)
{
if (!stack.isFullStack())
{
if (num % 2 == 0 || num % 3 == 0)
stack.push(num);
else if (!stack.isEmptyStack())
{
cout << stack.top() << " ";
stack.pop();
}
else
stack.push(num + 3);
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1254

| Chapter 17: Stacks and Queues

cin >> num;
}
cout << endl;
cout << "Stack Elements: ";
while (!stack.isEmptyStack())
{
cout << " " << stack.top();
stack.pop();
}
cout << endl;
7.

Consider the following statements:
linkedStackType<int> stack;
long long num;
int temp;
int secretNum = 0;

Show what is output by the following segment of code, if the input is
837298651020706: (4)
cin >> num;
num = abs(num);
while (num > 0)
{
stack.push(num % 100);
num = num / 100;
}
while (!stack.isEmptyStack())
{
temp = stack.top();
stack.pop();
secretNum = secretNum + temp;
}
cout << "secretNum = " << secretNum
8.
9.

10.

<< endl;

What does the program segment in Exercise 7 do? (4)
Evaluate the following postfix expressions: (5)
a.

17 5 3 - * 6 + =

b.

14 2 * 8 + 6 / 5 + =

c.

15 16 3 10 2 + + - + 8 / =

d.

1 8 12 - - 9 + 25 5 / * =

Convert the following infix expressions to postfix notations: (5)
a.

x * (y + z) - ( w + t)

b.

(x + y) / (z - w) * t

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

11.

12.

c.

((x - y) + (z - w) / t) * u

d.

x - y / (z + w) * t / u + (v - s)

|

1255

Write the equivalent infix expressions for the following postfix
expressions: (5)
a.

xy+z*w-

b.

xy*z/w+

c.

xyz+*w-

What is the output of the following program? (3)
#include <iostream>
#include <string>
#include "myStack.h"
using namespace std;template <class type>
void mystery(stackType<type>& s1, stackType<type>& s2,
stackType<type>& s3);
int main()
{
stackType<string> stack1;
stackType<string> stack2;
stackType<string> newStack;
string fNames[] = {"Chelsea", "Kirk", "David", "Stephanie",
"Bianca", "Katie", "Holly"};
string lNames[] = {"Jackson", "McCarthy", "Miller", "Pratt",
"Hollman", "Smith", "Klien"};
for (int i = 0; i < 7; i++)
{
stack1.push(fNames[i]);
stack2.push(lNames[i]);
}
mystery(stack1, stack2, newStack);
while (!newStack.isEmptyStack())
{
cout << newStack.top() << endl;
newStack.pop();
}
}
template <class type>
void mystery(stackType<type>& s1, stackType<type>& s2,
stackType<type>& s3)
{
while (!s1.isEmptyStack() && !s2.isEmptyStack())

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1256

| Chapter 17: Stacks and Queues

{
s3.push(s1.top() + " " + s2.top());
s1.pop();
s2.pop();
}
}
13.

What is the output of the following program? (3)
#include <iostream>
#include <cmath>
#include "myStack.h"
using namespace std;
void mystery(stackType<int>& s, stackType<double>& t);
int main()
{
int list[] = {1, 2, 3, 4, 5};
stackType<int> s1;
stackType<double> s2;
for (int i = 0; i < 5; i++)
s1.push(list[i]);
mystery(s1, s2);
while (!s2.isEmptyStack())
{
cout << s2.top() << " ";
s2.pop();
}
cout << endl;
}
void mystery(stackType<int>& s, stackType<double>& t)
{
double x = 1.0;
while (!s.isEmptyStack())
{
t.push(pow(s.top(), x));
s.pop();
x = x + 1;
}
}

14.

15.

Explain why, in the linked implementation of a stack, it is not necessary to
implement the operation to determine whether the stack is full. (4)
Suppose that stack is an object of type linkedStackType<int>. What is
the difference between the statements stack.top(); and stack.pop();? (4)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

16.

17.

18.

|

1257

Write the definition of the function template printListReverse that uses
a stack to print a linked list in reverse order. Assume that this function is a
member of the class linkedListType, designed in Chapter 16. (6)
Write the definition of the method second that takes as a parameter a stack
object and returns the second element of the stack. The original stack
remains unchanged. (3, 4)
Consider the following statements: (8, 9)
queueType<int> queue;
int num;

Show what is output by the following segment of code:
num = 7;
queue.addQueue(6);
queue.addQueue(num);
num = queue.front();
queue.deleteQueue();
queue.addQueue(num + 5);
queue.addQueue(14);
queue.addQueue(num - 2);
queue.addQueue(25);
queue.deleteQueue();
cout << "Queue elements: ";
while (!queue.isEmptyQueue())
{
cout << queue.front() << " ";
queue.deleteQueue();
}
cout << endl;
19.

Consider the following statements: (4, 10)
linkedStackType<int> stack;
linkedQueueType<int> queue;
int num;

Suppose the input is:
48 35 72 88 92 11 10 15 44 52 67 36

Show what is written by the following segment of code:
stack.push(0);
queue.addQueue(0);
cin >> num;
while (cin)
{
switch (num % 3)
{
case 0:
stack.push(num);
break;
case 1:
queue.addQueue(num);
break;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1258

| Chapter 17: Stacks and Queues

case 2:
if (!stack.isEmptyStack())
{
cout << stack.top() << " ";
stack.pop();
}
else if (!queue.isEmptyQueue())
{
cout << queue.front() << " ";
queue.deleteQueue();
}
else
cout << "Stack and queue are empty." << endl;
break;
} //end switch
cin >> num;
} //end while
cout << endl;
cout << "stack: ";
while (!stack.isEmptyStack())
{
cout << stack.top() << " ";
stack.pop();
}
cout << endl;
cout << "queue: ";
while (!queue.isEmptyQueue())
{
cout << queue.front() << " ";
queue.deleteQueue();
}
cout << endl;
20.

What does the following function do? (3, 9)
void mystery(queueType<int>& q)
{
stackType<int> s;
while (!q.isEmptyQueue())
{
s.push(q.front());
q.deleteQueue();
}
while (!s.isEmptyStack())
{
q.addQueue(2 * s.top());
s.pop();
}
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

21.

|

1259

Suppose that queue is a queueType object and the size of the array
implementing queue is 100. Also, suppose that the value of queueFront
is 50 and the value of queueRear is 99. (9)
What are the values of queueFront and queueRear after adding an
element to queue?
b. What are the values of queueFront and queueRear after removing an
element from queue?
Suppose that queue is a queueType object and the size of the array
implementing queue is 100. Also, suppose that the value of queueFront
is 99 and the value of queueRear is 25. (9)
a.

22.

What are the values of queueFront and queueRear after adding an
element to queue?
b. What are the values of queueFront and queueRear after removing an
element from queue?
Suppose that queue is a queueType object and the size of the array
implementing queue is 100. Also, suppose that the value of queueFront
is 25 and the value of queueRear is 75. (9)
a.

23.

What are the values of queueFront and queueRear after adding an
element to queue?
b. What are the values of queueFront and queueRear after removing an
element from queue?
Suppose that queue is a queueType object and the size of the array
implementing queue is 100. Also, suppose that the value of queueFront
is 99 and the value of queueRear is 25. (9)
a.

24.

What are the values of queueFront and queueRear after adding an
element to queue?
b. What are the values of queueFront and queueRear after removing an
element from queue?
Suppose that queue is implemented as an array with the special reserved
slot, as described in this chapter. Also, suppose that the size of the array
implementing queue is 100. If the value of queueFront is 50, what is the
position of the first queue element? (9)
Suppose that queue is implemented as an array with the special reserved
slot, as described in this chapter. Suppose that the size of the array implementing queue is 100. Also, suppose that the value of queueFront is 74
and the value of queueRear is 99. (9)
a.

25.

26.

a.

b.

What are the values of queueFront and queueRear after adding an
element to queue?
What are the values of queueFront and queueRear after removing
an element from queue? Also, what was the position of the removed
queue element?

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1260

27.

| Chapter 17: Stacks and Queues

Consider the following statements:
linkedQueueType <int> queue;
linkedStackType <int> stack;
long long num;
int digit1, digit2;

Show what is output by the following segment of code, if the input is
837298651020706: (4, 10)
cin >> num;
num = abs(num);
while (num > 0)
{
stack.push(num % 10);
num = num / 10;
}
while (!stack.isEmptyStack())
{
queue.addQueue(stack.top());
stack.pop();
}
if (!queue.isEmptyQueue())
{
digit1 = queue.front();
queue.deleteQueue();
}
while (!queue.isEmptyQueue())
{
digit2 = queue.front();
queue.deleteQueue();
cout << digit1 - digit2 << " ";
digit1 = digit2;
}
cout << endl;
28.
29.

30.

31.

32.

What does the program segment in Exercise 27 do? (4, 10)
Write a function template, reverseStack, that takes as a parameter a
stack object and uses a queue object to reverse the elements of the stack.
(3, 4, 9, 10)
Write a function template, reverseQueue, that takes as a parameter a
queue object and uses a stack object to reverse the elements of the queue.
(3, 4, 9, 10)
Add the operation queueCount to the class queueType (the array implementation of queues), which returns the number of elements in the queue.
Write the definition of the function template to implement this operation. (9)
Draw the UML class diagram of the class linkedStackType. (4)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

33.
34.
35.

|

1261

Draw the UML class diagram of the class queueADT. (8)
Draw the UML class diagram of the class queueType. (9)
Draw the UML class diagram of the class linkedQueueType. (10)

PROGRAMMING EXERCISES
1.

2.
3.

Two stacks of the same type are the same if they have the same number of
elements and their elements at the corresponding positions are the same.
Overload the relational operator == for the class stackType that returns
true if two stacks of the same type are the same; it returns false otherwise.
Also, write the definition of the function template to overload this operator.
Repeat Programming Exercise 1 for the class linkedStackType.
a. Add the following operation to the class stackType.
void

reverseStack(stackType<Type> &otherStack);

This operation copies the elements of a stack in reverse order onto
another stack.
Consider the following statements:
stackType<int> stack1;
stackType<int> stack2;

The statement:
stack1.reverseStack(stack2);

4.
5.

6.

7.

copies the elements of stack1 onto stack2 in reverse order. That is, the
top element of stack1 is the bottom element of stack2, and so on. The
old contents of stack2 are destroyed, and stack1 is unchanged.
b. Write the definition of the function template to implement the operation reverseStack.
Repeat Programming Exercises 3a and 3b for the class linkedStackType.
Write a program that takes as input an arithmetic expression. The program
outputs whether the expression contains matching grouping symbols. For
example, the arithmetic expressions {25 + (3 – 6) * 8} and 7 + 8 * 2 contain
matching grouping symbols. However, the expression 5 + {(13 + 7) / 8 - 2 * 9
does not contain matching grouping symbols.
Write a program that uses a stack to print the prime factors of a positive
integer in descending order.
The Programming Example, Converting a Number from Binary to Decimal,
in Chapter 15, uses recursion to convert a binary number into an equivalent
decimal number. Write a program that uses a stack to convert a binary
number into an equivalent decimal number.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1262

8.

9.

10.

| Chapter 17: Stacks and Queues

The Programming Example, Converting a Number from Decimal to Binary,
in Chapter 15, contains a program that uses recursion to convert a decimal
number into an equivalent binary number. Write a program that uses a stack
to convert a decimal number into an equivalent binary number.
Write a program that reads a string consisting of a positive integer or a
positive decimal number and converts the number to the numeric format. If
the string consists of a decimal number, the program must use a stack to
convert the decimal number to the numeric format.
(Infix to Postfix) Write a program that converts an infix expression into an
equivalent postfix expression.
The rules to convert an infix expression into an equivalent postfix expression
are as follows:
Suppose infx represents the infix expression and pfx represents the postfix
expression. The rules to convert infx into pfx are as follows:
a.
b.

Initialize pfx to an empty expression and also initialize the stack.
Get the next symbol, sym, from infx.
If sym is an operand, append sym to pfx.
b.2. If sym is (, push sym into the stack.
b.3. If sym is ), pop and append all of the symbols from the stack
until the most recent left parentheses. Pop and discard the left
parentheses.
b.4. If sym is an operator:
b.4.1. Pop and append all of the operators from the stack to pfx
that are above the most recent left parentheses and have
precedence greater than or equal to sym.
b.4.2. Push sym onto the stack.
After processing infx, some operators might be left in the stack. Pop
and append to pfx everything from the stack.
b.1.

c.

In this program, you will consider the following (binary) arithmetic operators:
+, -, *, and /. You may assume that the expressions you will process are error free.

Design a class that stores the infix and postfix strings. The class must include
the following operations:
•
•
•

getInfix: Stores the infix expression.
showInfix: Outputs the infix expression.
showPostfix: Outputs the postfix expression.

Some other operations that you might need are:
•

convertToPostfix: Converts the infix expression into a postfix
expression. The resulting postfix expression is stored in pfx.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

•

|

1263

precedence: Determines the precedence between two operators. If the
first operator is of higher or equal precedence than the second operator, it
returns the value true; otherwise, it returns the value false.

Include the constructors and destructors for automatic initialization and
dynamic memory deallocation.
Test your program on the following expressions:
a.

A + B - C;

b.

(A + B ) * C;

c.

(A + B) * (C - D);

d.

A + ((B + C) * (E - F) - G) / (H - I);

e.

A + B * (C + D ) - E / F * G + H;

For each expression, your answer must be in the following form:
Infix Expression: A + B - C;
Postfix Expression: A B + C 11.

12.

13.

14.

Write the definitions of the functions to overload the assignment operator
and copy constructor for the class queueType. Also, write a program to
test these operations.
Write the definitions of the functions to overload the assignment operator
and copy constructor for the class linkedQueueType. Also, write a
program to test these operations.
This chapter describes the array implementation of queues that use a special array
slot, called the reserved slot, to distinguish between an empty and a full queue.
Write the definition of the class and the definitions of the function members of
this queue design. Also, write a test program to test various operations on a queue.
Write the definition of the function moveNthFront that takes as a parameter a positive integer, n. The function moves the nth element of the
queue to the front. The order of the remaining elements remains unchanged.
For example, suppose:
queue = {5, 11, 34, 67, 43, 55} and n = 3.

After a call to the function moveNthFront:
queue = {34, 5, 11, 67, 43, 55}.

15.

Add this function to the class queueType. Also, write a program to test
your method.
Write a program that reads a line of text, changes each uppercase letter to
lowercase, and places each letter both in a queue and onto a stack. The
program should then verify whether the line of text is a palindrome (a set of
letters or numbers that is the same whether read forward or backward).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
7

1264

16.

17.

18.

| Chapter 17: Stacks and Queues

The implementation of a queue in an array, as given in this chapter, uses the
variable count to determine whether the queue is empty or full. You can also use
the variable count to return the number of elements in the queue. On the other
hand, class linkedQueueType does not use such a variable to keep track of
the number of elements in the queue. Redefine the class linkedQueueType
by adding the variable count to keep track of the number of elements in the queue.
Modify the definitions of the functions addQueue and deleteQueue as necessary. Add the function queueCount to return the number of elements in the
queue. Also, write a program to test various operations of the class you defined.
Write the definition of the class linkedQueueType, which is derived
from the class unorderedLinkedList, as explained in this chapter. Also,
write a program to test various operations of this class.
a. Write the definitions of the functions setWaitingTime, getArrivalTime,
getTransactionTime, and getCustomerNumber of the class
customerType defined in the section Application of Queues: Simulation.
b. Write the definitions of the functions getRemainingTransactionTime,
setCurrentCustomer,
getCurrentCustomerNumber,
getCurrentCustomerArrivalTime, getCurrentCustomerWaitingTime,
and getCurrentCustomerTransactionTime of the class serverType
defined in the section Application of Queues: Simulation.
c. Write the definition of the function runSimulation to complete the
design of the computer simulation program (see the section Application
of Queues: Simulation). Test run your program for a variety of data.
Moreover, use a random number generator to decide whether a customer arrived at a given time unit.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

18
CHAPTER

ª HunThomas/Shutterstock

S EARCHING AND S ORTING
A LGORITHMS
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about the various search algorithms

2.

Explore how to implement the sequential search algorithm and how it performs

3.

Explore how to implement the binary search algorithm and how it performs

4.

Learn about the asymptotic notation, Big-O, used in algorithm analysis

5.

Become familiar with the lower bound on comparison-based search algorithms

6.

Learn about the various sorting algorithms

7.

Explore how to implement the bubble sort algorithm and how it performs

8.

Become familiar with the performance of the selection sort algorithm

9.

Explore how to implement the insertion sort algorithm and how it performs

10.

Become familiar with the lower bound on comparison-based sorting algorithms

11.

Explore how to implement the quick sort algorithm and how it performs

12.

Explore how to implement the merge sort algorithm and how it performs

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1266

| Chapter 18: Searching and Sorting Algorithms

Chapters 12 and 13 described how to organize data into computer memory using
an array and how to perform basic operations on that data. Chapter 16 described
how to organize data using linked lists. The most important operation that can be
performed on a list is the search algorithm. Using the search algorithm, you can do
the following:
•
•

Determine whether a particular item is in the list.
If the data is specially organized (e.g., sorted), find the location in the list
where a new item can be inserted.
• Find the location of an item to be deleted.
The search algorithm’s performance, therefore, is crucial. If the search is slow, it takes a
large amount of computer time to accomplish your task; if the search is fast, you can
accomplish your task quickly.
In the first part of this chapter, we describe the search algorithms: sequential search and
binary search. Certain search algorithms work only on sorted data. Therefore, the second
half of this chapter discusses various sorting algorithms.

Searching and Sorting Algorithms
The searching and sorting algorithms that we describe are generic. Because searching
and sorting require comparisons of data, the algorithms should work on the type of data
that provides appropriate functions to compare data items. Now data can be organized
with the help of an array or a linked list. You can create an array of data items, or you can
use the class unorderedLinkedList to organize data. The algorithms that we
describe should work on either organization. Consequently, we will write the function
templates to implement a particular algorithm. All algorithms described in this chapter,
with the exception of the merge sort algorithms, are for array-based lists. Because of
storage issues and some other overheads, merge sort works better for linked lists. Therefore, after describing the merge sort algorithm, we will add it as a function to the
class unorderedLinkedList. We will also show how to use the searching and
sorting algorithms on objects of the class unorderedArrayListType. Moreover,
we will place all of the array-based searching and sorting functions in the header file
searchSortAlgorithms.h. Therefore, if you need to use a particular searching and/
or sorting function designed in this chapter, your program can include this header file
and use that function.

Search Algorithms
Chapters 12, 13, and 16 described how to implement the sequential search algorithm.
This chapter discusses other search algorithms and analyzes them. Analysis of the algorithms enables programmers to decide which algorithm to use for a specific application.
Before exploring these algorithms, let us make the following observations.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Search Algorithms

|

1267

Associated with each item in a data set is a special member that uniquely identifies the
item in the data set. For example, if you have a data set consisting of student records, then
the student ID uniquely identifies each student in a particular school. This unique
member of the item is called the key of the item. The keys of the items in the data set
are used in such operations as searching, sorting, inserting, and deleting. For instance,
when we search the data set for a particular item, we compare the key of the item for
which we are searching with the keys of the items in the data set.
When analyzing searching and sorting algorithms, the key comparisons refer to comparing the key of the search item with the key of an item in the list. The number of key
comparisons refers to the number of times the key of the search item (in algorithms such
as searching and sorting) is compared with the keys of the items in the list.

Sequential Search
The sequential search (also called a linear search) on array-based lists was described in
Chapters 12 and 13, and the sequential search on linked lists was covered in Chapter 16.
The sequential search works the same for both array-based and linked lists. The search
always starts at the first element in the list and continues until either the item is found in
the list or the entire list is searched.
Because we are interested in the performance of the sequential search (that is, the analysis
of this type of search), for easy reference and the sake of completeness, we provide the
sequential search algorithm for array-based lists (as described in Chapters 12 and 13). If
the search item is found, its index (that is, its location in the array) is returned. If the
search is unsuccessful, -1 is returned. Note that the following sequential search does not
require the list elements to be in any particular order.
template <class elemType>
int seqSearch(const elemType list[], int length,
const elemType& item)
{
int loc;
bool found = false;
loc = 0;
while (loc < length && !found)
if (list[loc] == item)
found = true;
else
loc++;
if (found)
return loc;
else
return -1;
} //end seqSearch

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1268

| Chapter 18: Searching and Sorting Algorithms

The sequential search algorithm, as given here, uses an iterative control structure
(the while loop) to compare the search item with the list elements. You can also write
a recursive algorithm to implement the sequential search algorithm. (See Programming
Exercise 1 at the end of this chapter.)

SEQUENTIAL SEARCH ANALYSIS
This section analyzes the performance of the sequential search algorithm in both the
worst case and the average case.

The statements before and after the loop are executed only once and hence require very
little computer time. The statements in the while loop are the ones that are repeated
several times. For each iteration of the loop, the search item is compared with an element
in the list, and a few other statements are executed, including some other comparisons.
Clearly, the loop terminates as soon as the search item is found in the list. Therefore,
execution of the other statements in the loop is directly related to the outcome of the key
comparison. Also, different programmers might implement the same algorithm differently, although the number of key comparisons would typically be the same. The speed
of a computer can also easily affect the time an algorithm takes to perform, but it, of
course, does not affect the number of key comparisons required.
Therefore, when analyzing a search algorithm, we count the number of key comparisons
because this number gives us the most useful information. Furthermore, the criteria for
counting the number of key comparisons can be applied equally well to other search
algorithms.
Suppose that L is a list of length n. We want to determine the number of key comparisons
made by the sequential search when the list L is searched for a given item.
If the search item is not in the list, we then compare the search item with every element
in the list, making n comparisons. This is an unsuccessful case.
Suppose that the search item is in the list. Then, the number of key comparisons depends
on where in the list the search item is located. If the search item is the first element of L,
we make only one key comparison. This is the best case. On the other hand, if the search
item is the last element in the list, the algorithm makes n comparisons. This is the worst
case. The best and worst cases are not likely to occur every time we apply the sequential
search on L, so it would be more helpful if we could determine the average behavior of
the algorithm. That is, we need to determine the average number of key comparisons the
sequential search algorithm makes in the successful case.
To determine the average number of comparisons in the successful case of the sequential
search algorithm:
1. Consider all possible cases.
2. Find the number of comparisons for each case.
3. Add the number of comparisons and divide by the number of cases.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Search Algorithms

|

1269

If the search item, called the target, is the first element in the list, one comparison is
required. If the target is the second element in the list, two comparisons are required.
Similarly, if the target is the kth element in the list, k comparisons are required. We
assume that the target can be any element in the list; that is, all list elements are equally
likely to be the target. Suppose that there are n elements in the list. The following
expression gives the average number of comparisons:
1 þ 2 þ  þ n
:
n

1
8

It is known that:
1 þ 2 þ  þ n ¼

nðn þ 1Þ
:
2

Therefore, the following expression gives the average number of comparisons made by
the sequential search in the successful case:
1 þ 2 þ    þ n 1 nðn þ 1Þ n þ 1
:
¼
¼
n
n
2
2
This expression shows that, on average, a successful sequential search searches half of
the list. It thus follows that if the list size is 1,000,000, on average, the sequential search
makes 500,000 comparisons. As a result, the sequential search is not efficient for large
lists.

Binary Search
As you can see, the sequential search is not efficient for large lists because, on average, it
searches half the list. We, therefore, describe another search algorithm called the binary
search, which is very fast. However, a binary search can be performed only on sorted
lists. We, therefore, assume that the list is sorted. Later in this chapter, we will describe
several sorting algorithms.
The binary search algorithm uses the ‘‘divide and conquer’’ technique to search the list.
First, the search item is compared with the middle element of the list. If the search item is
less than the middle element of the list, we restrict the search to the first half of the list;
otherwise, we search the second half of the list.
Consider the sorted list of length = 12 in Figure 18-1.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1270

| Chapter 18: Searching and Sorting Algorithms

[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10][11]
list

FIGURE 18-1

4

8

19

25

34

39

45

48

66

75

89

95

List of length 12

Suppose that we want to determine whether 75 is in the list. Initially, the entire list is the
search list (see Figure 18-2).

search list
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10][11]
list

4

8

19

25

34

39

45

48

66

75

89

95

mid

FIGURE 18-2

Search list, list[0]...list[11]

First, we compare 75 with the middle element in this list, list[5] (which is 39).
Because 75 6¼ list[5] and 75 > list[5], we then restrict our search to the list
list[6]...list[11], as shown in Figure 18-3.

search list
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10][11]
list

FIGURE 18-3

4

8

19

25

34

39

45

48

66

75

89

95

Search list, list[6]...list[11]

This process is now repeated on the list list[6]...list[11], which is a list of
length = 6.
Because we need to determine the middle element of the list frequently, the binary search
algorithm is typically implemented for array-based lists. To determine the middle element
of the list, we add the starting index, first, and the ending index, last, of the search list
and then divide by 2 to calculate its index. That is:
mid ¼

first þ last
.
2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Search Algorithms

|

1271

Initially, first = 0 and last = length – 1 (this is because an array index in C++ starts
at 0, and length denotes the number of elements in the list).
The following C++ function implements the binary search algorithm. If the item is
found in the list, its location is returned; if the search item is not in the list, -1 is returned.
template <class elemType>
int binarySearch(const elemType list[], int length,
const elemType& item)
{
int first = 0;
int last = length - 1;
int mid;
bool found = false;
while (first <= last && !found)
{
mid = (first + last) / 2;
if (list[mid] == item)
found = true;
else if (list[mid] > item)
last = mid - 1;
else
first = mid + 1;
}
if (found)
return mid;
else
return -1;
} //end binarySearch

In the binary search algorithm, each time through the loop, we make two key comparisons. The only exception is in the successful case; the last time through the loop, only
one key comparison is made.
The binary search algorithm, as given in this chapter, uses an iterative control structure
(the while loop) to compare the search item with the list elements. You can also write
a recursive algorithm to implement the binary search algorithm. (See Programming
Exercise 2 at the end of this chapter.)

Example 18-1 further illustrates how the binary search algorithm works.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1272

| Chapter 18: Searching and Sorting Algorithms

EXAMPLE 18-1
Consider the list given in Figure 18-4.

[0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10][11]
list

FIGURE 18-4

4

8

19

25

34

39

45

48

66

75

89

95

Sorted list for a binary search

The size of this list is 12; that is, the length is 12. Suppose that we are searching for
item 89. Table 18-1 shows the values of first, last, and mid each time through the
loop. It also shows the number of times the item is compared with an element in the list
each time through the loop.
TABLE 18-1

Values of first, last, and mid and the Number of Comparisons for Search
Item 89

Iteration

first

last

mid

list[mid]

Number of
comparisons

1

0

11

5

39

2

2

6

11

8

66

2

3

9

11

10

89

1 (found is true)

The item is found at location 10, and the total number of comparisons is 5.
Next, let us search the list for item 34. Table 18-2 shows the values of first, last, and
mid each time through the loop. It also shows the number of times the item is compared
with an element in the list each time through the loop.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Search Algorithms

TABLE 18-2

|

1273

Values of first, last, and mid and the Number of Comparisons for Search
Item 34

Iteration

first

last

mid

list[mid]

Number of
comparisons

1

0

11

5

39

2

2

0

4

2

19

2

3

3

4

3

25

2

4

4

4

4

34

1 (found is true)

The item is found at location 4, and the total number of comparisons is 7.
Let us now search for item 22, as shown in Table 18-3.
TABLE 18-3

Values of first, last, and mid and the Number of Comparisons for Search
Item 22

Iteration

first

last

mid

list[mid]

Number of
comparisons

1

0

11

5

39

2

2

0

4

2

19

2

3

3

4

3

25

2

4

3

2

the loop stops (because first > last)

This is an unsuccessful search. The total number of comparisons is 6.

Example 18-2 illustrates how to use the binary search algorithm in a program.
EXAMPLE 18-2
#include <iostream >
#include "searchSortAlgorithms.h"
using namespace std;
int main()

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1274

| Chapter 18: Searching and Sorting Algorithms

{
int intList[] = {2, 16, 34, 45, 53,
56, 69, 70, 75, 96};

//Line 1

int pos;

//Line 2

pos = binarySearch(intList, 10, 45);

//Line 3

if (pos != -1)
cout << "Line 5: " << 45
<< " found at position "
<< pos << endl;
else
cout << "Line 7: " << 45
<< " is not in intList " << endl;
return 0;

//Line 4
//Line 5
//Line 6
//Line 7

}

Sample Run:
Line 5: 45 found at position 3

The preceding program works as follows. The statement in Line 1 creates the array
intList. (Note that the array intList is sorted.) The statement in Line 2 declares pos
to be an int variable. The statement in Line 3 uses the binary search algorithm to
determine whether 45 is in intList. Note that the array intList, its lengths, and the
search item, which is 45, are passed as parameters to the function binarySearch. The
statements in Lines 4 to 7 output the result of the search, which is successful.

Performance of Binary Search
Suppose that L is a sorted list of size 1024 and we want to determine if an item x is in L.
From the binary search algorithm, it follows that every iteration of the while loop cuts
the size of the search list by half. (For example, see Figures 18-2 and 18-3.) Because
1024 ¼ 210, the while loop will have, at most, 11 iterations to determine whether x is in
L. Because every iteration of the while loop makes two item (key) comparisons, that is, x
is compared twice with the elements of L, the binary search will make, at most, 22
comparisons to determine whether x is in L. On the other hand, recall that a sequential
search on average will make 512 comparisons to determine whether x is in L.
To better understand how fast binary search is compared to sequential search, suppose
that L is of size 1048576. Because 1048576 ¼ 220, it follows that the while loop in a
binary search will have, at most, 21 iterations to determine whether an element is in
L. Every iteration of the while loop makes two key (that is, item) comparisons. Therefore, to determine whether an element is in L, a binary search makes, at most, 42 item
comparisons.
Note that 40 ¼ 2 * 20 ¼ 2 * log2220 ¼ 2 * log2(1048576).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Search Algorithms

|

1275

In general, suppose that L is a sorted list of size n. Moreover, suppose that n is a power of
2, that is, n ¼ 2m, for some nonnegative integer m. After each iteration of the while loop,
about half of the elements are left to search, that is, the search sublist for the next iteration
is half the size of the current sublist. For example, after the first iteration, the search sublist
size is about n=2 ¼ 2m1 . It is easy to see that the maximum number of the iteration of
the while loop is about m + 1. Also, m ¼ log2n. Each iteration makes two key
comparisons. Thus, the maximum number of comparisons to determine whether an
element x is in L is 2(m + 1) ¼ 2(log2n + 1) ¼ 2log2n + 2.
In the case of a successful search, it can be shown that for a list of length n, on average, a
binary search makes 2log2n – 3 key comparisons. In the case of an unsuccessful search, it
can be shown that for a list of length n, a binary search makes approximately 2log2n key
comparisons.

Binary Search Algorithm and the class
orderedArrayListType
The class orderedArrayListType, designed in Chapter 13, does not contain the
binary search algorithm. Now that you know how to implement the binary search
algorithm, you can learn how to use it in the class orderedArrayListType.
To use the binary search algorithm within the class orderedArrayListType, we add
the function binSearch to this class and call the functions binarySearch with the
appropriate parameters.
#include "arrayListType.h"
#include "searchSortAlgorithms.h"
template <class elemType>
class orderedArrayListType: public arrayListType<elemType>
{
public:
void insertAt(int location, const elemType& insertItem);
void insertEnd(const elemType& insertItem);
void replaceAt(int location, const elemType& repItem);
int seqSearch(const elemType& searchItem) const;
void insert(const elemType& insertItem);
void remove(const elemType& removeItem);
int binSearch(const elemType& removeItem);
orderedArrayListType(int size = 100);
//Constructor
};

The definition of the member function binSearch is:
template <class elemType>
int orderedArrayListType<elemType>::
binSearch(const elemType& item) const

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1276

| Chapter 18: Searching and Sorting Algorithms

{
return binarySearch(list, length, item);
}

Asymptotic Notation: Big-O Notation
Just as a problem is analyzed before writing the algorithm and the computer program, after an
algorithm is designed, it should also be analyzed. Usually, there are various ways to design a
particular algorithm. Certain algorithms take very little computer time to execute, while
others take a considerable amount of time. Consider the following examples.
EXAMPLE 18-3
Consider the following algorithm (assume that all variables are properly declared):
cout << "Enter the first number: ";
cin >> num1;
cout << endl;

//Line 1
//Line 2
//Line 3

cout << "Enter the second number: ";
cin >> num2;
cout << endl;

//Line 4
//Line 5
//Line 6

if (num1 >= num2)
max = num1;
else
max = num2;

//Line
//Line
//Line
//Line

7
8
9
10

cout << "The maximum number is: " << max << endl; //Line 11

Lines 1 to 6 each have one operation, << or >>. Line 7 has one operation, >¼. Either Line
8 or Line 9 executes; each has one operation. There are three operations, <<, in Line 11.
Therefore, the total number of operations executed in the preceding code is 6 þ 1 þ 1 þ
3 ¼ 11. In this algorithm, the number of operations executed is fixed.

EXAMPLE 18-4
Consider the following algorithm (assume that all variables are properly declared):
cout << "Enter positive integers ending with -1"
<< endl;

//Line 1

count = 0;
sum = 0;

//Line 2
//Line 3

cin >> num;

//Line 4

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Asymptotic Notation: Big-O Notation

while (num != -1)
{
sum = sum + num;
count++;
cin >> num;
}

|

1277

//Line 5
//Line 6
//Line 7
//Line 8

cout << "The sum of the numbers is: " << sum
<< endl;

//Line 9

if (count != 0)
average = sum / count;
else
average = 0;

//Line
//Line
//Line
//Line

cout << "The average is: " << average << endl;

//Line 14

10
11
12
13

This algorithm has five operations (Lines 1 through 4) before the while loop. Similarly,
there are nine or eight operations after the while loop, depending on whether Line 11 or
Line 13 executes.
Line 5 has one operation, and there are four operations within the while loop (Lines 6
through 8). Thus, Lines 5 through 8 have five operations. If the while loop executes 10
times, these five operations execute 10 times, plus one extra operation is executed at Line
5 to terminate the loop. Therefore, the number of operations executed from Lines 5
through 8 is 51.
If the while loop executes 10 times, the total number of operations executed is:
5  10 þ 1 þ 5 þ 9 or 5  10 þ 1 þ 5 þ 8:
That is:
5  10 þ 15 or 5  10 þ 14:
We can generalize it to the case when the while loop executes n times. If the while loop
executes n times, the number of operations executed is:
5n þ 15 or 5n þ 14:
In these expressions, for very large values of n, the term 5n becomes the dominating term,
and the terms 15 and 14 become negligible.

Usually, in an algorithm, certain operations are dominant. For example, in the algorithm
in Example 18-4, to add numbers, the dominant operation is in Line 6. Similarly, in a
search algorithm, because the search item is compared with the items in the list, the
dominant operations would be comparison, that is, the relational operation. Therefore, in
the case of a search algorithm, we count the number of comparisons.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1278

| Chapter 18: Searching and Sorting Algorithms

Suppose that an algorithm performs f(n) basic operations to accomplish a task, in which n is
the size of the problem. Suppose that you want to determine whether an item is in a list and
that the size of the list is n. To determine whether the item is in the list, there are various
algorithms. However, the basic method is to compare the item with the items in the list.
Therefore, the performance of the algorithm depends on the number of comparisons.
Thus, in the case of a search, n is the size of the list and f(n) becomes the count function;
that is, f(n) gives the number of comparisons done by the search algorithm. Suppose that
on a particular computer, it takes c units of computer time to execute one operation.
Thus, the computer time it would take to execute f(n) operations is cf(n). Clearly, the
constant c depends on the speed of the computer and, therefore, varies from computer to
computer. However, f(n), the number of basic operations, is the same on each computer.
If we know how the function f(n) grows as the size of the problem grows, we can
determine the efficiency of the algorithm. Consider Table 18-4.
TABLE 18-4

Growth Rate of Various Functions

n

log2n

nlog2n

n2

2n

1

0

0

1

2

2

1

2

2

4

4

2

8

16

16

8

3

24

64

256

16

4

64

256

65536

32

5

160

1024

4294967296

Table 18-4 shows how certain functions grow as the parameter n (the problem size)
grows. Suppose that the problem size is doubled. From Table 18-4, it follows that if the
number of basic operations is a function of f(n) ¼ n2, the number of basic operations is
quadrupled. If the number of basic operations is a function of f(n) ¼ 2n, then the number
of basic operations is squared. However, if the number of operations is a function of
f(n) ¼ log2n, the change in the number of basic operations is insignificant.
Suppose that a computer can execute 1 billion steps per second. Table 18-5 shows the
time that the computer takes to execute f(n) steps.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Asymptotic Notation: Big-O Notation

TABLE 18-5

|

1279

Time for f (n) Instructions on a Computer That Executes 1 Billion Instructions
per Second

n

f(n) = n

f (n) = log2n

f (n) = nlog2n

f (n) = n2

f (n) = 2n

10

0.01ms

0.003ms

0.033ms

0.1ms

1ms

20

0.02ms

0.004ms

0.086ms

0.4ms

1ms

30

0.03ms

0.005ms

0.147ms

0.9ms

1s

40

0.04ms

0.005ms

0.213ms

1.6ms

18.3min

50

0.05ms

0.006ms

0.282ms

2.5ms

13 days

100

0.10ms

0.007ms

0.664ms

10ms

41013
years

1000

1.00ms

0.010ms

9.966ms

1ms

10000

10ms

0.013ms

130ms

100ms

100000

0.10ms

0.017ms

1.67ms

10s

1000000

1 ms

0.020ms

19.93ms

16.7m

10000000

0.01s

0.023ms

0.23s

1.16 days

100000000

0.10s

0.027ms

2.66s

115.7 days

In Table 18-5, 1ms ¼ 10-6 seconds and 1ms ¼ 10-3 seconds.
Figure 18-5 shows the growth rate of functions in Table 18-5.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1280

| Chapter 18: Searching and Sorting Algorithms

f (n) = 2n
10
f (n) = nlog2n

f (n) = n 2

8

f (n) = n

6
f (n)
4

f (n) = log2n

2

0

FIGURE 18-5

0

2

4

n

6

8

10

Growth rate of various functions

The remainder of this section develops a notation that shows how a function f(n) grows as
n increases without bound. That is, we develop a notation that is useful in describing the
behavior of the algorithm, which gives us the most useful information about the algorithm. First, we define the term ‘‘asymptotic.’’
Let f be a function of n. By the term asymptotic, we mean the study of the function f as
n becomes larger and larger without bound.
Consider the functions g(n) ¼ n2 and f(n) ¼ n2 + 4n + 20. Clearly, the function g does not
contain any linear term; that is, the coefficient of n in g is zero. Consider Table 18-6.
TABLE 18-6

Growth Rate of n2 and n2 + 4n + 20

n

g(n) = n2

f (n) = n2 + 4n + 20

10

100

160

50

2500

2720

100

10000

10420

1000

1000000

1004020

10000

100000000

100040020

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Asymptotic Notation: Big-O Notation

|

1281

Clearly, as n becomes larger and larger, the term 4n + 20 in f(n) becomes insignificant,
and the term n2 becomes the dominant term. For large values of n, we can predict the
behavior of f(n) by looking at the behavior of g(n). In the algorithm analysis, if the
complexity of a function can be described by the complexity of a quadratic function
without the linear term, we say that the function is of O(n2), called Big-O of n2.
Let f and g be real-valued functions. Assume that f and g are nonnegative; that is, for all
real numbers n, f(n)  0 and g(n)  0.
Definition: We say that f(n) is Big-O of g(n), written f(n) ¼ O(g(n)), if there exist positive
constants c and n0 such that:
f(n)  cg(n) for all n  n0.
EXAMPLE 18-5
Let f(n) ¼ a, wherein a is a nonnegative real number and n  0. Note that f is a constant
function.
Now:
f ðnÞ ¼ a  a  1 for all n  a:
Let c ¼ a, n0 ¼ a, and g(n) ¼ 1. Then, f(n)  cg(n) for all n  n0. It now follows that
f(n) ¼ O(g(n)) ¼ O(1).
From Example 18-5, it follows that if f is a nonnegative constant function, then f
is O(1).
EXAMPLE 18-6
Let f(n) ¼ 2n + 5, n  0. Note that:
f(n) ¼ 2n + 5  2n + n ¼ 3n for all n  5.
Let c ¼ 3, n0 ¼ 5, and g(n) ¼ n. Then, f(n)  cg(n) for all n  5. It now follows that f(n) ¼
O(g(n)) ¼ O(n).

EXAMPLE 18-7
Let f(n) = n2 + 3n + 2, g(n) = n2, n  0. Note that:
3n + 2  n2 for all n  4.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1282

| Chapter 18: Searching and Sorting Algorithms

This implies that:
f(n) ¼ n2+ 3n + 2  n2+ n2  2n2 ¼ 2g(n) for all n  4.
Let c ¼ 2 and n0 ¼ 4. Then, f(n)  cg(n) for all n  4. It now follows that f(n) ¼
O( g(n)) ¼ O(n2).
In general, we can prove the following theorem. We state the theorem without proof.
Theorem: Let f(n) be a nonnegative real-valued function such that:
f(n) = amnm + am1nm1 +    +a1n + a0,
in which ais are real numbers, am 6¼ 0, n  0, and m is a nonnegative integer. Then:
f(n) = O(nm).
In Example 18-8, we use the preceding theorem to establish the Big-O of certain functions.
EXAMPLE 18-8
In the following, f(n) is a nonnegative real-valued function.
Function
f(n) = an + b, in which a and b are real numbers and a is nonzero
f (n) = n2 + 5n + 1
f (n) = 4n6 + 3n3 + 1
f (n) = 10n7 + 23
f (n) = 6n15

Big-O
f(n) =
f(n) =
f (n) =
f(n) =
f (n) =

O(n)
O(n2)
O(n6)
O(n7)
O(n15)

EXAMPLE 18-9
Suppose that f(n) ¼ 2log2n + a, in which a is a real number. It can be shown that
f(n) ¼ O(log2n).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Asymptotic Notation: Big-O Notation

|

1283

EXAMPLE 18-10
Consider the following code, in which m and n are int variables and their values are
nonnegative:
for (int i = 0; i < m; i++)
for (int j = 0; j < n; j++)
cout << i * j << endl;

//Line 1
//Line 2
//Line 3

This code contains nested for loops. The outer for loop, at Line 1, executes m times.
For each iteration of the outer loop, the inner loop at Line 2 executes n times. For each
iteration of the inner loop, the output statement in Line 3 executes. It follows that the
total number of iterations of the nested for loop is mn. So the number of times the
statement in Line 3 executes is mn. It follows that this algorithm is O(mn). Note that if
m ¼ n, then this algorithm is O(n2).
Table 18-7 shows some common Big-O functions that appear in the algorithm analysis.
Let f(n) ¼ O(g(n)), wherein n is the problem size.
TABLE 18-7

Some Big-O Functions That Appear in Algorithm Analysis

Function g (n)

Growth rate of f (n)

g(n) = 1

The growth rate is constant, so it does not depend on n, the size of
the problem.

g(n) = log2n

The growth rate is a function of log2n. Because a logarithm function
grows slowly, the growth rate of the function f is also slow.

g(n) = n

The growth rate is linear. The growth rate of f is directly proportional
to the size of the problem.

g(n) = nlog2n

The growth rate is faster than the linear algorithm.

g(n) = n2

The growth rate of such functions increases rapidly with the size of
the problem. The growth rate is quadrupled when the problem size is
doubled.

g(n) = 2n

The growth rate is exponential. The growth rate is squared when the
problem size is doubled.

It can be shown that:
Oð1Þ  Oðlog2 nÞ  OðnÞ  Oðnlog2 nÞ  Oðn2 Þ  Oð2n Þ:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1284

| Chapter 18: Searching and Sorting Algorithms

Using the notations developed in this section, we can conclude that the algorithm
in Example 18-3 is of order O(1), and the algorithm in Example 18-4 is of O(n).
Table 18-8 summarizes the algorithm analysis of the search algorithms discussed earlier.
TABLE 18-8

Number of Comparisons for a List of Length n

Algorithm

Successful Search

Unsuccessful Search

Sequential search

nþ1 1
1
= n þ =O(n)
2
2
2

n = O(n)

Binary search

2log2n – 3 = O(log2n)

2log2n = O(log2n)

Lower Bound on Comparison-Based Search Algorithms
Sequential and binary search algorithms search the list by comparing the target element
with the list elements. For this reason, these algorithms are called comparison-based
search algorithms. Earlier sections of this chapter showed that a sequential search is of
the order n, and a binary search is of the order log2n, where n is the size of the list. The
obvious question is: Can we devise a search algorithm that has an order less than log2n?
Before we answer this question, first we obtain the lower bound on the number of
comparisons for the comparison-based search algorithms.
Theorem: Let L be a list of size n > 1. Suppose that the elements of L are sorted. If
SRH(n) denotes the minimum number of comparisons needed, in the worst case, by
using a comparison-based algorithm to recognize whether an element x is in L, then
SRH(n)  log2(n + 1).
Corollary: The binary search algorithm is an optimal worst-case algorithm for solving
search problems by the comparison method.
From these results, it follows that if we want to design a search algorithm that is of an
order less than log2n, then it cannot be comparison based.

Sorting Algorithms
There are several sorting algorithms in the literature. In this chapter, we discuss some of
the commonly used sorting algorithms. To compare their performance, we also provide
some analysis of these algorithms. These sorting algorithms can be applied to either arraybased lists or linked lists. We will specify whether the algorithm being developed is for
array-based lists or linked lists.

Sorting a List: Bubble Sort
Many sorting algorithms are available in the literature. This section describes using the sorting
algorithm called the bubble sort to sort a list.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Sorting a List: Bubble Sort

|

1285

Suppose list[0...n - 1] is a list of n elements, indexed 0 to n - 1. We want to
rearrange, that is, sort, the elements of list in increasing order. The bubble sort
algorithm works as follows.
In a series of n - 1 iterations, the successive elements list[index] and list[index + 1] of
the list are compared. If list[index] is greater than list[index + 1], then the elements
list[index] and list[index + 1] are swapped.
It follows that the smaller elements move toward the top, and the larger elements move
toward the bottom.
In the first iteration, we consider the list[0...n - 1]. As you will see after the first
iteration, the largest element of the list is moved to the last position, which is position
n – 1, in the list. In the second iteration, we consider the list[0...n - 2]. After the
second iteration, the second largest element in the list is moved to the position n – 2,
which is second to the last position in the list. In the third iteration, we consider the
list[0...n - 3], and so on. As you will see, after each iteration, the size of the
unsorted portion of the list shrinks.
Consider the list[0...4] of five elements, as shown in Figure 18-6.

list

FIGURE 18-6

list[0]

10

list[1]

7

list[2]

19

list[3]

5

list[4]

16

List of five elements

Iteration 1: Sort

list[0...4]. Figure 18-7 shows how the elements of
list get rearranged in the first iteration.

10
unsorted
list

FIGURE 18-7

7

compare
and
swap

7
10

compare

7

7

7

10

10

10

19

19

19

5

5

5

16

16

16

compare
and
swap

5
19
16

compare
and
swap

5
16
19

Elements of list during the first iteration

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1286

| Chapter 18: Searching and Sorting Algorithms

Notice that in the first diagram of Figure 18-7, list[0] >
list[1]. Therefore, list[0] and list[1] are swapped. In
the second diagram, list[1] and list[2] are compared.
Because list[1] < list[2], they do not get swapped. The
third diagram of Figure 18-7 compares list[2] with list[3];
because list[2] > list[3], list[2] is swapped with
list[3]. Then, in the fourth diagram, we compare list[3]
with list[4]. Because list[3] > list[4], list[3] and
list[4] are swapped.
After the first iteration, the largest element is at the last position.
Therefore, in the next iteration, we consider the list[0...3].
Iteration 2: Sort list[0...3]. Figure 18-8 shows how the elements of
list get rearranged in the second iteration.

7
unsorted
list

FIGURE 18-8

compare

7

7

compare
and
swap

7

10

10

5

5

16

16

16

16

19

19

19

19

5
10

compare

5
10

Elements of list during the second iteration

The elements are compared and swapped as in the first iteration.
Here, only the list elements list[0] through list[3] are
considered. After the second iteration, the last two elements
are in the right place. Therefore, in the next iteration, we
consider list[0...2].
Iteration 3: Sort list[0...2]. Figure 18-9 shows how the elements of
list get rearranged in the third iteration.

unsorted
list

FIGURE 18-9

7
5

compare
and
swap

5
7

compare

5
7

10

10

10

16

16

16

19

19

19

Elements of list during the third iteration

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Sorting a List: Bubble Sort

|

1287

After the third iteration, the last three elements are in the right
place. Therefore, in the next iteration, we consider list[0...1].
Iteration 4: Sort list[0...1]. Figure 18-10 shows how the elements of
list get rearranged in the fourth iteration.

unsorted
list

FIGURE 18-10

5

compare

5

7

7

10

10

16

16

19

19

Elements of list during the fourth iteration

After the fourth iteration, list is sorted.
The following C++ function implements the bubble sort algorithm:
template <class elemType>
void bubbleSort(elemType list[], int length)
{
for (int iteration = 1; iteration < length; iteration++)
{
for (int index = 0; index < length - iteration;
index++)
{
if (list[index] > list[index + 1])
{
elemType temp = list[index];
list[index] = list[index + 1];
list[index + 1] = temp;
}
}
}
} //end bubbleSort

Example 18-11 illustrates how to use the bubble sort algorithm in a program.
EXAMPLE 18-11 (BUBBLE SORT)
#include <iostream>
#include "searchSortAlgorithms.h"
using namespace std;
template <class elemType>
void print(elemType list[], int length);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1288

| Chapter 18: Searching and Sorting Algorithms

int main()
{
int intList[] = {2, 56, 34, 25, 73,
46, 89, 10, 5, 16};

//Line 1

cout << "Line 2: Before sorting, intList: "; //Line 2
print(intList, 10);

//Line 3

cout << endl;

//Line 4

bubbleSort(intList, 10);

//Line 5

cout << "Line 6: After sorting, intList: ";

//Line 6

print(intList, 10);

//Line 7

return 0;
}
template <class elemType>
void print(elemType list[], int length)
{
for (int i = 0; i < length; i++)
cout << list[i] << " ";
cout << endl;
}

Sample Run:
Line 2: Before sorting, intList: 2 56 34 25 73 46 89 10 5 16
Line 6: After sorting, intList: 2 5 10 16 25 34 46 56 73 89

The statement in Line 1 declares and initializes intList to be an array of 10 components
of type int. The statement in Line 3 outputs the values of the array intList before
sorting this array. The statement in Line 5 uses the function bubbleSort to sort list.
Notice that both intList and its length (the number of elements) are passed as
parameters to the function bubbleSort. The statement in Line 7 outputs the sorted
intList.

Analysis: Bubble Sort
In the case of search algorithms, our only concern was with the number of key (item)
comparisons. A sorting algorithm makes key comparisons and also moves the data.
Therefore, in analyzing the sorting algorithm, we look at the number of key comparisons
as well as the number of data movements.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Sorting a List: Bubble Sort

|

1289

Suppose a list L of length n is to be sorted using bubble sort. Consider the function
bubbleSort as given in this chapter. This function contains nested for loops. Because
L is of length n, the outer loop executes n – 1 times. For each iteration of the outer loop,
the inner loop executes a certain number of times. Let us consider the first iteration of the
outer loop. During the first iteration of the outer loop, the number of iterations of
the inner loop is n – 1. So there are n – 1 comparisons. Similarly, during the second
iteration of the outer loop, the number of iterations of the inner loop is n – 2, and so on.
Thus, the total number of comparisons is:
ðn  1Þ þ ðn  2Þ þ    þ 2 þ 1 ¼

nðn  1Þ
1
1
¼ n2  n ¼ Oðn2 Þ:
2
2
2

In the worst case, the body of the if statement always executes. So in the worst case, the
number of assignments is:
3

nðn  1Þ
3
3
¼ n2  n ¼ Oðn2 Þ:
2
2
2

If the list is already sorted, which is the best case, the number of assignments is 0. It can be
nðn  1Þ
shown that, on average, bubble sort makes about
item assignments. However, the
4
nðn  1Þ
number of comparisons for the bubble sort, as given in this chapter, is always
2 .
Therefore, to sort a list of size 1000, bubble sort makes about 500,000 key comparisons
and about 250,000 item assignments. The next section presents the selection sort algorithm that reduces the number of item assignments.
Exercise 9 at the end of this chapter gives a version of the bubble sort algorithm in which
the number of comparisons in the best case is O (n).

Bubble Sort Algorithm and the class
unorderedArrayListType
The class unorderedArrayListType, designed in Chapter 13, does not contain any
sorting algorithm. Now that you know how to implement the bubble sort algorithm, you
can learn how to use it in the class unorderedArrayListType.
To use the binary search algorithm within the class unorderedArrayListType, we
add the function sort to this class and call the functions bubbleSort with the appropriate parameters. (Note that we have also added the function to use the binary search
algorithm.)
template <class elemType>
class unorderedArrayListType: public arrayListType<elemType>

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1290

| Chapter 18: Searching and Sorting Algorithms

{
public:
void insertAt(int location, const elemType& insertItem);
void insertEnd(const elemType& insertItem);
void replaceAt(int location, const elemType& repItem);
int seqSearch(const elemType& searchItem) const;
void remove(const elemType& removeItem);
void sort();
int binSearch(const elemType& item) const;
unorderedArrayListType(int size = 100);
//Constructor
};

The definitions of the member functions binSearch and sort are:
template <class elemType>
int unorderedArrayListType<elemType>::
binSearch(const elemType& item) const
{
return binarySearch(list, length, item);
}
template <class elemType>
void unorderedArrayListType<elemType>::sort()
{
selectionSort(list, length);
}

We leave it as an exercise for you to write a program to test the member functions sort
and binSearch.

Selection Sort: Array-Based Lists
Chapter 8 described the selection sort algorithm for array-based lists. However, the
selection sort algorithm given in Chapter 8 works only for arrays of type int. In this
section, using templates we give a generic selection sort algorithm. Note that the
algorithm given here is slightly different than the one given in Chapter 8.
Suppose that list is the array to be sorted and length denotes the length, that is, the
number of elements in list. As described in Chapter 9, a selection sort involves the
following steps:
a. Find the location of the smallest element.
b. Move the smallest element to the beginning of the unsorted list.
Given the starting index, first, and the ending index, last, of the list, the following
C++ function returns the index of the smallest element in list[first]...
list[last].

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Selection Sort: Array-Based Lists

|

1291

template <class elemType>
int minLocation(elemType list[], int first, int last)
{
int loc, minIndex;
minIndex = first;
for (loc = first + 1; loc <= last; loc++)
if (list[loc] < list[minIndex])
minIndex = loc;
return minIndex;
} //end minLocation

Given the locations in the list of the elements to be swapped, the following C++
function, swap, swaps those elements:
template <class elemType>
void swap(elemType list[], int first, int second)
{
elemType temp;
temp = list[first];
list[first] = list[second];
list[second] = temp;
} //end swap

We can now complete the definition of the function selectionSort:
template <class elemType>
void selectionSort(elemType list[], int length)
{
int loc, minIndex;
for (loc = 0; loc < length; loc++)
{
minIndex = minLocation(list, loc, length - 1);
swap(list, loc, minIndex);
}
} //end selectionSort

We leave it as an exercise for you to write a program to test the selection sort algorithm.
(See Programming Exercise 6 at the end of this chapter.)
1.

A selection sort can also be implemented by selecting the largest element in the unsorted
portion of the list and moving it to the bottom of the list. You can easily implement this
form of selection sort by altering the if statement in the function minLocation and
passing the appropriate parameters to both the corresponding function and the function
swap (when these functions are called in the function selectionSort).

2.

A selection sort can also be applied to linked lists. The general algorithm is the same,
and the details are left as an exercise for you. See Programming Exercise 7 at the
end of this chapter.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1292

| Chapter 18: Searching and Sorting Algorithms

Analysis: Selection Sort
Suppose that a list L of length n is to be sorted using the selection sort algorithm. The
function swap does three item assignments and is executed n  1 times. Hence, the
number of item assignments is 3(n  1) ¼ O(n).
The key comparisons are made by the function minLocation. For a list of length k, the
function minLocation makes k  1 key comparisons. Also, the function minLocation
is executed n  1 times (by the function selectionSort). The first time, the function
minLocation finds the index of the smallest key item in the entire list and, therefore,
makes n  1 comparisons. The second time, the function minLocation finds the index
of the smallest element in the sublist of length n  1 and so makes n  2 comparisons, and
so on. Hence, the number of key comparisons is as follows:
nðn  1Þ
2
1 2 1
¼ n  n
2
2
1 2
¼ n þ OðnÞ
2
¼ Oðn2 Þ:

ðn  1Þ þ ðn  2Þ þ    þ 2 þ 1 ¼

It thus follows that if n ¼ 1000, the number of key comparisons the selection sort
algorithm makes is:
1
1
ð1000Þ2  ð1000Þ ¼ 499500  500000:
2
2
Note that the selection sort algorithm does not depend on the initial arrangement of the
data. The number of comparisons is always O(n2) and the number of assignments is O(n).
In general, this algorithm is good only for small lists because O(n2) grows rapidly as n
grows. However, if data movement is expensive and the number of comparisons is not,
then this algorithm could be a better choice over other algorithms.

Insertion Sort: Array-Based Lists
The previous section described and analyzed the selection sort algorithm. It was shown
that if n ¼ 1000, the number of key comparisons is approximately 500,000, which is quite
high. This section describes the sorting algorithm called the insertion sort, which tries to
improve—that is, reduce—the number of key comparisons.
The insertion sort algorithm sorts the list by moving each element to its proper place in
the sorted portion of the list. Consider the list given in Figure 18-11.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Insertion Sort: Array-Based Lists

list

FIGURE 18-11

[0]

[1]

[2]

[3]

[4]

[5]

[6]

[7]

10

18

25

30

23

17

45

35

|

1293

list

The length of the list is 8. In this list, the elements list[0], list[1], list[2], and
list[3] are in order. That is, list[0]...list[3] is sorted (see Figure 18-12).

[0]
list

FIGURE 18-12

10

sorted list
[1] [2] [3]
18

25

30

unsorted list
[4] [5] [6] [7]
23

17

45

35

Sorted and unsorted portion of list

Next, we consider the element list[4], the first element of the unsorted list. Because
list[4] < list[3], we need to move the element list[4] to its proper location. It
thus follows that element list[4] should be moved to list[2] (see Figure 18-13).

[0]
list

10

sorted list
[1] [2] [3]
18

25

30

unsorted list
[4] [5] [6] [7]
23

17

45

35

move

FIGURE 18-13

Move list[4] into list[2]

To move list[4] into list[2], first we copy list[4] into temp, a temporary
memory space (see Figure 18-14).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1294

| Chapter 18: Searching and Sorting Algorithms

sorted list
list

[0]

[1]

[2]

[3]

[4]

[5]

[6]

[7]

10

18

25

30

23

17

45

35

temp

FIGURE 18-14

unsorted list

copy

23

Copy list[4] into temp

Next, we copy list[3] into list[4] and then list[2] into list[3] (see Figure 18-15).

sorted list
list

unsorted list

[0]

[1]

[2]

[3]

[4]

[5]

[6]

[7]

10

18

25

30

23

17

45

35

temp

23

copy

FIGURE 18-15

copy

List before copying list[3] into list[4] and then list[2] into list[3]

After copying list[3] into list[4] and list[2] into list[3], the list is as shown in
Figure 18-16.

sorted list
list

[1]

[2]

[3]

[4]

[5]

[6]

[7]

10

18

25

25

30

17

45

35

temp

FIGURE 18-16

unsorted list

[0]

23

List after copying list[3] into list[4] and then list[2] into list[3]

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Insertion Sort: Array-Based Lists

|

1295

We now copy temp into list[2]. Figure 18-17 shows the resulting list.

[0]
list

10

temp

FIGURE 18-17

sorted
list
[1] [2]
18

23

23

[3]

[4]

25

30

unsorted
list
[5] [6] [7]
17

45

35

copy

List after copying temp into list[2]

Now list[0]...list[4] is sorted, and list[5]...list[7] is unsorted. We repeat
this process on the resulting list by moving the first element of the unsorted list into the
sorted list in the proper place.
From this discussion, we see that during the sorting phase, the array containing the list is
divided into two sublists: sorted and unsorted. Elements in the sorted sublist are in order;
elements in the unsorted sublist are to be moved one at a time to their proper places
in the sorted sublist. We use an index—say, firstOutOfOrder—to point to the
first element in the unsorted sublist; that is, firstOutOfOrder gives the index of the
first element in the unsorted portion of the array. Initially, firstOutOfOrder is
initialized to 1.
This discussion translates into the following pseudocode algorithm:
for (firstOutOfOrder = 1; firstOutOfOrder < length; firstOutOfOrder++)
if (list[firstOutOfOrder] is less than list[firstOutOfOrder – 1])
{
copy list[firstOutOfOrder] into temp
initialize location to firstOutOfOrder
do
{
a. copy list[location – 1] into list[location]
b. decrement location by 1 to consider the next element
of the sorted portion of the array
}
while (location > 0 && the list element at location - 1 is
greater than temp)
}
copy temp into list[location]

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1296

| Chapter 18: Searching and Sorting Algorithms

The following C++ function implements the previous algorithm:
template <class elemType>
void insertionSort(elemType list[], int length)
{
for (int firstOutOfOrder = 1; firstOutOfOrder < length;
firstOutOfOrder++)
if (list[firstOutOfOrder] < list[firstOutOfOrder - 1])
{
elemType temp = list[firstOutOfOrder];
int location = firstOutOfOrder;
do
{
list[location] = list[location - 1];
location--;
}
while (location > 0 && list[location - 1] > temp);
list[location] = temp;
}
} //end insertionSort

We leave it as an exercise for you to write a program to test the insertion sort algorithm.
(See Programming Exercise 8 at the end of this chapter.)
An insertion sort can also be applied to linked lists. The general algorithm is the same,
and the details are left as an exercise for you. See Programming Exercise 9 at the end of
this chapter.

Analysis: Insertion Sort
Let L be a list of length n. Suppose L is to be sorted using insertion sort. The for loop
executes n  1 times. In the best case, when the list is already sorted, for each iteration of
the for loop, the if statement evaluates to false, so there are n  1 key comparisons.
Thus, in the best case, the number of key comparisons is n – 1 ¼ O(n). Let us consider the
worst case. In this case, for each iteration of the for loop, the if statement evaluates to
true. Moreover, in the worst case, for each iteration of the for loop, the do. . .while loop
executes firstOutOfOrder - 1 times. It follows that in the worst case, the number of key
comparisons is:
1 þ 2 þ    þ ðn  1Þ ¼ nðn  1Þ=2 ¼ Oðn2 Þ:
It can be shown that the average number of key comparisons and the average number of
item assignments in an insertion sort algorithm are:
1 2
n þ OðnÞ ¼ Oðn2 Þ:
4
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Lower Bound on Comparison-Based Sort Algorithms

|

1297

Table 18-9 summarizes the behavior of the bubble sort, selection sort, and insertion sort
algorithms.
TABLE 18-9

Average Case Behavior of the Bubble Sort, Selection Sort, and Insertion Sort
Algorithms for a List of Length n

Algorithm
Bubble sort
Selection sort
Insertion sort

Number of Comparisons

Number of Swaps

nðn  1Þ
= O(n2)
2
nðn  1Þ
= O(n2)
2
1 2
n þ O(n) = O(n2)
4

nðn  1Þ
= O(n2)
4
3(n  1) =O(n)
1 2
n þ O(n) = O(n2)
4

Lower Bound on Comparison-Based Sort
Algorithms
In the previous sections, we discussed the selection and insertion sort algorithms and
noted that the average-case behavior of these algorithms is O(n2). Both of these algorithms are comparison based; that is, the lists are sorted by comparing their respective
keys. Before discussing any additional sorting algorithms, let us discuss the best-case
scenario for comparison-based sorting algorithms.
We can trace the execution of a comparison-based algorithm by using a graph called a
comparison tree. Let L be a list of n distinct elements, wherein n > 0. For any j and k,
wherein 1  j  n and 1  k  n, either L[ j] < L[k] or L[ j] > L[k]. Because each
comparison of the keys has two outcomes, the comparison tree is a binary tree. While
drawing this figure, we draw each comparison as a circle called a node. The node is labeled
as j:k, representing the comparison of L[ j] with L[k]. If L[ j] < L[k], follow the left branch;
otherwise, follow the right branch. Figure 18-18 shows the comparison tree for a list
of length 3. (In Figure 18-18, the rectangle, called a leaf, represents the final ordering of
the nodes.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1298

| Chapter 18: Searching and Sorting Algorithms

1:2
L[1] > L[2]

L[1] < L[2]

2:3

2:3
L[2] < L[3]
1,2,3

1:3
L[1] < L[3]
1,3,2

FIGURE 18-18

L[2]<L[3]

L[2] > L[3]

L[2]>L[3]

1:3
L[1] > L[3]
L[1] < L[3]
3,1,2

2,1,3

3,2,1
L[1] > L[3]
2,3,1

Comparison tree for sorting three items

We call the top node in the figure the root node. The straight line that connects the two
nodes is called a branch. A sequence of branches from a node, x, to another node, y, is
called a path from x to y.
Associated with each path from the root to a leaf is a unique permutation of the elements
of L. This uniqueness follows because the sort algorithm only moves the data and makes
comparisons. Furthermore, the data movement on any path from the root to a leaf is the
same regardless of the initial inputs. For a list of n elements, n > 0, there are n! different
permutations. Any one of these n! permutations might be the correct ordering of L. Thus,
the comparison tree must have at least n! leaves.
Now let us consider the worst case for all comparison-based sorting algorithms. We state
the following result without proof.
Theorem: Let L be a list of n distinct elements. Any sorting algorithm that sorts L by
comparison of the keys only, in its worst case, makes at least O(nlog2n) key comparisons.
As analyzed in the previous sections, both the selection and insertion sort algorithms are
of the order O(n2). The remainder of this chapter discusses sorting algorithms that, on
average, are of the order O(nlog2n).

Quick Sort: Array-Based Lists
In the previous section, we noted that the lower bound on comparison-based algorithms is
O(nlog2n). The sorting algorithms bubble sort, selection sort, and insertion sort, discussed earlier
in this chapter, are of the order O(n2). In this and the next two sections, we discuss sorting
algorithms that are of the order O(nlog2n). The first algorithm is the quick sort algorithm.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Sort: Array-Based Lists

|

1299

The quick sort algorithm uses the divide-and-conquer technique to sort a list. The list is
partitioned into two sublists, which are then sorted and combined into one list in such a
way so that the combined list is sorted. Thus, the general algorithm is:
if (the list size is greater than 1)
{
a. Partition the list into two sublists, say lowerSublist and
upperSublist.
b. Quick sort lowerSublist.
c. Quick sort upperSublist.
d. Combine the sorted lowerSublist and sorted upperSublist.
}

After partitioning the list into two sublists called lowerSublist and upperSublist, the
sublists are sorted using the quick sort algorithm. In other words, we use recursion to
implement the quick sort algorithm.
The quick sort algorithm described here is for array-based lists. The algorithm for linked
lists can be developed in a similar manner and is left as an exercise for you.
In the quick sort algorithm, the list is partitioned in such way that combining the
sorted lowerSublist and upperSublist is trivial. Therefore, in a quick sort, all of
the sorting work is done in partitioning the list. Because all of the sorting work
occurs during the partitioning of the list, we first describe the partition procedure in
detail.
To partition the list into two sublists, first we choose an element of the list called
pivot. The pivot is used to divide the list into two sublists: lowerSublist and
upperSublist. The elements in lowerSublist are smaller than pivot, and the
elements in upperSublist are greater than or equal to pivot. For example, consider

the list in Figure 18-19.

list

FIGURE 18-19

[0]

[1]

[2]

[3]

[4]

[5]

[6]

[7]

[8]

45

82

25

94

50

60

78

32

92

list before the partition

There are several ways to determine pivot. However, pivot is chosen so that, it is
hoped, lowerSublist and upperSublist are of nearly equal size. For illustration
purposes, let us choose the middle element of the list as pivot. The partition procedure
that we describe partitions this list using pivot as the middle element, in our case 50, as
shown in Figure 18-20.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1300

| Chapter 18: Searching and Sorting Algorithms

list

[0]
32

[1]
25

[2]
45

[3]
50

[4]
82

lowerSublist

FIGURE 18-20

[5]
60

[6]
78

[7]
94

[8]
92

upperSublist

list after the partition

From Figure 18-20, it follows that after partitioning list into lowerSublist and
upperSublist, pivot is in the right place. Thus, after sorting lowerSublist and
upperSublist, combining the two sorted sublists is trivial.
The partition algorithm is as follows (we assume that pivot is chosen as the middle
element of the list).
1. Determine pivot, and swap pivot with the first element of
the list.
Suppose that the index smallIndex points to the last element less than
pivot. The index smallIndex is initialized to the first element of the list.
2. For the remaining elements in the list (starting at the second element):
If the current element is less than pivot,
a. Increment smallIndex.
b. Swap the current element with the array element pointed to by
smallIndex.
3. Swap the first element, that is, pivot, with the array element pointed to
by smallIndex.
Step 2 can be implemented using a for loop, with the loop starting at the second element
of the list.
Step 1 determines the pivot and moves pivot to the first array position. During the
execution of Step 2, the list elements get arranged as shown in Figure 18-21. (Suppose
the name of the array containing the list elements is list.)

lower
sublist
pivot

< pivot

upper
sublist
>= pivot

smallIndex

FIGURE 18-21

elements to be
moved in a
sublist

index

List during the execution of Step 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Sort: Array-Based Lists

|

1301

As shown in Figure 18-21, pivot is in the first array position. Elements in the lower sublist
are less than pivot; elements in the upper sublist are greater than or equal to pivot. The
variable smallIndex contains the index of the last element of the lower sublist; the variable
index contains the index of the next element that needs to be moved, either in the lower
sublist or in the upper sublist. As explained in Step 2, if the next element of the list (that is,
list[index]) is less than pivot, we advance smallIndex to the next array position and
swap list[index] with list[smallIndex]. Next, we illustrate Step 2.
Suppose that the list is as given in Figure 18-22.

[0]

[1]

[2]

[3]

[4]

[5]

[6]

[7]

[8]

32

55

87

13

78

96

52

48

22

FIGURE 18-22

[9] [10] [11] [12] [13]
11

58

66

88

45

List before sorting

Step 1 requires us to determine the pivot and swap it with the first array element. For
the list in Figure 18-22, the middle element is at the position (0 + 13) / 2 = 6. That is,
pivot is at position 6. Therefore, after swapping pivot with the first array element, the
list is as shown in Figure 18-23. (Notice that in Figure 18-23, 52 is swapped with 32.)

[0]

[1]

[2]

[3]

[4]

[5]

[6]

[7]

[8]

52

55

87

13

78

96

32

48

22

[9] [10] [11] [12] [13]
11

58

66

88

45

pivot

FIGURE 18-23

List after moving pivot to the first array position

Suppose that after executing Step 2 a few times, the list is as shown in Figure 18-24.

lower
sublist
52

13

32

48

upper
sublist
22

96

87

55

78

11

58

66

88

45

pivot
smallIndex

FIGURE 18-24

index

List after a few iterations of Step 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1302

| Chapter 18: Searching and Sorting Algorithms

As shown in Figure 18-24, the next element of the list that needs to be moved into a
sublist is indicated by index. Because list[index] < pivot, we need to move the
element list[index] into the lower sublist. To do so, we first advance smallIndex to
the next array position and then swap list[smallIndex] with list[index]. The
resulting list is as shown in Figure 18-25. (Notice that 11 is swapped with 96.)

lower sublist
52

13

32

48

22

upper sublist
11

87

55

78

96

58

66

88

45

66

88

45

pivot
smallIndex

FIGURE 18-25

index

List after moving 11 into the lower sublist

Now consider the list in Figure 18-26.

lower sublist
52

13

32

48

22

upper sublist
11

87

55

78

96

58

pivot
smallIndex

FIGURE 18-26

index

List before moving 58 into a sublist

For the list in Figure 18-26, list[index] is 58, which is greater than pivot. Therefore,
list[index] is to be moved into the upper sublist. This is accomplished by leaving 58 at
its position and increasing the size of the upper sublist by one, to the next array position.
After moving 58 into the upper sublist, the list is as shown in Figure 18-27.

lower sublist
52

13

32

48

22

upper sublist
11

87

55

78

96

58

66

88

45

pivot
smallIndex

FIGURE 18-27

index

List after moving 58 into the upper sublist

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Sort: Array-Based Lists

|

1303

After moving the elements that are less than pivot into the lower sublist and elements that
are greater than pivot into the upper sublist (that is, after completely executing Step 2), the
resulting list is as shown in Figure 18-28.

lower sublist
52

13

32

48

22

upper sublist

11

45

55

78

96

58

66

88

87

pivot

1
8

smallIndex

List elements after arranging into the lower sublist and upper sublist

FIGURE 18-28

Next, we execute Step 3 and move 52, pivot, to the proper position in the list.
This is accomplished by swapping 52 with 45. The resulting list is as shown in
Figure 18-29.

lower sublist
45

13

32

48

22

upper sublist
11

52

55

78

96

58

66

88

87

pivot

FIGURE 18-29

List after swapping 52 with 45

As shown in Figure 18-29, Steps 1, 2, and 3 in the preceding algorithm partition the list
into two sublists. The elements less than pivot are in the lower sublist; the elements
greater than or equal to pivot are in the upper sublist.
To partition the list into the lower and upper sublists, we need to keep track of only the
last element of the lower sublist and the next element of the list that needs to be moved
into either the lower sublist or the upper sublist. In fact, the upper sublist is between the
two indices smallIndex and index.
We now write the function, partition, to implement the preceding partition algorithm. After rearranging the elements of the list, the function partition returns the
location of pivot so that we can determine the starting and ending locations of the
sublists. The definition of the function partition is:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1304

| Chapter 18: Searching and Sorting Algorithms

template <class elemType>
int partition(elemType list[], int first, int last)
{
elemType pivot;
int index, smallIndex;
swap(list, first, (first + last) / 2);
pivot = list[first];
smallIndex = first;
for (index = first + 1; index <= last; index++)
if (list[index] < pivot)
{
smallIndex++;
swap(list, smallIndex, index);
}
swap(list, first, smallIndex);
return smallIndex;
} //end partition

Note that the formal parameters first and last specify the starting and ending
indices, respectively, of the sublist of the list to be partitioned. If first = 0 and
last ¼ length – 1, the entire list is partitioned.
As you can see from the definition of the function partition, certain elements of the list
need to be swapped. The following function, swap, accomplishes this task. (Notice that
this swap function is the same as the one given earlier in this chapter for the selection sort
algorithm.)
template <class elemType>
void swap(elemType list[], int first, int second)
{
elemType temp;
temp = list[first];
list[first] = list[second];
list[second] = temp;
} //end swap

Once the list is partitioned into lowerSublist and upperSublist, we again apply the
quick sort function to sort the two sublists. Because both sublists are sorted using the
same quick sort algorithm, the easiest way to implement this algorithm is to use recursion. Therefore, this section gives the recursive version of the quick sort algorithm. As
explained previously, after rearranging the elements of the list, the function partition
returns the index of pivot so that the starting and ending indices of the sublists can be
determined.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Sort: Array-Based Lists

|

1305

Given the starting and ending indices of a list, the following function, recQuickSort,
implements the recursive version of the quick sort algorithm:
template <class elemType>
void recQuickSort(elemType list[], int first, int last)
{
int pivotLocation;
if (first < last)
{
pivotLocation = partition(list, first, last);
recQuickSort(list, first, pivotLocation - 1);
recQuickSort(list, pivotLocation + 1, last);
}
} //end recQuickSort

Finally, we write the quick sort function, quickSort, that calls the function
recQuickSort on the original list:
template <class elemType>
void quickSort(elemType list[], int length)
{
recQuickSort(list, 0, length - 1);
} //end quickSort

We leave it as an exercise for you to write a program to test the quick sort algorithm. See
Programming Exercise 10 at the end of this chapter.

Analysis: Quick Sort
The general analysis of the quick sort algorithm is beyond the scope of this book.
However, let us determine the number of comparisons in the worst case. Suppose
that L is a list of n elements, n  0. In a quick sort, all of the sorting work is done by
the function partition. From the definition of the function partition, it follows
that to partition a list of length k, the function partition makes k – 1 key
comparisons. Also, in the worst case, after partition, one sublist is of length k – 1,
and the other sublist is of length 0.
It follows that in the worst case, the first call of the function partition makes n – 1
key comparisons. In the second call, the function partition partitions a list of length
n – 1, so it makes n – 2 key comparisons, and so on. We can now conclude that to sort a
list of length n, in the worst case, the total number of key comparisons made by a quick
sort is:
ðn  1Þ þ ðn  2Þ þ    þ 2 þ 1 ¼ nðn  1Þ=2 ¼ Oðn2 Þ:
Table 18-10 summarizes the behavior of the quick sort algorithm for a list of
length n.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1306

| Chapter 18: Searching and Sorting Algorithms

TABLE 18-10 Analysis of the Quick Sort Algorithm for a List of Length n

Number of Comparisons

Number of Swaps

Average case

(1.39)nlog2 n þ O(n) = O(nlog2 n)

(0.69)nlog2 n þ O(n) = O(nlog2 n)

Worst case

n2 n
 = O(n2)
2
2

n2 3n
þ
2 = O(n2)
2
2

Merge Sort: Linked List-Based Lists
In the previous section, we described the quick sort algorithm and stated that the averagecase behavior of a quick sort is O(nlog2n). However, the worst-case behavior of a quick
sort is O(n2). This section describes the sorting algorithm whose behavior is always
O(nlog2n).
Like the quick sort algorithm, the merge sort algorithm uses the divide-and-conquer
technique to sort a list. A merge sort algorithm also partitions the list into two sublists,
sorts the sublists, and then combines the sorted sublists into one sorted list. This section
describes the merge sort algorithm for linked list-based lists. We leave it for you to
develop the merge sort algorithm for array-based lists, which can be done by using the
techniques described for linked lists.
The merge sort and the quick sort algorithms differ in how they partition the list. As
discussed earlier, a quick sort first selects an element in the list, called pivot, and then
partitions the list so that the elements in one sublist are less than pivot and the elements
in the other sublist are greater than or equal to pivot. By contrast, a merge sort divides
the list into two sublists of nearly equal size. For example, consider the list whose
elements are as follows:
list: 35

28

18

45

62

48

30

38

The merge sort algorithm partitions this list into two sublists as follows:
first sublist: 35 28 18 45
second sublist: 62 48 30 38

The two sublists are sorted using the same algorithm (that is, a merge sort) used on the
original list. Suppose that we have sorted the two sublists. That is, suppose that the lists
are now as follows:
first sublist: 18 28 35 45
second sublist: 30 38 48 62

Next, the merge sort algorithm combines, that is, merges, the two sorted sublists into one
sorted list.
Figure 18-30 further illustrates the merge sort process.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Merge Sort: Linked List-Based Lists

35

35

28

18

28 18
divide

45

35 28
divide

35

18 45
divide

28

18

merge
28 35

18

FIGURE 18-30

45

merge
18 45

merge
28 35

18

45 62
divide

28

45

30

merge
35 38

48

30

62

48 30 38
divide

1307

38

62 48
divide

62

|

30 38
divide

48

30

merge
48 62

38

merge
30 38

30

merge
38 48

45

48

62

62

Merge sort algorithm

From Figure 18-30, it is clear that in the merge sort algorithm, most of the sorting work is
done in merging the sorted sublists.
The general algorithm for the merge sort is as follows:
if the list is of a size greater than 1
{
a. Divide the list into two sublists.
b. Merge sort the first sublist.
c. Merge sort the second sublist.
d. Merge the first sublist and the second sublist.
}

As remarked previously, after dividing the list into two sublists—the first sublist and the
second sublist—the two sublists are sorted using the merge sort algorithm. In other
words, we use recursion to implement the merge sort algorithm.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1308

| Chapter 18: Searching and Sorting Algorithms

We next describe the necessary algorithm to:
•
•
•

Divide the list into two sublists of nearly equal size.
Merge sort both sublists.
Merge the sorted sublists.

Divide
Because data is stored in a linked list, we do not know the length of the list. Furthermore,
a linked list is not a random access data structure. Therefore, to divide the list into two
sublists, we need to find the middle node of the list.
Consider the list in Figure 18-31.

head
65

FIGURE 18-31

18

85

95

25

20

45

75

30

Unsorted linked list

To find the middle of the list, we traverse the list with two pointers—say, middle and
current. The pointer middle is initialized to the first node of the list. Because this list
has more than two nodes, we initialize current to the third node. (Recall that we sort
the list only if it has more than one element because a list of size 1 is already sorted. Also,
if the list has only two nodes, we set current to nullptr.) Consider the list shown in
Figure 18-32.

head
65
middle

FIGURE 18-32

18

85

95

25

20

45

75

30

current

middle and current before traversing the list

Every time we advance middle by one node, we advance current by one node.
After advancing current by one node, if current is not nullptr, we again advance
current by one node. That is, for the most part, every time middle advances by one
node, current advances by two nodes. Eventually, current becomes nullptr
and middle points to the last node of the first sublist. For example, for the list in Figure
18-32, when current becomes nullptr, middle points to the node with info 25
(see Figure 18-33).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Merge Sort: Linked List-Based Lists

|

1309

head
65

18

85

95

25

20

45

75

30

middle

FIGURE 18-33

middle after traversing the list

It is now easy to divide the list into two sublists. First, using the link of middle, we assign
a pointer to the node following middle. Then, we set the link of middle to nullptr.
Figure 18-34 shows the resulting sublists.

head
65

18

85

95

25
middle

otherhead
20

FIGURE 18-34

45

75

30

List after dividing it into two lists

This discussion translates into the following C++ function, divideList:
template <class Type>
void unorderedLinkedList<Type>::
divideList(nodeType<Type>* first1,
nodeType<Type>* &first2)
{
nodeType<Type>* middle;
nodeType<Type>* current;
if (first1 == nullptr)
//list is empty
first2 = nullptr;
else if (first1->link == nullptr) //list has only one node
first2 = nullptr;
else
{
middle = first1;
current = first1->link;
if (current != nullptr)
//list has more than two nodes
current = current->link;
while (current != nullptr)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1310

| Chapter 18: Searching and Sorting Algorithms

{
middle = middle->link;
current = current->link;
if (current != nullptr)
current = current->link;
} //end while
//first2 points to the first
//node of the second sublist
middle->link = nullptr; //set the link of the last node
//of the first sublist to nullptr
} //end else
} //end divideList
first2 = middle->link;

Now that we know how to divide a list into two sublists of nearly equal size, next we
focus on merging the sorted sublists. Recall that in a merge sort, most of the sorting work
is done in merging the sorted sublists.

Merge
Once the sublists are sorted, the next step in the merge sort algorithm is to merge the
sorted sublists. Sorted sublists are merged into a sorted list by comparing the elements of
the sublists and then adjusting the pointers of the nodes with the smaller info. Let us
illustrate this procedure on the sublists shown in Figure 18-35. Suppose that first1
points to the first node of the first sublist, and first2 points to the first node of the
second sublist.

first1
18

25

65

85

20

30

45

75

95

first2

FIGURE 18-35

Sublists before merging

We first compare the info of the first node of each sublist to determine the first node of
the merged list. We set newHead to point to the first node of the merged list. We also use
the pointer lastMerged to keep track of the last node of the merged list. The pointer
of the first node of the sublist with the smaller node then advances to the next node of
that sublist. Figure 18-36 shows the sublist of Figure 18-35 after setting newHead and
lastMerged and advancing first1.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Merge Sort: Linked List-Based Lists

|

1311

first1

newHead
18

25

65

85

30

45

75

95

lastMerged
first2
20

FIGURE 18-36

Sublists after setting newHead and lastMerged and advancing first1

In Figure 18-36, first1 points to the first node of the first sublist that is yet to be
merged with the second sublist. So, we again compare the nodes pointed to by first1
and first2, and adjust the link of the smaller node and the last node of the merged list
so as to move the smaller node to the end of the merged list. For the sublists shown in
Figure 18-36, after adjusting the necessary links, we have Figure 18-37.

first1

newHead
18

25

65

85

95

45

75

first2
20

30

lastMerged

FIGURE 18-37

Merged list after putting the node with info 20 at the end of the merged list

We continue this process for the remaining elements of both sublists. Every time we move
a node to the merged list, we advance either first1 or first2 to the next node.
Eventually, either first1 or first2 becomes nullptr. If first1 becomes nullptr,
the first sublist is exhausted first, so we attach the remaining nodes of the second sublist at
the end of the partially merged list. If first2 becomes nullptr, the second sublist is
exhausted first, so we attach the remaining nodes of the first sublist at the end of the partially
merged list.
Following this discussion, we can now write the C++ function mergeList to merge the
two sorted sublists. The pointers of the first nodes of the sublists are passed as parameters
to the function mergeList.
template <class Type>
nodeType<Type>* unorderedLinkedList<Type>::
mergeList(nodeType<Type>* first1,
nodeType<Type>* first2)
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1312

| Chapter 18: Searching and Sorting Algorithms

{
nodeType<Type> *lastSmall; //pointer to the last node of
//the merged list
nodeType<Type> *newHead;
//pointer to the merged list
if (first1 == nullptr)
//the first sublist is empty
return first2;
else if (first2 == nullptr)
//the second sublist is empty
return first1;
else
{
if (first1->info < first2->info) //compare the
//first nodes
{
newHead = first1;
first1 = first1->link;
lastSmall = newHead;
}
else
{
newHead = first2;
first2 = first2->link;
lastSmall = newHead;
}
while (first1 != nullptr && first2 != nullptr)
{
if (first1->info < first2->info)
{
lastSmall->link = first1;
lastSmall = lastSmall->link;
first1 = first1->link;
}
else
{
lastSmall->link = first2;
lastSmall = lastSmall->link;
first2 = first2->link;
}
} //end while
if (first1 == nullptr) //first sublist is exhausted first
lastSmall->link = first2;
else
//second sublist is exhausted first
lastSmall->link = first1;
return newHead;
}
}//end mergeList

Finally, we write the recursive merge sort function, recMergeSort, which uses the
divideList and mergeList functions to sort a list. The pointer of the first node of the
list to be sorted is passed as a parameter to the function recMergeSort.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Merge Sort: Linked List-Based Lists

|

1313

template <class Type>
void unorderedLinkedList<Type>::recMergeSort(
nodeType<Type>* &head)
{
nodeType<Type> *otherHead;
if (head != nullptr) //if the list is not empty
if (head->link != nullptr) //if the list has more than
//one node
{
divideList(head, otherHead);
recMergeSort(head);
recMergeSort(otherHead);
head = mergeList(head, otherHead);
}
} //end recMergeSort

We can now give the definition of the function mergeSort, which should be included as
a public member of the class unorderedLinkedList. (Note that the functions
divideList, merge, and recMergeSort can be included as private members of the
class unorderedLinkedList because these functions are used only to implement the
function mergeSort.) The function mergeSort calls the function recMergeSort and
passes first to this function. It also sets last to point to the last node of the list. The
definition of the function mergeSort is:
template <class Type>
void unorderedLinkedList<Type>::mergeSort()
{
recMergeSort(first);
if (first == nullptr)
last = nullptr;
else
{
last = first;
while (last->link != nullptr)
last = last->link;
}
} //end mergeSort

We leave it as an exercise for you to write a program to test the merge sort algorithm. See
Programming Exercise 13 at the end of this chapter.

Analysis: Merge Sort
Suppose that L is a list of n elements, in which n > 0. Suppose that n is a power of 2, that
is, n ¼ 2m for some nonnegative integer m, so that we can divide the list into two sublists,
each of size:
n 2m
¼ 2m1 :
¼
2
2
Moreover, each sublist can also be divided into two sublists of the same size. Each call to the
function recMergeSort makes two recursive calls to the function recMergeSort, and each
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1314

| Chapter 18: Searching and Sorting Algorithms

call divides the sublist into two sublists of the same size. Suppose that m ¼ 3, that is, n ¼ 23 ¼ 8.
So, the length of the original list is 8. The first call to the function recMergeSort divides the
original list into two sublists, each of size 4. The first call then makes two recursive calls to the
function recMergeSort. Each of these recursive calls divides each sublist, of size 4, into two
sublists, each of size 2. We now have four sublists, each of size 2. The next set of recursive calls
divides each sublist, of size 2, into sublists of size 1. So, we now have eight sublists, each of size 1.
It follows that the exponent 3 in 23 indicates the level of the recursion (see Figure 18-38).

Recursion Level: 0
Number of calls to recMergeSort: 1
Each call: recMergeSort 8 elements

8

4

2

1

2

1

FIGURE 18-38

Recursion Level: 1
Number of calls to recMergeSort: 2
Each call: recMergeSort 4 elements

4

1

2

1

1

Recursion Level: 2
Number of calls to recMergeSort: 4
Each call: recMergeSort 2 elements

2

1

1

1

Recursion Level: 3
Number of calls to recMergeSort: 8
Each call: recMergeSort 1 element

Levels of recursion to recMergeSort for a list of length 8

Let us consider the general case when n = 2m. Note that the number of recursion levels
is m. Also, note that to merge a sorted list of size s with a sorted list of size t, the maximum
number of comparisons is s + t  1.
Consider the function mergeList, which merges two sorted lists into a sorted list. Note that
this is where the actual work (comparisons and assignments) is done. The initial call to the
function recMergeSort, at level 0, produces two sublists, each of the size n/2. To merge
these two lists, after they are sorted, the maximum number of comparisons is:
n
n
þ  1 ¼ n  1 ¼ OðnÞ:
2
2
At level 1, we merge two sets of sorted lists, in which each sublist is of the size n/4. To merge
two sorted sublists, each of the size n/4, we need, at most:
n
n
n
þ 1¼ 1
4
4
2
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Merge Sort: Linked List-Based Lists

|

1315

comparisons. Thus, at level 1 of the recursion, the number of comparisons is 2(n / 2 – 1) ¼
n – 2 ¼ O(n). In general, at level k of the recursion, there are a total of 2k calls to the function
k+1
mergeList. Each of these calls merges two sublists, each of the size n / 2
, which requires
k
a maximum of n / 2  1 comparisons. Thus, at level k of the recursion, the maximum
number of comparisons is:
2k

n
2k


 1 ¼ n  2k ¼ OðnÞ:

It now follows that the maximum number of comparisons at each level of the recursion is O(n).
Because the number of levels of the recursion is m, the maximum number of comparisons
made by the merge sort algorithms is O(nm). Now n ¼ 2m implies that m ¼ log2n. Hence, the
maximum number of comparisons made by the merge sort algorithm is O(n log2n).
If W(n) denotes the number of key comparisons in the worst case to sort L, then
W(n) ¼ O(n log2n).
Let A(n) denote the number of key comparisons in the average case. In the average case,
during merge, one of the sublists will exhaust before the other list. From this, it follows that,
on average, when merging two sorted sublists of combined size n, the number of comparisons
will be less than n  1. On average, it can be shown that the number of comparisons for
merge sort is given by the following equation: If n is a power of 2, A(n) ¼ n log2n  1.25n ¼
O(n log2n). This is also a good approximation when n is not a power of 2.
We can also obtain an analysis of the merge sort algorithm by constructing and solving
certain equations as follows. As noted before, in merge sort, all of the comparisons are
made in the procedure mergeList, which merges two sorted sublists. If one sublist is of
size s and the other sublist is of size t, then merging these lists would require, at most,
s þ t  1 comparisons in the worst case. Hence:
W ðnÞ ¼ W ðsÞ þ W ðtÞ þ s þ t  1:
Note that s = n / 2 and t = n / 2. Suppose that n = 2m. Then, s = 2m1 and t = 2m1. It
follows that s þ t = n. Hence:
W ðnÞ ¼ W ðn=2Þ þ W ðn=2Þ þ n  1 ¼ 2W ðn=2Þ þ n  1; n > 0:
Also:
W ð1Þ ¼ 0:
It is known that when n is a power of 2, W(n) is given by the following equation:
W ðnÞ ¼ n log2 n  ðn  1Þ ¼ Oðn log2 nÞ:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1316

| Chapter 18: Searching and Sorting Algorithms

(Heap Sort) This chapter also discusses the heap sort algorithm. The necessary material
is in the file Heap_Sort.pdf. The file is available at www.cengagebrain.com. To find the
file, navigate to the book’s page by typing in the ISBN of this text and then click on
Free Materials.

PROGRAMMING EXAMPLE:

Election Results

The presidential election for the student council of your local university is about to
be held. The chair of the election committee wants to computerize the voting and
has asked you to write a program to analyze the data and report the winner.
Watch
the Video

The university has four major divisions, and each division has several departments.
For the election, the four divisions are labeled as region 1, region 2, region 3, and
region 4. Each department in each division handles its own voting and reports the
votes received by each candidate to the election committee. The voting is reported in
the following form:
firstName lastName regionNumber numberOfVotes

The election committee wants the output in the following tabular form:
--------------------Election Results--------------------

Candidate Name
-----------------Sheila
Bower
Danny
Dillion
Lisa
Fisher
Greg
Goldy
Peter
Lamba
Mickey
Miller

Region1
------23
25
110
75
285
112

Region2
------70
71
158
34
56
141

Votes
Region3
------133
156
0
134
0
156

Region4
------267
97
0
0
46
67

Total
-----493
349
268
243
387
476

Winner: Sheila Bower, Votes Received: 493
Total votes polled: 2216

The names of the candidates must be in alphabetical order in the output.
For this program, we assume that six candidates are seeking the student council’s
president post. This program can be enhanced to handle any number of candidates.
The data are provided in two files. One file, candData.txt, consists of the names of
the candidates seeking the president’s post. The names of the candidates in this file are
in no particular order. In the second file, voteData.txt, each line consists of the
voting results in the following form:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Election Results

|

1317

firstName lastName regionNumber numberOfVotes

Each line in the file voteData.txt consists of the candidate’s name, the region number,
and the number of votes received by the candidate in that region. There is one entry per
line. For example, the input file containing the voting data looks like the following:
Greg Goldy 2 34
Mickey Miller 1 56
Lisa Fisher 2 56
Peter Lamba 1 78
Danny Dillion 4 29
Sheila Bower 4 78
.
.
.

The first line indicates that Greg Goldy received 34 votes from region 2.

PROBLEM
ANALYSIS
AND
ALGORITHM
DESIGN

Input

Two files: One containing the candidates’ names and the other containing the
voting data, as described previously.

Output

The election results in a tabular form, as described previously, and the winner’s name.

From the output, it is clear that the program must organize the voting data by region
and calculate the total votes received by each candidate and polled for the election
overall. Furthermore, the names of the candidates must appear in alphabetical order.

The main component of this program is a candidate. Therefore, first we will design the
class candidateType to implement a candidate object. Moreover, in this program,
we use an array of candidateType object to implement the list of candidates.
Every candidate has a name and receives votes. Because there are four regions, we
can use an array of four components. In Example 10-10 (Chapter 10), we designed
the class personType to implement the name of a person. Recall that an object of
type personType can store the first name and the last name. Now that we have
discussed operator overloading, we redesign the class personType and define the
relational operators so that the names of two people can be compared. We will also
overload the assignment operator for easy assignment and use the stream extraction
and insertion operators for input/output. Because every candidate is a person, we will
derive the class candidateType from the class personType.
personType

The class personType implements the first name and last name of a person.
Therefore, the class personType has two member variables: firstName to store
the first name and lastName to store the last name. We declare these as protected so
that the definition of the class personType can be easily extended to accommodate
the requirements of a specific application needed to implement a person’s name. The
definition of the class personType is given next.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1318

| Chapter 18: Searching and Sorting Algorithms

//************************************************************
// Author: D.S. Malik
//
// class personType
// This class specifies the members to implement a person's
// name. It overloads the stream insertion and extraction
// operators and relational operators for comparison.
//************************************************************
#include <string>
using namespace std;
class personType
{
friend istream& operator>>(istream&, personType&);
friend ostream& operator<<(ostream&, const personType&);
public:
void setName(string first, string last);
//Function to set firstName and lastName according
//to the parameters.
//Postcondition: firstName = first; lastName = last
string getFirstName() const;
//Function to return the first name.
//Postcondition: The value of firstName is returned.
string getLastName() const;
//Function to return the last name.
//Postcondition: The value of lastName is returned.
personType(string first = "", string last = "");
//Constructor
//Sets firstName and lastName according to the
//parameters. The default values of the parameters are
//empty strings.
//Postcondition: firstName = first; lastName = last
//overload the relational operators
operator==(const personType& right) const;
operator!=(const personType& right) const;
operator<=(const personType& right) const;
operator<(const personType& right) const;
operator>=(const personType& right) const;
operator>(const personType& right) const;

bool
bool
bool
bool
bool
bool

protected:
string firstName; //variable to store the first name
string lastName; //variable to store the last name
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Election Results

|

1319

We now give the definitions of the functions to implement the various operations of
the class personType.
The definitions of the member functions setName, getFirstName, getLastName,
and the constructors are the same as those given in Chapter 10. We, therefore, consider
the definitions of the functions to overload the relational and stream operators.
The names of two people are the same if their first and last names are the same.
Therefore, the definition of the function to overload the equality operator is:
bool personType::operator==(const personType& right) const
{
return (firstName == right.firstName
&& lastName == right.lastName);
}

The names of two people are different if either their first or last names are different.
Therefore, the definition of the function to overload the not equal to operator is:
bool personType::operator!=(const personType& right) const
{
return (firstName != right.firstName
|| lastName != right.lastName);
}

Similarly, the definitions of the functions to overload the remaining relational
operators are:
bool personType::operator<=(const personType& right) const
{
return (lastName <= right.lastName ||
(lastName == right.lastName &&
firstName <= right.firstName));
}
bool personType::operator<(const personType& right) const
{
return (lastName < right.lastName ||
(lastName == right.lastName &&
firstName < right.firstName));
}
bool personType::operator>=(const personType& right) const
{
return (lastName >= right.lastName ||
(lastName == right.lastName &&
firstName >= right.firstName));
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1320

| Chapter 18: Searching and Sorting Algorithms

bool personType::operator>(const personType& right) const
{
return (lastName > right.lastName ||
(lastName == right.lastName &&
firstName > right.firstName));
}

The definitions of the functions to overload the stream extraction and insertion
operators are given next.
istream& operator>>(istream& isObject, personType& pName)
{
isObject >> pName.firstName >> pName.lastName;
return isObject;
}
ostream& operator<<(ostream& osObject, const personType& pName)
{
osObject << pName.firstName << " " << pName.lastName;
return osObject;
}

Candidate

As remarked previously, the main component of this program is candidate. Every
candidate has a name and can receive votes. Because there are four regions, we can
use an array of four components to store the votes received.
There are six candidates. Therefore, we declare a list of six candidates of type
candidateType. This chapter extended the class unorderedArrayListType by
illustrating how to include the searching and sorting algorithms developed in
this chapter. We will use this class to maintain the list of candidates. This list of
candidates will be sorted and searched. Therefore, we must define (that is, overload)
the assignment and relational operators for the class candidateType because these
operators are used by the searching and sorting algorithms.
Data in the file containing the candidates’ data consists of only the names of the
candidates. Therefore, in addition to overloading the assignment operator so that
the value of one object can be assigned to another object, we also overload the
assignment operator for the class candidateType so that only the name (of
the personType) of the candidate can be assigned to a candidate object. That is, we
overload the assignment operator twice: once for objects of type candidateType
and once for objects of types candidateType and personType.
//*************************************************************
// Author: D.S. Malik
//
// class candidateType
// This class specifies the members to implement the properties

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Election Results

|

1321

// of a candidate. It overloads the assignment operator
// and relational operators for comparison.
//*************************************************************
#include <string>
#include "personType.h"
const int NO_OF_REGIONS = 4;
class candidateType: public personType
{
public:
const candidateType& operator=(const candidateType&);
//Overload the assignment operator for objects of the
//type candidateType.
const candidateType& operator=(const personType&);
//Overload the assignment operator for objects so that
//the value of an object of type personType can be
//assigned to an object of type candidateType.
void updateVotesByRegion(int region, int votes);
//Function to update the votes of a candidate for a
//particular region.
//Postcondition: Votes for the region specified by
//
the parameter are updated by adding
//
the votes specified by the parameter
//
votes.
void setVotes(int region, int votes);
//Function to set the votes of a candidate for a
//particular region.
//Postcondition: Votes for the region specified by
//
the parameter region are set to the votes
//
specified by the parameter votes.
void calculateTotalVotes();
//Function to calculate the total votes received by a
//candidate.
//Postcondition: The votes in each region are added
//
and assigned to totalVotes.
int getTotalVotes() const;
//Function to return the total votes received by a
//candidate.
//Postcondition: The value of totalVotes is returned.
void printData() const;
//Function to output the candidate's name, the votes
//received in each region, and the total votes received.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1322

| Chapter 18: Searching and Sorting Algorithms

candidateType();
//Default constructor.
//Postcondition: Candidate's
//
blanks, the
//
region, and
//
initialized

name is initialized to
number of votes in each
the total votes are
to 0.

//Overload the relational operators.
operator==(const candidateType& right) const;
operator!=(const candidateType& right) const;
operator<=(const candidateType& right) const;
operator<(const candidateType& right) const;
operator>=(const candidateType& right) const;
operator>(const candidateType& right) const;

bool
bool
bool
bool
bool
bool

private:
int votesByRegion[NO_OF_REGIONS];

//array to store the
//votes received in
//each region
int totalVotes; //variable to store the total votes

};

Figure 18-39 shows the UML diagram of the class candidateType.

candidateType
-votesByRegion[NO_OF_REGIONS]:int
-totalVotes: int
+operator=(const candidateType&):
const candidateType&
+operator=(const personType&):
const candidateType&
+updateVotesByRegion(int, int): void
+setVotes(int, int): void
+calculateTotalVotes(): void
+getTotalVotes() const: int
+printData() const: void
+candidateType()
+operator==(const candidateType&) const: bool
+operator!=(const candidateType&) const: bool
+operator<=(const candidateType&) const: bool
+operator<(const candidateType&) const: bool
+operator>=(const candidateType&) const: bool
+operator>(const candidateType&) const: bool

FIGURE 18-39

personType

candidateType

UML class diagram of class candidateType

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Election Results

|

1323

The definitions of the functions of the class candidateType are given next.
To set the votes of a particular region, the region number and the number of votes
are passed as parameters to the function setVotes. Because an array index starts at 0,
region 1 corresponds to the array component at position 0, and so on. Therefore, to
set the value of the correct array component, 1 is subtracted from the region. The
definition of the function setVotes is:
void candidateType::setVotes(int region, int votes)
{
votesByRegion[region - 1] = votes;
}

To update the votes for a particular region, the region number and the number of
votes for that region are passed as parameters. The votes are then added to the
region’s previous value. The definition of the function updateVotesByRegion is:
void candidateType::updateVotesByRegion(int region, int votes)
{
votesByRegion[region - 1] = votesByRegion[region - 1]
+ votes;
}

The definitions of the functions calculateTotalVotes, getTotalVotes,
printData, and the default constructor are quite straightforward and are given next.
void candidateType::calculateTotalVotes()
{
int i;
totalVotes = 0;
for (i = 0; i < NO_OF_REGIONS; i++)
totalVotes += votesByRegion[i];
}
int candidateType::getTotalVotes() const
{
return totalVotes;
}
void candidateType::printData() const
{
cout << left
<< setw(8) << firstName << " "
<< setw(8) << lastName << " ";
cout << right;
for (int i = 0; i < NO_OF_REGIONS; i++)
cout << setw(8) << votesByRegion[i] << " ";
cout << setw(7) << totalVotes << endl;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1324

| Chapter 18: Searching and Sorting Algorithms

candidateType::candidateType()
{
for (int i = 0; i < NO_OF_REGIONS; i++)
votesByRegion[i] = 0;
totalVotes = 0;
}

To overload the relational operators for the class candidateType, the names of the
candidates are compared. For example, two candidates are the same if they have the same
name. The definitions of these functions are similar to the definitions of the functions to
overload the relational operators for the class personType and are given next.
bool candidateType::operator==(const candidateType& right) const
{
return (firstName == right.firstName
&& lastName == right.lastName);
}
bool candidateType::operator!=(const candidateType& right) const
{
return (firstName != right.firstName
|| lastName != right.lastName);
}
bool candidateType::operator<=(const candidateType& right) const
{
return (lastName <= right.lastName ||
(lastName == right.lastName &&
firstName <= right.firstName));
}
bool candidateType::operator<(const candidateType& right) const
{
return (lastName < right.lastName ||
(lastName == right.lastName &&
firstName < right.firstName));
}
bool candidateType::operator>=(const candidateType& right) const
{
return (lastName >= right.lastName ||
(lastName == right.lastName &&
firstName >= right.firstName));
}
bool candidateType::operator>(const candidateType& right) const
{
return (lastName > right.lastName ||
(lastName == right.lastName &&
firstName > right.firstName));
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Election Results

|

1325

const candidateType& candidateType::operator=
(const candidateType& right)
{
if (this != &right) // avoid self-assignment
{
firstName = right.firstName;
lastName = right.lastName;
for (int i = 0; i < NO_OF_REGIONS; i++)
votesByRegion[i] = right.votesByRegion[i];
totalVotes = right.totalVotes;
}
return *this;
}
const candidateType& candidateType::operator=
(const personType& right)
{
firstName = right.getFirstName();
lastName = right.getLastName();
return *this;
}
MAIN PROGRAM

Now that the class candidateType has been designed and implemented, we focus
on designing the main program.
Because there are six candidates, we create a list, candidateList, containing six
components of type candidateType. The first thing that the program should do is
read each candidate’s name from the file candData.txt into the list candidateList.
Then, we sort candidateList.
The next step is to process the voting data from the file voteData.txt, which holds
the voting data. After processing the voting data, the program should calculate the
total votes received by each candidate and print the data, as shown previously. Thus,
the general algorithm is:
1.
2.
3.
4.
5.

Read each candidate’s name into candidateList.
Sort candidateList.
Process the voting data.
Calculate the total votes received by each candidate.
Print the results.

The following statement creates the object candidateList.
unorderedArrayListType<candidateType> candidateList(NO_OF_CANDIDATES);

Figure 18-40 shows the object candidateList. Every component of the array list
is an object of type candidateType.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1326

| Chapter 18: Searching and Sorting Algorithms

candidateList
list
list[0]
list[1]

list[0]

list[2]
list[3]

firstName

list[4]

lastName

list[5]

votesByRegion

0

totalVotes

0

length

6

maxSize

6

FIGURE 18-40

0

0

0

candidateList

In Figure 18-40, the array votesByRegion and the variable totalVotes are initialized to
0 by the default constructor of the class candidateType. To save space, whenever
needed, we will draw the object candidateList, as shown in Figure 18-41.

candidateList
list
list[0]

0

0

0

0

0

list[1]

0

0

0

0

0

list[2]

0

0

0

0

0

list[3]

0

0

0

0

0

list[4]

0

0

0

0

0

list[5]

0

0

0

0

0

length

6

maxSize

6

FIGURE 18-41

candidateList

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Election Results

fillNames

|

1327

The first thing that the program must do is read the candidates’ names into
candidateList. Therefore, we write a function to accomplish this task. The
file candData.txt is opened in the function main. The names of the input file
and candidateList are, therefore, passed as parameters to the function
fillNames. Because the member variable list of the object candidateList is
protected, it cannot be accessed directly. We, therefore, create an object temp
of type candidateType to store the candidates’ names and use the function
insertEnd (of list) to store each candidate’s name in the object candidateList.
The definition of the function fillNames follows:
void fillNames(ifstream& inFile,
unorderedArrayListType<candidateType>& cList)
{
string firstN;
string lastN;
int i;
candidateType temp;
for (i = 0; i < NO_OF_CANDIDATES; i++)
{
inFile >> firstN >> lastN;
temp.setName(firstN, lastN);
cList.insertEnd(temp);
}
}

Figure 18-42 shows the object candidateList after a call to the function fillNames.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1328

| Chapter 18: Searching and Sorting Algorithms

candidateList
list

FIGURE 18-42

Sort Names

list[0]

Greg

Goldy

0

0

0

0

0

list[1]

Mickey

Miller

0

0

0

0

0

list[2]

Lisa

Fisher

0

0

0

0

0

list[3]

Peter

Lamba

0

0

0

0

0

list[4]

Danny

Dillion

0

0

0

0

0

list[5]

Sheila

Bower

0

0

0

0

0

length

6

maxSize

6

Object candidateList after a call to the function fillNames

After reading the candidates’ names, we next sort the array list of the object
candidateList using any of the (array-based) sorting algorithms discussed in this
chapter. Because candidateList is an object of type unorderedArrayListType,
we use the member function sort to sort candidateList. (For illustration purposes,
we use selection sort in the function sort. In fact, you can use any array-based sorting
algorithm discussed in this chapter.) The following statement accomplishes this task:
candidateList.sort();

After this statement executes, candidateList is as shown in Figure 18-43.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Election Results

|

1329

candidateList
list

FIGURE 18-43

Process
Voting Data

list[0]

Sheila

Bower

0

0

0

0

0

list[1]

Danny

Dillion

0

0

0

0

0

list[2]

Lisa

Fisher

0

0

0

0

0

0

0

0

0

list[3]

Greg

Goldy

0

list[4]

Peter

Lamba

0

0

0

0

0

list[5]

Mickey

Miller

0

0

0

0

0

length

6

maxSize

6

Object candidateList after the statement candidateList.sort(); executes

Processing the voting data is quite straightforward. Each entry in the file
voteData.txt is of the form:
firstName lastName regionNumber numberOfVotes

After reading an entry from the file voteData.txt, we locate the row in the array
list (of the object candidateList) corresponding to the specific candidate and
update the entry specified by regionNumber.
The component votesByRegion is a private member of each component of the
array list. Moreover, list is a private member of candidateList. The only
way we can update the votes of a candidate is to make a copy of that candidate’s
record into a temporary object, update the object, and then copy the temporary
object back into list by replacing the old value with the new value of the
temporary object. We can use the member function retrieveAt to make a copy of
the candidate whose votes need to be updated. After updating the temporary object,
we can use the member function replaceAt to copy the temporary object back into
the list. Suppose the next entry read is:
Lisa Fisher 2 35

This entry says that Lisa Fisher received 35 votes from region 2. Suppose that
before processing this entry, candidateList is as shown in Figure 18-44.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1330

| Chapter 18: Searching and Sorting Algorithms

candidateList
list

FIGURE 18-44

list[0]

Sheila

Bower

0

0

50

0

0

list[1]

Danny

Dillion

10

0

56

0

0

list[2]

Lisa

Fisher

76

13

0

0

0

list[3]

Greg

Goldy

0

45

0

0

0

list[4]

Peter

Lamba

80

0

0

0

0

list[5]

Mickey

Miller

100

0

0

20

0

length

6

maxSize

6

Object candidateList before processing entry Lisa Fisher 2 35

We make a copy of the row corresponding to Lisa Fisher (see Figure 18-45).

region

temp

FIGURE 18-45

Lisa

Fisher

76

13

0

0

0

Object temp

Next, the following statement updates the voting data for region 2. (Here, region = 2
and votes = 35.)
temp.updateVotesByRegion(region, votes);

After this statement executes, the object temp is as shown in Figure 18-46.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Election Results

|

1331

region

temp

FIGURE 18-46

Lisa

Fisher

76

48

0

0

0

Object temp after temp.updateVotesByRegion(region,votes); executes

1
8

Now we copy the object temp into list (see Figure 18-47).

candidateList
list

FIGURE 18-47

list[0]

Sheila

Bower

0

0

50

0

0

list[1]

Danny

Dillion

10

0

56

0

0

list[2]

Lisa

Fisher

76

48

0

0

0

list[3]

Greg

Goldy

0

45

0

0

0

list[4]

Peter

Lamba

80

0

0

0

0

list[5]

Mickey

Miller

100

0

0

20

0

length

6

maxSize

6

candidateList after copying temp

Because the member list of candidateList is sorted, we can use the binary search
algorithm to find the row position in list corresponding to the candidate whose votes
need to be updated. Essentially, the definition of the function processVotes is:
void processVotes(ifstream& inFile,
unorderedArrayListType<candidateType>& cList)
{
string firstN;
string lastN;
int region;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1332

| Chapter 18: Searching and Sorting Algorithms

int votes;
int candLocation;
candidateType temp;
inFile >> firstN >> lastN >> region >> votes;
temp.setName(firstN, lastN);
temp.setVotes(region, votes);
while (inFile)
{
candLocation = cList.binSearch(temp);
if (candLocation != -1)
{
cList.retrieveAt(candLocation, temp);
temp.updateVotesByRegion(region, votes);
cList.replaceAt(candLocation, temp);
}
inFile >> firstN >> lastN >> region >> votes;
temp.setName(firstN, lastN);
temp.setVotes(region, votes);
}
}

Add Votes

After processing the voting data, the next step is to find the total votes received by
each candidate. This is done by adding the votes received in each region.
Now votesByRegion is a private member of candidateType, and list is a
protected member of candidateList. Therefore, to add the votes for each
candidate, we use the function retrieveAt to make a temporary copy of each
candidate’s data, add the votes in the temporary object, and then copy the temporary
object back into candidateList. The following function does this:
void addVotes(unorderedArrayListType<candidateType>& cList)
{
int i;
candidateType temp;
for (i = 0; i < NO_OF_CANDIDATES; i++)
{
cList.retrieveAt(i, temp);
temp.calculateTotalVotes();
cList.replaceAt(i, temp);
}
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Election Results

|

1333

Figure 18-48 shows candidateList after adding the votes for each candidate—that
is, after a call to the function addVotes.

candidateList
list

FIGURE 18-48

Print
Heading and
Print Results

list[0]

Sheila

Bower

23

70 133 267

493

list[1]

Danny

Dillion

25

71 156 97

349

list[2]

Lisa

Fisher

110 158

list[3]

Greg

Goldy

75

list[4]

Peter

Lamba

285 56

list[5]

Mickey

Miller

length

6

maxSize

6

0

0

268

0

243

46

387

112 141 156 67

476

34 134
0

candidateList after a call to the function addVotes

To complete the program, we include a function to print the heading, which
outputs the first four lines of the output. The following function accomplishes this
task:
void printHeading()
{
cout << "
--------------------Election Results---------"
<< "-----------" << endl << endl;
cout << "
Votes" << endl;
cout << " Candidate Name
Region1 Region2 Region3 "
<< "Region4
Total"<<endl;
cout << "------------------ ------- ------- "
<< "------- ------- ------" << endl;
}

We now describe the function printResults, which prints the results. Suppose that
the variable sumVotes holds the total votes polled for the election, the variable
largestVotes holds the largest number of votes received by a candidate, and the
variable winLoc holds the index of the winning candidate in the array list. Further

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1334

| Chapter 18: Searching and Sorting Algorithms

suppose that temp is an object of type candidateType. The algorithm for this
function is:
1. Initialize sumVotes, largestVotes, and winLoc to zero.
2. For each candidate:
a. Retrieve the candidate’s data into temp.
b. Print the candidate’s name and relevant data.
c. Retrieve the total votes received by the candidate and update
sumVotes.
d. if (largestVotes < temp.getTotalVotes())
{
largestVotes = temp.getTotalVotes();
winLoc = i;
}

3. Output the final lines of output.
We leave the definition of the function printResults as an exercise. (See Programming Exercise 18.)
PROGRAM LISTING (MAIN PROGRAM)
//*************************************************************
// Author: D.S. Malik
//
// This program processes voting data for the student council
// president’s post. It outputs each candidate's name and the
// votes they received. The name of the winner is also printed.
//*************************************************************
#include
#include
#include
#include
#include

<iostream>
<string>
<fstream>
"candidateType.h"
"unorderedArrayListType.h"

using namespace std;
const int NO_OF_CANDIDATES = 6;
void fillNames(ifstream& inFile,
unorderedArrayListType<candidateType>& cList);
void processVotes(ifstream& inFile,
unorderedArrayListType<candidateType>& cList);
void addVotes(unorderedArrayListType<candidateType>& cList);
void printHeading();
void printResults
(const unorderedArrayListType<candidateType>& cList);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: Election Results

|

1335

int main()
{
unorderedArrayListType<candidateType>
candidateList(NO_OF_CANDIDATES);
candidateType temp;
ifstream inFile;
inFile.open("candData.txt");
if (!inFile)
{
cout << "Input file (candData.txt) does not exist. "
<< "Program terminates!!" << endl;
return 1;
}
fillNames(inFile, candidateList);
candidateList.sort();
inFile.close();
inFile.clear();
inFile.open("voteData.txt");
if (!inFile)
{
cout << "Input file (voteData.txt) does not exist. "
<< "Program terminates!!" << endl;
return 1;
}
processVotes(inFile, candidateList);
addVotes(candidateList);
printHeading();
printResults(candidateList);
return 0;
}
//Place the definitions of the functions fillNames,
//addVotes, processVotes, and printHeading here. Also, write and place
//the definition of the function printResults here.

Sample Run: After you have written the definitions of the functions of the class
candidateType and of the function printResults and then run your program, it
should produce the following output. (See Programming Exercise 18.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1336

| Chapter 18: Searching and Sorting Algorithms

--------------------Election Results--------------------

Candidate Name
-----------------Sheila
Bower
Danny
Dillion
Lisa
Fisher
Greg
Goldy
Peter
Lamba
Mickey
Miller

Region1
------23
25
110
75
285
112

Region2
------70
71
158
34
56
141

Votes
Region3
------133
156
0
134
0
156

Region4
------267
97
0
0
46
67

Total
-----493
349
268
243
387
476

Winner: Sheila Bower, Votes Received: 493
Total votes polled: 2216

Input Files candData.txt
Greg Goldy
Mickey Miller
Lisa Fisher
Peter Lamba
Danny Dillion
Sheila Bower
voteData.txt
Greg Goldy 2 34
Mickey Miller 1 56
Lisa Fisher 2 56
Peter Lamba 1 78
Danny Dillion 4 29
Sheila Bower 4 78
Mickey Miller 2 63
Lisa Fisher 1 23
Peter Lamba 2 56
Danny Dillion 1 25
Sheila Bower 2 70
Peter Lamba 4 23
Danny Dillion 4 12
Greg Goldy 3 134
Sheila Bower 4 100
Mickey Miller 3 67
Lisa Fisher 2 67
Danny Dillion 3 67
Sheila Bower 1 23
Mickey Miller 1 56
Lisa Fisher 2 35
Sheila Bower 3 78
Peter Lamba 1 27
Danny Dillion 2 34

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

1337

Greg Goldy 1 75
Peter Lamba 4 23
Sheila Bower 3 55
Mickey Miller 4 67
Peter Lamba 1 23
Danny Dillion 3 89
Mickey Miller 3 89
Peter Lamba 1 67
Danny Dillion 2 37
Sheila Bower 4 89
Mickey Miller 2 78
Lisa Fisher 1 87
Peter Lamba 1 90
Danny Dillion 4 56

QUICK REVIEW
1.

2.
3.

4.
5.
6.
7.
8.
9.
10.

11.

The sequential search algorithm searches the list for a given item, starting
with the first element in the list. It continues to compare the search item
with the elements in the list until either the item is found or no more
elements are left in the list with which it can be compared.
On average, the sequential search algorithm searches half of the list.
For a list of length n, in a successful search, on average, the sequential search
nþ1
makes
¼ OðnÞ comparisons.
2
A sequential search is not efficient for large lists.
A binary search is much faster than a sequential search.
A binary search requires the list elements to be in order, that is, sorted.
To search for an item in a list of length 1024, a binary search requires no
more than 11 iterations of the loop, and so no more than 22 comparisons.
For a list of length n, in a successful search, on average, the binary search
makes 2log2n  3 key comparisons.
Let f be a function of n. By the term asymptotic, we mean the study of the
function f as n becomes larger and larger without bound.
Let f and g be real-valued functions. Assume that f and g are nonnegative,
that is, for all real numbers n, f(n)  0 and g(n)  0. We say that f(n) is
Big-O of g(n), written f(n) = O(g(n)), if there exist positive constants c and
n0 such that f(n)  cg(n) for all n  n0.
Let f(n) be a nonnegative, real-valued function such that f(n) = amnm þ
am1nm1 þ    þa1n þ a0, wherein ais are real numbers, am 6¼ 0, n  0,
and m is a nonnegative integer. Then, f(n) = O(nm).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1338

12.

13.
14.
15.

16.
17.

18.

19.

20.
21.

22.
23.
24.
25.
26.

| Chapter 18: Searching and Sorting Algorithms

Let L be a list of size n > 1. Suppose that the elements of L are sorted. If
SRH(n) is the minimum number of comparisons needed, in the worst case,
by using a comparison-based algorithm to recognize whether an element x
is in L, then SRH(n)  log2(n + 1).
The binary search algorithm is the optimal worst-case algorithm for solving
search problems by using the comparison method.
To construct a search algorithm of the order less than log2n, it cannot be
comparison based.
nðn  1Þ
For a list of length n, on average, the bubble sort algorithm makes
2
nðn  1Þ
item assignments.
key comparisons and about
4
The selection sort algorithm sorts a list by finding the smallest (or equivalently
largest) element in the list and then moving it to the beginning (or end) of the list.
For a list of length n, in which n > 0, the selection sort algorithm makes
1 2 1
n  n key comparisons and 3(n  1) item assignments.
2
2
For a list of length n, in which n > 0, on average, the insertion sort algorithm
1
1
makes n2 + O(n) key comparisons and n2 þ O(n) item assignments.
4
4
Let L be a list of n distinct elements. Any sorting algorithm that sorts L by
comparison of the keys only, in its worst case, makes at least O(nlog2n) key
comparisons.
Both the quick sort and merge sort algorithms sort a list by partitioning it.
To partition a list, the quick sort algorithm first selects an item from the list
called pivot. The algorithm then rearranges the elements so that the
elements in one of the sublists are less than pivot and the elements in
the other sublist are greater than or equal to pivot.
In a quick sort, the sorting work is done in partitioning the list.
On average, the number of key comparisons in a quick sort is O(nlog2n). In
the worst case, the number of key comparisons in a quick sort is O(n2).
The merge sort algorithm partitions the list by dividing it in the middle.
In a merge sort, the sorting work is done in merging the list.
The number of key comparisons in a merge sort is O(nlog2n).

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.

The member that uniquely identifies a data item is called the key of that
data item. (1)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

1339

A sequential search of a list assumes that the list elements are sorted in
ascending order. (2)
c. A binary search of a list assumes that the list is sorted. (3)
d. A binary search is faster on ordered lists and slower on unordered lists. (3)
e. A binary search is faster on large lists, but a sequential search is faster on
small lists. (2, 3)
f. For a sorted list of length 128, to determine whether an item is in the list,
the binary search algorithm makes at most 16 comparisons. (3)
4
3
g. Let f(n) = n  8n + 2, where n is a nonnegative integer. Then
f(n) = O(4n). (4)
h. Let n be a nonnegative integer. Then O(n)  O(nlog2n). (4)
i. For a list of length 100, the bubble sort given in this chapter makes
exactly 4950 key comparisons to sort the list. (7)
j. For a list of length 100, the selection sort given in this chapter makes
exactly 297 item assignments to sort the list. (8)
k. For a list of length 100, in the worst case the insertion sort given in this
chapter makes exactly 5050 key comparisons to sort the list. (9)
l. Let L be a list of n distinct elements. Any sorting algorithm that sorts L by
comparison of the keys only, in its worst case, makes at least O(nlog2n)
key comparisons. (10)
m. The quick sort algorithm partitions a list into two sublists such that the
elements in the first sublist are less than pivot and the elements in the
second sublist are greater than pivot. (11)
n. The merge sort algorithm partitions a list into two sublists such that the
number of elements in the first sublist is less than the number of elements
in the second sublist. (12)
Consider the following list:
b.

2.

11, 72, 50, 18, 36, 88, 66, 35, 45

Using the sequential search as described in this chapter, how many comparisons are required to find whether the following items are in the list? (Recall
that by comparisons we mean item comparisons, not index comparisons.) (2)
3.

a.

66

a.

Write a version of the sequential search algorithm that can be used to
search a sorted list. (1, 2)
Consider the following list:

b.

b.

11

c.

37

d.

90

4, 16, 28, 36, 48, 64, 69, 80, 84, 92, 148, 150

Using a sequential search on ordered lists, which you designed in (a), how
many comparisons are required to determine whether the following items

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1340

| Chapter 18: Searching and Sorting Algorithms

are in the list? (Recall that comparisons mean item comparisons, not index
comparisons.) (1, 2)
i.
4.

48

70 iii.

ii.

92 iv.

4

Consider the following list:
5, 12, 25, 32, 38, 46, 58, 62, 85, 90, 97, 105, 110

Using the binary search as described in this chapter, how many comparisons
are required to find whether the following items are in the list? Show the
values of first, last, and middle and the number of comparisons after
each iteration of the loop. (3)
a.
5.

6.

32

b.

20

c.

105

d.

60

Suppose that L is a sorted list of 4096 elements. What is the maximum number
of comparisons made by the binary search algorithm, given in this chapter, to
determine if an item is in L? (3)
Each of the following expressions represents the number of operations for
certain algorithms. What is the order of each of these expressions? (4)
n2 + 6n + 4 b. 5n3 + 2n + 8 c. (n2 + 1) (3n + 5) d. 5(6n + 4)
Let L be a sorted list of size 1000. In the worst case, to determine whether an
element x is in L, what is the minimum number of comparisons made by a
comparison-based search algorithm? (5)
Sort the following list using the bubble sort algorithm as discussed in this
chapter. Show the list after each iteration of the outer for loop. (7)
a.

7.

8.

38, 60, 43, 5, 70, 58, 15, 10
9.

a.

The number of comparisons in the best case of a bubble sort algorithm, as
given in this chapter, is O(n2). Show that the following version of the
bubble sort algorithm reduces the number of comparisons in the best
case of the bubble sort algorithm to O(n). (6)
//list – list to be sorted
//elemType – type of the list elements
//length – length of the list
bool isSorted = false;
for (int iteration = 1; (iteration < length) && !isSorted;
iteration++)
{
isSorted = true; //assume that the sublist is sorted
for (int index = 0; index < length - iteration; index++)
{
if (list[index] > list[index + 1])

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

1341

{
elemType temp = list[index];
list[index] = list[index + 1];
list[index + 1] = temp;
isSorted = false;
}
}
}
b.

Using the algorithm given in part (a), find the number of iterations
that are needed to sort the following list: (6)
65, 14, 52, 43, 75, 25, 80, 90, 95

10.

Sort the following list using the bubble sort algorithm as discussed in this
chapter. Show the list after each iteration of the outer for loop. (7)
46, 58, 16, 25, 83, 98, 8, 70, 5, 62

11.

Assume the following list of keys:
2, 5, 18, 32, 4, 16, 28

12.

The first four keys are in order. To move 4 to its proper position using the
insertion sort algorithm as described in this chapter, exactly how many key
comparisons are executed? (9)
Assume the following list of keys:
12, 38, 45, 50, 55, 5, 30

13.

The first five keys are in order. To move 5 to its proper position using the
insertion sort algorithm as described in this chapter, exactly how many key
comparisons are executed? (9)
Assume the following list of keys:
90, 12, 2, 80, 55, 11, 17, 15, 58, 98, 36

14.

This list is to be sorted using the insertion sort algorithm as described in this
chapter for array-based lists. Show the resulting list after seven passes of the
sorting phase—that is, after seven iterations of the for loop. (9)
Recall the insertion sort algorithm (contiguous version) as discussed in this
chapter. Assume the following list of keys:
30, 20, 35, 27, 96, 82, 56, 60, 48, 75, 5, 80

15.

16.

Exactly how many key comparisons are executed to sort this list using the
insertion sort algorithm? (9)
Suppose that L is a list of 10,000 elements. Find the average number of
comparisons made by bubble sort, selection sort, and insertion sort to sort
L. (7, 8, 9)
Let L be a list of 1024 distinct elements. Suppose L is sorted using a
comparison-based algorithm. In the worst case, what is the minimum
number of key comparisons to sort L? (10)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1342

17.

18.

| Chapter 18: Searching and Sorting Algorithms

Both the merge sort and quick sort algorithms sort a list by partitioning it.
Explain how the merge sort algorithm differs from the quick sort algorithm
in partitioning the list. (11, 12)
Assume the following list of keys:
36, 55, 89, 95, 65, 75, 13, 62, 86, 9, 23, 74, 2, 100, 98

This list is to be sorted using the quick sort algorithm as discussed in this chapter.
Use pivot as the middle element of the list. (11)
Give the resulting list after one call to the function partition.
b. What is the size of the list that the function partition partitioned?
c. What are the sizes of the two sublists created by the function partition?
Suppose that the list of keys is as given in Exercise 18 and that this list is to
be sorted using the quick sort algorithm as discussed in this chapter. Use
pivot as the middle element of the list. (11)
a.

19.

Give the resulting list after two calls to the function partition.
b. What is the size of the list that the function partition partitioned?
c. What are the sizes of the two sublists created by the function partition?
Suppose that the list of keys is as given in Exercise 18. Use the quick sort
algorithm, as discussed in this chapter, to determine the number of times the
function partition is called to completely sort the list. (11)
Assume the following list of keys:
a.

20.

21.

48, 30, 66, 50, 9, 95, 80, 15, 25, 18, 94, 55, 3, 22, 62

This list is to be sorted using the quick sort algorithm as discussed in this
chapter. Use pivot as the median of the first, last, and middle elements
of the list. (11)
What is the pivot?
b. Give the resulting list after one call to the function partition.
c. What is the size of the list that the function partition partitioned?
d. What are the sizes of the two sublists created by the function
partition?
Suppose that the list of keys is as given in Exercise 21 and that this list is
to be sorted using the quick sort algorithm as discussed in this chapter.
Use pivot as the median of the first, last, and middle elements of
the list. (11)
a.

22.

a.
b.
c.
d.

What is the pivot during the second call of the function partitioned?
Give the resulting list after two calls to the function partition.
What is the size of the list that the function partition partitioned?
What are the sizes of the two sublists created by the function partition?

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

23.

24.

|

1343

Suppose that the list of keys is as given in Exercise 21. Use the quick sort
algorithm, as discussed in this chapter, to determine the number of times the
function partition is called to completely sort the list. (11)
Suppose that L is a list of 11 elements and it is sorted using the merge sort
algorithm. (12)
What are the sizes of the first and second sublists after the first execution
of the function divide?
b. How many times is the function divide called to sort L?
Suppose that L is a list of 10,000 elements. Find the average number of
comparisons made by quick sort and merge sort to sort L. (11, 12)
Suppose that the elements of a list are in descending order and they need to be put
in ascending order. Write a C++ function that takes as input an array of items in
descending order and the number of elements in the array. The function rearranges the element of the array in ascending order. Your function must not
incorporate any sorting algorithms, that is, no item comparisons should take place.
a.

25.

26.

PROGRAMMING EXERCISES
1.

2.

3.
4.

(Recursive sequential search) The sequential search algorithm given in
this chapter is nonrecursive. Write and implement a recursive version of the
sequential search algorithm.
(Recursive binary search) The binary search algorithm given in this
chapter is nonrecursive. Write and implement a recursive version of the
binary search algorithm. Also, write a program to test your algorithm.
Write a program to test the function you designed in Exercise 3.
Write a program to find the number of comparisons using binarySearch
and the sequential search algorithm as follows:
Suppose list is an array of 1000 elements.
a.
b.
c.

d.

Use a random number generator to fill list.
Use any sorting algorithm to sort list.
Search list for some items as follows:
i.
Use the binary search algorithm to search the list. (You may need to
modify the algorithm given in this chapter to count the number
of comparisons.)
ii. Use the binary search algorithm to search the list, switching to a sequential
search when the size of the search list reduces to less than 15. (Use the
sequential search algorithm for a sorted list.)
Print the number of comparisons for Steps c(i) and c(ii). If the item is
found in the list, then print its position.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1344

5.

6.

7.
8.

9.
10.

11.

12.

| Chapter 18: Searching and Sorting Algorithms

(Modified Bubble Sort) Write a complete C++ function template to
implement the modified bubble sort algorithm given in Exercise 9 of this
chapter. Call this function modifiedBubbleSort. Also, write a program to
test your function.
Write a program to test the selection sort algorithm for array-based lists as
given in this chapter.
Write and test a version of the selection sort algorithm for linked lists.
Write a program to test the insertion sort algorithm for array-based lists as
given in this chapter.
Write and test a version of the insertion sort algorithm for linked lists.
Write a program to test the quick sort algorithm for array-based lists as
given in this chapter.
(C. A. R. Hoare) Let L be a list of size n. The quick sort algorithm can be used
to find the kth smallest item in L, wherein 0  k  n  1, without completely
sorting L. Write and implement a C++ function, kThSmallestItem, that
uses a version of the quick sort algorithm to determine the kth smallest item in
L without completely sorting L.
Sort an array of 10,000 elements using the quick sort algorithm as follows:
a.
b.

c.

d.

e.

13.

14.

Sort the array using pivot as the middle element of the array.
Sort the array using pivot as the median of the first, last, and
middle elements of the array.
Sort the array using pivot as the middle element of the array. However, when the size of any sublist reduces to less than 20, sort the sublist
using an insertion sort.
Sort the array using pivot as the median of the first, last, and
middle elements of the array. When the size of any sublist reduces to
less than 20, sort the sublist using an insertion sort.
Calculate and print the CPU time for each of the preceding four steps.

To find the current CPU time, declare a variable, say, x, of type clock_t.
The statement x = clock(); stores the current CPU time in x. You can
check the CPU time before and after a particular phase of a program. Then,
to find the CPU time for that particular phase of the program, subtract the
before time from the after time. Moreover, you must include the header
file ctime to use the data type clock_t and the function clock. Use a
random number generator to initially fill the array.
Write a program to test the merge sort algorithm for linked lists as given in
this chapter.
Write and test a version of the merge sort algorithm for array-based lists.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

15.

16.

17.
18.

19.

20.

|

1345

Write a program that creates three identical arrays, list1, list2, and
list3, of 5000 elements. The program then sorts list1 using bubble sort,
list2 using selection sort, and list3 using insertion sort and outputs
the number of comparisons and item assignments made by each sorting
algorithm.
Write a program that creates three identical lists, list1, list2, and list3,
of 5000 elements. The program then sorts list1 using quick sort, list2
using insertion sort, and list3 using merge sort and outputs the number of
comparisons and item assignments made by quick sort and insertion sort and
the number of comparisons made by merge sort.
Write a program to test the function you designed in Exercise 26.
Write the definitions of the function printResults of the Election
Results programming example. Also, write a program to produce the output shown in the sample run of this programming example.
In the Election Results programming example, the class candidateType
contains a function calculateTotalVotes, which calculates the total number of votes received by a candidate. After processing the voting data, this
function calculates the total number of votes for a candidate. The function
updateVotesByRegion (of the class candidateType) updates only the
number of votes for a particular region. Modify the definition of this function
so that it also updates the total number of votes received by the candidate. By
doing so, the function addVotes in the main program is no longer needed.
Modify and run your program with the modified definition of the function
updateVotesByRegion.
In the Election Results programming example, the object candidateList of
type unorderedArrayListType is declared to process the voting data.
The operations of inserting a candidate’s data and updating and retrieving
the votes were somewhat complicated. The member variable list is a
protected member of candidateList, and each component of list is a
private member. To update the candidates’ votes, copy each candidate’s data
from candidateList into a temporary object of type candidateType,
update the temporary object, and then replace the candidate’s data
with the temporary object. In this exercise, you are to modify the Election
Results programming example to simplify the accessing of a candidate’s
data. Derive the class candidateListType from the class
unorderedArrayListType as follows:
class candidateListType:
public unorderedArrayListType<candidateType>
{
public:
candidateListType(int size = 0);
//constructor
void processVotes(string fName, string lName, int region,
int votes);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
8

1346

| Chapter 18: Searching and Sorting Algorithms

//Function to update the number of votes for
//a particular candidate for a particular region.
//The name of the candidate, the region number, and
//the number of votes are passed as parameters.
void addVotes();
//Function to find the total number of votes
//received by each candidate.
void printResult();
//Function to output the voting data.
};

Because the class candidateListType is derived from the class
unorderedArrayListType, and list is a protected member of the
class unorderedArrayListType (inherited from the class
arrayListType), list can be directly accessed by a member of the class
candidateListType.
Write the definitions of the member functions of the class
candidateListType. Rewrite and run your program using the class
candidateListType.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

19
CHAPTER

ª HunThomas/Shutterstock

B INARY T REES
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about binary trees

2.

Learn about the basic terminologies used in binary trees:
left and right subtrees, path, height, level of a node, leaves,
parent of a node

3.

Explore various binary tree traversal algorithms

4.

Explore how to implement the basic operations on a binary tree

5.

Learn about binary search trees

6.

Learn how to organize data in a binary search tree

7.

Learn how to insert and delete items in a binary search tree

8.

Explore nonrecursive binary tree traversal algorithms

9.

Explore binary tree traversal algorithms and functions as parameters

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1348

| Chapter 19: Binary Trees

When data is being organized, a programmer’s highest priority is to organize it in such a
way that item insertion, deletion, and lookups (searches) are fast. You have already seen
how to store and process data in an array. Because an array is a random-access data
structure, if the data is properly organized (say, sorted), then we can use a search
algorithm, such as a binary search, to effectively find and retrieve an item from the list.
However, we know that storing data in an array has its limitations. For example, item
insertion (especially if the array is sorted) and item deletion can be very time consuming,
especially if the list size is very large, because each of these operations requires data
movement. To speed up item insertion and deletion, we used linked lists. Item insertion
and deletion in a linked list do not require any data movement; we simply adjust some of
the links in the list. However, one of the drawbacks of linked lists is that they must
be processed sequentially. That is, to insert or delete an item, or simply to search the list
for a particular item, we must begin our search at the first node in the list. As you know, a
sequential search is good only for very small lists because the average search length of
a sequential search is half the size of the list.

Binary Trees
This chapter discusses how to organize data dynamically so that item insertion, deletion,
and lookups are more efficient.
We first introduce some definitions to facilitate our discussion.
Definition: A binary tree, T, is either empty or such that:
i. T has a special node called the root node;
ii. T has two sets of nodes, LT and RT, called the left subtree and right
subtree of T, respectively; and
iii. LT and RT are binary trees.
Suppose that T is a binary tree with the root node A. Let LA denote the left subtree of A
and RA denote the right subtree of A. Now LA and RA are binary trees. Suppose that B is
the root node of LA and C is the root node of RA. B is called the left child of A; C is
called the right child of A. Moreover, A is called the parent of B and C.
A binary tree can be shown pictorially. In the diagram of a binary tree, each node of the
binary tree is represented as a circle, and the circle is labeled by the node. The root node
of the binary tree is drawn at the top. The left child of the root node (if any) is drawn
below and to the left of the root node. Similarly, the right child of the root node (if any)
is drawn below and to the right of the root node. Children are connected to the parent by
an arrow from the parent to the child. An arrow is usually called a directed edge or a
directed branch (or simply a branch) (see Figure 19-1). Because the root node, B, of
LA is already drawn, we apply the same (recursive) procedure to draw the remaining parts
of LA. RA is drawn similarly. If a node has no left child, for example, we draw an arrow
from the node to the left, ending with three stacked lines. That is, three lines at the end of
an arrow indicate that the subtree is empty.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Trees

|

1349

A

B
D

C
E

F

G

H

1
9
FIGURE 19-1

Binary tree

In Figure 19-1, the root node of this binary tree is A. The left subtree of the root node,
which we denote by LA, is the set LA ¼ {B, D, E, G}, and the right subtree of the root
node, which we denote by RA, is the set RA ¼ {C, F, H}. The root node of the left
subtree of A—that is, the root node of LA—is node B. The root node of RA is C, and so
on. Clearly, LA and RA are binary trees. Because three lines at the end of an arrow mean
that the subtree is empty, it follows that the left subtree of D is empty. Also, note that for
node F, the left child is H and node F has no right child.
Example 19-1 shows nonempty binary trees.
EXAMPLE 19-1
Figure 19-2 shows binary trees with one, two, or three nodes.

A

A

A

B

(a) Binary tree
with one node

FIGURE 19-2

(b) Binary tree
with two nodes

A
C

(c) Binary tree
with two nodes

B

C

(d) Binary tree
with three nodes

Binary tree with one, two, or three nodes

In the binary tree of Figure 19-2(a), the root node is A, LA ¼ empty, and RA ¼ empty.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1350

| Chapter 19: Binary Trees

In the binary tree of Figure 19-2(b), the root node is A, LA ¼ {B}, and RA ¼ empty. The
root node of LA ¼ B, LB ¼ empty, and RB ¼ empty.
In the binary tree of Figure 19-2(c), the root node is A, LA ¼ empty, and RA ¼ {C}. The
root node of RA ¼ C, LC ¼ empty, and RC ¼ empty.
In the binary tree of Figure 19-2(d), the root node is A, LA ¼ {B}, and RA ¼ {C}. The
root node of LA ¼ B, LB ¼ empty, and RB ¼ empty. The root node of RA ¼ C, LC ¼
empty, and RC ¼ empty.

EXAMPLE 19-2
Figure 19-3 shows other cases of nonempty binary trees with three nodes.

A
B

B

A

A

(i)

C

C
E

D

FIGURE 19-3

A

(ii)

F

(iii)

G

(iv)

Various binary trees with three nodes

As you can see from the preceding examples, every node in a binary tree has, at
most, two children. Thus, every node, other than storing its own information, must
keep track of its left subtree and right subtree. This implies that every node has two
pointers, say, lLink and rLink. The pointer lLink points to the root node of the
left subtree of the node; the pointer rLink points to the root node of the right
subtree of the node.
The following struct defines the node of a binary tree:
template <class elemType>
struct nodeType
{
elemType info;
nodeType <elemType> *lLink;
nodeType <elemType> *rLink;
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Trees

|

1351

From the definition of the node, it is clear that for each node:
1. The data is stored in info.
2. A pointer to the left child is stored in lLink.
3. A pointer to the right child is stored in rLink.
Furthermore, a pointer to the root node of the binary tree is stored outside of the binary
tree in a pointer variable, usually called the root, of type nodeType. Thus, in general, a
binary tree looks like the diagram in Figure 19-4.

root

1
9

A

B

D

E
G

FIGURE 19-4

C

F
H

Binary tree

For simplicity, we will continue to draw binary trees as before. That is, we will use circles
to represent nodes and left and right arrows to represent links. As before, three lines at the
end of an arrow mean that the subtree is empty.
Before we leave this section, let us define a few terms.
A node in a binary tree is called a leaf if it has no left and right children. Let U and V be two
nodes in the binary tree T. U is called the parent of V if there is a branch from U to V. A path
from a node X to a node Y in a binary tree is a sequence of nodes X0, X1, . . ., Xn such that:
i. X ¼ X0, Xn ¼ Y
ii. Xi1 is the parent of Xi for all i ¼ 1, 2, . . ., n. That is, there is a branch
from X0 to X1, X1 to X2, . . ., Xi1 to Xi, . . ., Xn1 to Xn.
If X0, X1, . . ., Xn is a path from node X to node Y, sometimes we denote it by X ¼ X0 
X1      Xn1  Xn ¼ Y or simply X  X1      Xn1  Y.
Because the branches only go from a parent to its children, from the previous discussion it is
clear that in a binary tree, there is a unique path from the root to every node in the binary tree.
Definition: The length of a path in a binary tree is the number of branches on that path.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1352

| Chapter 19: Binary Trees

Definition: The level of a node in a binary tree is the number of branches on the path
from the root to the node.
Clearly, the level of the root node of a binary tree is 0, and the level of the children of the
root node is 1.
Definition: The height of a binary tree is the number of nodes on the longest path from
the root to a leaf.
EXAMPLE 19-3
Consider the binary tree of Figure 19-5. In this example, the terms such as node A and
(node with info A) mean the same thing.
root
A

B
D

C
F

E

G

H

I

FIGURE 19-5

Binary tree

In this binary tree, the nodes I, E, and H have no left and right children. So, the nodes I,
E, and H are leaves.
There is a branch from node A to node B. So, node A is the parent of node B. Similarly,
node A is the parent of node C, node B is the parent of nodes D and E, node C is the parent
of node F, node D is the parent of node G, and so on.
A–B–D–G is a path from node A to node G. Because there are three branches on this path,
the length of this path is 3. Similarly, B–D–G–I is a path from node B to node I.

There are three leaves in this binary tree, which are I, E, and H. Also, the paths from root
to these leaves are: A–B–D–G-I, A–B–E, and A–C–F–H. Clearly, the longest path from
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Trees

|

1353

root to a leaf is A–B–D–G-I. The number of nodes on this path is 5. Hence, the height of
the binary tree is 5.

Suppose that a pointer, p, to the root node of a binary tree is given. We next describe a
C++ function, height, to find the height of the binary tree. The pointer to the root
node is passed as a parameter to the function height.
If the binary tree is empty, then the height is 0. Suppose that the binary tree is nonempty. To find
the height of the binary tree, we first find the height of the left subtree and the height of the right
subtree. We then take the maximum of these two heights and add 1 to find the height of the
binary tree. To find the height of the left (right) subtree, we apply the same procedure because the
left (right) subtree is a binary tree. Therefore, the general algorithm to find the height of a binary
tree is as follows. Suppose height(p) denotes the height of the binary tree with root p.
if (p is nullptr)
height(p) = 0
else
height(p) = 1 + max(height(p->lLink), height(p->rLink))

Clearly, this is a recursive algorithm. The following function implements this algorithm:
template <class elemType>
int height(nodeType<elemType> *p)
{
if (p == nullptr)
return 0;
else
return 1 + max(height(p->lLink), height(p->rLink));
}

The definition of the function height uses the function max to determine the larger of
two integers. The function max can be easily implemented.
Similarly, we can implement algorithms to find the number of nodes and number of
leaves in a binary tree.

Copy Tree
One useful operation on binary trees is to make an identical copy of a binary tree. A
binary tree is a dynamic data structure; that is, memory for the nodes of a binary tree is
allocated and deallocated during program execution. Therefore, if we use just the value of
the pointer of the root node to make a copy of a binary tree, we get a shallow copy of the
data. To make an identical copy of a binary tree, we need to create as many nodes as there
are in the binary tree to be copied. Moreover, in the copied tree, these nodes must appear
in the same order as they are in the original binary tree.
Given a pointer to the root node of a binary tree, we next describe a function that makes
a copy of a given binary tree. This function is also quite useful in implementing the copy
constructor and overloading the assignment operator, as described later in this chapter
(see ‘‘Implementing Binary Trees’’).
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1354

| Chapter 19: Binary Trees

template <class elemType>
void copyTree(nodeType<elemType>* &copiedTreeRoot,
nodeType<elemType>* otherTreeRoot)
{
if (otherTreeRoot == nullptr)
copiedTreeRoot = nullptr;
else
{
copiedTreeRoot = new nodeType<elemType>;
copiedTreeRoot->info = otherTreeRoot->info;
copyTree(copiedTreeRoot->lLink, otherTreeRoot->lLink);
copyTree(copiedTreeRoot->rLink, otherTreeRoot->rLink);
}
} //end copyTree

We will use the function copyTree when we overload the assignment operator and
implement the copy constructor.

Binary Tree Traversal
The item insertion, deletion, and lookup operations require that the binary tree be
traversed. Thus, the most common operation performed on a binary tree is to traverse
the binary tree, or visit each node of the binary tree. As you can see from the diagram of a
binary tree, the traversal must start at the root node because there is a pointer to the root
node of the binary tree. For each node, we have two choices:
•
•

Visit the node first.
Visit the subtrees first.

These choices lead to three commonly used traversals of a binary tree:
•
•
•

Inorder traversal
Preorder traversal
Postorder traversal

INORDER TRAVERSAL
In an inorder traversal, the binary tree is traversed as follows:

1. Traverse the left subtree.
2. Visit the node.
3. Traverse the right subtree.
PREORDER TRAVERSAL
In a preorder traversal, the binary tree is traversed as follows:

1. Visit the node.
2. Traverse the left subtree.
3. Traverse the right subtree.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Trees

|

1355

POSTORDER TRAVERSAL
In a postorder traversal, the binary tree is traversed as follows:

1. Traverse the left subtree.
2. Traverse the right subtree.
3. Visit the node.
Clearly, each of these traversal algorithms is recursive.
The listing of the nodes produced by the inorder traversal of a binary tree is called the
inorder sequence. The listing of the nodes produced by the preorder traversal is called
the preorder sequence, and the listing of the nodes produced by the postorder traversal
is called the postorder sequence.

EXAMPLE 19-4
Consider the binary tree in Figure 19-6. Let T be a binary tree. Suppose that T is nonempty
and the root node of T is A. Then inorder(T) or inorder(A) denotes the listing of nodes of
T in the inorder sequence and root(T) denotes the root node of T. For simplicity, we
assume that visiting a node means to output the data stored in the node. In the section
‘‘Binary Tree Traversal and Functions as Parameters,’’ we will explain how to modify the
binary tree traversal algorithms so that by using a function, the user can specify the action to
be performed on a node when the node is visited.

A
B

C

D

E
F

FIGURE 19-6

G

Binary tree for an inorder traversal

Let T denote the binary tree in Figure 19-6. Then, root(T) ¼ A. Therefore, we start the
traversal at A. That is, determine inorder(A). Because the binary tree is nonempty, to
determine inorder(A), we do the following:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1356

| Chapter 19: Binary Trees

1. Determine inorder(LA), where LA is the left subtree of A. Note that
LA ¼ {B, D, F}.
2. Visit A.
3. Determine inorder(RA), where RA is the right subtree of A. Note that
RA ¼ {C, E, G}.
Now we cannot do Step 2 until we have finished Step 1.
1. inorder(LA): Now LA is a binary tree, and root(LA) ¼ B. So to
determine inorder(LA), we do the following:
1.1. Determine inorder(LB), where LB ¼ {D, F}.
1.2. Visit B.
1.3. Determine inorder(RB), where RB ¼ empty.
As before, first we complete Step 1.1 before proceeding to Step 1.2.
1.1. inorder(LB): Now LB is a binary tree, and root(LB) ¼ D. So to
determine inorder(LB), we do the following:
1.1.1. Determine inorder(LD), where LD ¼ empty.
1.1.2. Visit D.
1.1.3. Determine inorder(RD), where RD ¼ {F}.
Because LD ¼ empty, Step 1.1.1 is completed, so we proceed to Step
1.1.2, which outputs D. Because Step 1.1.2 is also completed, we
proceed to Step 1.1.3.
1.1.3. Determine inorder(RD), where RD ¼ {F}. Now RD is a binary
tree, and root(RD) ¼ F. So to determine inorder(RD), we do the
following:
1.1.3.1. Determine inorder(LF), where LF ¼ empty.
1.1.3.2. Visit F.
1.1.3.3. Determine inorder(RF), where RF ¼ empty.
Because LF ¼ empty, Step 1.1.3.1 is completed, so we proceed to Step
1.1.3.2, which outputs F. Because Step 1.1.3.2 is also completed, we
proceed to Step 1.1.3.3. Because RF ¼ empty, this step is also completed.
Thus, Step 1.1.3 is completed, which in turn completes Step 1.1.
Next, we proceed to Step 1.2, which outputs B. After completing Step 1.2,
we proceed to Step 1.3. Now Step 1.3 requires us to determine inorder(RB).
However, RB ¼ empty, so Step 1.3 is completed, which in turn completes
Step 1.
2. Next, we proceed to Step 2, which outputs A. At this point we have
completed inorder(LA) and visited A.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Trees

|

1357

3. Now, we proceed to Step 3, that is, determine inorder(RA), where
RA ¼ {C, E, G}. Now RA is a nonempty binary tree and root(RA) ¼ C, so
to determine inorder(RA), we need to do the following:
3.1. Determine inorder(LC), where LC ¼ empty.
3.2. Visit C.
Now LC ¼ empty, so Step 3.1 is completed. Next, in Step 3.2, we output C,
which completes this step. After completing Step 3.2, we proceed to Step 3.3.
3.3. Determine inorder(RC), where RC ¼ {E, G}. Now RC is a nonempty
binary tree with root(RC) ¼ E. Thus, inorder(RC) requires us to
complete the following steps:
3.3.1. Determine inorder(LE), where LE ¼{G}.
3.3.2. Visit E.
3.3.3. Determine inorder(RE), where RE ¼ empty.
To complete Step 3.3.1, we must determine inorder(LE), where LE ¼{G}.
Now LE is a binary tree with root(LE) ¼{G}. Therefore, to determine
inorder(LE), we must complete the following steps:
3.3.1.1. Determine inorder(LG), where LG ¼ empty.
3.3.1.2. Visit G.
3.3.1.3. Determine inorder(RG), where RG ¼ empty.
Now LG ¼ empty, so Step 3.3.1.1 is completed. Next Step 3.3.1.2
outputs G, which completes this step. Because RG ¼ empty, Step
3.3.1.3 is also completed. This in turn completes Step 3.3.1.
After completing Step 3.3.1, to complete Step 3.3.2, we output E. Next because
RE ¼ empty, Step 3.3.3 is also completed, which in turn completes Step 3.3.
Because Step 3.3 is completed, Step 3 is also completed, that is we have determined
inorder(RA). It now follows that:
inorder(A) ¼ DFBACGE
In a similar manner, the preorder and postorder traversals output the nodes in the
following order:
preorder(A) ¼ ABDFCEF
postorder(A) ¼ FDBGECA
As you can see from the walk-through of the inorder traversal, after visiting the left subtree
of a node, we must come back to the node itself. The links are only in one direction; that is,
the parent node points to the left and right children, but there is no pointer from each child
to the parent. Therefore, before going to a child, we must somehow save a pointer to the
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1358

| Chapter 19: Binary Trees

parent node. A convenient way to do this is to write a recursive inorder function because in
a recursive call, after completing a particular call, the control goes back to the caller. (Later,
we will discuss how to write nonrecursive traversal functions.) The recursive definition of
the function to implement the inorder traversal algorithms is:
template <class elemType>
void inorder(nodeType<elemType> *p) const
{
if (p != nullptr)
{
inorder(p->lLink);
cout << p->info << " ";
inorder(p->rLink);
}
}

To do the inorder traversal of a binary tree, the root node of the binary tree is passed as a
parameter to the function inorder. For example, if root points to the root node of the
binary tree, a call to the function inorder is:
inorder(root);

Similarly, we can write the functions to implement the preorder and postorder traversals.
The definitions of these functions are given next:
template <class elemType>
void preorder(nodeType<elemType> *p) const
{
if (p != nullptr)
{
cout << p->info << " ";
preorder(p->lLink);
preorder(p->rLink);
}
}
template <class elemType>
void postorder(nodeType<elemType> *p) const
{
if (p != nullptr)
{
postorder(p->lLink);
postorder(p->rLink);
cout << p->info << " ";
}
}

This section described the binary tree traversal algorithms inorder, preorder, and postorder. If you want to make a copy of a binary tree while preserving the structure of the
binary tree, you can use preorder traversal. To delete all of the nodes of a binary tree, you
can use the postorder traversal. Later in this chapter, we will discuss binary search trees.
The inorder traversal of a binary search tree visits the nodes in sorted order.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Implementing Binary Trees

|

1359

In addition to the inorder, preorder, and postorder traversals, a binary tree can also be
traversed level-by-level, also known as breadth-first traversal. In Chapter 20, we discuss
graphs. A binary tree is also a graph. We discuss how to implement breadth-first traversal
algorithms for graphs. You can modify that algorithm to do a breadth-first traversal of
binary trees.

Implementing Binary Trees
The preceding sections described various operations that can be performed on a binary
tree, as well as the functions to implement these operations. This section describes
binary trees as an abstract data type (ADT). Before designing the class to implement a
binary tree as an ADT, let us list the various operations that are typically performed on a
binary tree.
1.
2.
3.
4.
5.
6.
7.
8.
9.

Determine whether the binary tree is empty.
Search the binary tree for a particular item.
Insert an item in the binary tree.
Delete an item from the binary tree.
Find the height of the binary tree.
Find the number of nodes in the binary tree.
Find the number of leaves in the binary tree.
Traverse the binary tree.
Copy the binary tree.

The item search, insertion, and deletion operations all require the binary tree to be
traversed. However, because the nodes of a binary tree are in no particular order, these
algorithms are not very efficient on arbitrary binary trees. That is, no criteria exist to
guide the search on these binary trees, as we will see in the next section. Therefore, we
will discuss these algorithms when we discuss special binary trees.
The following class defines binary trees as an ADT. The definition of the node is the same
as before. However, for the sake of completeness and easy reference, we give the
definition of the node followed by the definition of the class:
//Definition of the Node
template <class elemType>
struct nodeType
{
elemType info;
nodeType<elemType> *lLink;
nodeType<elemType> *rLink;
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1360

| Chapter 19: Binary Trees

//Definition of the class
template <class elemType>
class binaryTreeType
{
public:
const binaryTreeType<elemType>& operator=
(const binaryTreeType<elemType>&);
//Overload the assignment operator.
bool isEmpty() const;
//Function to determine whether the binary tree is empty.
//Postcondition: Returns true if the binary tree is empty;
//
otherwise, returns false.
void inorderTraversal() const;
//Function to do an inorder traversal of the binary tree.
//Postcondition: Nodes are printed in inorder sequence.
void preorderTraversal() const;
//Function to do a preorder traversal of the binary tree.
//Postcondition: Nodes are printed in preorder sequence.
void postorderTraversal() const;
//Function to do a postorder traversal of the binary tree.
//Postcondition: Nodes are printed in postorder sequence.
int treeHeight() const;
//Function to determine the height of a binary tree.
//Postcondition: Returns the height of the binary tree.
int treeNodeCount() const;
//Function to determine the number of nodes in a
//binary tree.
//Postcondition: Returns the number of nodes in the
//
binary tree.
int treeLeavesCount() const;
//Function to determine the number of leaves in a
//binary tree.
//Postcondition: Returns the number of leaves in the
//
binary tree.
void destroyTree();
//Function to destroy the binary tree.
//Postcondition: Memory space occupied by each node
//
is deallocated.
//
root = nullptr;
virtual bool search(const elemType& searchItem) const = 0;
//Function to determine if searchItem is in the binary
//tree.
//Postcondition: Returns true if searchItem is found in
//
the binary tree; otherwise, returns
//
false.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Implementing Binary Trees

|

1361

virtual void insert(const elemType& insertItem) = 0;
//Function to insert insertItem in the binary tree.
//Postcondition: If there is no node in the binary tree
//
that has the same info as insertItem, a
//
node with the info insertItem is created
//
and inserted in the binary search tree.
virtual void deleteNode(const elemType& deleteItem) = 0;
//Function to delete deleteItem from the binary tree.
//Postcondition: If a node with the same info as
//
deleteItem is found, it is deleted from
//
the binary tree.
//
If the binary tree is empty or
//
deleteItem is not in the binary tree,
//
an appropriate message is printed.
binaryTreeType(const binaryTreeType<elemType>& otherTree);
//Copy constructor
binaryTreeType();
//Default constructor
~binaryTreeType();
//Destructor
protected:
nodeType<elemType>

*root;

private:
void copyTree(nodeType<elemType>* &copiedTreeRoot,
nodeType<elemType>* otherTreeRoot);
//Makes a copy of the binary tree to which
//otherTreeRoot points.
//Postcondition: The pointer copiedTreeRoot points to
//
the root of the copied binary tree.
void destroy(nodeType<elemType>* &p);
//Function to destroy the binary tree to which p points.
//Postcondition: Memory space occupied by each node, in
//
the binary tree to which p points, is
//
deallocated.
//
p = nullptr;
void inorder(nodeType<elemType> *p) const;
//Function to do an inorder traversal of the binary
//tree to which p points.
//Postcondition: Nodes of the binary tree, to which p
//
points, are printed in inorder sequence.
void preorder(nodeType<elemType> *p) const;
//Function to do a preorder traversal of the binary
//tree to which p points.
//Postcondition: Nodes of the binary tree, to which p
//
points, are printed in preorder
//
sequence.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1362

| Chapter 19: Binary Trees

void postorder(nodeType<elemType> *p) const;
//Function to do a postorder traversal of the binary
//tree to which p points.
//Postcondition: Nodes of the binary tree, to which p
//
points, are printed in postorder
//
sequence.
int height(nodeType<elemType> *p) const;
//Function to determine the height of the binary tree
//to which p points.
//Postcondition: Height of the binary tree to which
//
p points is returned.
int max(int x, int y) const;
//Function to determine the larger of x and y.
//Postcondition: Returns the larger of x and y.
int nodeCount(nodeType<elemType> *p) const;
//Function to determine the number of nodes in
//the binary tree to which p points.
//Postcondition: The number of nodes in the binary
//
tree to which p points is returned.
int leavesCount(nodeType<elemType> *p) const;
//Function to determine the number of leaves in
//the binary tree to which p points.
//Postcondition: The number of leaves in the binary
//
tree to which p points is returned.
};

We leave the UML class diagram of the class binaryTreeType as an exercise for
you. See Exercise 33 at the end of this chapter.
The functions search, insert, and deleteNode are declared as abstract in the definition
of the class binaryTreeType. This is because, in this section, we are discussing arbitrary
binary trees. Implementing these operations for arbitrary binary trees is inefficient, if not
impossible, as we will discuss in the section ‘‘Binary Search Trees.’’ Because the class
binaryTreeType contains abstract functions, this class is an abstract class. So, you cannot
create objects of this class. In the section ‘‘Binary Search Tree,’’ we will derive a class from
the class binaryTreeType and provide the definitions of these functions.
Note that the definition of the class binaryTreeType contains the statement to
overload the assignment operator, copy constructor, and destructor. This is because the
class binaryTreeType contains pointer member variables. Recall that for classes with
pointer member variables, we must explicitly overload the assignment operator, include
the copy constructor, and include the destructor.
The definition of the class binaryTreeType contains several member functions that
are private members of the class. These functions are used to implement the public
member functions of the class. For example, to do an inorder traversal, the function
inorderTraversal calls the function inorder and passes the pointer root as a
parameter to this function. Moreover, the pointer root is declared as a protected
member so that we can later derive special binary trees.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Implementing Binary Trees

|

1363

Next, we give the definitions of the nonabstract member functions of the class
binaryTreeType.
The binary tree is empty if root is nullptr. So the definition of the function isEmpty is:
template <class elemType>
bool binaryTreeType<elemType>::isEmpty() const
{
return (root == nullptr);
}

The default constructor initializes the binary tree to an empty state; that is, it sets the
pointer root to nullptr. Therefore, the definition of the default constructor is:
template <class elemType>
binaryTreeType<elemType>::binaryTreeType()
{
root = nullptr;
}

The definitions of the other functions are:
template <class elemType>
void binaryTreeType<elemType>::inorderTraversal() const
{
inorder(root);
}
template <class elemType>
void binaryTreeType<elemType>::preorderTraversal() const
{
preorder(root);
}
template <class elemType>
void binaryTreeType<elemType>::postorderTraversal() const
{
postorder(root);
}
template <class elemType>
int binaryTreeType<elemType>::treeHeight() const
{
return height(root);
}
template <class elemType>
int binaryTreeType<elemType>::treeNodeCount() const
{
return nodeCount(root);
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1364

| Chapter 19: Binary Trees

template <class elemType>
int binaryTreeType<elemType>::treeLeavesCount() const
{
return leavesCount(root);
}
template <class elemType>
void binaryTreeType<elemType>::inorder
(nodeType<elemType> *p) const
{
if (p != nullptr)
{
inorder(p->lLink);
cout << p->info << " ";
inorder(p->rLink);
}
}
template <class elemType>
void binaryTreeType<elemType>::preorder
(nodeType<elemType> *p) const
{
if (p != nullptr)
{
cout << p->info << " ";
preorder(p->lLink);
preorder(p->rLink);
}
}
template <class elemType>
void binaryTreeType<elemType>::postorder
(nodeType<elemType> *p) const
{
if (p != nullptr)
{
postorder(p->lLink);
postorder(p->rLink);
cout << p->info << " ";
}
}
template<class elemType>
int binaryTreeType<elemType>::height
(nodeType<elemType> *p) const
{
if (p == nullptr)
return 0;
else
return 1 + max(height(p->lLink), height(p->rLink));
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Implementing Binary Trees

|

1365

template <class elemType>
int binaryTreeType<elemType>::max(int x, int y) const
{
if (x >= y)
return x;
else
return y;
}

The definitions of the functions nodeCount and leavesCount are left as exercises for
you. See Programming Exercises 1 and 2 at the end of this chapter.
Next, we give the definitions of the functions copyTree, destroy, destroyTree; the
copy constructor; and the destructor. We also overload the assignment operator.
The definition of the function copyTree is the same as before; here, this function is a
member of the class binaryTreeType.
template <class elemType>
void binaryTreeType<elemType>::copyTree
(nodeType<elemType>* &copiedTreeRoot,
nodeType<elemType>* otherTreeRoot)
{
if (otherTreeRoot == nullptr)
copiedTreeRoot = nullptr;
else
{
copiedTreeRoot = new nodeType<elemType>;
copiedTreeRoot->info = otherTreeRoot->info;
copyTree(copiedTreeRoot->lLink, otherTreeRoot->lLink);
copyTree(copiedTreeRoot->rLink, otherTreeRoot->rLink);
}
} //end copyTree

To destroy a binary tree, for each node, first we destroy its left subtree, then its right
subtree, and then the node itself. We must use the operator delete to deallocate the
memory occupied by the node. The definition of the function destroy is:
template <class elemType>
void binaryTreeType<elemType>::destroy(nodeType<elemType>* &p)
{
if (p != nullptr)
{
destroy(p->lLink);
destroy(p->rLink);
delete p;
p = nullptr;
}
}

To implement the function destroyTree, we use the function destroy and pass the
root node of the binary tree to the function destroy. The definition of the function
destroyTree is:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1366

| Chapter 19: Binary Trees

template <class elemType>
void binaryTreeType<elemType>::destroyTree()
{
destroy(root);
}

Recall that when a class object is passed by value, the copy constructor copies the value of
the actual parameters into the formal parameters. Because the class binaryTreeType
has pointer member variables and a pointer is used to create dynamic memory, we must
provide the definition of the copy constructor to avoid the shallow copying of data. The
definition of the copy constructor, given next, uses the function copyTree to make an
identical copy of the binary tree that is passed as a parameter.
//copy constructor
template <class elemType>
binaryTreeType<elemType>::binaryTreeType
(const binaryTreeType<elemType>& otherTree)
{
if (otherTree.root == nullptr) //otherTree is empty
root = nullptr;
else
copyTree(root, otherTree.root);
}

The definition of the destructor is quite straightforward. When the object of type
binaryTreeType goes out of scope, the destructor deallocates the memory occupied
by the nodes of the binary tree. The definition of the destructor uses the function
destroy to accomplish this task.
//Destructor
template <class elemType>
binaryTreeType<elemType>:: ~binaryTreeType()
{
destroy(root);
}

Next, we discuss the definition of the function to overload the assignment operator. To
assign the value of one binary tree to another binary tree, we make an identical copy of
the binary tree to be assigned by using the function copyTree. The definition of the
function to overload the assignment operator is:
//Overload the assignment operator
template <class elemType>
const binaryTreeType<elemType>& binaryTreeType<elemType>::
operator=(const binaryTreeType<elemType>& otherTree)
{
if (this != &otherTree) //avoid self-copy
{
if (root != nullptr)
//if the binary tree is not empty,
//destroy the binary tree
destroy(root);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Search Trees

|

1367

if (otherTree.root == nullptr) //otherTree is empty
root = nullptr;
else
copyTree(root, otherTree.root);
}//end else
return *this;
}

Binary Search Trees
Now that you know the basic operations on a binary tree, this section discusses a special
type of binary tree called the binary search tree.

1
9

Consider the binary tree in Figure 19-7.

root
78

32
89

46

28

FIGURE 19-7

60
98

53

Arbitrary binary tree

Suppose that we want to determine whether 53 is in the binary tree. To do so, we can
use any of the previous traversal algorithms to visit each node and compare the search
item with the data stored in the node. However, this could require us to traverse a large
part of the binary tree, so the search will be slow. The reason that we need to visit each
node in the binary tree until either the item is found or we have traversed the entire
binary tree is that no criteria exist to guide our search. This case is like an arbitrary linked
list, in which we must start our search at the first node and continue looking at each node
until either the item is found or the entire list is searched.
On the other hand, consider the binary tree in Figure 19-8.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1368

| Chapter 19: Binary Trees

root
60

50
30

70
58

46

FIGURE 19-8

80

77

Binary search tree

In the binary tree in Figure 19-8, the data in each node is:
•
•

Larger than the data in its left child
Smaller than the data in its right child

The binary tree in Figure 19-8 has some order to its nodes. Suppose that we want to
determine whether 58 is in this binary tree. As before, we must start our search at the root
node. We compare 58 with the data in the root node; that is, we compare 58 with 60.
Because 58 6¼ 60 and 58 < 60, it is guaranteed that 58 will not be in the right subtree of the
root node. Therefore, if 58 is in the binary tree, then it must be in the left subtree of the root
node. We follow the left pointer of the root node and go to the node with info 50. We now
apply the same criteria at this node. Because 58 > 50, we must follow the right pointer of
this node and go to the node with info 58. At this node, we find 58.
This example shows that every time we move down to a child, we eliminate one of the
subtrees of the node from our search. If the binary tree is nicely constructed, then the
search is very similar to the binary search on arrays.
The binary tree given in Figure 19-8 is a special type of binary tree called a binary search
tree. (In the following definition, by the term key of the node, we mean the key of the
data item that uniquely identifies the item.)
Definition: A binary search tree, T, is either empty or:
i. T has a special node called the root node;
ii. T has two sets of nodes, LT and RT, called the left subtree and right
subtree of T, respectively;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Search Trees

|

1369

iii. The key in the root node is larger than every key in the left subtree and
smaller than every key in the right subtree; and
iv. LT and RT are binary search trees.
The following operations are typically performed on a binary search tree.
1.
2.
3.
4.
5.
6.
7.
8.
9.

Determine whether the binary search tree is empty.
Search the binary search tree for a particular item.
Insert an item in the binary search tree.
Delete an item from the binary search tree.
Find the height of the binary search tree.
Find the number of nodes in the binary search tree.
Find the number of leaves in the binary search tree.
Traverse the binary search tree.
Copy the binary search tree.

Clearly, every binary search tree is a binary tree. The height of a binary search tree is
determined in the same way as the height of a binary tree. Similarly, the operations to
find the number of nodes, to find the number of leaves, and to do inorder, preorder, and
postorder traversals of a binary search tree are the same as those for a binary tree.
Therefore, we can inherit all of these operations from the binary tree. That is, we can
extend the definition of the binary tree by using the principle of inheritance and hence
define the binary search tree.
The following class defines a binary search tree as an ADT by extending the definition of
the binary tree:
template <class elemType>
class bSearchTreeType: public binaryTreeType<elemType>
{
public:
bool search(const elemType& searchItem) const;
//Function to determine if searchItem is in the binary
//search tree.
//Postcondition: Returns true if searchItem is found in
//
the binary search tree; otherwise,
//
returns false.
void insert(const elemType& insertItem);
//Function to insert insertItem in the binary search tree.
//Postcondition: If there is no node in the binary search
//
tree that has the same info as
//
insertItem, a node with the info
//
insertItem is created and inserted in the
//
binary search tree.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1370

| Chapter 19: Binary Trees

void deleteNode(const elemType& deleteItem);
//Function to delete deleteItem from the binary search tree.
//Postcondition: If a node with the same info as deleteItem
//
is found, it is deleted from the binary
//
search tree.
//
If the binary tree is empty or deleteItem
//
is not in the binary tree, an appropriate
//
message is printed.
private:
void deleteFromTree(nodeType<elemType>* &p);
//Function to delete the node to which p points is
//deleted from the binary search tree.
//Postcondition: The node to which p points is deleted
//
from the binary search tree.
};

We leave it as an exercise for you to draw the UML class diagram of the class
bSearchTreeType and the inheritance hierarchy. See Exercise 34 at the end of this
chapter.
Next, we describe each of these operations.
SEARCH
The function search searches the binary search tree for a given item. If the item is found in
the binary search tree, it returns true; otherwise, it returns false. Because the pointer root
points to the root node of the binary search tree, we must begin our search at the root node.
Furthermore, because root must always point to the root node, we need a pointer—say,
current—to traverse the binary search tree. The pointer current is initialized to root.

If the binary search tree is nonempty, we first compare the search item with the info in
the root node. If they are the same, we stop the search and return true. Otherwise, if the
search item is smaller than the info in the node, we follow lLink to go to the left subtree;
otherwise, we follow rLink to go to the right subtree. We repeat this process for the next
node. If the search item is in the binary search tree, our search ends at the node containing the
search item; otherwise, the search ends at an empty subtree. Thus, the general algorithm is:
if root is nullptr
Cannot search an empty tree, returns false.
else
{
current = root;
while (current is not nullptr and not found)
if (current->info is the same as the search item)
set found to true;
else
if (current->info is greater than the search item)
follow the lLink of current
else
follow the rLink of current
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Search Trees

|

1371

This pseudocode algorithm translates into the following C++ function:
template <class elemType>
bool bSearchTreeType<elemType>::search
(const elemType& searchItem) const
{
nodeType<elemType> *current;
bool found = false;
if (root == nullptr)
cout << "Cannot search an empty tree." << endl;
else
{
current = root;
while (current != nullptr && !found)
{
if (current->info == searchItem)
found = true;
else if (current->info > searchItem)
current = current->lLink;
else
current = current->rLink;
}//end while
}//end else
return found;
}//end search

INSERT
After inserting an item in a binary search tree, the resulting binary tree must be a binary
search tree. To insert a new item, first we search the binary search tree and find the place
where the new item is to be inserted. The search algorithm is similar to the search algorithm
of the function search. Here, we traverse the binary search tree with two pointers—a pointer,
say, current, to check the current node and a pointer, say, trailCurrent, pointing to
the parent of current. Because duplicate items are not allowed, our search must end at an
empty subtree. We can then use the pointer trailCurrent to insert the new item at the
proper place. The item to be inserted, insertItem, is passed as a parameter to the function
insert. The general algorithm is:

a.

Create a new node and copy insertItem into the new node. Also set lLink
and rLink of the new node to nullptr.

b. if the root is nullptr, the tree is empty, so make root point to
the new node.
else
{
current = root;
while (current is not nullptr)

//search the binary tree

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1372

| Chapter 19: Binary Trees

{
trailCurrent = current;
if (current->info is the same as the insertItem)
Error: Cannot insert duplicate
exit
else
if (current->info > insertItem)
Follow lLink of current
else
Follow rLink of current
}
//insert the new node in the binary tree
if (trailCurrent->info > insertItem)
make the new node the left child of trailCurrent
else
make the new node the right child of trailCurrent
}

This pseudocode algorithm translates into the following C++ function:
template <class elemType>
void bSearchTreeType<elemType>::insert
(const elemType& insertItem)
{
nodeType<elemType> *current; //pointer to traverse the tree
nodeType<elemType> *trailCurrent; //pointer behind current
nodeType<elemType> *newNode; //pointer to create the node
newNode = new nodeType<elemType>;
newNode->info = insertItem;
newNode->lLink = nullptr;
newNode->rLink = nullptr;
if (root == nullptr)
root = newNode;
else
{
current = root;
while (current != nullptr)
{
trailCurrent = current;
if (current->info == insertItem)
{
cout << "The item to be inserted is already ";
cout << "in the tree -- duplicates are not "
<< "allowed." << endl;
return;
}
else if (current->info > insertItem)
current = current->lLink;
else
current = current->rLink;
}//end while
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Search Trees

|

1373

if (trailCurrent->info > insertItem)
trailCurrent->lLink = newNode;
else
trailCurrent->rLink = newNode;
}
}//end insert

DELETE
As before, first we search the binary search tree to find the node to be deleted. To help
you better understand the delete operation, before describing the function to delete an
item from the binary search tree, let us consider the binary search tree in Figure 19-9.

1
9

root
60

50
30

70
53

80
57

35
32

75
40

77
48

45

FIGURE 19-9

Binary search tree before deleting a node

After deleting the desired item (if it exists in the binary search tree), the resulting tree
must be a binary search tree. The delete operation has four cases, as follows:
Case 1: The node to be deleted has no left and right subtrees; that is, the node to be
deleted is a leaf. For example, the node with info 45 is a leaf.
Case 2: The node to be deleted has no left subtree; that is, the left subtree is empty, but it
has a nonempty right subtree. For example, the left subtree of node with info 40 is
empty, and its right subtree is nonempty.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1374

| Chapter 19: Binary Trees

Case 3: The node to be deleted has no right subtree; that is, the right subtree is empty,
but it has a nonempty left subtree. For example, the left subtree of node with info 80 is
empty, and its right subtree is nonempty.
Case 4: The node to be deleted has nonempty left and right subtrees. For example, the
left and the right subtrees of node with info 50 are nonempty.
Figure 19-10 illustrates these four cases.

root

root

60

60

70

50

50

32

40

40

77

45

(a) Delete 45

(b) Delete 30

root

root
60

50
30

60

70

57

30

77

40

80

53
57

35
32

48
45

70

48
75

53
35

FIGURE 19-10

75

57

48

77

48

32

80

53

32

75

57

35

35

80

53

30

70

75
77

40
45

(c) Delete 80

(d) Delete 50

Binary trees of Figure 19-9 after deleting various items

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Search Trees

|

1375

Case 1: Suppose that we want to delete 45 from the binary search tree in Figure 19-9. We
search the binary tree and arrive at the node containing 45. Because this node is a leaf and is
the left child of its parent, we can simply set the lLink of the parent node to nullptr and
deallocate the memory occupied by this node. After deleting this node, Figure 19-10(a)
shows the resulting binary search tree.
Case 2: Suppose that we want to delete 30 from the binary search tree in Figure 19-9. In
this case, the node to be deleted has no left subtree. Because 30 is the left child of its parent
node, we make the lLink of the parent node point to the right child of 30 and then
deallocate the memory occupied by 30. Figure 19-10(b) shows the resulting binary tree.
Case 3: Suppose that we want to delete 80 from the binary search tree of Figure 19-9.
The node containing 80 has no right child and is the right child of its parent. Thus,
we make the rLink of the parent of 80—that is, 70—point to the left child of 80.
Figure 19-10(c) shows the resulting binary tree.
Case 4: Suppose that we want to delete 50 from the binary search tree in Figure 19-9. The
node with info 50 has a nonempty left subtree and a nonempty right subtree. Here, we first
reduce this case to either case 2 or case 3 as follows. To be specific, suppose that we reduce it to
case 3—that is, the node to be deleted has no right subtree. For this case, we find the immediate
predecessor of 50 in this binary tree, which is 48. This is done by first going to the left child of
50 and then locating the rightmost node of the left subtree of 50. To do so, we follow the
rLink of the nodes. Because the binary search tree is finite, we eventually arrive at a node that
has no right subtree. Next, we swap the info in the node to be deleted with the info of its
immediate predecessor. In this case, we swap 48 with 50. This reduces to the case wherein the
node to be deleted has no right subtree. We now apply case 3 to delete the node. (Note:
Because we will delete the immediate predecessor from the binary tree, we, in fact, copy only
the info of the immediate predecessor into the node to be deleted.) After deleting 50 from the
binary search tree in Figure 19-9, the resulting binary tree is as shown in Figure 19-10(d).
In each case, we clearly see that the resulting binary tree is again a binary search tree.
From this discussion, it follows that to delete an item from the binary search tree, we must
do the following:
1. Find the node containing the item (if any) to be deleted.
2. Delete the node.
We accomplish the second step by a separate function, which we will call deleteFromTree.
Given a pointer to the node to be deleted, this function deletes the node by taking into
account the previous four cases.
From the preceding examples, it is clear that whenever we delete a node from the binary
tree, we adjust one of the pointers of the parent node. Because the adjustment has to be
made in the parent node, we must call the function deleteFromTree by using an
appropriate pointer of the parent node. For example, suppose that the node to be deleted
is 35, which is the right child of its parent node. Suppose that trailCurrent points to the
node containing 30, the parent node of 35. A call to the function deleteFromTree is:
deleteFromTree(trailCurrent->rLink);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1376

| Chapter 19: Binary Trees

Of course, if the node to be deleted is the root node, then the call to the function
deleteFromTree is:
deleteFromTree(root);

We now define the C++ function deleteFromTree:
template <class elemType>
void bSearchTreeType<elemType>::deleteFromTree
(nodeType<elemType>* &p)
{
nodeType<elemType> *current; //pointer to traverse the tree
nodeType<elemType> *trailCurrent; //pointer behind current
nodeType<elemType> *temp;
//pointer to delete the node
if (p == nullptr)
cout << "Error: The node to be deleted does not exist."
<< endl;
else if (p->lLink == nullptr && p->rLink == nullptr)
{
temp = p;
p = nullptr;
delete temp;
}
else if (p->lLink == nullptr)
{
temp = p;
p = temp->rLink;
delete temp;
}
else if (p->rLink == nullptr)
{
temp = p;
p = temp->lLink;
delete temp;
}
else
{
current = p->lLink;
trailCurrent = nullptr;
while (current->rLink != nullptr)
{
trailCurrent = current;
current = current->rLink;
}//end while
p->info = current->info;
if (trailCurrent == nullptr) //current did not move;
//current == p->lLink; adjust p
p->lLink = current->lLink;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Search Trees

|

1377

else
trailCurrent->rLink = current->lLink;
delete current;
}//end else
} //end deleteFromTree

Next, we describe the function deleteNode. The function deleteNode first searches
the binary search tree to find the node containing the item to be deleted. The item to be
deleted, deleteItem, is passed as a parameter to the function. If the node containing
deleteItem is found in the binary search tree, the function deleteNode calls
the function deletefromTree to delete the node. The definition of the function
deleteNode is given next.
template <class elemType>
void bSearchTreeType<elemType>::deleteNode
(const elemType& deleteItem)
{
nodeType<elemType> *current; //pointer to traverse the tree
nodeType<elemType> *trailCurrent; //pointer behind current
bool found = false;
if (root == nullptr)
cout << "Cannot delete from an empty tree."
<< endl;
else
{
current = root;
trailCurrent = root;
while (current != nullptr && !found)
{
if (current->info == deleteItem)
found = true;
else
{
trailCurrent = current;
if (current->info > deleteItem)
current = current->lLink;
else
current = current->rLink;
}
}//end while
if (current == nullptr)
cout << "The item to be deleted is not in the tree."
<< endl;
else if (found)
{
if (current == root)
deleteFromTree(root);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1378

| Chapter 19: Binary Trees

else if (trailCurrent->info > deleteItem)
deleteFromTree(trailCurrent->lLink);
else
deleteFromTree(trailCurrent->rLink);
}
else
cout << "The item to be deleted is not in the tree."
<< endl;
}
} //end deleteNode

Binary Search Tree: Analysis
Let T be a binary search tree with n nodes, in which n > 0. Suppose that we want to
determine whether an item, x, is in T. The performance of the search algorithm depends
on the shape of T. Let us first consider the worst case. In the worst case, T is linear. That
is, the T is one of the forms shown in Figure 19-11.

a1

a1
a2

a2
.
.
.

.
.
.
an

(a)

FIGURE 19-11

an

(b)

Linear binary search trees

Because T is linear, the performance of the search algorithm on T is the same as its performance
on a linear list. Therefore, in the successful case, on average, the search algorithm makes
n þ 1 ¼ OðnÞ key comparisons. In the unsuccessful case, it makes n comparisons.
2
Let us now consider the average-case behavior. In the successful case, the search would
end at a node. Because there are n items, there are n! possible orderings of the keys. We
assume that all n! orderings of the keys are possible. Let S(n) denote the number of
comparisons in the average successful case, and let U(n) denote the number of comparisons in the average unsuccessful case.
The number of comparisons required to determine whether x is in T is one more than
the number of comparisons required to insert x in T. Furthermore, the number of
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Nonrecursive Binary Tree Traversal Algorithms

|

1379

comparisons required to insert x in T is the same as the number of comparisons made in
the unsuccessful search, reflecting that x is not in T. From this, it follows that:
SðnÞ ¼ 1 þ

Uð0Þ þ Uð1Þ þ ::: þ Uðn  1Þ
n

ð19-1Þ

It is also known that:

SðnÞ ¼


1
1 þ UðnÞ  3
n

ð19-2Þ

Solving equations (19-1) and (19-2), it can be shown that:
UðnÞ  2:77log2 n ¼ Oðlog2 nÞ
and:
SðnÞ  2:77log2 n ¼ Oðlog2 nÞ
We can now formulate the following result.
Theorem: Let T be a binary search tree with n nodes, in which n > 0. The average
number of nodes visited in a search of T is approximately 1.39log2n ¼ O(log2n), and the
number of key comparisons is approximately 2.77log2n ¼ O(log2n).

Nonrecursive Binary Tree Traversal Algorithms
The previous sections described how to do the following:
•
•
•
•

Traverse a binary tree using the inorder, preorder, and postorder methods.
Construct a binary tree.
Insert an item in the binary tree.
Delete an item from the binary tree.

The traversal algorithms—inorder, preorder, and postorder—discussed earlier are recursive. Because traversing a binary tree is a fundamental operation, this section discusses the
nonrecursive inorder, preorder, and postorder traversal algorithms.

Nonrecursive Inorder Traversal
In the inorder traversal of a binary tree, for each node, the left subtree is visited first,
then the node, and then the right subtree. It follows that in an inorder traversal, the first
node visited is the leftmost node of the binary tree. For example, in the binary tree in
Figure 19-12, the leftmost node is the node with info 28.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1380

| Chapter 19: Binary Trees

60

70
20

90
55

88

28

FIGURE 19-12

Binary tree; the leftmost node is 28

To get to the leftmost node of the binary tree, we start by traversing the binary tree at the
root node and then follow the left link of each node until the left link of a node becomes
null. From this point, we back up to the parent node, visit the node, and then move to
the right node. Because links go in only one direction, to get back to a node, we must
save a pointer to the node before moving to the child node. Moreover, the nodes must be
backtracked in the order they were traversed. It follows that while backtracking, the
nodes must be visited in a last-in first-out manner. This can be done by using a stack. We,
therefore, save a pointer to a node in a stack. The general algorithm is as follows:
1. current = root; //start traversing the binary tree at the root node
2. while (current is not nullptr or stack is nonempty)
if (current is not nullptr)
{
push current onto stack;
current = current->lLink;
}
else
{
current = stack.top();
pop stack;
visit current;
//visit the node
current = current->rLink; //move to the right child
}

The following function implements the nonrecursive inorder traversal of a binary tree:
template <class elemType>
void binaryTreeType<elemType>::nonRecursiveInTraversal() const
{
stackType<nodeType<elemType>*> stack;
nodeType<elemType> *current;
current = root;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Nonrecursive Binary Tree Traversal Algorithms

|

1381

while ((current != nullptr) || (!stack.isEmptyStack()))
if (current != nullptr)
{
stack.push(current);
current = current->lLink;
}
else
{
current = stack.top();
stack.pop();
cout << current->info << " ";
current = current->rLink;
}
cout << endl;
} //end nonRecursiveInTraversal

Nonrecursive Preorder Traversal
In a preorder traversal of a binary tree, for each node, first the node is visited, then the left
subtree is visited, and then the right subtree is visited. As in the case of an inorder
traversal, after visiting a node and before moving to the left subtree, we must save a
pointer to the node so that after visiting the left subtree, we can visit the right subtree.
The general algorithm is as follows:
1. current = root; //start the traversal at the root node
2. while (current is not nullptr or stack is nonempty)
if (current is not nullptr)
{
visit current node;
push current onto stack;
current = current->lLink;
}
else
{
current = stack.top();
pop stack;
current = current->rLink; //move to the right child
}

The following function implements the nonrecursive preorder traversal algorithm:
template <class elemType>
void binaryTreeType<elemType>::nonRecursivePreTraversal() const
{
stackType<nodeType<elemType>*> stack;
nodeType<elemType> *current;
current = root;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1382

| Chapter 19: Binary Trees

while ((current != nullptr) || (!stack.isEmptyStack()))
if (current != nullptr)
{
cout << current->info << " ";
stack.push(current);
current = current->lLink;
}
else
{
current = stack.top();
stack.pop();
current = current->rLink;
}
cout << endl;
} //end nonRecursivePreTraversal

Nonrecursive Postorder Traversal
In a postorder traversal of a binary tree, for each node, first the left subtree is visited, then
the right subtree is visited, and then the node is visited. As in the case of an inorder
traversal, in a postorder traversal, the first node visited is the leftmost node of the binary
tree. Because—for each node—the left and right subtrees are visited before visiting the
node, we must indicate to the node whether the left and right subtrees have been visited.
After visiting the left subtree of a node and before visiting the node, we must visit its right
subtree. Therefore, after returning from a left subtree, we must tell the node that the right
subtree needs to be visited, and after visiting the right subtree, we must tell the node that
it can now be visited. To do this, other than saving a pointer to the node (to get back to
the right subtree and to the node itself), we also save an integer value of 1 before moving
to the left subtree and an integer value of 2 before moving to the right subtree. Whenever
the stack is popped, the integer value associated with that pointer is popped as well. This
integer value tells whether the left and right subtrees of a node have been visited.
The general algorithm is:
1. current = root; //start the traversal at the root node
2. v = 0;
3. if current is nullptr
The binary tree is empty

4. if current is not nullptr

a.

push current onto stack;

b.

push 1 onto stack;

c.

current = current->lLink;

d.

while (stack is not empty)
if (current is not nullptr and v is 0)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Tree Traversal Algorithms and Functions as Parameters

|

1383

{
push current and 1 onto stack;
current = current->lLink;
}
else
{
assign the top element of stack to current and v;
pop stack;
if (v == 1)
{
push current and 2 onto stack;
current = current->rLink;
v = 0;
}
else
visit current;
}

We will use two (parallel) stacks: one to save a pointer to a node and another to save the
integer value (1 or 2) associated with this pointer. We leave it as an exercise for you to
write the definition of a C++ function to implement the preceding postorder traversal
algorithm. See Programming Exercise 6 at the end of this chapter.

Binary Tree Traversal Algorithms and Functions
as Parameters
Suppose that you have stored employee data in a binary search tree, and at the end of the
year pay increases or bonuses are to be awarded to each employee. This task requires that
each node in the binary search tree be visited and that the salary of each employee be
updated. The preceding sections discussed various ways to traverse a binary tree. However,
in these traversal algorithms—inorder, preorder, and postorder—whenever we visited a
node, for simplicity and for illustration purposes, we output only the data contained in each
node. How do we use a traversal algorithm to visit each node and update the data in each
node? One way to do so is to first create another binary search tree in which the data in
each node is the updated data of the original binary search tree and then destroy the old
binary search tree. This would require extra computer time and perhaps extra memory
and, therefore, is not efficient. Another solution is to write separate traversal algorithms to
update the data. This solution requires you to frequently modify the definition of the class
implementing the binary search tree. However, if the user can write an appropriate
function to update the data of each employee and then pass the function as a parameter
to the traversal algorithms, we can considerably enhance the program’s flexibility. This
section describes how to pass functions as parameters to other functions.
In C++, a function name without any parentheses is considered a pointer to the function.
To specify a function as a formal parameter to another function, we specify the function
type, followed by the function name as a pointer, followed by the parameter types of the
function. For example, consider the following statements:
void fParamFunc1(void (*visit) (int));
void fParamFunc2(void (*visit) (elemType&));

//Line 1
//Line 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1384

| Chapter 19: Binary Trees

The statement in Line 1 declares fParamFunc1 to be a function that takes as a parameter
any void function that has one value parameter of type int. The statement in Line 2
declares fParamFunc2 to be a function that takes as a parameter any void function that
has one reference parameter of type elemType.
We can now rewrite, say, the inorder traversal function of the class binaryTreeType.
Alternately, we can overload the existing inorder traversal functions. To further illustrate
function overloading, we will overload the inorder traversal functions. Therefore, we
include the following statements in the definition of the class binaryTreeType:
void inorderTraversal(void (*visit) (elemType&)) const;
//Function to do an inorder traversal of the binary tree.
//The parameter visit, which is a function, specifies
//the action to be taken at each node.
//Postcondition: The action specified by the function
//
visit is applied to each node of the
//
binary tree.
void inorder(nodeType<elemType> *p,
void (*visit) (elemType&)) const;
//Function to do an inorder traversal of the binary tree
//starting at the node specified by the parameter p.
//The parameter visit, which is a function, specifies the
//action to be taken at each node.
//Postcondition: The action specified by the function visit
//
is applied to each node of the binary tree
//
to which p points.

The definitions of these functions are as follows:
template <class elemType>
void binaryTreeType<elemType>::inorderTraversal
(void (*visit) (elemType& item)) const
{
inorder(root, *visit);
}
template <class elemType>
void binaryTreeType<elemType>::inorder(nodeType<elemType>* p,
void (*visit) (elemType& item)) const
{
if (p != nullptr)
{
inorder(p->lLink, *visit);
(*visit)(p->info);
inorder(p->rLink, *visit);
}
}

The statement:
(*visit)(p->info);

in the definition of the function inorder makes a call to the function with one reference
parameter of type elemType pointed to by the pointer visit.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary Tree Traversal Algorithms and Functions as Parameters

|

1385

Example 19-5 further illustrates how functions are passed as parameters to other functions.
EXAMPLE 19-5
This example shows how to pass a user-defined function as a parameter to the binary tree
traversal algorithms. For illustration purposes, we show how to use only the inorder
traversal function.
The following program uses the class bSearchTreeType, which is derived from
the class binaryTreeType, to build the binary tree. The traversal functions are
included in the class binaryTreeType, which are then inherited by the class
bSearchTreeType.

1
9

#include <iostream>
#include "binarySearchTree.h"
using namespace std;
void print(int& x);
void update(int& x);
int main()
{
bSearchTreeType<int> treeRoot;

//Line 1

int num;

//Line 2

cout << "Line 3: Enter numbers ending "
<< "with -999." << endl;
cin >> num;

//Line 3
//Line 4

while (num != -999)
{
treeRoot.insert(num);
cin >> num;
}
cout << endl
<< "Line 8: Tree nodes in inorder: ";
treeRoot.inorderTraversal(print);
cout << endl << "Line 10: Tree Height: "
<< treeRoot.treeHeight()
<< endl << endl;

//Line 5
//Line 6
//Line 7

//Line 8
//Line 9
//Line 10

cout << "Line 11: ******* Update Nodes "
<< "*******" << endl;
treeRoot.inorderTraversal(update);

//Line 11
//Line 12

cout << "Line 13: Tree nodes in inorder "
<< "after the update: " << endl
<< "
";
treeRoot.inorderTraversal(print);

//Line 13
//Line 14

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1386

| Chapter 19: Binary Trees

cout << endl << "Line 15: Tree Height: "
<< treeRoot.treeHeight() << endl;

//Line 15

return 0;

//Line 16

}
void print(int& x)
{
cout << x << " ";
}

//Line 17

void update(int& x)
{
x = 2 * x;
}

//Line 19

//Line 18

//Line 20

Sample Run: In this sample run, the user input is shaded.
Line 3: Enter numbers ending with -999.
56 87 23 65 34 45 12 90 66 -999
Line 8: Tree nodes in inorder: 12 23 34 45 56 65 66 87 90
Line 10: Tree Height: 4
Line 11: ******* Update Nodes *******
Line 13: Tree nodes in inorder after the update:
24 46 68 90 112 130 132 174 180
Line 15: Tree Height: 4

This program works as follows. The statement in Line 1 declares treeRoot to be a binary
search tree object, in which the data in each node is of type int. The statements in Lines 4
through 7 build the binary search tree. The statement in Line 9 uses the member function
inorderTraversal of treeRoot to traverse the binary search tree treeRoot. The
parameter to the function inorderTraversal, in Line 9, is the function print (defined
at Line 17). Because the function print outputs the value of its argument, the statement in
Line 9 outputs the data of the nodes of the binary search tree treeRoot. The statement in
Line 10 outputs the height of the binary search tree.
The statement in Line 12 uses the member function inorderTraversal to traverse
the binary search tree treeRoot. In Line 12, the actual parameter of the function
inorderTraversal is the function update (defined at Line 19). The function
update doubles the value of its argument. Therefore, the statement in Line 12 updates
the data of each node of the binary search tree by doubling the value. The statements in
Lines 14 and 15 output the nodes and the height of the binary search tree.

(AVL trees) This chapter also discusses AVL trees. The necessary material is in the file
AVL Trees.pdf. The file is available at www.cengagebrain.com. To find the file, navigate to
the book’s page by typing in the ISBN of this text and then click on Free Materials.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store (Revisited)

PROGRAMMING EXAMPLE:

Watch
the Video

DVD Object

|

1387

DVD Store (Revisited)

In Chapter 16, we designed a program to help a DVD store automate its DVD rental
process. That program used an (unordered) linked list to keep track of the DVD
inventory in the store. Because the search algorithm on a linked list is sequential and
the list is fairly large, the search could be time consuming. In this chapter, you learned
how to organize data into a binary tree. If the binary tree is nicely constructed (that is,
it is not linear), then the search algorithm can be improved considerably. Moreover,
in general, item insertion and deletion in a binary search tree are faster than in a
linked list. We will, therefore, redesign the DVD store program so that the DVD
inventory can be maintained in a binary tree. As in Chapter 16, we leave the design
of the customer list in a binary tree as exercises for you.
In Chapter 16, a linked list was used to maintain a list of DVDs in the store. Because
the linked list was unordered, to see whether a particular DVD was in stock, the
sequential search algorithm used the equality operator for comparison. However, in
the case of a binary tree, we need other relational operators for the search, insertion,
and deletion operations. We will, therefore, overload all of the relational operators.
Other than this difference, the class dvdType is the same as before. However, we
give its definition for the sake of completeness.
//************************************************************
// Author: D.S. Malik
//
// class dvdType
// This class specifies the members to implement a DVD. It
// overloads the stream insertion operator and relational
// operators.
//************************************************************
class dvdType
{
friend ostream& operator<< (ostream&, const dvdType&);
public:
void setDVDInfo(string title, string star1,
string star2, string producer,
string director, string productionCo,
int setInStock);
//Function to set the details of a DVD.
//The member variables are set according to the
//parameters.
//Postcondition: dvdTitle = title; movieStar1 = star1;
//
movieStar2 = star2;
//
movieProducer = producer;
//
movieDirector = director;
//
movieProductionCo = productionCo;
//
copiesInStock = setInStock;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1388

| Chapter 19: Binary Trees

int getNoOfCopiesInStock() const;
//Function to check the number of copies in stock.
//Postcondition: The value of copiesInStock is returned.
void checkOut();
//Function to rent a DVD.
//The number of copies in stock is decremented by one.
//Postcondition: copiesInStock--;
void checkIn();
//Function to check in a DVD.
//The number of copies in stock is incremented by one.
//Postcondition: copiesInStock++;
void printTitle() const;
//Function to print the title of a movie.
void printInfo() const;
//Function to print the details of a DVD.
//Postcondition: The title of the movie, stars, director,
//
and so on are output on the screen.
bool checkTitle(string title);
//Function to check whether the title is the same as the
//title of the DVD.
//Postcondition: Returns the value true if the title is
//
the same as the title of the DVD, and
//
false otherwise.
void updateInStock(int num);
//Function to increment the number of copies in stock by
//adding the value of the parameter num.
//Postcondition: copiesInStock = copiesInStock + num;
void setCopiesInStock(int num);
//Function to set the number of copies in stock.
//Postcondition: copiesInStock = num;
string getTitle() const;
//Function to return the title of the DVD.
//Postcondition: The title of the DVD is returned.
dvdType(string title = "", string star1 = "",
string star2 = "", string producer = "",
string director = "", string productionCo = "",
int setInStock = 0);
//Constructor
//The member variables are set according to the incoming
//parameters. If no values are specified, the default
//values are assigned.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store (Revisited)

//Postcondition:
//
//
//
//
//

|

1389

dvdTitle = title; movieStar1 = star1;
movieStar2 = star2;
movieProducer = producer;
movieDirector = director;
movieProductionCo = productionCo;
copiesInStock = setInStock;

//Overload relational operators
operator==(const dvdType&) const;
operator!=(const dvdType&) const;
operator<(const dvdType&) const;
operator<=(const dvdType&) const;
operator>(const dvdType&) const;
operator>=(const dvdType&) const;

bool
bool
bool
bool
bool
bool

private:
string dvdTitle;

//variable to store the name
//of the movie
string movieStar1; //variable to store the name
//of the star
string movieStar2; //variable to store the name
//of the star
string movieProducer; //variable to store the name
//of the producer
string movieDirector; //variable to store the name
//of the director
string movieProductionCo; //variable to store the name
//of the production company
int copiesInStock; //variable to store the number of
//copies in stock

};

The definitions of the member functions of the class dvdType are the same as in
Chapter 16. Because here we are overloading all of the relational operators, we give
only the definitions of these member functions.
//Overload the relational operators
bool dvdType::operator==(const dvdType& right) const
{
return (dvdTitle == right.dvdTitle);
}
bool dvdType::operator!=(const dvdType& right) const
{
return (dvdTitle != right.dvdTitle);
}
bool dvdType::operator<(const dvdType& right) const
{
return (dvdTitle < right.dvdTitle);
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1390

| Chapter 19: Binary Trees

bool dvdType::operator<=(const dvdType& right) const
{
return (dvdTitle <= right.dvdTitle);
}
bool dvdType::operator>(const dvdType& right) const
{
return (dvdTitle > right.dvdTitle);
}
bool dvdType::operator>=(const dvdType& right) const
{
return (dvdTitle >= right.dvdTitle);
}

DVD List

The DVD list is maintained in a binary search tree. Therefore, we derive the class
dvdBinaryTree from the class bSearchTreeType. The definition of the
class dvdBinaryTree is as follows:
//***********************************************************
// Author: D.S. Malik
//
// class dvdBinaryTree
// This class extends the class bSearchTreeType to create
// a DVD list.
//***********************************************************
class dvdBinaryTree: public bSearchTreeType<dvdType>
{
public:
bool dvdSearch(string title);
//Function to search the list to see whether a
//particular title, specified by the parameter title,
//is in the store.
//Postcondition: Returns true if the title is found,
//
and false otherwise.
bool isDVDAvailable(string title);
//Function to determine whether a copy of a particular
//DVD is in the store.
//Postcondition: Returns true if at least one copy of
//
the DVD specified by title is in the
//
store, and false otherwise.
void dvdCheckIn(string title);
//Function to check in a DVD returned by a customer.
//Postcondition: copiesInStock is incremented by one.
void dvdCheckOut(string title);
//Function to check out a DVD, that is, rent a DVD.
//Postcondition: copiesInStock is decremented by one.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store (Revisited)

|

1391

bool dvdCheckTitle(string title) const;
//Function to determine whether a particular DVD is in
//the store.
//Postcondition: Returns true if the DVD’s title is
//
the same as title, and false otherwise.
void dvdUpdateInStock(string title, int num);
//Function to update the number of copies of a DVD
//by adding the value of the parameter num. The
//parameter title specifies the name of the DVD for
//which the number of copies is to be updated.
//Postcondition: copiesInStock = copiesInStock + num;
void dvdSetCopiesInStock(string title, int num);
//Function to reset the number of copies of a DVD.
//The parameter title specifies the name of the DVD
//for which the number of copies is to be reset, and
//the parameter num specifies the number of copies.
//Postcondition: copiesInStock = num;
void dvdPrintTitle() const;
//Function to print the titles of all the DVDs in
//the store.
private:
void searchDVDList(string title, bool& found,
nodeType<dvdType>* &current) const;
//This function searches the DVD list for a
//particular DVD, specified by the parameter title.
//If the DVD is found, the parameter found is set to
//true, otherwise false; the parameter current points
//to the node containing the DVD.
void inorderTitle(nodeType<dvdType> *p) const;
//This function prints the titles of all the DVDs
//in stock.
};

The definitions of the member functions isDVDAvailable, dvdCheckIn,
dvdCheckOut, dvdCheckTitle, dvdUpdateInStock,
dvdSetCopiesInStock, and dvdSearch of the class dvdBinaryTree are
similar to the definitions of these functions given in Chapter 16. The only difference
is that, here, these are members of the class dvdBinaryTree. You can find the
complete definitions of these functions on the Web site that accompanies this book.
Next, we discuss the definitions of the remaining functions of the
class dvdBinaryTree.
The function searchDVDList uses a search algorithm similar to the search
algorithm for a binary search tree given earlier in this chapter. It returns true if the
search item is found in the list. It also returns a pointer to the node containing the
search item. The definition of this function is as follows:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1392

| Chapter 19: Binary Trees

void dvdBinaryTree::searchDVDList(string title,
bool& found,
nodeType<dvdType>* &current) const
{
found = false;
dvdType temp;
temp.setDVDInfo(title, "", "", "", "", "", 0);
if (root == nullptr) //tree is empty
cout << "Cannot search an empty list. " << endl;
else
{
current = root; //set current point to the root node
//of the binary tree
found = false; //set found to false
while (current != nullptr && !found) //search the tree
if (current->info == temp)
//item is found
found = true;
else if (current->info > temp)
current = current->lLink;
else
current = current->rLink;
} //end else
} //end searchDVDList

Given a pointer to the root node of the binary tree containing the DVDs, the
function inorderTitle uses the inorder traversal algorithm to print the titles of the
DVDs. Notice that this function outputs only the DVD titles. The definition of this
function is as follows:
void dvdBinaryTree::inorderTitle
(nodeType<dvdType> *p) const
{
if (p != nullptr)
{
inorderTitle(p->lLink);
p->info.printTitle();
inorderTitle(p->rLink);
}
}

The function dvdPrintTitle uses the function inorderTitle to print the titles
of all DVDs in the store. The definition of this function is:
void dvdBinaryTree::dvdPrintTitle() const
{
inorderTitle(root);
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store (Revisited)

MAIN
PROGRAM

|

1393

The main program is the same as before. Here, we give only the listing of this
program. We assume that the name of the header file containing the definition of the
class dvdBinaryTree is dvdBinaryTree.h, and so on.
//*************************************************************
// Author: D.S. Malik
//
// This program uses the classes dvdType and dvdBinaryTree
// to create a list of DVDs for a DVD store. It performs
// basic operations such as check in and check out DVDs.
//*************************************************************
#include
#include
#include
#include
#include
#include

<iostream>
<fstream>
<string>
"binarySearchTree.h"
"dvdType.h"
"dvdBinaryTree.h"

1
9

using namespace std;
void createDVDList(ifstream& infile,
dvdBinaryTree& dvdList);
void displayMenu();
int main()
{
dvdBinaryTree
int choice;
string title;

dvdList;

ifstream infile;
infile.open("dvdDat.txt");
if (!infile)
{
cout << "The input file does not exist. "
<< "Program terminates!!"<< endl;
return 1;
}
createDVDList(infile, dvdList);
infile.close();
displayMenu();
cout << "Enter your choice:
cin >> choice;
cin.ignore(100, '\n');

//show the menu
";
//get the request
//ignore the remaining
//characters in the line

cout << endl;
while (choice != 9)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1394

| Chapter 19: Binary Trees

{
switch (choice)
{
case 1:
cout << "Enter the title: ";
getline(cin, title);
cout << endl;
if (dvdList.dvdSearch(title))
cout << "The store carries " << title << endl;
else
cout << "The store does not carry " << title
<< endl;
break;
case 2:
cout << "Enter the title: ";
getline(cin, title);
cout << endl;
if (dvdList.dvdSearch(title))
{
if (dvdList.isDVDAvailable(title))
{
dvdList.dvdCheckOut(title);
cout << "Enjoy your movie: " << title
<< endl;
}
else
cout << "Currently " << title
<< " is out of stock." << endl;
}
else
cout << "The store does not carry " << title
<< endl;
break;
case 3:
cout << "Enter the title: ";
getline(cin, title);
cout << endl;
if (dvdList.dvdSearch(title))
{
dvdList.dvdCheckIn(title);
cout << "Thanks for returning " << title
<< endl;
}
else
cout << "The store does not carry " << title
<< endl;
break;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Example: DVD Store (Revisited)

|

1395

case 4:
cout << "Enter the title: ";
getline(cin, title);
cout << endl;
if (dvdList.dvdSearch(title))
{
if (dvdList.isDVDAvailable(title))
cout << title << " is currently in "
<< "stock." << endl;
else
cout << title << " is currently out "
<< "of stock." << endl;
}
else
cout << "The store does not carry " << title
<< endl;
break;
case 5:
dvdList.dvdPrintTitle();
break;
case 6:
dvdList.inorderTraversal();
break;
default: cout << "Invalid selection." << endl;
}//end switch
displayMenu();
//display the menu
cout << "Enter your choice: ";
cin >> choice;
//get the next request
cin.ignore(100, '\n'); //ignore the remaining
//characters in the line
cout << endl;
}//end while
return 0;
}
void createDVDList(ifstream& infile,
dvdBinaryTree& dvdList)
{
string title;
string star1;
string star2;
string producer;
string director;
string productionCo;
int inStock;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1396

| Chapter 19: Binary Trees

dvdType newDVD;
getline(infile, title);
while (infile)
{
getline(infile, star1);
getline(infile, star2);
getline(infile, producer);
getline(infile, director);
getline(infile, productionCo);
infile >> inStock;
infile.ignore(100, '\n');
newDVD.setDVDInfo(title, star1, star2, producer,
director, productionCo, inStock);
dvdList.insert(newDVD);
getline(infile, title);
}//end while
}//end createDVDList
void displayMenu()
{
cout << "Select one of the following:" << endl;
cout << "1: To check whether the store carries a "
<< "particular DVD." << endl;
cout << "2: To check out a DVD." << endl;
cout << "3: To check in a DVD." << endl;
cout << "4: To check whether a particular DVD is "
<< "in stock." << endl;
cout << "5: To print only the titles of all the DVDs."
<< endl;
cout << "6: To print a list of all the DVDs." << endl;
cout << "9: To exit" << endl;
}

QUICK REVIEW
1.

2.
3.
4.

A binary tree is either empty or it has a special node called the root node.
If the tree is nonempty, the root node has two sets of nodes, called the
left and right subtrees, such that the left and right subtrees are also binary
trees.
The node of a binary tree has two links in it.
A node in the binary tree is called a leaf if it has no left and right children.
A node U is called the parent of a node V if there is a branch from U to V.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

5.

6.
7.
8.
9.
10.

1397

A path from a node X to a node Y in a binary tree is a sequence of nodes
X0, X1, . . ., Xn such that (a) X ¼ X0, Xn ¼ Y, and (b) Xi1 is the parent of
Xi for all i ¼ 1, 2, . . ., n. That is, there is a branch from X0 to X1, X1 to X2,
. . ., Xi1 to Xi, . . ., Xn1 to Xn.
The length of a path in a binary tree is the number of branches on
that path.
The level of a node in a binary tree is the number of branches on the path
from the root to the node.
The level of the root node of a binary tree is 0, and the level of the children
of the root node is 1.
The height of a binary tree is the number of nodes on the longest path from
the root to a leaf.
In an inorder traversal, the binary tree is traversed as follows:
Traverse the left subtree.
b.
Visit the node.
c.
Traverse the right subtree.
In a preorder traversal, the binary tree is traversed as follows:
a.

11.

Visit the node.
b.
Traverse the left subtree.
c.
Traverse the right subtree.
In a postorder traversal, the binary tree is traversed as follows:
a.

12.

Traverse the left subtree.
b.
Traverse the right subtree.
c.
Visit the node.
A binary search tree T is either empty or:
a.

13.

T has a special node called the root node;
ii. T has two sets of nodes, LT and RT, called the left subtree and the right
subtree of T, respectively;
iii.
The key in the root node is larger than every key in the left subtree
and smaller than every key in the right subtree; and
iv.
LT and RT are binary search trees.
To delete a node from a binary search tree that has both left and right
nonempty subtrees, first its immediate predecessor is located, then the
predecessor’s info is copied into the node, and finally the predecessor is
deleted.
i.

14.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1398

| Chapter 19: Binary Trees

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

2.

Mark the following statements as true or false.
a. A binary tree must be nonempty. (1, 2)
b. The level of the root node is 0. (1, 2)
c. If a tree has only one node, the height of the tree is 0 because the
number of levels is 0. (2)
d. The level of a node in a binary tree is the number of branches on the
path from the root to the node. (2)
e. The inorder traversal of a binary tree always outputs the data in ascending
order. (3)
f.
In preorder traversal of a binary tree, the node is visited before visiting
the left and right subtrees. (3)
g. In a binary search tree, the data in a node is larger than the data in its
left child, if any. (5)
h. In a binary search tree, the left and right subtrees of a node are binary
search trees. (5)
i.
To insert a new item in a binary search tree, first we search the binary
search tree and find the place where the new item is to be inserted. (7)
j.
Typically, a stack is used to implement a nonrecursive traversal algorithm in a binary tree. (8)
k. In C++, a function name without any parentheses is considered a
pointer to the function. (9)
There are 14 different binary trees with four nodes. Draw all of them. (1, 2)
The binary tree of Figure 19-13, is to be used for Exercises 3 through 20.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

1399

A

B

C

D
H

E
I

L
O

FIGURE 19-13

J

K
M

P

G

F

1
9

N
Q

R

Figure for Exercises 3 to 20

Find LA, the node in the left subtree of A. (1, 2)
4.
Find RA, the node in the right subtree of A. (1, 2)
5.
Find LB, the node in the left subtree of B. (1, 2)
6.
Find RB, the node in the right subtree of B. (1, 2)
7.
Find LE, the node in the left subtree of E. (1, 2)
8.
Find the height of the tree with root A. (1, 2)
9.
Find the height of the tree with root D. (1, 2)
10. Find the level of the node M. (1, 2)
11. Find the height of the tree with root C. (1, 2)
12. Find the level of the node K. (1, 2)
13. Find the level of the node F. (1, 2)
14. Find the number of leaves in the binary tree with root A. (1, 2)
15. Find the number of leaves in the binary tree with root C. (1, 2)
16. List the leaves in the binary tree with root E. (1, 2)
17. List the nodes in the path from node A to node P. (1, 2)
18. List the nodes of this binary tree in an inorder sequence. (3)
19. List the nodes of this binary tree in a preorder sequence. (3)
20. List the nodes of this binary tree in a postorder sequence. (3)
The binary search tree of Figure 19-14 is to be used for Exercises 21 through 25.
(Note: These exercises are independent of each other.)
3.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1400

| Chapter 19: Binary Trees

68

95

50

40
28
10

75

55
62

35

60

30

72

99
80

96
85

98

90
88

FIGURE 19-14

21.
22.

23.
24.

25.
26.

27.
28.

29.

Figure for Exercises 21 to 25

List the path from the node with info 68 to the node with info 90. (2, 5)
A node with info 58 is to be inserted in the tree. List the nodes that are visited
by the function insert to insert 58. Redraw the tree after inserting 58. (7)
Delete node 60 and redraw the binary tree. (7)
Delete nodes 50 and 95 in that order. Redraw the binary tree after each
deletion. (7)
Delete node 75 and redraw the binary tree. (7)
Insert 28, 25, 26, 42, 47, 30, 45, 29, 5 into an initially empty binary
search tree. Draw the final binary search tree. (6, 7)
Prove that a binary tree with n nodes has exactly n + 1 empty subtree
(nullptr). (1, 2)
Suppose that you are given two sequences of elements corresponding to the
inorder sequence and the preorder sequence. Prove that it is possible to
reconstruct a unique binary tree. (1, 3)
The following lists the nodes in a binary tree in two different orders:
preorder:
inorder:

ABCDEFGHIJKLM
CEDFBAHJIKGML

Draw the binary tree. (1, 3)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

30.

|

1401

Given the nodes of a binary tree in the preorder sequence and the postorder
sequence, show that it may not be possible to reconstruct a unique binary tree. (3)
The binary tree of Figure 19-15 is to be used for Exercises 31 and 32.

root
a

b

c

g

FIGURE 19-15
31.

32.

33.
34.

f

e

d

h

Figure for Exercises 31 and 32

Recall the nonrecursive inorder traversal algorithm for a binary tree given
in this chapter. Do an inorder traversal of the binary tree in Figure 19-15.
Show the stack contents after each push and pop operation. (8)
Recall the nonrecursive preorder traversal algorithm for a binary tree given
in this chapter. Do a preorder traversal of the binary tree in Figure 19-15.
Show the stack contents after each push and pop operation. (8)
Draw the UML class diagram of the class binaryTreeType.
Draw the UML class diagram of the class bSearchTreeType. Also,
show the inheritance hierarchy.

PROGRAMMING EXERCISES
1.

2.

3.

Write the definition of the function, nodeCount, that returns the number of
nodes in the binary tree. Add this function to the class binaryTreeType
and create a program to test this function.
Write the definition of the function, leavesCount, that takes as a parameter
a pointer to the root node of a binary tree and returns the number of leaves in
a binary tree. Add this function to the class binaryTreeType and create a
program to test this function.
Write a function, swapSubtrees, that swaps all of the left and right subtrees
of a binary tree. Add this function to the class binaryTreeType
and create a program to test this function.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1
9

1402

4.

5.
6.

7.

8.

9.

10.

| Chapter 19: Binary Trees

Write a function, singleParent, that returns the number of nodes in a
binary tree that have only one child. Add this function to the class
binaryTreeType and create a program to test this function. (Note: First
create a binary search tree.)
Write a program to test various operations on a binary search tree.
a. Write the definition of the function to implement the nonrecursive
postorder traversal algorithm.
b. Write a program to test the nonrecursive inorder, preorder, and postorder traversal algorithms. (Note: First create a binary search tree.)
Write a version of the preorder traversal algorithm in which a user-defined
function can be passed as a parameter to specify the visiting criteria at a node.
Also, write a program to test your function.
Write a version of the postorder traversal algorithm in which a user-defined
function can be passed as a parameter to specify the visiting criteria at a node.
Also, write a program to test your function.
Write a function that inserts the nodes of a binary tree into an ordered
linked list. Also write a program to test your function.
Write a program to do the following:
Build a binary search tree, T1.
b. Do a postorder traversal of T1 and, while doing the postorder traversal,
insert the nodes into a second binary search tree T2.
c. Do a preorder traversal of T2 and, while doing the preorder traversal,
insert the node into a third binary search tree T3.
d. Do an inorder traversal of T3.
e. Output the heights and the number of leaves in each of the three binary
search trees.
(DVD Store Program) In Programming Exercise 14 in Chapter 16, you
were asked to design and implement a class to maintain customer data in a
linked list. Because the search on a linked list is sequential and, therefore, can
be time consuming, design and implement the class customerBTreeType
so that this customer data can be stored in a binary search tree. The class
customerBTreeType must be derived from the class bSearchTreeType,
as designed in this chapter. (To output the number of DVDs rented by a
customer, write the definition of the function nodeCount, as in Programming
Exercise 1, of the class binaryTreeType.)
(DVD Store Program) Using classes to implement the DVD data, DVD
list data, customer data, and customer list data, as designed in this chapter
and in Programming Exercise 11, design and complete the program to put
the DVD store into operation. (To output the number of DVDs rented by a
customer, write the definition of the function nodeCount, as in Programming Exercise 1, of the class binaryTreeType.)
a.

11.

12.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

20
CHAPTER

ª HunThomas/Shutterstock.com

G RAPHS
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about graphs

2.

Become familiar with the basic terminology of graph theory

3.

Discover how to represent graphs in computer memory

4.

Explore graphs as ADTs

5.

Examine and implement various graph traversal algorithms

6.

Learn how to implement the shortest path algorithm

7.

Examine and implement the minimal spanning tree algorithm

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1404

| Chapter 20: Graphs

In previous chapters, you learned various ways to represent and manipulate data. This
chapter discusses how to implement and manipulate graphs, which have numerous
applications in computer science.

Introduction
In 1736, the following problem was posed. In the town of Königsberg (now called
Kaliningrad), the river Pregel (Pregolya) flows around the island Kneiphof and then
divides into two branches (see Figure 20-1).

C

c

d
g

A
Königsberg

a

D

f

b

B

FIGURE 20-1

e

Königsberg bridge problem

The river has four land areas (A, B, C, D), as shown in the figure. These land areas are
connected using seven bridges, as shown in Figure 20-1. The bridges are labeled a, b, c, d, e,
f, and g. The Königsberg bridge problem is as follows: Starting at one land area, is it possible
to walk across all of the bridges exactly once and return to the starting land area? In 1736,
Euler represented the Königsberg bridge problem as a graph, as shown in Figure 20-2, and
answered the question in the negative. This marked (as recorded) the birth of graph theory.

C
c

g

d
e

A
a

D

b
f
B

FIGURE 20-2

Graph representation of Königsberg bridge problem

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Graph Definitions and Notations

|

1405

A solution of the Königsberg bridge problem is given in the book Discrete Mathematics:
Theory and Applications (Revised Edition) listed in Appendix H.

Over the past 200 years, graph theory has been applied to a variety of applications. Graphs
are used to model electrical circuits, chemical compounds, highway maps, and so on.
They are also used in the analysis of electrical circuits, finding the shortest route, project
planning, linguistics, genetics, social science, and so forth. In this chapter, you will learn
about graphs and their applications in computer science.

Graph Definitions and Notations
To facilitate and simplify our discussion, we borrow a few definitions and terminology
from set theory. Let X be a set. If a is an element of X, then we write a 2 X. (The symbol
‘‘2’’ means ‘‘belongs to.’’) A set Y is called a subset of X if every element of Y is also an
element of X. If Y is a subset of X, we write Y  X. (The symbol ‘‘’’ means ‘‘is a subset
of.’’) The intersection of sets A and B, written A \ B, is the set of all of the elements that
are in A and B; that is, A \ B ¼ {x | x 2 A and x 2 B}. (The symbol ‘‘\’’ means
‘‘intersection.’’) The union of sets A and B, written A [ B, is the set of all of the elements
that are in A or in B; that is, A [ B ¼ {x | x 2 A or x 2 B}. (The symbol ‘‘[’’ means
‘‘union.’’ Moreover, note that x 2 A [ B means x is in A or x is in B or x is in both A and B.
Also, the symbol ‘‘|’’ is read as ‘‘such that.’’)
For sets A and B, the set A  B is the set of all of the ordered pairs of elements of A and
B; that is, A  B ¼ {(a, b) | a 2 A, b 2 B}.
A graph G is a pair, G ¼ (V, E), in which V is a finite nonempty set, called the set of
vertices of G, and E  V  V. That is, the elements of E are the pair of elements of V.
E is called the set of edges.
Let V(G) denote the set of vertices and E(G) denote the set of edges of a graph G. If the
elements of E(G) are ordered pairs, G is called a directed graph or digraph; otherwise,
G is called an undirected graph. In an undirected graph, the pairs (u, v) and (v, u)
represent the same edge. If (u, v) is an edge in a directed graph, then sometimes the vertex
u is called the origin of the edge, and the vertex v is called the destination.
Let G be a graph. A graph H is called a subgraph of G if V(H )  V(G) and E(H )  E(G );
that is, every vertex of H is a vertex of G, and every edge in H is an edge in G.
To learn more about sets and graph terminology, the interested reader is referred to the book
Discrete Mathematics: Theory and Applications (Revised Edition), listed in Appendix H.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1406

| Chapter 20: Graphs

A graph can be shown pictorially. The vertices are drawn as circles, and a label inside of
the circle represents the vertex. In an undirected graph, the edges are drawn using lines.
In a directed graph, the edges are drawn using arrows. Moreover, in a directed graph, the
tail of a pictorial directed edge is the origin, and the head is the destination.
EXAMPLE 20-1
Figure 20-3 shows some examples of undirected graphs.

1

2

1
2

5

4

7
3

3
4

6

5

6
7

London

SF

Tokyo
NY
Paris

LA
Dallas

FIGURE 20-3

Delhi

Various undirected graphs

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Graph Definitions and Notations

|

1407

EXAMPLE 20-2
Figure 20-4 shows some examples of directed graphs.

1

2

4

3

0

1

3

5

4

5
7

6

G1

G2

FIGURE 20-4

2

8

2
0

Various directed graphs

For the graphs of Figure 20-4, we have
V (G1) ¼ {1, 2, 3, 4, 5}

E(G1) ¼ {(1, 2), (1, 4), (2, 3), (2, 5), (4, 2), (4, 3), (4, 5)}

V (G2) ¼ {0, 1, 2, 3, 4, 5, 6, 7, 8}

E(G2) ¼ {(0, 1), (0, 3), (1, 2), (1, 5), (2, 0), (2, 7), (3, 4),
(3, 6), (4, 8),(5, 4), (6, 0), (8, 5), (8, 6),}

Let G be an undirected graph. Let u and v be two vertices in G. Then, u and v are called
adjacent if there is an edge from one to the other; that is, (u, v) 2 E(G). Let e ¼ (u, v) be
an edge in G. We then say that edge e is incident on the vertices u and v. An edge
incident on a single vertex is called a loop. If two edges, e1 and e2, are associated with the
same pair of vertices, then e1 and e2 are called parallel edges. A graph is called a simple
graph if it has no loops and no parallel edges. There is a path from u to v if there is a
sequence of vertices u1, u2, . . ., un such that u ¼ u1, un ¼ v, and (ui, ui + 1) is an edge for all
i ¼ 1, 2, . . ., n  1. Vertices u and v are called connected if there is a path from u to v. A
simple path is a path in which all of the vertices, except possibly the first and last
vertices, are distinct. A cycle in G is a simple path in which the first and last vertices are
the same. G is called connected if there is a path from any vertex to any other vertex. A
maximal subset of connected vertices is called a component of G.
Let G be a directed graph, and let u and v be two vertices in G. If there is an edge from u
to v, that is, (u, v) 2 E(G), then we say that u is adjacent to v and v is adjacent from u.
The definitions of the paths and cycles in G are similar to those for undirected graphs. G
is called strongly connected if any two vertices in G are connected.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1408

| Chapter 20: Graphs

Consider the directed graphs of Figure 20-4. In G1, 1-4-2-5 is a path from vertex 1 to
vertex 5. There are no cycles in G1. In G2, 0-3-4-8-5 is a path from vertex 0 to vertex 5;
6-0-1-2-7 is a path from vertex 6 to vertex 7; 0-1-2-0 is a cycle; 3-4-8-6-0-3 is a cycle;
and 0-1-5-4-8-6-0 is a cycle.

Graph Representation
To write programs that process and manipulate graphs, the graphs must be stored—that
is, represented—in computer memory. A graph can be represented (in computer
memory) in several ways. We now discuss two commonly used methods: adjacency
matrices and adjacency lists.

Adjacency Matrix
Let G be a graph with n vertices, in which n > 0. Let V(G) ¼ {v1, v2, . . ., vn}. The
adjacency matrix AG of G is a two-dimensional n  n matrix such that the (i, j)th entry
of AG is 1 if there is an edge from vi to vj; otherwise, the (i, j)th entry is zero. That is:

AG ði; jÞ ¼

1 if ð i ;  j Þ 2 EðGÞ
0 otherwise

In an undirected graph, if (vi, vj) 2 E(G), then (vj, vi) 2 E(G), so AG(i, j) ¼ 1 ¼ AG( j, i).
It follows that the adjacency matrix of an undirected graph is symmetric.
EXAMPLE 20-3
Consider the directed graphs of Figure 20-4. The adjacency matrices of the directed
graphs G1 and G2 are as follows:

2

0
60
6
AG1 ¼ 6
60
40
0

1
0
0
1
0

0
1
0
1
0

1
0
0
0
0

3
0
17
7
07
7 and
15
0

2
0 0
16
60
26
61
36
60
AG 2 ¼ 4 6
60
56
60
66
61
740
8 0

1
0
0
0
0
0
0
0
0

0
1
0
0
0
0
0
0
0

1
0
0
0
0
0
0
0
0

0
0
0
1
0
1
0
0
0

0
1
0
0
0
0
0
0
1

0
0
0
1
0
0
0
0
1

0
0
1
0
0
0
0
0
0

3
0
07
7
07
7
07
7
17
7
07
7
07
7
05
0

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Operations on Graphs

|

1409

Adjacency Lists
Let G be a graph with n vertices, in which n > 0. Let V(G) ¼ {v1, v2, . . ., vn}. In the
adjacency list representation, corresponding to each vertex, v, there is a linked list such
that each node of the linked list contains the vertex, u, such that (v, u) 2 E(G). Because
there are n nodes, we use an array, A, of size n, such that A[i] is a reference variable
pointing to the first node of the linked list containing the vertices to which vi is adjacent.
Clearly, each node has two components, say vertex and link. The component
vertex contains the index of the vertex adjacent to vertex i.
EXAMPLE 20-4
Consider the directed graphs of Figure 20-4. Figure 20-5 shows the adjacency list of the
directed graphs G1 and G2.

[1]

2

4

[0]

1

3

[2]

3

5

[1]

2

5

[2]

0

7

[3]

4

6

[4]

8

[5]

4

[6]

0

[3]
2

[4]

3

5

[5]
Adjacency list of graph G1 of Figure 20-4

[7]
[8]

5

6

Adjacency list of graph G2 of Figure 20-4

FIGURE 20-5

Adjacency list of graphs of Figure 20-4

Operations on Graphs
Now that you know how to represent graphs in computer memory, the next obvious
step is to learn the basic operations on a graph. The operations commonly performed on a
graph are as follows:
1. Create the graph. That is, store the graph in computer memory using a
particular graph representation.
2. Clear the graph. This operation makes the graph empty.
3. Determine whether the graph is empty.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1410

| Chapter 20: Graphs

4. Traverse the graph.
5. Print the graph.
We will add more operations on a graph when we discuss a specific application or a
particular graph later in this chapter.
How a graph is represented in computer memory depends on the specific application. For
illustration purposes, we use the adjacency list (linked list) representation of graphs. Therefore, for each vertex, v, the vertices adjacent to v (in a directed graph, also called the
immediate successors) are stored in the linked list associated with v.
To manage the data in a linked list, we use the class unorderedLinkedList,
discussed in Chapter 16.
The labeling of the vertices of a graph depends on a specific application. If you are dealing
with the graph of cities, you could label the vertices by the names of the cities. However, to
write algorithms to manipulate a graph as well as to simplify the algorithm, there must be
some ordering to the vertices. That is, we must specify the first vertex, the second vertex, and
so on. Therefore, for simplicity, throughout this chapter, we assume that the n vertices of the
graphs are numbered 0, 1, . . ., n  1. Moreover, it follows that the class that we will design to
implement the graph algorithm will not be a template.

Graphs as ADTs
In this section, we describe the class to implement graphs as an abstract data
type (ADT) and provide the definitions of the functions to implement the operations
on a graph.
The following class defines a graph as an ADT:
class graphType
{
public:
bool isEmpty() const;
//Function to determine whether the graph is empty.
//Postcondition: Returns true if the graph is empty;
//
otherwise, returns false.
void createGraph();
//Function to create a graph.
//Postcondition: The graph is created using the
//
adjacency list representation.
void clearGraph();
//Function to clear graph.
//Postcondition: The memory occupied by each vertex
//
is deallocated.
void printGraph() const;
//Function to print graph.
//Postcondition: The graph is printed.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Graphs as ADTs

|

1411

void depthFirstTraversal();
//Function to perform the depth first traversal of
//the entire graph.
//Postcondition: The vertices of the graph are printed
//
using depth first traversal algorithm.
void dftAtVertex(int vertex);
//Function to perform the depth first traversal of
//the graph at a node specified by the parameter vertex.
//Postcondition: Starting at vertex, the vertices are
//
printed using depth first traversal
//
algorithm.
void breadthFirstTraversal();
//Function to perform the breadth first traversal of
//the entire graph.
//Postcondition: The vertices of the graph are printed
//
using breadth first traversal algorithm.
graphType(int size
//Constructor
//Postcondition:
//
//

= 0);
gSize = 0; maxSize = size;
graph is an array of pointers to linked
lists.

~ graphType();
//Destructor
//The storage occupied by the vertices is deallocated.
protected:
int maxSize;
//maximum number of vertices
int gSize;
//current number of vertices
unorderedLinkedList<int> *graph; //array to create
//adjacency lists
private:
void dft(int v, bool visited[]);
//Function to perform the depth first traversal of
//the graph at a node specified by the parameter vertex.
//This function is used by the public member functions
//depthFirstTraversal and dftAtVertex.
//Postcondition: Starting at vertex, the vertices are
//
printed using depth first traversal
//
algorithm.
};

We leave the UML class diagram of the class graphType as an exercise.
The definitions of the functions of the class graphType are discussed next.
A graph is empty if the number of vertices is zero—that is, if gSize is 0. Therefore, the
definition of the function isEmpty is:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1412

| Chapter 20: Graphs

bool graphType::isEmpty() const
{
return (gSize ¼¼ 0);
}

The definition of the function createGraph depends on how the data is input into the
program. For illustration purposes, we assume that the data to the program is input from a
file. The user is prompted for the input file. The data in the file appears in the following
form:
5
0 2 4 ... –999
1 3 6 8 ... –999
...

The first line of input specifies the number of vertices in the graph. The first entry in the
remaining lines specifies the vertex, and all of the remaining entries in the line (except the last)
specify the vertices that are adjacent to the vertex. Each line ends with the number -999.
Using these conventions, the definition of the function createGraph is:
void graphType::createGraph()
{
ifstream infile;
char fileName[50];
int index;
int vertex;
int adjacentVertex;
if (gSize != 0) //if the graph is not empty, make it empty
clearGraph();
cout << "Enter input file name: ";
cin >> fileName;
cout << endl;
infile.open(fileName);
if (!infile)
{
cout << "Cannot open input file." << endl;
return;
}
infile >> gSize;

//get the number of vertices

for (index = 0; index < gSize; index++)
{
infile >> vertex;
infile >> adjacentVertex;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Graphs as ADTs

|

1413

while (adjacentVertex != -999)
{
graph[vertex].insertLast(adjacentVertex);
infile >> adjacentVertex;
} //end while
} // end for
infile.close();
} //end createGraph

The function clearGraph empties the graph by deallocating the storage occupied by
each linked list and then setting the number of vertices to zero.
void graphType::clearGraph()
{
int index;
for (index = 0; index < gSize; index++)
graph[index].destroyList();
gSize = 0;
} //end clearGraph

The definition of the function printGraph is given next.
void graphType::printGraph() const
{
int index;
for (index = 0; index < gSize; index++)
{
cout << index << " ";
graph[index].print();
cout << endl;
}
cout << endl;
} //end printGraph

The definitions of the constructor and the destructor are:
//Constructor
graphType::graphType(int size)
{
maxSize = size;
gSize = 0;
graph = new unorderedLinkedList<int>[size];
}
//Destructor
graphType:: ~ graphType()
{
clearGraph();
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1414

| Chapter 20: Graphs

Graph Traversals
Processing a graph requires the ability to traverse the graph. This section discusses the
graph traversal algorithms.
Traversing a graph is similar to traversing a binary tree, except that traversing a graph is a
bit more complicated. Recall that a binary tree has no cycles. Also, starting at the root
node, we can traverse the entire tree. On the other hand, a graph might have cycles, and
we might not be able to traverse the entire graph from a single vertex (for example, if the
graph is not connected). Therefore, we must keep track of the vertices that have been
visited. We must also traverse the graph from each vertex (that has not been visited) of the
graph. This ensures that the entire graph is traversed.
The two most common graph traversal algorithms are the depth first traversal and
breadth first traversal, which are described next. For simplicity, we assume that when a
vertex is visited, its index is output. Moreover, each vertex is visited only once. We use
the bool array visited to keep track of the visited vertices.

Depth First Traversal
The depth first traversal is similar to the preorder traversal of a binary tree. The general
algorithm is:
for each vertex, v, in the graph
if v is not visited
start the depth first traversal at v

Consider the graph G of Figure 20-6.

0

3

6

1

4

7

2

FIGURE 20-6

5

9
8

Directed graph G

A depth first ordering of the vertices of the graph G in Figure 20-6 is
0, 1, 4, 3, 2, 5, 7, 8, 6, 9

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Graph Traversals

|

1415

For the graph of Figure 20-6, the depth first search starts at the vertex 0. After visiting all
of the vertices that can be reached starting at the vertex 0, the depth first search starts at
the next vertex that is not visited. There is a path from the vertex 0 to every other vertex
except the vertices 6 and 9. Therefore, when the depth first search starts at the vertex 0,
all of the vertices except 6 and 9 are visited before these vertices. After completing the
depth first search that started at the vertex 0, the depth first search starts at the vertex 6
and then at the vertex 9. Note that there is no path from the vertex 6 to the vertex 9.
Therefore, after completing the depth first search that started at the vertex 6, the depth
first search starts at the vertex 9.
The general algorithm to do a depth first traversal at a given node, v, is:
1. Mark node v as visited
2. Visit the node
3. for each vertex u adjacent to v
if u is not visited
start the depth first traversal at u
Clearly, this is a recursive algorithm. We use a recursive function, dft, to implement this
algorithm. The vertex at which the depth first traversal is to be started, and the bool
array visited, are passed as parameters to this function:
void graphType::dft(int v, bool visited[])
{
visited[v] = true;
cout << " " << v << " "; //visit the vertex
linkedListIterator<int> graphIt;
//for each vertex adjacent to v
for (graphIt = graph[v].begin(); graphIt != graph[v].end();
++graphIt)
{
int w = *graphIt;
if (!visited[w])
dft(w, visited);
} //end while
} //end dft

In the preceding code, note that the statement:
linkedListIterator<int> graphIt;

declares graphIt to be an iterator. In the for loop, we use it to traverse a linked list
(adjacency list) to which the pointer graph[v] points. Next, let us look at the statement:
int w = *graphIt;

The expression *graphIt returns the label of the vertex, adjacent to the vertex v, to
which graphIt points.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1416

| Chapter 20: Graphs

Next, we give the definition of the function depthFirstTraversal to implement the
depth first traversal of the graph:
void graphType::depthFirstTraversal()
{
bool *visited; //pointer to create the array to keep
//track of the visited vertices
visited = new bool[gSize];
int index;
for (index = 0; index < gSize; index++)
visited[index] = false;
//For each vertex that is not visited, do a depth
//first traverssal
for (index = 0; index < gSize; index++)
if (!visited[index])
dft(index,visited);
delete [] visited;
} //end depthFirstTraversal

The function depthFirstTraversal performs a depth first traversal of the entire
graph. The definition of the function dftAtVertex, which performs a depth first
traversal at a given vertex, is as follows:
void graphType::dftAtVertex(int vertex)
{
bool *visited;
visited = new bool[gSize];
for (int index = 0; index < gSize; index++)
visited[index] = false;
dft(vertex, visited);
delete [] visited;
} // end dftAtVertex

Breadth First Traversal
The breadth first traversal of a graph is similar to traversing a binary tree level by level
(the nodes at each level are visited from left to right). All of the nodes at any level, i, are
visited before visiting the nodes at level i + 1.
A breadth first ordering of the vertices of the graph G (Figure 20-6) is:
0, 1, 3, 4, 2, 5, 7, 8, 6, 9
For the graph G, we start the breadth traversal at vertex 0. After visiting the vertex 0,
next we visit the vertices that are directly connected to it and are not visited, which are

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Graph Traversals

|

1417

1 and 3. Next, we visit the vertices that are directly connected to 1 and are not visited,
which is 4. After this, we visit the vertices that are directly connected to 3 and are not
visited, which in this instance is the single vertex 2. After this, we visit the vertices that are
directly connected to 2 and are not visited, and so on.
As in the case of the depth first traversal, because it might not be possible to traverse the
entire graph from a single vertex, the breadth first traversal also traverses the graph from
each vertex that is not visited. Starting at the first vertex, the graph is traversed as much as
possible; we then go to the next vertex that has not been visited. To implement the
breadth first search algorithm, we use a queue. The general algorithm is:
a.

for each vertex v in the graph
if v is not visited
add v to the queue //start the breadth first search at v

b. Mark v as visited
c. while the queue is not empty
c.1. Remove vertex u from the queue
c.2. Retrieve the vertices adjacent to u
c.3. for each vertex w that is adjacent to u
if w is not visited

c.3.1. Add w to the queue
c.3.2. Mark w as visited
The following C++ function, breadthFirstTraversal, implements this algorithm:
void graphType::breadthFirstTraversal()
{
linkedQueueType<int> queue;
bool *visited;
visited = new bool[gSize];
for (int ind = 0; ind < gSize; ind++)
visited[ind] = false; //initialize the array
//visited to false
linkedListIterator<int> graphIt;
for (int index = 0; index < gSize; index++)
if (!visited[index])
{
queue.addQueue(index);
visited[index] = true;
cout << " " << index << " ";

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1418

| Chapter 20: Graphs

while (!queue.isEmptyQueue())
{
int u = queue.front();
queue.deleteQueue();
for (graphIt = graph[u].begin();
graphIt != graph[u].end(); ++graphIt)
{
int w = *graphIt;
if (!visited[w])
{
queue.addQueue(w);
visited[w] = true;
cout << " " << w << " ";
}
}
} //end while
}
delete [] visited;
} //end breadthFirstTraversal

As we continue to discuss graph algorithms, we will be writing C++ functions to
implement specific algorithms, so we will derive (using inheritance) new classes from
the class graphType.

Shortest Path Algorithm
Watch
the Video

The graph theory has many applications. For example, we can use graphs to show how
different chemicals are related or to show airline routes. They can also be used to show
the highway structure of a city, state, or country. The edges connecting two vertices can
be assigned a nonnegative real number, called the weight of the edge. If the graph
represents a highway structure, the weight can represent the distance between two places
or the travel time from one place to another. Such graphs are called weighted graphs.
Let G be a weighted graph. Let u and v be two vertices in G, and let P be a path in G
from u to v. The weight of the path P is the sum of the weights of all the edges on the
path P, which is also called the weight of v from u via P.
Let G be a weighted graph representing a highway structure. Suppose that the weight of
an edge represents the travel time. For example, to plan monthly business trips, a salesperson wants to find the shortest path (that is, the path with the smallest weight) from
her or his city to every other city in the graph. Many such problems exist in which we
want to find the shortest path from a given vertex, called the source, to every other
vertex in the graph.
This section describes the shortest path algorithm, also called a greedy algorithm,
developed by Dijkstra.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Shortest Path Algorithm

|

1419

Let G be a graph with n vertices, in which n > 0. Let V(G) ¼ {v1, v2, . . ., vn}. Let W be
a two-dimensional n  n matrix such that:

W ði; jÞ ¼

wij if ði ; j Þ is an edge in G and wij is the weight of the edge ði ; j Þ
1 if there is no edge from i to j

The input to the program is the graph and the weight matrix associated with the graph. To
make inputting the data easier, we extend the definition of the class graphType (using
inheritance) and add the function createWeightedGraph to create the graph and the
weight matrix associated with the graph. Let us call this class weightedGraphType.
The functions to implement the shortest path algorithm will also be added to this class.
class weightedGraphType: public graphType
{
public:
void createWeightedGraph();
//Function to create the graph and the weight matrix.
//Postcondition: The graph using adjacency lists and
//
its weight matrix is created.
void shortestPath(int vertex);
//Function to determine the weight of a shortest path
//from vertex, that is, source, to every other vertex
//in the graph.
//Postcondition: The weight of the shortest path from
//
vertex to every other vertex in the
//
graph is determined.
void printShortestDistance(int vertex);
//Function to print the shortest weight from vertex
//to the other vertex in the graph.
//Postcondition: The weight of the shortest path from
//
vertex to every other vertex in the
//
graph is printed.
weightedGraphType(int size = 0);
//Constructor
//Postcondition: gSize = 0; maxSize = size;
//
graph is an array of pointers to linked
//
lists.
//
weights is a two-dimensional array to
//
store the weights of the edges.
//
smallestWeight is an array to store the
//
smallest weight from source to vertices.
~ weightedGraphType();
//Destructor
//The storage occupied by the vertices and the arrays
//weights and smallestWeight is deallocated.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1420

| Chapter 20: Graphs

protected:
double **weights;
//pointer to create weight matrix
double *smallestWeight; //pointer to create the array to
//store the smallest weight from
//source to vertices
};

We leave the UML class diagram of the class weightedGraphType and the inheritance hierarchy as an exercise. The definition of the function createWeightedGraph is
also left as an exercise for you. Next, we describe the shortest path algorithm.

Shortest Path
Given a vertex, say, vertex (that is, a source), this section describes the shortest path
algorithm.
The general algorithm is:
1. Initialize the array smallestWeight so that:
smallestWeight[u] = weights[vertex, u]

2. Set smallestWeight[vertex] = 0.
3. Find the vertex, v, that is closest to the vertex for which the shortest
path has not been determined.
4. Mark v as the (next) vertex for which the smallest weight is found.
5. For each vertex w in G, such that the shortest path from vertex to w has
not been determined and an edge (v, w) exists, if the weight of the
path to w via v is smaller than its current weight, update the weight of w
to the weight of v + the weight of the edge (v, w).
Because there are n vertices, Steps 3 through 5 are repeated n  1 times.
Example 20-5 illustrates the shortest path algorithm. (We use the bool array weightFound
to keep track of the vertices for which the smallest weight from the source vertex has been
found. If the smallest weight for a vertex, from the source, has been found, then this vertex’s
corresponding entry in the array weightFound is set to true; otherwise, the corresponding
entry is false.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Shortest Path Algorithm

|

1421

EXAMPLE 20-5
Let G be the graph shown in Figure 20-7.

0

3

1

16

5

3

12

2

2

10
7

3

4

4

5

FIGURE 20-7

2
0

Weighted graph G

Suppose that the source vertex of G is 0. The graph shows the weight of each edge. After
Steps 1 and 2 execute, the resulting graph is as shown in Figure 20-8.

16
0

w = 16
1
5

3

12

2

w=2

3

3

2

10
7

4

w=∞

4
w=3

5

FIGURE 20-8

smallestWeight

[0] [1] [2] [3] [4]
0
16
2
3
∞

weightFound

[0] [1] [2] [3] [4]
T
F
F
F
F

Graph after Steps 1 and 2 execute

Iteration 1 of Steps 3 to 5: At Step 3, we select a vertex that is closest to the vertex
0 and for which the shortest path has not been found. We do this by finding a vertex in
the array smallestWeight that has the smallest weight and a corresponding entry in the
array weightFound of false. Therefore, in this iteration, we select the vertex 3.
At Step 4, we mark weightFound[3] as true. Next, at Step 5, we consider vertices

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1422

| Chapter 20: Graphs

1 and 4 because these are the vertices for which there is an edge from the vertex 3, and
the shortest part from 0 to these vertices has not been found. We then check if the path
from the vertex 0 to the vertices 1 and 4 via the vertex 3 can be improved. The weight of
the path 0–3–1 from 0 to 1 is less than the weight of the path 0–1. So we update
smallestWeight[1] to 14. The weight of the path 0-3-4, which is 2 + 7 = 9, is
greater than the weight of the path 0–4, which is 3. So we do not update the weight of

the vertex 4. Figure 20-9 shows the resulting graph. (The dotted arrow shows the shortest
path from the source—that is, from 0—to the vertex.)

16
0

w=14
1
5

3

12

2

w=2

3

3

2

10
7

4

w=∞

4
w=3

5

FIGURE 20-9

smallestWeight

[0] [1] [2] [3] [4]
0
14
2
3
∞

weightFound

[0] [1] [2] [3] [4]
T
F
F
T
F

Graph after the first iteration of Steps 3, 4, and 5

Iteration 2 of Steps 3 to 5: At Step 3, we select vertex 4 because this is the vertex in the
array smallestWeight that has the smallest weight, and its corresponding entry in the
array weightFound is false. Next, we execute Steps 4 and 5. At Step 4, we set
weightFound[4] to true. At Step 5, we consider vertices 1 and 2 because these are the
vertices for which there is an edge from the vertex 4, and the shortest path from 0 to
these vertices has not been found. We then check if the path from the vertex 0 to the
vertices 1 and 2 via the vertex 4 can be improved. Clearly, the weight of the path 0–4–1,
which is 13, is smaller than the current weight of 1, which is 14. So we update
smallestWeight[1]. Similarly, we update smallestWeight[2]. Figure 20-10
shows the resulting graph.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Shortest Path Algorithm

16
0

w=13
1

w=2

1423

3
5

3

12

2
3

|

2

10
7

4

w=7

4
w=3

5

FIGURE 20-10

smallestWeight

[0] [1] [2] [3] [4]
0
13
2
3
7

weightFound

[0] [1] [2] [3] [4]
T
F
F
T
T

Graph after the second iteration of Steps 3, 4, and 5

Iteration 3 of Steps 3 to 5: At Step 3, the vertex selected is 2. At Step 4, we set
weightFound[2] to true. Next, at Step 5, we consider the vertex 1 because this is the
vertex for which there is an edge from the vertex 2, and the shortest part from 0 to this
vertex has not been found. We then check if the path from the vertex 0 to the vertex 1
via the vertex 2 can be improved. Clearly, the weight of the path 0–4–2–1, which is 10,
from 0 to 1 is smaller than the current weight of 1 (which is 13). So we update
smallestWeight[1]. Figure 20-11 shows the resulting graph.

16
0

w=10
1
5

3

12

2

w=2

3

3

2

10
7

4

w=7

4
w=3

5

FIGURE 20-11

smallestWeight

[0] [1] [2] [3] [4]
0
10
2
3
7

weightFound

[0] [1] [2] [3] [4]
T
F
T
T
T

Graph after the third iteration of Steps 3, 4, and 5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1424

| Chapter 20: Graphs

Iteration 4 of Steps 3 to 5: At Step 3, the vertex 1 is selected, and at Step 4,
weightFound[1] is set to true. In this iteration, the action of Step 5 is null because
the shortest path from the vertex 0 to every other vertex in the graph has been
determined. Figure 20-12 shows the final graph.

16
0

w=10
1
5

3

12

2

w=2

3

3

2

10
7

4

w=7

4
w=3

5

FIGURE 20-12

smallestWeight

[0] [1] [2] [3] [4]
0
10
2
3
7

weightFound

[0] [1] [2] [3] [4]
T
T
T
T
T

Graph after the fourth iteration of Steps 3, 4, and 5

The following C++ function, shortestPath, implements the previous algorithm:
void weightedGraphType::shortestPath(int vertex)
{
for (int j = 0; j < gSize; j++)
smallestWeight[j] = weights[vertex][j];
bool *weightFound;
weightFound = new bool[gSize];
for (int j = 0; j < gSize; j++)
weightFound[j] = false;
weightFound[vertex] = true;
smallestWeight[vertex] = 0;
for (int i = 0; i < gSize - 1; i++)
{
double minWeight = DBL_MAX;
int v;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Shortest Path Algorithm

|

1425

for (int j = 0; j < gSize; j++)
if (!weightFound[j])
if (smallestWeight[j] < minWeight)
{
v = j;
minWeight = smallestWeight[v];
}
weightFound[v] = true;
for (int j = 0; j < gSize; j++)
if (!weightFound[j])
if (minWeight + weights[v][j] < smallestWeight[j])
smallestWeight[j] = minWeight + weights[v][j];
} //end for
} //end shortestPath

Note that the function shortestPath records only the weight of the shortest path from
the source to a vertex. We leave it for you to modify this function so that the shortest
path from the source to a vertex is also recorded. Moreover, this function used the named
constant DBL_MAX, which is defined in the header file cfloat.
The definitions of the function printShortestDistance and the constructor and
destructor are:
void weightedGraphType::printShortestDistance(int vertex)
{
cout << "Source Vertex: " << vertex << endl;
cout << "Shortest Distance from Source to each Vertex."
<< endl;
cout << "Vertex Shortest_Distance" << endl;
for (int j = 0; j < gSize; j++)
cout << setw(4) << j << setw(12) << smallestWeight[j]
<< endl;
cout << endl;
} //end printShortestDistance
//Constructor
weightedGraphType::weightedGraphType(int size)
:graphType(size)
{
weights = new double*[size];
for (int i = 0; i < size; i++)
weights[i] = new double[size];
smallestWeight = new double[size];
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1426

| Chapter 20: Graphs

//Destructor
weightedGraphType:: ~ weightedGraphType()
{
for (int i = 0; i < gSize; i++)
delete [] weights[i];
delete [] weights;
delete smallestWeight;
}

Minimal Spanning Tree
Consider the graph of Figure 20-13, which represents the airline connections of a
company between seven cities. The number on each edge represents some cost factor
of maintaining the connection between the cities.

0
6

2

1

2

3

2

4

7
5

8

4
10

FIGURE 20-13

5

6
5

Airline connections between cities and the cost factor of maintaining the
connections

Due to financial hardship, the company needs to shut down the maximum number of
connections and still be able to fly from one city to another (the flights need not be
direct). The graphs of Figure 20-14(a), (b), and (c) show three different solutions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Minimal Spanning Tree |

0
6

0

5

2

1

2

3
7

4

5

8
6
5
(a)

FIGURE 20-14

0

5

2
1

2

3

2

4

5

4
10

1427

5

2
1

2

3

2

4

7
5

4
6

6
5

5

(b)

(c)

Possible solutions to the graph of Figure 20-13

The total cost factor of maintaining the remaining connections in Figure 20-14(a) is 33, in
Figure 20-14(b) it is 28, and in Figure 20-14(c) it is 25. Out of these three solutions, obviously,
the desired solution is the one shown by the graph of Figure 20-14(c) because it gives the lowest
cost factor. The graphs of Figure 20-14 are called spanning trees of the graph of Figure 20-13.
Let us note the following from the graphs of Figure 20-14. Each of the graphs is a subgraph of
the graph of Figure 20-13, and there is a unique path from a node to any other node. Such
graphs are called trees. There are many other situations in which, given a weighted graph, we
need to determine a graph with the smallest weight, such as in Figure 20-14. In this section, we
give an algorithm to determine such graphs. However, first we introduce some terminology.
A (free) tree T is a simple graph such that if u and v are two vertices in T, then there is a unique
path from u to v. A tree in which a particular vertex is designated as a root is called a rooted
tree. If a weight is assigned to the edges in T, T is called a weighted tree. If T is a weighted
tree, the weight of T, denoted by W(T ), is the sum of the weights of all of the edges in T.
A tree T is called a spanning tree of graph G if T is a subgraph of G such that V(T ) ¼ V(G);
that is, all of the vertices of G are in T.
Suppose that G denotes the graph of Figure 20-13. Then, the graphs of Figure 20-14
show three spanning trees of G. Let us note the following theorem.
Theorem: A graph G has a spanning tree if and only if G is connected.
From this theorem, it follows that in order to determine a spanning tree of a graph, the
graph must be connected.
Let G be a weighted graph. A minimal spanning tree of G is a spanning tree with the
minimum weight.
Prim’s algorithm and Kruskal’s algorithm are two well-known algorithms that can be
used to find the minimal spanning tree of a graph. This section discusses Prim’s algorithm

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1428

| Chapter 20: Graphs

to find a minimal spanning tree. The interested reader can find the Kruskal’s algorithm in
the discrete structures book or a data structures book listed in Appendix H.
Prim’s algorithm builds the tree iteratively by adding edges until a minimal spanning tree
is obtained. We start with a designated vertex, which we call the source vertex. At each
iteration, a new edge that does not complete a cycle is added to the tree.
Let G be a weighted graph such that V(G) ¼ {v0, v1,. . .,vn-1}, in which n, the number of
vertices, is positive. Let v0 be the source vertex. Let T be the partially built tree. Initially,
V(T ) contains the source vertex, and E(T ) is empty. At the next iteration, a new vertex
that is not in V(T ) is added to V(T ), such that an edge exists from a vertex in T to the
new vertex so that the corresponding edge has the smallest weight. The corresponding
edge is added to E(T ).
The general form of Prim’s algorithm is as follows. (Let n be the number of vertices in G.)
1. Set V(T) ¼ {source}
2. Set E(T) ¼ empty
3. for i = 1 to n
3.1. minWeight = infinity;
3.2. for j = 1 to n

3.3.
3.4.

if vj is in V(T)
for k = 1 to n
if vk is not in T and weight[vj, vk] < minWeight
{
endVertex = vk;
edge = (vj, vk);
minWeight = weight[vj, vk];
}
V(T) = V(T) [ {endVertex};
E(T) = E(T) [ {edge};

Let us illustrate Prim’s algorithm using the graph G of Figure 20-15 (which is same as the
graph of Figure 20-13).
0
6

2

1

2

3

2

4

7
5

8

4
10

FIGURE 20-15

5

6
5

Weighted graph G

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Minimal Spanning Tree |

1429

Let N denote the set of vertices of G that are not in T. Suppose that the source vertex is 0.
After Steps 1 and 2 execute, V(T), E(T), and N are as shown in Figure 20-16(a).

0
6

2

1

2

3

2

4

8

4
10

7

5

0

V(T) = {0}
E(T) = φ
N = {1,2,3,4,5,6}

5

6

2

1

Edge
5 (0,1)
(0,2)
6
(0,3)

Edge Weight
6
5
2 (least)

2
8

4
10

2

2

3
4

8

4
10

7

5

6
1

Edge
5 (0,1)
(2,5)
6
(2,6)
(3,4)

Edge Weight
6
7
5 (least)
8

4

2

10

2

3
4

8
5

5
2

3

2

4

8

4
10

7

5
6

5

7

0

V(T) = {0,1,2,3,6}
E(T) = {(0,3),(0,2),
(2,6),(6,1)}
N = {4,5}

5

2

6

Edge
(0,1)
(0,2)
(3,4)

Edge Weight
6
5 (least)
8

V(T) = {0,2,3,6}
E(T) = {(0,3),(0,2),(2,6)}
N = {1,4,5}

Edge
(0,1)
(2,5)
(3,4)
(6,1)

Edge Weight
6
7
8
4 (least)

(d)

0
1

5

2

(c)

6

7

5

0

V(T) = {0,2,3}
E(T) = {(0,3),(0,2)}
N = {1,4,5,6}

5

2

4

V(T) = {0,3}
E(T) = {(0,3)}
N = {1,2,3,4,5,6}

(b)

0
1

2

3

(a)

6

5

5 Edge
(1,4)
6
(2,5)
(3,4)

6

2

1
4
10

(e)

2

3

2

Edge Weight
2 (least)
7
8

5

4

8
5

7

V(T) = {0,1,2,3,4,6}
E(T) = {(0,3),(0,2),(2,6),
(6,1),(1,4)}
N = {5}

5 Edge
Edge Weight
(2,5) 7 (least)
6
(4,5) 10

(f)

0
6
1

10

2

3

2
4

5

2

4

8

7

V(T) = {0,1,2,3,4,5,6}
E(T) = {(0,3),(0,2),(2,6),(6,1),(1,4),(2,5)}
N=φ

5
6

5
(g)

FIGURE 20-16

Prim’s algorithm to find a minimal spanning tree

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1430

| Chapter 20: Graphs

In Figure 20-16(a), Step 3.2 checks the edges shown in this figure; and the edge with the
least weight is identified. Figure 20-16(b), shows the resulting graph, V(T), E(T), and N.
(The dotted line shows the edge in T.) At the next iteration, Step 3.2 checks the edges shown
in Figure 20-16(b); and the edge with the least weight is identified, which results in the
graph of Figure 20-16(c). Thus, in Figure 20-16 in each graph, we identify V(T), E(T),
and N; identify the edges checked by Step 3.2; and identify the edge with the least weight.
Also in each figure, the dotted lines show the edges in T. In Figure 20-16(g), the dotted lines
show a minimal spanning tree of G of weight 25.
Note that the graph in Figure 20-16(b) is obtained after the first iteration of Step 3, the
graph in Figure 20-16(c) is obtained after the second iteration of Step 3, and so on.
Finally, the graph in Figure 20-16(g) is obtained after the sixth iteration of Step 3.
Before we give the definition of the function to implement Prim’s algorithm, let us first
define the spanning tree as an ADT.
Let mstv be a bool array such that mstv [j] is true if the vertex vi is in T, and false
otherwise. Let edges be an array such that edges[j] = k if there is an edge connecting
vertices vj and vk. Suppose that the edge (vi, vj) is in the minimal spanning tree. Let
edgeWeights be an array such that edgeWeights[j] is the weight of the edge (vi, vj).
Using these conventions, the following class defines a spanning tree as an ADT:
class msTreeType: public graphType
{
public:
void createSpanningGraph();
//Function to create the graph and the weight matrix.
//Postcondition: The graph using adjacency lists and
//
its weight matrix is created.
void minimalSpanning(int sVertex);
//Function to create a minimal spanning tree with
//root as sVertex.
// Postcondition: A minimal spanning tree is created.
//
The weight of the edges is also
//
saved in the array edgeWeights.
void printTreeAndWeight();
//Function to output the edges of the minimal
//spanning tree and the weight of the minimal
//spanning tree.
//Postcondition: The edges of a minimal spanning tree
//
and their weights are printed.
msTreeType(int size = 0);
//Constructor
//Postcondition: gSize = 0; maxSize = size;
//
graph is an array of pointers to linked
//
lists.
//
weights is a two-dimensional array to

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Minimal Spanning Tree |

//
//
//
//
//
//

1431

store the weights of the edges.
edges is an array to store the edges
of a minimal spanning tree.
edgeWeight is an array to store the
weights of the edges of a minimal
spanning tree.

~ msTreeType();
//Destructor
//The storage occupied by the vertices and the arrays
//weights, edges, and edgeWeights is deallocated.
protected:
int source;
double **weights;
int *edges;
double *edgeWeights;
};

We leave the UML class diagram of the class msTreeType and the inheritance hierarchy as
an exercise. The definition of the function createSpanningGraph is also left as an exercise
for you. This function creates the graph and the weight matrix associated with the graph.
The following C++ function, minimalSpanning, implements Prim’s algorithm, as
described previously:
void msTreeType::minimalSpanning(int sVertex)
{
int startVertex, endVertex;
double minWeight;
source = sVertex;
bool *mstv;
mstv = new bool[gSize];
for (int j = 0; j < gSize; j++)
{
mstv[j] = false;
edges[j] = source;
edgeWeights[j] = weights[source][j];
}
mstv[source] = true;
edgeWeights[source] = 0;
for (int i = 0; i < gSize - 1; i++)
{
minWeight = DBL_MAX;
for (int j = 0; j < gSize; j++)
if (mstv[j])
for (int k = 0; k < gSize; k++)
if (!mstv[k] && weights[j][k] < minWeight)
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1432

| Chapter 20: Graphs

{
endVertex = k;
startVertex = j;
minWeight = weights[j][k];
}
mstv[endVertex] = true;
edges[endVertex] = startVertex;
edgeWeights[endVertex] = minWeight;
} //end for
} //end minimalSpanning

The definition of the function minimalSpanning contains three nested for loops.
Therefore, in the worst case, Prim’s algorithm given in this section is of the order O(n3).
It is possible to design Prim’s algorithm so that it is of the order O(n2). Programming
Exercise 5 at the end of this chapter asks you to do this.
The definition of the function printTreeAndWeight is:
void msTreeType::printTreeAndWeight()
{
double treeWeight = 0;
cout << "Source Vertex: " << source << endl;
cout << "Edges
Weight" << endl;
for (int j = 0; j < gSize; j++)
{
if (edges[j] != j)
{
treeWeight = treeWeight + edgeWeights[j];
cout << "("<<edges[j] << ", " << j << ")
<< edgeWeights[j] << endl;
}
}

"

cout << endl;
cout << "Minimal Spanning Tree Weight: "
<< treeWeight << endl;
} //end printTreeAndWeight

The definitions of the constructor and the destructor are as follows:
msTreeType::msTreeType(int size)
:graphType(size)
{
weights = new double*[size];
for (int i = 0; i < size; i++)
weights[i] = new double[size];
edges

= new int[size];

edgeWeights = new double[size];
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

1433

//Destructor
msTreeType:: ~ msTreeType()
{
for (int i = 0; i < gSize; i++)
delete [] weights[i];
delete [] weights;
delete [] edges;
delete edgeWeights;
}
(Topological Ordering) This chapter also discusses topological ordering. The
necessary material is in the file TopologicalOrder.pdf. The file is available at
www.cengagebrain.com. To find the file, navigate to the book’s page by typing
in the ISBN of this text and then click on Free Materials.

QUICK REVIEW
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.

11.
12.
13.

A graph G is a pair, G ¼ (V, E ), in which V is a finite nonempty set, called
the set of vertices of G, and E  V  V, called the set of edges.
In an undirected graph G ¼ (V, E ), the elements of E are unordered
pairs.
In a directed graph G ¼ (V, E ), the elements of E are ordered pairs.
Let G be a graph. A graph H is called a subgraph of G if every vertex of H is
a vertex of G and every edge in H is an edge in G.
Two vertices u and v in an undirected graph are called adjacent if there is an
edge from one to the other.
Let e ¼ (u, v) be an edge in an undirected graph G. The edge e is said to be
incident on the vertices u and v.
An edge incident on a single vertex is called a loop.
In an undirected graph, if two edges e1 and e2 are associated with the same
pair of vertices, then e1 and e2 are called parallel edges.
A graph is called a simple graph if it has no loops and no parallel
edges.
A path from a vertex u to a vertex v is a sequence of vertices u1, u2, . . .,
un such that u ¼ u1, un ¼ v, and (ui, ui + 1) is an edge for all i ¼ 1, 2, . . .,
n  1.
The vertices u and v are called connected if there is a path from u to v.
A simple path is a path in which all of the vertices, except possibly the first
and last vertices, are distinct.
A cycle in G is a simple path in which the first and last vertices are the
same.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1434

14.
15.
16.

17.
18.

19.

20.
21.
22.
23.
24.
25.
26.
27.
28.
29.

| Chapter 20: Graphs

An undirected graph G is called connected if there is a path from any vertex
to any other vertex.
A maximal subset of connected vertices is called a component of G.
Suppose that u and v are vertices in a directed graph G. If there is an
edge from u to v, that is, (u, v) 2 E, we say that u is adjacent to v and v
is adjacent from u.
A directed graph G is called strongly connected if any two vertices in G are
connected.
Let G be a graph with n vertices, in which n > 0. Let V(G) ¼ {v1, v2, . . ., vn}.
The adjacency matrix AG is a two-dimensional n  n matrix such that
the (i, j)th entry of AG is 1 if there is an edge from vi to vj; otherwise, the
(i, j)th entry is zero.
In an adjacency list representation, corresponding to each vertex v is a
linked list such that each node of the linked list contains the vertex u, and
(v, u) 2 E(G).
The depth first traversal of a graph is similar to the preorder traversal of a
binary tree.
The breadth first traversal of a graph is similar to the level-by-level traversal
of a binary tree.
The shortest path algorithm gives the shortest distance for a given node to
every other node in the graph.
In a weighted graph, every edge has a nonnegative weight.
The weight of the path P is the sum of the weights of all of the edges on the
path P, which is also called the weight of v from u via P.
A (free) tree T is a simple graph such that if u and v are two vertices in T,
there is a unique path from u to v.
A tree in which a particular vertex is designated as a root is called a rooted tree.
Suppose T is a tree. If a weight is assigned to the edges in T, T is called a
weighted tree.
If T is a weighted tree, the weight of T, denoted by W(T ), is the sum of the
weights of all the edges in T.
A tree T is called a spanning tree of graph G if T is a subgraph of G such
that V(T ) ¼ V(G), that is, if all of the vertices of G are in T.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

|

1435

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.
b.
c.
d.

e.

f.

g.
h.
i.

A simple graph has no loops and no parallel edges. (2)
Two vertices are called connected if there is an edge incident on them. (2)
A graph G is strongly connected if any two vertices in G are connected. (2)
If an entry in the adjacency matrix of a graph is 1, the corresponding
vertices are adjacent. (3)
In the adjacency list representation of a graph G, corresponding to each
vertex, v, there is an array such that each vertex adjacent from v is stored
in this array. (3)
The breadth first traversal of a graph is similar to traversing a binary tree
level by level. (5)
The weight of the path is the largest weight of an edge on that path. (6)
Every graph has a spanning tree. (7)
A minimal spanning tree of a graph is a spanning tree with the minimum weight. (7)

2
0

Use the graphs in Figure 20-17 for Exercises 2 through 10.

1

2

1

0

2
0
4

5

3

3

4

6
5

6

7

7
8

9

10

(a)

FIGURE 20-17

2.
3.

10

8

11

9
(b)

Graphs for Exercises 2 to 10

In Figure 20-17(a), find a path from vertex 0 to vertex 6. (2)
In Figure 20-17(a), find a path from vertex 1 to vertex 10 via vertex 3.
What is the length of your path? (2)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1436

4.

5.

6.

7.

8.

9.

10.

| Chapter 20: Graphs

In Figure 20-17(a), determine if the graph is simple. Also determine if there
is a cycle in this graph. (2)
In Figure 20-17(a), determine if the vertices 0 and 9 are connected. If these
vertices are connected, find a path from vertex 0 to vertex 9. (2)
In Figure 20-17(b), determine if the vertices 3 and 8 are connected. If these
vertices are connected, find a path from vertex 3 to vertex 8. (2)
In Figure 20-17(b), determine if the vertices 0 and 5 are connected. If these
vertices are connected, find a path from vertex 0 to vertex 5. (2)
In Figure 20-17(b), find a path, if any, from vertex 0 to vertex 7 that has
6 edges. (2)
In Figure 20-17(b), find a path, if any, from vertex 0 to vertex 11 that has
6 edges. (2)
In Figure 20-17(b), determine if the graph is simple. Also determine if there
is a cycle in this graph. (2)

Use the graphs in Figure 20-18 for Exercises 11 through 16.

0

1

1
0

2
6

3
5

3

2

4
4

7

6

5

8
8

7
(a)

FIGURE 20-18

11.
12.
13.
14.
15.

10

9

11

(b)

Graphs for Exercises 11 through 16

Find the adjacency matrix of the graph in Figure 20-18(a). (3)
Draw the adjacency list of the graph in Figure 20-18(a). (3)
List the nodes of the graph, in Figure 20-18(a), in a depth first traversal. (5)
List the nodes of the graph, in Figure 20-18(a), in a breadth first traversal. (5)
List the nodes of the graph, in Figure 20-18(b), in a breadth first traversal. (5)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

16.
17.

1437

List the nodes of the graph, in Figure 20-18(b), in a depth first traversal. (5)
Find the weight matrix of the graph in Figure 20-19. (6)

10

0

1

6

6

3

10

8

2

FIGURE 20-19

5

4

3

18.

|

6

4

11

Graph for Exercise 17

Consider the graph in Figure 20-20. Find the shortest distance from node 0
to every other node in the graph. (6)

3

0

1

4
15

12
5

8

5

7

3

2

8
4

2
3

FIGURE 20-20
19.

Graph for Exercise 18

Find a spanning tree in the graph in Figure 20-21. (7)

0

1
3

4

FIGURE 20-21

2
8

5
6

7

Graph for Exercise 19

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

1438

20.

| Chapter 20: Graphs

Find a spanning tree in the graph in Figure 20-22. (7)

0

2

4

7
6

1

FIGURE 20-22
21.

3

9

5

8

Graph for Exercise 20

Find the minimal spanning tree for the graph in Figure 20-23, using the
algorithm given in this chapter. (7)

4

0

1
3

3
6

3

4

6

FIGURE 20-23

2

5

1
7

5

15

3

2

2

10

7

5

Graph for Exercise 21

PROGRAMMING EXERCISES
1.
2.
3.

4.
5.

Write a program that outputs the nodes of a graph in a depth first traversal.
Write a program that outputs the nodes of a graph in a breadth first traversal.
Write a program that outputs the shortest distance from a given node to
every other node in the graph.
Write a program that outputs the minimal spanning tree for a given graph.
The algorithm to determine the minimal spanning tree given in this chapter
is of the order O(n3). The following is an alternative to Prim’s algorithm that
is of the order O(n2).
Input:

A connected weighted graph G ¼ (V, E ) of n vertices, numbered
0, 1, . . ., n  1; starting with vertex s, with a weight matrix of W.

Output:

The minimal spanning tree.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Programming Exercises

|

1439

Prim2(G, W, n, s)

Let T = (V, E), where E = f.
for (j = 0; j < n; j++)
{
edgeWeights[j] = W(s,j);
edges[j] = s;
visited[s] = false;
}
edgeWeights[s] = 0;
visited[s] = true;
while (not all nodes are visited)
{

Choose the node that is not visited and has the smallest weight, and call it k.
visited[k] = true;
E = E [ {(k, edges[k])}
V = V [ {k}
for each node j that is not visited
if (W(k,j) < edgeWeights[j])
{
edgeWeights[j] = W(k,j);
edges[j] = k;
}
}
return T;

Write a definition of the function Prim2 to implement this algorithm, and
also add this function to the class msTreeType. Furthermore, write a
program to test this version of Prim’s algorithm.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
0

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

21
CHAPTER

ª HunThomas/Shutterstock

S TANDARD T EMPLATE
L IBRARY (STL)
I N T H I S C H A P T E R , YO U W I L L :

1.

Learn about the Standard Template Library (STL)

2.

Become familiar with the three basic components of the STL:
containers, iterators, and algorithms

3.

Become familiar with basic operations on vector objects

4.

Learn about the member functions common to all containers

5.

Learn about the member functions common to all sequence containers

6.

Learn how to use the copy algorithm

7.

Explore how to use range-based for loops

8.

Explore how various containers, such as deque and list, are used to
manipulate data in a program

9.

Learn about various types of iterators and how they are used

10.

Explore how to use the associative containers sets, multisets, maps, and multimaps

11.

Explore how to use the container adapters: stacks and queues

12.

Become familiar with the various types of STL algorithms

13.

Learn about function objects: arithmetic and relational

14.

Become familiar with insert iterators

15.

Explore how to use various generic algorithms

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1442

| Chapter 21: Standard Template Library (STL)

Chapter 13 introduced and examined templates in detail. With the help of class
templates, we developed (and used) a generic code to process lists. For example, we used
the class listType to process a list of integers and a list of strings. In Chapters 16 and
17, we studied the three most important data structures: linked lists, stacks, and queues. In
these chapters, using class templates, we developed generic code to process linked lists. In
addition, using the second principle of object-oriented programming (OOP), we developed generic code to process ordered lists. Furthermore, in Chapter 17, we used class
templates to develop generic code to implement stacks and queues. Along the way, you
saw that a template is a powerful tool that promotes code reuse.
ANSI/ISO Standard C++ is equipped with a Standard Template Library (STL). Among
other things, the STL provides class templates to process lists (contiguous or linked),
stacks, and queues. This chapter discusses many important features of the STL and shows
how to use the tools provided by the STL in a program.

Components of the STL
The main objective of a program is to manipulate data and generate results. Achieving
this goal requires the ability to store data into computer memory, access a particular piece
of data, and write algorithms to manipulate the data.
For example, if all data items are of the same type and we have some idea of the number
of data items, we could use an array to store the data. We can then use an index to access
a particular component of the array. Using a loop and the array index, we can step
through the elements of the array. Algorithms, such as those for initializing the array,
sorting, and searching, are used to manipulate the data stored in an array. On the other
hand, if we do not want to be concerned about the size of the data, we can use a linked
list to process it. If the data needs to be processed in a Last In First Out (LIFO) manner,
we can use a stack. Similarly, if the data needs to be processed in a First In First Out
(FIFO) manner, we can use a queue.
The STL is equipped with these features to effectively manipulate data. More formally,
the STL has three main components:
•
•
•

Containers
Iterators
Algorithms

Containers and iterators are class templates. Iterators are used to step through the elements
of a container. Algorithms are used to manipulate data. The following sections discuss
each of these components in detail.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

|

1443

Container Types
Containers are used to manage objects of a given type. The STL containers are classified
into three categories, as follows:
•
•
•

Sequence containers (also called sequential containers)
Associative containers
Container adapters

Sequence Containers
Every object in a sequence container has a specific position. The three predefined
sequence containers are:
•
•
•

vector
deque
list

Before discussing container types in general, let us first briefly describe the sequence
container vector. We do so because vector containers are similar to arrays and thus can
be processed like arrays. Also, with the help of vector containers, we can describe several
properties that are common to all containers. In fact, all containers use the same names for
the common operations. Of course, there are operations that are specific to a container,
which will be discussed when describing a specific container.

Sequence Container: vector
A vector container stores and manages its objects in a dynamic array. Because an array is a
random access data structure, the elements of a vector can be accessed randomly. Item
insertion in the middle or beginning of an array is time consuming, especially if the array
is large. However, inserting an item at the end is quite fast.
The name of the class that implements the vector container is vector. (Recall that
containers are class templates.) The name of the header file containing the class
vector is vector. Thus, to use a vector container in a program, the program must
include the following statement:
#include <vector>

Furthermore, to define an object of type vector, we must specify the type of the object
because the class vector is a class template. For example, the statement:
vector<int> intList;

declares intList to be a vector and the component type to be int. Similarly, the statement:
vector<string> stringList;

declares stringList to be a vector container and the component type to be string.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1444

| Chapter 21: Standard Template Library (STL)

DECLARING VECTOR OBJECTS
The class vector contains several constructors, including the default constructor.
Therefore, a vector container can be declared and initialized several ways. Table 21-1
describes how a vector container of a specific type can be declared and initialized.
TABLE 21-1

Various Ways to Declare and Initialize a Vector Container

Statement

Effect

vector<elemType> vecList;

Creates the empty vector
container vecList. (The
default constructor is invoked.)

vector<elemType> vecList(otherVecList);

Creates the vector container
vecList and initializes
vecList to the elements of
the vector otherVecList.
vecList and
otherVecList are of the
same type.

vector<elemType> vecList(size);

Creates the vector container
vecList of size size.
vecList is initialized using
the default constructor.

vector<elemType> vecList(n, elm);

Creates the vector container
vecList of size n.
vecList is initialized using
n copies of the element elm.

vector<elemType> vecList(beg, end);

Creates the vector container
vecList. vecList is
initialized to the elements in
the range [beg, end), that
is, all the elements in the range
beg...end-1. Both beg
and end are pointers, called
iterators in STL terminology.
(Later in this chapter, we
explain how iterators are used.)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

|

1445

Now that we know how to declare a vector sequence container, let us discuss how to
manipulate the data stored in a vector container. In order to manipulate the data in a
vector container, we must know the following basic operations:
•
•
•

Item insertion
Item deletion
Stepping through the elements of a vector container

The elements in a vector container can be accessed directly by using the operations given
in Table 21-2. The name of the function is shown in bold.
TABLE 21-2

Operations to Access the Elements of a Vector Container

Expression

Description

vecList.at(index)

Returns the element at the position specified by index.

vecList[index]

Returns the element at the position specified by index.

vecList.front()

Returns the first element. (Does not check whether the
container is empty.)

vecList.back()

Returns the last element. (Does not check whether the
container is empty.)

From Table 21-2, it follows that the elements in a vector can be processed just as they can
in an array. See Example 21-1. (Recall that in C++, arrays start at location 0. Similarly,
the first element in a vector container is at location 0.)
EXAMPLE 21-1
Consider the following statement, which declares intList to be a vector container of
size 5 with an element type of int:
vector<int> intList(5);

You can use a loop, such as the following, to store elements into intList:
for (int j = 0; j < 5; j++)
intList[j] = j;

Similarly, you can use a for loop to output the elements of intList.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1446

| Chapter 21: Standard Template Library (STL)

The class vector also contains member functions that can be used to find the number
of elements currently in the container, the maximum number of elements that can be
inserted into a container, and so on. Table 21-3 describes some of these operations. The
name of the function is shown in bold. (Suppose that vecCont is a vector container.)
TABLE 21-3

Operations to Determine the Size of a Vector Container

Expression

Description

vecCont.capacity()

Returns the maximum number of elements that can
be inserted into the container vecCont without
reallocation.

vecCont.empty()

Returns true if the container vecCont is empty,
false otherwise.

vecCont.size()

Returns the number of elements currently in the
container vecCont.

vecCont.max_size()

Returns the maximum number of elements that
can be inserted into the container vecCont.

The class vector also contains member functions that can be used to manipulate the
data, as well as insert and delete items, in a vector container. Suppose that vecList is a
container of type vector. Item insertion and deletion in vecList are accomplished
using the operations given in Table 21-4. These operations are implemented as member
functions of the class vector and are shown in bold. Table 21-4 also shows how
these operations are used.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

TABLE 21-4

|

1447

Various Operations on a Vector Container

Statement

Effect

vecList.clear()

Deletes all of the elements from the
container.

vecList.erase(position)

Deletes the element at the position
specified by position.

vecList.erase(beg, end)

Deletes all of the elements starting at
beg until end-1.

vecList.insert(position, elem)

A copy of elem is inserted at the
position specified by position.
The position of the new element is
returned.

vecList.insert(position, n, elem)

n copies of elem are inserted at the
position specified by position.

vecList.insert(position, beg, end)

A copy of the elements, starting at
beg until end-1, is inserted into
vecList at the position specified by
position.

vecList.push_back(elem)

A copy of elem is inserted into
vecList at the end.

vecList.pop_back()

Deletes the last element.

vecList.resize(num)

Changes the number of elements to
num. If size() increases, the
default constructor creates the new
elements.

vecList.resize(num, elem)

Changes the number of elements to
num. If size() increases, the new
elements are copies of elem.

In Table 21-4, the identifiers position, beg, and end in STL terminology are called
iterators. An iterator is just like a pointer. In general, iterators are used to step through the
elements of a container. In other words, with the help of an iterator, we can walk through
the elements of a container and process them one at a time. Because iterators are an
integral part of the STL, they are discussed in the section ‘‘Iterators’’ located later in this
chapter.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1448

| Chapter 21: Standard Template Library (STL)

Example 21-1 used a for loop and the array subscripting operator, [], to access the
elements of intList. We declare intList to be a vector object of size 5. Does this
mean that we can store only five elements in intList? The answer is no. We can, in
fact, add more elements to intList. However, because when we declared intList we
specified the size to be 5, in order to add elements past position 4, we use the function
push_back. Furthermore, if we initially declare a vector object and do not specify its
size, then to add elements to the vector object, we use the function push_back.
Example 21-2 explains how to use the function push_back.
EXAMPLE 21-2
The following statement declares intList to be a vector object of size 0:
vector<int> intList;

To add elements to intList, we can use the function push_back as follows:
intList.push_back(34);
intList.push_back(55);

After these statements execute, the size of intList is 2 and:
intList = {34, 55}

In Example 21-2, because intList is declared to be of size 0, we use the function
push_back to add elements to intList. However, we can also use the resize
function to increase the size of intList and then use the array subscripting operator.
For example, suppose that intList is declared as in Example 21-2. Then, the following
statement sets the size of intList to 10:
intList.resize(10);

Similarly, the following statement increases the size of intList by 10:
intList.resize(intList.size() + 10);

However, at times, the push_back function is more convenient because it does not
need to know the size of the vector; it simply adds the elements at the end.
Next, we describe how to declare an iterator in a vector container.
DECLARING AN ITERATOR TO A VECTOR CONTAINER
The class vector contains a typedef iterator, which is declared as a public
member. An iterator to a vector container is declared using the typedef iterator. For
example, the statement:
vector<int>::iterator intVecIter;

declares intVecIter to be an iterator in a vector container of type int.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

|

1449

Because iterator is a typedef defined inside the class vector, we must use the
container name (which is vector), the container element type, and the scope resolution
operator to use the typedef iterator.
The expression:
++intVecIter

advances the iterator intVecIter to the next element in the container, and the expression:
*intVecIter

returns the element at the current iterator position.
Note that these operations are the same as the operations on pointers, discussed in
Chapter 12. Recall that when used as a unary operator, * is called the dereferencing
operator.
We now discuss how to use an iterator in a vector container to manipulate the data stored
in the vector container.
Suppose that we have the following statements:
vector<int> intList;
vector<int>::iterator intVecIter;

//Line 1
//Line 2

The statement in Line 1 declares intList to be a vector container, and the element type
is int. The statement in Line 2 declares intVecIter to be an iterator in a vector
container whose element type is int.
CONTAINERS AND THE FUNCTIONS begin AND end
Every container has the member functions begin and end. The function begin returns
the position of the first element in the container; the function end returns the position of
one past the last element in the container. Also, these functions have no parameters.

After the following statement executes:
intVecIter = intList.begin();

the iterator intVecIter points to the first element in the container intList.
The following for loop outputs the elements of intList to the standard output device.
for (intVecIter = intList.begin(); intVecIter != intList.end();
++intVecIter)
cout << *intVecIter << " ";

Example 21-3 shows how the function insert works with vector objects.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1450

| Chapter 21: Standard Template Library (STL)

EXAMPLE 21-3
Consider the following statements:
int intArray[7] = {1, 3, 5, 7, 9, 11, 13};
vector<int> vecList(intArray, intArray + 7);
vector<int>::iterator intVecIter;

//Line 1
//Line 2
//Line 3

The statement in Line 2 declares and initializes the vector container vecList. Now
consider the following statements:
intVecIter = vecList.begin();
++intVecIter;
vecList.insert(intVecIter, 22);

//Line 4
//Line 5
//Line 6

The statement in Line 4 initializes the iterator intVecIter to the first element of
vecList; the statement in Line 5 advances intVecIter to the second element of
vecList. The statement in Line 6 inserts 22 at the position specified by intVecIter.
After the statement in Line 6 executes, vecList = {1, 22, 3, 5, 7, 9, 11, 13}.
Notice that the size of the container also increases.
The following example illustrates how to use a vector container in a program and how to
process the elements in a vector container.
EXAMPLE 21-4
#include <iostream>
#include <vector>
using namespace std;
int main()
{
vector<int> intList;
int i;

//Line 1
//Line 2

intList.push_back(13);
intList.push_back(75);
intList.push_back(28);
intList.push_back(35);

//Line
//Line
//Line
//Line

3
4
5
6

cout << "Line 7: List elements: ";
for (i = 0; i < 4; i++)
cout << intList[i] << " ";
cout << endl;

//Line
//Line
//Line
//Line

7
8
9
10

for (i = 0; i < 4; i++)
intList[i] *= 2;

//Line 11
//Line 12

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

cout << "Line 13: List elements: ";
for (i = 0; i < 4; i++)
cout << intList[i] << " ";
cout << endl;

//Line
//Line
//Line
//Line

vector<int>::iterator listIt;

//Line 17

cout << "Line 18: List elements: ";
for (listIt = intList.begin();
listIt != intList.end(); ++listIt)
cout << *listIt << " ";
cout << endl;

//Line 18

listIt = intList.begin();
++listIt;
++listIt;

//Line 22
//Line 23
//Line 24

//Insert 88 at the position specified
//by listIt
intList.insert(listIt, 88);

//Line 25

cout << "Line 25: List elements: ";
for (listIt = intList.begin();
listIt != intList.end(); ++listIt)
cout << *listIt << " ";
cout << endl;

|

1451

13
14
15
16

//Line 19
//Line 20
//Line 21

//Line 26
//Line 27
//Line 28
//Line 29

return 0;
}

Sample Run:
Line
Line
Line
Line

7: List elements: 13 75 28 35
13: List elements: 26 150 56 70
18: List elements: 26 150 56 70
25: List elements: 26 150 88 56 70

The statement in Line 1 declares a vector container (or vector for short), intList, of
type int. The statement in Line 2 declares i to be an int variable. The statements in
Lines 3 through 6 use the operation push_back to insert four numbers—13, 75, 28,
and 35—into intList. The statements in Lines 8 and 9 use the for loop and the array
subscripting operator, [], to output the elements of intList. In the output, see the line
marked Line 7, which contains the output of Lines 7 through 10. The statements in Lines
11 and 12 use a for loop to double the value of each element of intList; the
statements in Lines 14 and 15 output the elements of intList. In the output, see the
line marked Line 13, which contains the output of Lines 13 through 16.
The statement in Line 17 declares listIt to be a vector iterator that processes any
vector container whose elements are of type int. Using the iterator listIt, the
statements in Lines 19 and 20 output the elements of intList. After the statement in
Line 22 executes, listIt points to the first element of intList. The statements in
Lines 23 and 24 advance listIt twice; after these statements execute, listIt points to
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1452

| Chapter 21: Standard Template Library (STL)

the third element of intList. The statement in Line 25 inserts 88 into intList at the
position specified by the iterator listIt. Because listIt points to the component at
position 2 (the third element of intList), 88 is inserted at position 2 in intList; that
is, 88 becomes the third element of intList. The statements in Lines 27 and 28 output
the modified intList.

Member Functions Common to All Containers
The previous section discussed vector containers. This section discusses operations that
are common to all containers. For example, every container class has the default constructor, several constructors with parameters, the destructor, a function to insert an
element into a container, and so on.
Recall that a class encapsulates data and operations on that data into a single unit. Because
every container is a class, several operations are directly defined for a container and are
provided as part of the definition of the class. Also, recall that the operations to manipulate
the data are implemented with the help of functions and are called member functions of the
class. Table 21-5 describes the member functions that are common to all containers; that is,
these functions are included as members of the class template implementing the container.
Suppose ct, ct1, and ct2 are containers of the same type. In Table 21-5, the name of
the function is shown in bold. This table also shows how a function is called.
TABLE 21-5

Operations Common to All Containers

Member function

Description

Default constructor

Initializes the object to an empty state.

Constructor with parameters

In addition to the default constructor, every
container has constructors with parameters. We
will describe these constructors when we discuss a
specific container.

Copy constructor

Executes when an object is passed as a parameter
by value and when an object is declared and
initialized using another object of the same type.

Destructor

Executes when the object goes out of scope.

ct.empty()

Returns true if container ct is empty, false
otherwise.

ct.size()

Returns the number of elements currently in
container ct.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

TABLE 21-5

|

1453

Operations Common to All Containers (continued)

Member function

Description

ct.max_size()

Returns the maximum number of elements that
can be inserted in container ct.

ct1.swap(ct2)

Swaps the elements of containers ct1 and ct2.

ct.begin()

Returns an iterator to the first element into
container ct.

ct.end()

Returns an iterator to the position after the last
element into container ct.

ct.rbegin()

Reverse begin. Returns a pointer to the last
element into container ct. This function is used to
process the elements of ct in reverse.

ct.rend()

Reverse end. Returns a pointer to the position
before the first element into container ct.

ct.insert(position,elem)

Inserts elem into container ct at the position
specified by position. Note that here,
position is an iterator.

ct.erase(beg, end)

Deletes all of the elements between
beg...end-1 from container ct. Both beg
and end are iterators.

ct.clear()

Deletes all of the elements from the container.
After a call to this function, container ct is empty.

Operator functions

ct1 = ct2;

Copies the elements of ct2 into ct1. After this
operation, the elements in both containers are the
same.

ct1 == ct2

Returns true if containers ct1 and ct2 are
equal, false otherwise.

ct1 != ct2

Returns true if containers ct1 and ct2 are not
equal, false otherwise.

Because these operations are common to all containers, when discussing a specific
container, to save space, these operations will not be listed again.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1454

| Chapter 21: Standard Template Library (STL)

Member Functions Common to Sequence Containers
The previous section described the member functions that are common to all containers. In
addition to these member functions, Table 21-6 describes the member functions that are
common to all sequence containers, that is, containers of type vector, deque, and list.
The name of the function is shown in bold. (Suppose that seqCont is a sequence container.)
TABLE 21-6

Member Functions Common to All Sequence Containers

Expression

Description

seqCont.insert(position, elem)

A copy of elem is inserted at the
position specified by the iterator
position. The position of the new
element is returned.

seqCont.insert(position, n, elem)

n copies of elem are inserted at the
position specified by the iterator
position.

seqCont.insert(position, beg, end)

A copy of the elements, starting at
beg until end-1, is inserted into
seqCont at the position specified
by the iterator position. Also,
beg and end are iterators.

seqCont.push_back(elem)

A copy of elem is inserted into
seqCont at the end.

seqCont.pop_back()

Deletes the last element.

seqCont.erase(position)

Deletes the element at the position
specified by the iterator position.

seqCont.erase(beg, end)

Deletes all of the elements starting at
beg until end-1. Both beg and
end are iterators.

seqCont.clear()

Deletes all of the elements from the
container.

seqCont.resize(num)

Changes the number of elements to
num. If size() grows, the new
elements are created by their default
constructor.

seqCont.resize(num, elem)

Changes the number of elements to
num. If size() grows, the new
elements are copies of elem.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

|

1455

The copy Algorithm
Example 21-4 used a for loop to output the elements of a vector container. The STL
provides a convenient way to output the elements of a container with the help of the
function copy. The function copy is provided as a part of the generic algorithm and can
be used with any container type. Because we frequently need to output the elements of a
container, before continuing with our discussion of containers, let us describe this
function.
The function copy does more than output the elements of a container. In general, it
allows us to copy the elements from one place to another. For example, to output the
elements of a vector or to copy the elements of a vector into another vector, we can use
the function copy. The prototype of the function template copy is:
template <class inputIterator, class outputIterator>
outputIterator copy(inputIterator first1, inputIterator last,
outputIterator first2);

The parameter first1 specifies the position from which to begin copying the elements;
the parameter last specifies the end position. The parameter first2 specifies where to
copy the elements. Therefore, the parameters first1 and last specify the source;
parameter first2 specifies the destination.
Note that the elements within the range first1. . .last-1 are copied.
The definition of the function template copy is contained in the header file algorithm.
Thus, to use the function copy, the program must include the statement:
#include <algorithm>

The function copy works as follows. Consider the following statement:
int intArray[] = {5, 6, 8, 3, 40, 36, 98, 29, 75};

This statement creates an array intArray of nine components. Here, intArray[0] = 5,
intArray[1] = 6, and so on.
The statement:
vector<int> vecList(9);

creates an empty container of nine components of type vector and the element type int.
Recall that the array name, intArray, is actually a pointer and contains the base address of
the array. Therefore, intArray points to the first component of the array, intArray + 1
points to the second component of the array, and so on.
Now consider the statement:
copy(intArray, intArray + 9, vecList.begin());

This statement copies the elements starting at the location intArray, which is the first
component of the array intArray, until intArray + 9 - 1 (that is, intArray + 8),

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1456

| Chapter 21: Standard Template Library (STL)

which is the last element of the array intArray, into the container vecList. (Note that
here, first1 is intArray, last is intArray + 9, and first2 is vecList.begin().)
After the previous statement executes:
vecList = {5, 6, 8, 3, 40, 36, 98, 29, 75}

Next, consider the statement:
copy(intArray + 1, intArray + 9, intArray);

Here, first1 is intArray + 1; that is, first1 points to the location of the second
element of the array intArray, and last is intArray + 9. Also, first2 is intArray;
that is, first2 points to the location of the first element of the array intArray. Therefore,
the second array element is copied into the first array component, the third array element
into the second array component, and so on. After the preceding statement executes:
intArray = {6, 8, 3, 40, 36, 98, 29, 75, 75}

Clearly, the elements of the array intArray are shifted to the left by one position.
Now consider the statement:
copy(vecList.rbegin() + 2, vecList.rend(), vecList.rbegin());

Recall that the function rbegin (reverse begin) returns a pointer to the last element into
a container; it is used to process the elements of a container in reverse. Therefore,
vecList.rbegin() + 2 returns a pointer to the third-to-last element into the container vecList. Similarly, the function rend (reverse end) returns a pointer to the first
element into a container. The previous statement shifts the elements of the container
vecList to the right by two positions. After the previous statement executes, the
container vecList is:
vecList = {5, 6, 5, 6, 8, 3, 40, 36, 98}

Example 21-5 shows the effect of the preceding statements using a C++ program. Before
discussing Example 21-5, let us describe a special type of iterators called ostream
iterators. These iterators work well with the function copy to copy the elements of a
container to an output device.
THE ostream ITERATOR AND THE FUNCTION copy
One way to output the contents of a container is to use a for loop, the function begin
to initialize the for loop control variable, and the function end to set the limit.
Alternatively, the function copy can be used to output the elements of a container. In
this case, an iterator of type ostream specifies the destination. (ostream iterators are
discussed in detail later in this chapter.) When we create an iterator of type ostream, we
also specify the type of element that the iterator will output.

The following statement illustrates how to create an ostream iterator of type int:
ostream_iterator<int> screen(cout, " ");

//Line A

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

|

1457

This statement creates screen to be an ostream iterator with the element type int.
The iterator screen has two arguments: the object cout and a space. Thus, the iterator
screen is initialized using the object cout. When this iterator outputs elements, they
are separated by a space.
The statement:
copy(intArray, intArray + 9, screen);

outputs the elements of intArray on the screen.
Similarly, the statement:
copy(vecList.begin(), vecList.end(), screen);

outputs the elements of the container vecList on the screen.
We will frequently use the function copy to output the elements of a container by using
an ostream iterator. Also, until we discuss ostream iterators in detail, we will use
statements similar to Line A to create an ostream iterator.
Of course, we can directly specify an ostream iterator in the function copy. For
example, the statement (shown previously):
copy(vecList.begin(), vecList.end(), screen);

is equivalent to the statement:
copy(vecList.begin(), vecList.end(),
ostream_iterator<int>(cout, " "));

Finally, the statement:
copy(vecList.begin(), vecList.end(),
ostream_iterator<int>(cout, ", "));

outputs the elements of vecList with a comma and space between them.
Example 21-5 shows how to use the function copy and an ostream iterator in a program.
EXAMPLE 21-5
#include
#include
#include
#include

<algorithm>
<vector>
<iterator>
<iostream>

using namespace std;
int main()
{
int intArray[] = {5, 6, 8, 3, 40,
36, 98, 29, 75};

//Line 1

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1458

| Chapter 21: Standard Template Library (STL)

vector<int> vecList(9);

//Line 2

ostream_iterator<int> screen(cout, " ");

//Line 3

cout << "Line 4: intArray: ";
copy(intArray, intArray + 9, screen);
cout << endl;

//Line 4
//Line 5
//Line 6

copy(intArray, intArray + 9, vecList.begin());

//Line 7

cout << "Line 8: vecList: ";
copy(vecList.begin(), vecList.end(), screen);
cout << endl;

//Line 8
//Line 9
//Line 10

copy(intArray + 1, intArray + 9, intArray);

//Line 11

cout << "Line 12: After shifting the elements "
<< "one position to the left, " << endl
<< "
intArray: ";

//Line 12

copy(intArray, intArray + 9, screen);

//Line 13

cout << endl;

//Line 14

copy(vecList.rbegin() + 2, vecList.rend(),
vecList.rbegin());
cout << "Line 16: After shifting the elements "
<< "down by two positions, "<< endl
<< "
vecList: ";

//Line 15
//Line 16

copy(vecList.begin(), vecList.end(), screen);

//Line 17

cout << endl;

//Line 18

return 0;
}

Sample Run:
Line 4: intArray: 5 6 8 3 40 36 98 29 75
Line 8: vecList: 5 6 8 3 40 36 98 29 75
Line 12: After shifting the elements one position to the left,
intArray: 6 8 3 40 36 98 29 75 75
Line 16: After shifting the elements down by two positions,
vecList: 5 6 5 6 8 3 40 36 98

Range-Based for Loops
In the previous section, we described how to use the copy function to output the
elements of a vector container. Moreover, Chapter 8 introduced range-based for loops,
which is a feature of C++11 Standard, and discussed how it can be effectively used to
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

|

1459

process the elements of an array. In Chapter 12, we explained that if a formal parameter of
a function is an array, a range-based for loop cannot be used on that formal parameter,
and we explained why a range-based for loop cannot be used on dynamic arrays.
However, a range-based for loop can be used on sequence containers such as vector
objects, even if they are declared as formal parameters to a function. Next, we explain
how to use range-based for loops to process the elements of a vector object.
Consider the following statements:
vector<int> intList;

//Line 1

intList.push_back(13);
intList.push_back(75);
intList.push_back(28);
intList.push_back(35);

//Line
//Line
//Line
//Line

2
3
4
5

As in Example 21-4, the statement in Line 1 declares the vector intList, of type int.
The statements in Lines 2 through 5 use the function push_back to insert four
numbers—13, 75, 28, and 35—into intList.
Next, consider the following for loop:
for (auto p : list)
cout << p << " ";
cout << endl;

In this for loop, after the statement auto p : list executes, p will point to the first
element of intList. We used auto so that the compiler can infer the correct type for p.
In this for loop, p ranges over the elements of list. You can read this as ‘‘for all p in
list.’’ As we can see, this for loop outputs the elements of intList.
In Example 21-4, we used a for loop to multiply each element of intList by 2. Next,
we illustrate how to use a range-based for loop to multiply each element of intList by 2.
In fact, we write a function that uses a formal parameter of type vector<int> to multiply
each element of a vector object of type int by 2. So consider the following function:
void doubleList(vector<int> &list)
{
for (auto &p : list) //p is a reference to allow us to change
//the elements of list
p = p * 2;
}

The function doubleList takes as a parameter a reference to an object of type vector<int>.
(Notice that the formal parameter, list, of the function doubleList is a reference
parameter.) The body of this function multiplies each element of list by 2. Note that the
definition of this function uses a range-based for loop to process the elements of list.
Example 21-6 further illustrates how to use a range-based for loop on vector objects.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1460

| Chapter 21: Standard Template Library (STL)

EXAMPLE 21-6
#include <iostream>
#include <vector>
using namespace std;
void doubleList(vector<int> &list);
void printList(const vector<int> &list);

//Line 1
//Line 2

int main()
{
vector<int> intList;

//Line 3
//Line 4
//Line 5

intList.push_back(13);
intList.push_back(75);
intList.push_back(28);
intList.push_back(35);

//Line
//Line
//Line
//Line

6
7
8
9

cout << "intList: ";
printList(intList);

//Line 10
//Line 11

doubleList(intList);

//Line 12

cout << "intList after multiplying each "
<< "element by 2: ";
printList(intList);

//Line 13
//Line 14

cout << endl;

//Line 15

return 0;
}

//Line 16
//Line 17

void printList(const vector<int> &list)
{
for (auto p : list)
cout << p << " ";
cout << endl;
}

//Line
//Line
//Line
//Line
//Line
//Line

18
19
20
21
22
23

void doubleList(vector<int> &list)
{
for (auto &p : list)
p = p * 2;
}

//Line
//Line
//Line
//Line
//Line

24
25
26
27
28

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

|

1461

Sample Run:
intList: 13 75 28 35
intList after multiplying each element by 2: 26 150 56 70

This sample is easy to follow. However, note that the preceding program uses the
function printList to output the elements of intList and the function doubleList
to multiply each element of intList by 2. Both these functions use a range-based
for loop to process the elements of an object of type vector<int>.

Initializing vector Objects during Declaration
C++ allows variables of simple data types or arrays to be initialized when they are
declared. For example, consider the following statements:
int x = 90;
int list = {2, 3, 4, 5};

The first statement declares x to be an int variable and initializes x to 90. The second
statement declares list to be an int array of 4 elements and initializes the elements of
list to 2, 3, 4, and 5, respectively. In Examples 21-4 and 21-6, we declared intList
to be a vector object of type int and then used the function push_back to store
int values in intList. To be specific, the following statements were used to declare
intList to be a vector<int> object and store 13, 75, 28, and 35 in intList:
vector<int> intList;
intList.push_back(13);
intList.push_back(75);
intList.push_back(28);
intList.push_back(35);

C++11 allows a vector object to be declared and initialized at the same time. For
example, the following statement declares inList to be a vector<int> object and
store 13, 75, 28, and 35 in it.
vector<int> intList = {13, 75, 28, 35};

That is, in C++11, the five statements used earlier to declare and initialize intList
can be replaced by the preceding statement. However, at the time of the writing of this
book, the compiler that we used to test the C++ code has not implemented this feature
of C++11. Therefore, we will continue to use the array subscripting operator or the
function push_back, whichever is applicable, to store data or initialize a vector
object.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1462

| Chapter 21: Standard Template Library (STL)

Sequence Container: deque
This section describes the deque sequence containers. The term deque stands for
double-ended queue. Deque containers are implemented as dynamic arrays in such a
way that the elements can be inserted at both ends. Thus, a deque can expand in either
direction. Elements can also be inserted in the middle. Inserting elements in the beginning or at the end is fast; inserting elements in the middle, however, is time consuming
because the elements in the queue need to be shifted.
The name of the class defining the deque containers is deque. The definition of the
class deque, and the functions to implement the various operations on a deque
object, are also contained in the header file deque. Therefore, to use a deque container
in a program, the program must include the following statement:
#include <deque>

The class deque contains several constructors. Thus, a deque object can be initialized
in various ways when it is declared, as described in Table 21-7.
TABLE 21-7

Various Ways to Declare a deque Object

Statement

Description

deque<elementType> deq;

Creates an empty deque container
deq. (The default constructor is
invoked.)

deque<elementType> deq(otherDeq);

Creates the deque container deq
and initializes it to the elements of
otherDeq; deq and otherDeq
are of the same type.

deque<elementType> deq(size);

Creates the deque container deq of
size size. deq is initialized using the
default constructor.

deque<elementType> deq(n, elm);

Creates the deque container deq of
size n. deq is initialized using n copies
of the element elm.

deque<elementType> deq(beg, end);

Creates the deque container deq.
deq is initialized to the elements in
the range [beg, end), that is, all
elements in the range beg...end-1.
Both beg and end are iterators.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

|

1463

In addition to the operations that are common to all sequence containers (Table 21-6),
Table 21-8 describes the operations that can be used to manipulate the elements of a
deque container. The name of the function implementing the operations is shown in
bold. Each statement also shows how to use a particular function. Suppose that deq is a
deque container.
TABLE 21-8

Various Operations that Can Be Performed on a deque Object

Expression

Description

deq.assign(n,elem)

Assigns n copies of elem.

deq.assign(beg, end)

Assigns all of the elements in the range
beg...end-1.

deq.push_front(elem)

Inserts elem at the beginning of deq.

deq.pop_front()

Removes the first element from deq.

deq.at(index)

Returns the element at the position specified
by index.

deq[index]

Returns the element at the position specified
by index.

deq.front()

Returns the first element. (Does not check
whether the container is empty.)

deq.back()

Returns the last element. (Does not check
whether the container is empty.)

Example 21-7 illustrates how to use a deque container in a program.
EXAMPLE 21-7
//deque Example
#include <iostream>
#include <deque>
#include <algorithm>
#include <iterator>
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1464

| Chapter 21: Standard Template Library (STL)

int main()
{
deque<int> intDeq;
ostream_iterator<int> screen(cout, " ");

//Line 1
//Line 2

intDeq.push_back(13);
intDeq.push_back(75);
intDeq.push_back(28);
intDeq.push_back(35);

//Line
//Line
//Line
//Line

3
4
5
6

cout << "Line 7: intDeq: ";
copy(intDeq.begin(), intDeq.end(), screen);
cout << endl;

//Line 7
//Line 8
//Line 9

intDeq.push_front(0);
intDeq.push_back(100);

//Line 10
//Line 11

cout << "Line 12: After adding two more "
<< "elements, one at the front " << endl
<< "
and one at the back, intDeq: "; //Line 12
copy(intDeq.begin(), intDeq.end(), screen);
//Line 13
cout << endl;
//Line 14
intDeq.pop_front();
intDeq.pop_front();

//Line 15
//Line 16

cout << "Line 17: After removing the first "
<< "two elements, " << endl
<< "
intDeq: ";
copy(intDeq.begin(), intDeq.end(), screen);
cout << endl;

//Line 17
//Line 18
//Line 19

intDeq.pop_back();
intDeq.pop_back();

//Line 20
//Line 21

cout << "Line 22: After removing the last "
<< "two elements, " << endl
<< "
intDeq = ";
copy(intDeq.begin(), intDeq.end(), screen);
cout << endl;

//Line 22
//Line 23
//Line 24

deque<int>::iterator

//Line 25

deqIt;

deqIt = intDeq.begin();
++deqIt;

//Line 26
//deqIt points to the
//second element
//Line 27

intDeq.insert(deqIt, 444);

//Insert 444 at the
//location deqIt

//Line 28

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

cout << "Line 29: After inserting 444, "
<< "intDeq: ";
copy(intDeq.begin(), intDeq.end(), screen);
cout << endl;

//Line 29
//Line 30
//Line 31

intDeq.assign(2, 45);

//Line 32

cout << "Line 33: After assigning two "
<< "copies of 45, intDeq: ";
copy(intDeq.begin(), intDeq.end(), screen);
cout << endl;

//Line 33
//Line 34
//Line 35

intDeq.push_front(-10);
intDeq.push_back(-999);

//Line 36
//Line 37

|

1465

cout << "Line 38: After inserting two "
<< "elements, one at the front " << endl
<< "
and one at the back, intDeq: "; //Line 38
copy(intDeq.begin(), intDeq.end(), screen);
//Line 39
cout << endl;
//Line 40
return 0;
}

Sample Run:
Line 7: intDeq: 13 75 28 35
Line 12: After adding two more elements, one at the front
and one at the back, intDeq: 0 13 75 28 35 100
Line 17: After removing the first two elements,
intDeq: 75 28 35 100
Line 22: After removing the last two elements,
intDeq = 75 28
Line 29: After inserting 444, intDeq: 75 444 28
Line 33: After assigning two copies of 45, intDeq: 45 45
Line 38: After inserting two elements, one at the front
and one at the back, intDeq: -10 45 45 -999

The statement in Line 1 declares a deque container intDeq of type int; that is, all of the
elements of intDeq are of type int. The statement in Line 2 declares screen to be an
ostream iterator initialized to the standard output device. The statements in Lines 3
through 6 use the push_back operation to insert four numbers—13, 75, 28, and 35—
into intDeq. The statement in Line 8 outputs the elements of intDeq. In the output,
see the line marked Line 7, which contains the output of the statements in Lines 7
through 9.
The statement in Line 10 inserts 0 at the beginning of intDeq; the statement in Line 11
inserts 100 at the end of intDeq. The statement in Line 13 outputs the modified
intDeq.
The statements in Lines 15 and 16 use the function pop_front to remove the first two
elements of intDeq; the statement in Line 18 outputs the modified intDeq. The

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1466

| Chapter 21: Standard Template Library (STL)

statements in Lines 20 and 21 use the function pop_back to remove the last two
elements of intDeq, and the statement in Line 23 outputs the modified intDeq.
The statement in Line 25 declares deqIt to be a deque iterator that processes all
deque containers whose elements are of type int. After the statement in Line 26
executes, deqIt points to the first element of intDeq. The statement in Line 27
advances deqIt to the next element of intDeq. The statement in Line 28 inserts 444
into intDeq at the position specified by deqIt. The statement in Line 30 outputs
intDeq.
The statement in Line 32 assigns two copies of 45 to intDeq. After the statement in Line
32 executes, the old elements of intDeq are removed and intDeq now contains only
two copies of 45. The output of the statement in Line 34 illustrates this. In the output,
see the line marked Line 33, which contains the output of the statements in Lines 33
through 35 of the program.
The meaning of the remaining statements is self-explanatory.

Sequence Container: list
This section describes the sequence container list. List containers are implemented as
doubly linked lists. Thus, every element in a list points to both its immediate predecessor
and its immediate successor (except the first and last elements). Recall that a linked list is
not a random access data structure, such as an array. Therefore, to access, say, the fifth
element in the list, we must first traverse the first four elements.
The name of the class containing the definition of the class list is list. The
definition of the class list, and the definitions of the functions to implement the
various operations on a list, are contained in the header file list. Therefore, to use list
in a program, the program must include the following statement:
#include <list>

Like other container classes, the class list contains several constructors. Thus, a
list object can be initialized in several ways when it is declared, as described in
Table 21-9.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

TABLE 21-9

|

1467

Various Ways to Declare a list Object

Statement

Description

list<elementType> listCont;

Creates the empty list
container listCont. (The
default constructor is invoked.)

list<elementType> listCont(otherList);

Creates the list container
listCont and initializes it to
the elements of otherList.
listCont and otherList
are of the same type.

list<elementType> listCont(size);

Creates the list container
listCont of size size.
listCont is initialized using
the default constructor.

list<elementType> listCont(n, elm);

Creates the list container
listCont of size n.
listCont is initialized using
n copies of the element elm.

list<elementType> listCont(beg, end);

Creates the list container
listCont. listCont is
initialized to the elements in the
range [beg, end), that is, all
of the elements in the range
beg...end-1. Both beg and
end are iterators.

Table 21-5 described the operations that are common to all containers. Table 21-6
described the operations that are common to all sequence containers. In addition to
these common operations, Table 21-10 describes the operations that are specific to a
list container. The name of the function implementing the operation is shown in
bold.
In Table 21-10, listCont is a container of type list.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1468

| Chapter 21: Standard Template Library (STL)

TABLE 21-10 Various Operations Specific to a list Container

Expression

Description

listCont.assign(n, elem)

Assigns n copies of elem.

listCont.assign(beg, end)

Assigns all of the elements in
the range beg...end-1.
Both beg and end are
iterators.

listCont.push_front(elem)

Inserts elem at the
beginning of listCont.

listCont.pop_front()

Removes the first element
from listCont.

listCont.front()

Returns the first element.
(Does not check whether the
container is empty.)

listCont.back()

Returns the last element.
(Does not check whether the
container is empty.)

listCont.remove(elem)

Removes all of the elements
that are equal to elem.

listCont.remove_if(oper)

Removes all of the elements
for which oper is true.

listCont.unique()

If the consecutive elements
in listCont have the
same value, removes the
duplicates.

listCont.unique(oper)

If the consecutive elements
in listCont have the
same value, removes the
duplicates, for which oper
is true.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

|

1469

TABLE 21-10 Various Operations Specific to a list Container (continued)

Expression

Description

listCont1.splice(pos, listCont2)

All of the elements of
listCont2 are moved
to listCont1 before
the position specified by
the iterator pos. After this
operation, listCont2 is
empty.

listCont1.splice(pos, listCont2, pos2)

All of the elements starting
at pos2 of listCont2
are moved to listCont1
before the position
specified by the iterator
pos.

listCont1.splice(pos, listCont2, beg, end)

All of the elements in the
range beg...end-1 of
listCont2 are moved
to listCont1 before
the position specified by
the iterator pos. Both
beg and end are
iterators.

listCont.sort()

The elements of
listCont are sorted.
The sort criteria is <.

listCont.sort(oper)

The elements of
listCont are sorted.
The sort criteria is
specified by oper.

listCont1.merge(listCont2)

Suppose that the elements
of listCont1 and
listCont2 are sorted.
This operation moves all of
the elements of
listCont2 into
listCont1. After this
operation, the elements in
listCont1 are sorted.
Moreover, after this
operation, listCont2 is
empty.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1470

| Chapter 21: Standard Template Library (STL)

TABLE 21-10 Various Operations Specific to a list Container (continued)

Expression

Description

listCont1.merge(listCont2, oper)

Suppose that the elements
of listCont1 and
listCont2 are sorted
according to the sort
criteria oper. This
operation moves all of the
elements of listCont2
into listCont1. After
this operation, the
elements in listCont1
are sorted according to the
sort criteria oper.

listCont.reverse()

The elements of
listCont are reversed.

Example 21-8 illustrates how to use the various operations on a list container.
EXAMPLE 21-8
//List Container Example
#include
#include
#include
#include

<iostream>
<list>
<iterator>
<algorithm>

using namespace std;
int main()
{
list<int> intList1, intList2, intList3, intList4;

//Line 1

ostream_iterator<int> screen(cout, " ");

//Line 2

intList1.push_back(23);
intList1.push_back(58);
intList1.push_back(58);
intList1.push_back(58);
intList1.push_back(36);
intList1.push_back(15);
intList1.push_back(93);
intList1.push_back(98);
intList1.push_back(58);
cout << "Line 12: intList1: ";
copy(intList1.begin(), intList1.end(), screen);
cout << endl;

//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line
//Line

3
4
5
6
7
8
9
10
11
12
13
14

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Components of the STL

|

intList2 = intList1;

//Line 15

cout << "Line 16: intList2: ";
copy(intList2.begin(), intList2.end(), screen);
cout << endl;

//Line 16
//Line 17
//Line 18

intList1.unique();

//Line 19

cout << "Line 20: After removing the consecutive "
<< "duplicates," << endl
<< "
intList1: ";
copy(intList1.begin(), intList1.end(), screen);
cout << endl;

//Line 20
//Line 21
//Line 22

intList2.sort();

//Line 23

cout << "Line 24: After sorting, intList2: ";
copy(intList2.begin(), intList2.end(), screen);
cout << endl;

//Line 24
//Line 25
//Line 26

intList3.push_back(13);
intList3.push_back(23);
intList3.push_back(25);
intList3.push_back(136);
intList3.push_back(198);

//Line
//Line
//Line
//Line
//Line

cout << "Line 32: intList3: ";
copy(intList3.begin(), intList3.end(), screen);
cout << endl;

//Line 32
//Line 33
//Line 34

intList4.push_back(-2);
intList4.push_back(-7);
intList4.push_back(-8);

//Line 35
//Line 36
//Line 37

cout << "Line 38: intList4: ";
copy(intList4.begin(), intList4.end(), screen);
cout << endl;

//Line 38
//Line 39
//Line 40

intList3.splice(intList3.begin(), intList4);

//Line 41

cout << "Line 42: After moving the elements of "
<< "intList4 into intList3," << endl
<< "
intList3: ";
copy(intList3.begin(), intList3.end(), screen);
cout << endl;

//Line 42
//Line 43
//Line 44

intList3.sort();

//Line 45

cout << "Line 46: After sorting, intList3: ";
copy(intList3.begin(), intList3.end(), screen);
cout << endl;
intList2.merge(intList3);

//Line
//Line
//Line
//Line

1471

27
28
29
30
31

46
47
48
49

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1472

| Chapter 21: Standard Template Library (STL)

cout << "Line 50: After merging intList2 and "
<< "intList3, intList2: " << endl
<< "
";
copy(intList2.begin(), intList2.end(), screen);
cout << endl;

//Line 50
//Line 51
//Line 52

intList2.unique();

//Line 53

cout << "Line 54: After removing the consecutive "
<< "duplicates, intList2: " << endl
<< "
";
copy(intList2.begin(), intList2.end(), screen);
cout << endl;

//Line 54
//Line 55
//Line 56

return 0;
}

Sample Run:
Line 12: intList1: 23 58 58 58 36 15 93 98 58
Line 16: intList2: 23 58 58 58 36 15 93 98 58
Line 20: After removing the consecutive duplicates,
intList1: 23 58 36 15 93 98 58
Line 24: After sorting, intList2: 15 23 36 58 58 58 58 93 98
Line 32: intList3: 13 23 25 136 198
Line 38: intList4: -2 -7 -8
Line 42: After moving the elements of intList4 into intList3,
intList3: -2 -7 -8 13 23 25 136 198
Line 46: After sorting, intList3: -8 -7 -2 13 23 25 136 198
Line 50: After merging intList2 and intList3, intList2:
-8 -7 -2 13 15 23 23 25 36 58 58 58 58 93 98 136 198
Line 54: After removing the consecutive duplicates, intList2:
-8 -7 -2 13 15 23 25 36 58 93 98 136 198

For the most part, the output of the preceding program is straightforward. The statements
in Lines 3 through 11 insert the element numbers 23, 58, 58, 58, 36, 15, 93, 98, and
58 (in that order) into intList1. The statement in Line 15 copies the elements of
intList1 into intList2. After this statement executes, intList1 and intList2
are identical. The statement in Line 19 removes any consecutive occurrences of the same
elements. For example, the number 58 appears consecutively three times. The operation
unique removes two occurrences of 58. Note that this operation has no effect on the 58
that appears at the end of intList1.
The statement in Line 23 sorts intList2. The statements in Lines 27 through 31 insert 13,
23, 25, 136, and 198 into intList3. Similarly, the statements in Lines 35 through 37
insert -2, -7, and -8 into intList4. The statement in Line 41 uses the operation splice
to move the elements of intList4 to the beginning of intList3. After the splice
operation, intList4 is empty. The statement in Line 45 sorts intList3, and the
statement in Line 49 merges intList2 and intList3 into intList2. After the merge
operation, intList3 is empty. The meanings of the remaining statements are similar.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Iterators

|

1473

Example 21-6 shows how to use a range-based for loop on vector objects. Now
range-based for loops are a feature of C++11 Standard and they can be used to
process the elements of any sequence container object such as list and deque. For
example, in Example 21-8, the statement in Line 13, which outputs the elements of
intList1, can also be written as:

for (auto p : intList1)
cout << p << " ";
Similarly, the statements in Lines 17, 21, 25, and 33 can be written using range-based
for loops. The file STL_Example21-8_list_Modified.cpp, available at the
Web site accompanying this book, contains the modified program, given in Example 21-8,
that uses range-based for loops to output the elements of list containers intList1,
intList2, and intList3.

Examples 21-5, 21-7, and 21-8 further clarify that iterators are important to efficiently
process the elements of a container. Before describing associative containers, let us discuss
iterators in some detail.

Iterators
Iterators are similar to pointers. In general, an iterator points to the elements of a
container (sequence or associative). Thus, with the help of iterators, we can successively
access each element of a container.
The two most common operations on iterators are ++ (the increment operator) and * (the
dereferencing operator). Suppose that cntItr is an iterator into a container. The statement:
++cntItr;

advances cntItr so that it points to the next element in the container. Similarly, the
statement:
*cntItr;

gives access to the element of the container pointed to by cntItr.

Types of Iterators
There are five types of iterators:
•
•
•
•
•

Input iterators
Output iterators
Forward iterators
Bidirectional iterators
Random access iterators

The following sections describe these iterators.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1474

| Chapter 21: Standard Template Library (STL)

INPUT ITERATORS
Input iterators, with read access, step forward element by element; consequently, they return the
values element by element. These iterators are provided for reading data from an input stream.

Suppose inputIterator is an input iterator. Table 21-11 describes the operations on
inputIterator.
TABLE 21-11 Operations on an Input Iterator

Expression

Effect

*inputIterator

Gives access to the element to which
inputIterator points.

inputIterator->member

Gives access to the member of the element.

++inputIterator

Moves forward, returns the new position
(pre-increment).

inputIterator++

Moves forward, returns the old position
(post-increment).

inputIt1 == inputIt2

Returns true if the two iterators are the same, and
false otherwise.

inputIt1 != inputIt2

Returns true if the two iterators are not the same,
and false otherwise.

OUTPUT ITERATORS
Output iterators, with write access, step forward element by element. These iterators are
provided for writing data to an output stream. They are also used as inserters.

Suppose outputIterator is an output iterator. Table 21-12 describes the operations
on outputIterator.
TABLE 21-12 Operations on an Output Iterator

Expression

Effect

*outputIterator = value;

Writes the value at the position specified by
outputIterator.

++outputIterator

Moves forward, returns the new position
(pre-increment).

outputIterator++

Moves forward, returns the old position
(post-increment).

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Iterators

|

1475

Output iterators cannot be used to iterate over a range twice. Thus, if we write data at the
same position twice, there is no guarantee that the new value will replace the old value.

FORWARD ITERATORS
Forward iterators combine all of the functionality of input iterators and almost all of
the functionality of output iterators. Suppose forwardIterator is a forward iterator.
Table 21-13 describes the operations on forwardIterator.
TABLE 21-13 Operations on a Forward Iterator

Expression

Effect

*forwardIterator

Gives access to the element to which
forwardIterator points.

forwardIterator->member

Gives access to the member of the element.

++forwardIterator

Moves forward, returns the new position
(pre-increment).

forwardIterator++

Moves forward, returns the old position
(post-increment).

forwardIt1 == forwardIt2

Returns true if the two iterators are the same,
and false otherwise.

forwardIt1 != forwardIt2

Returns true if the two iterators are not the
same, and false otherwise.

forwardIt1 = forwardIt2

Assignment

A forward iterator can refer to the same element in the same collection and process the
same element more than once.

BIDIRECTIONAL ITERATORS
Bidirectional iterators are forward iterators that can also iterate backward over the elements.
Suppose biDirectionalIterator is a bidirectional iterator. The operations defined
for forward iterators (Table 21-13) are also applicable to bidirectional iterators. To step
backward, the decrement operations are also defined for biDirectionalIterator.
Table 21-14 shows additional operations on a bidirectional iterator.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1476

| Chapter 21: Standard Template Library (STL)

TABLE 21-14 Additional Operations on a Bidirectional Iterator

Expression

Effect

--biDirectionalIterator

Moves backward, returns the new position
(pre-decrement).

biDirectionalIterator--

Moves backward, returns the old position
(post-decrement).

Bidirectional iterators can be used with containers of type vector, deque, list,
set, multiset, map, and multimap.

RANDOM ACCESS ITERATORS
Random access iterators are bidirectional iterators that can randomly process the elements
of a container. These iterators can be used with containers of types vector, deque,
and string, as well as arrays. The operations defined for bidirectional iterators
(for example, Tables 21-13 and 21-14) are also applicable to random access iterators.
Table 21-15 describes the additional operations that are defined for random access
iterators. Suppose rAccessIterator is a random access iterator.
TABLE 21-15 Additional Operations on a Random Access Iterator

Expression

Effect

rAccessIterator[n]

Accesses the nth element.

rAccessIterator += n

Moves rAccessIterator forward n
elements if n >= 0 and backward if n < 0.

rAccessIterator -= n

Moves rAccessIterator backward n
elements if n >= 0 and forward if n < 0.

rAccessIterator + n

Returns the iterator of the next nth element.

n + rAccessIterator

Returns the iterator of the next nth element.

rAccessIterator - n

Returns the iterator of the previous nth element.

rAccessIt1 - rAccessIt2

Returns the distance between the iterators
rAccessIt1 and rAccessIt2.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Iterators

|

1477

TABLE 21-15 Additional Operations on a Random Access Iterator (continued)

Expression

Effect

rAccessIt1 < rAccessIt2

Returns true if rAccessIt1 is before
rAccessIt2, and false otherwise.

rAccessIt1 <= rAccessIt2

Returns true if rAccessIt1 is before or
equal to rAccessIt2, and false otherwise.

rAccessIt1 > rAccessIt2

Returns true if rAccessIt1 is after
rAccessIt2, and false otherwise.

rAccessIt1 >= rAccessIt2

Returns true if rAccessIt1 is after or equal
to rAccessIt2, and false otherwise.

Figure 21-1 shows the iterator hierarchy.
Input iterators

Output iterators

Forward iterators

Bidirectional iterators

Random access iterators

FIGURE 21-1

Iterator hierarchy

Now that you know the different types of iterators, next we describe how to declare an
iterator into a container.
typedef ITERATOR
Every container (sequence or associative) contains a typedef iterator. Thus, an
iterator into a container is declared using the typedef iterator. For example, the
statement:
vector<int>::iterator intVecIter;

declares intVecIter to be an iterator into a vector container of type int.
Because iterator is a typedef defined inside a container (that is, a class) such as
vector, we must use the appropriate container name, container element type, and the
scope resolution operator to use the typedef iterator.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1478

| Chapter 21: Standard Template Library (STL)

typedef CONST_ITERATOR
Because an iterator works like a pointer, with the help of an iterator into a container and
the dereferencing operator, *, we can modify the elements of the container. However, if
a container is declared as const, then we must prevent the iterator from modifying the
elements of the container, especially accidentally. To handle this situation, every container contains another typedef const_iterator. For example, the statement:
vector<int>::const_iterator intConstVecIt;

declares intConstVecIt to be an iterator into a vector container whose elements are
of type int. The iterator intConstVecIt is used to process the elements of those
vector containers that are declared as constant vector containers of type vector<int>.
An iterator of type const_iterator is a read-only iterator.
typedef REVERSE_ITERATOR
Every container also contains the typedef reverse_iterator. An iterator of this
type is used to iterate through the elements of a container in reverse.
typedef CONST_REVERSE_ITERATOR
An iterator of this type is a read-only iterator and is used to iterate through the elements
of a container in reverse. It is required if the container is declared as const, and we need
to iterate through the elements of the container in reverse.

In addition to the previous four typedefs, several other typedefs are common to all
containers and are described in Table 21-16.
TABLE 21-16 Various typedefs Common to All Containers

typedef

Effect

difference_type

The type of result from subtracting two iterators referring to
the same container.

pointer

A pointer to the type of elements stored in the container.

reference

A reference to the type of elements stored in the container.

const_reference

A constant reference to the type of elements stored in the
container. A constant reference is read-only.

size_type

The type used to count the elements in a container. This type
is also used to index through sequence containers, except
list containers.

value_type

The type of container elements.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Associative Containers

|

1479

Stream Iterators
Another useful set of iterators is that of stream iterators—istream iterators and
ostream iterators. This section describes both types of iterators.
istream_iterator
The istream iterator is used to input data into a program from an input stream. The
class istream_iterator contains the definition of an input stream iterator. The
general syntax to use an istream iterator is:
istream_iterator<Type> isIdentifier(istream&);

in which Type is either a built-in type or a user-defined class type, for which an input
iterator is defined. The identifier isIdentifier is initialized using the constructor
whose argument is either an istream class object, such as cin, or any publicly defined
istream subtype, such as ifstream.
ostream_iterator
The ostream iterators are used to output data from a program into an output stream.
These iterators were defined earlier in this chapter. We review them here for the sake of
completeness.

The class ostream_iterator contains the definition of an output stream iterator.
The general syntax to use an ostream iterator is:
ostream_iterator<Type> osIdentifier(ostream&);

or:
ostream_iterator<Type> osIdentifier(ostream&, char* deLimit);

in which Type is either a built-in type or a user-defined class type, for which an output
iterator is defined. The identifier osIdentifier is initialized using the constructor
whose argument is either an ostream class object, such as cout, or any publicly defined
ostream subtype, such as ofstream. In the second form used to declare an ostream
iterator, by using the second argument (deLimit) of the initializing constructor, we can
specify a character separating the output.

Associative Containers
This section discusses associative containers. Elements in an associative container are
automatically sorted according to some ordering criteria. The default ordering criterion
is the relational operator < (less than). Users also have the option of specifying their own
ordering criterion.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1480

| Chapter 21: Standard Template Library (STL)

Because elements in an associative container are sorted automatically, when a new
element is inserted into the container, it is inserted at the proper place. A convenient
and fast way to implement this type of data structure is to use a binary search tree. This is,
in fact, how associative containers are implemented. Thus, every element in the container
has a parent node (except the root node) and, at most, two children. For each element,
the key in the parent node is larger than the key in the left child and smaller than the key
in the right child.
The predefined associative containers in the STL are:
•
•
•
•

Sets
Multisets
Maps
Multimaps

This book discusses only the associative containers set and multiset.

Associative Containers: set and multiset
As described earlier, both the containers set and multiset automatically sort their
elements according to some sort criteria. The default sorting criterion is the relational
operator < (less than); that is, the elements are arranged in ascending order. The user can
also specify other sorting criteria. For user-defined data types, such as classes, the relational
operators must be overloaded properly.
The only difference between the containers set and multiset is that the container
multiset allows duplicates; the container set does not.
The name of the class defining the container set is set; the name of the class defining
the container multiset is multiset. The name of the header file containing the
definitions of the classes set and multiset, and the definitions of the functions to
implement the various operations on these containers, is set. Thus, to use any of these
containers, the program must include the following statement:
#include <set>

Declaring set or multiset Associative Containers
The classes set and multiset contain several constructors to declare and initialize
containers of these types. This section discusses the various ways that these types of
associative containers are declared and initialized. Table 21-17 describes how a set/
multiset container of a specific type can be declared and initialized.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Associative Containers

|

1481

TABLE 21-17 Various Ways to Declare a Set /Multiset Container

Statement

Effect

ctType<elmType> ct;

Creates an empty set/multiset
container, ct. The sort
criterion is <.

ctType<elmType, sortOp> ct;

Creates an empty set/multiset
container, ct. The sort
criterion is specified by
sortOp.

ctType<elmType> ct(otherCt);

Creates a set/multiset
container, ct. The elements of
otherCt are copied into ct.
The sort criterion is <. Both ct
and otherCt are of the same
type.

ctType<elmType, sortOp> ct(otherCt);

Creates a set/multiset
container, ct. The elements of
otherCt are copied into ct.
The sort criterion is specified
by sortOp. Both ct and
otherCt are of the same
type. Note that the sort criteria
of ct and otherCt must be
the same.

ctType<elmType> ct(beg, end);

Creates a set/multiset
container, ct. The elements
starting at the position beg
until the position end-1 are
copied into ct. Both beg and
end are iterators.

ctType<elmType, sortOp> ct(beg, end);

Creates a set/multiset
container, ct. The elements
starting at the position beg
until the position end-1 are
copied into ct. Both beg and
end are iterators. The sort
criterion is specified by
sortOp.

If you want to use sort criteria other than the default, you must specify this option when
the container is declared. For example, consider the following statements:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1482

| Chapter 21: Standard Template Library (STL)

set<int> intSet;
set<int, greater<int> > otherIntSet;
multiset<string> stringMultiSet;
multiset<string, greater<string> > otherStringMultiSet;

//Line
//Line
//Line
//Line

1
2
3
4

The statement in Line 1 declares intSet to be an empty set container, the element type is
int, and the sort criterion is the default sort criterion. The statement in Line 2 declares
otherIntSet to be an empty set container, the element type is int, and the sort criterion is
greater-than. That is, the elements in the container otherIntSet will be arranged in
descending order. The statements in Lines 3 and 4 have similar conventions.
The function greater is defined in the header file functional. Other functions and their
purposes from this header are discussed in the section Function Objects later in this chapter.
The statements in Lines 2 and 4 illustrate how to specify the descending sorting criterion.
In the statements in Lines 2 and 4, note the space between the two > symbols—that is,
the space between greater<int> and >. If you are using an old compiler, then this
space is important because >> is also a shift operator in C++. However, this restriction is
removed in C++11 and the compiler that we used to write programs in this book has
implemented it. Therefore, in C++11, the statements in Lines 2 and 4 can be written as:

set<int, greater<int>> otherIntSet;
//Line 2
multiset<string, greater<string>> otherStringMultiSet; //Line 4

Item Insertion and Deletion from set /multiset
Suppose that ct is either of type set or multiset. Table 21-18 describes the operations
that can be used to insert or delete elements from a set. It also illustrates how to use these
operations. The name of the function is shown in bold.
TABLE 21-18 Operations to Insert or Delete Elements from a Set

Expression

Effect

ct.insert(elem)

Inserts a copy of elem into ct. In the case of
sets, it also returns whether the insert operation
succeeded.

ct.insert(position, elem)

Inserts a copy of elem into ct. The position
where elem is inserted is returned. The first
parameter, position, hints where to begin the
search for insert. The parameter position
is an iterator.

ct.insert(beg, end);

Inserts a copy of all of the elements into ct
starting at the position beg until end-1. Both
beg and end are iterators.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Associative Containers

|

1483

TABLE 21-18 Operations to Insert or Delete Elements from a Set (continued)

Expression

Effect

ct.erase(elem);

Deletes all of the elements with the value elem.
The number of deleted elements is returned.

ct.erase(position);

Deletes the element at the position specified by
the iterator position. No value is returned.

ct.erase(beg, end);

Deletes all of the elements starting at the
position beg until the position end-1. Both
beg and end are iterators. No value is returned.

ct.clear();

Deletes all of the elements from the container ct.
After this operation, the container ct is empty.

Example 21-9 shows the various operations on a set/multiset container.

2
1

EXAMPLE 21-9
#include
#include
#include
#include
#include
#include

<iostream>
<set>
<string>
<iterator>
<algorithm>
<functional>

using namespace std;
int main()
{
set<int> intSet;
set<int, greater<int> > intSetA;

//Line 1
//Line 2

set<int, greater<int> >::iterator intGtIt;

//Line 3

ostream_iterator<int> screen(cout, " ");

//Line 4

intSet.insert(16);
intSet.insert(8);
intSet.insert(20);
intSet.insert(3);

//Line
//Line
//Line
//Line

cout << "Line 9: intSet: ";
copy(intSet.begin(), intSet.end(), screen);
cout << endl;

//Line 9
//Line 10
//Line 11

intSetA.insert(36);
intSetA.insert(84);

//Line 12
//Line 13

5
6
7
8

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1484

| Chapter 21: Standard Template Library (STL)

intSetA.insert(30);
intSetA.insert(39);
intSetA.insert(59);
intSetA.insert(238);
intSetA.insert(156);

//Line
//Line
//Line
//Line
//Line

cout << "Line 19: intSetA: ";
copy(intSetA.begin(), intSetA.end(), screen);
cout << endl;

//Line 19
//Line 20
//Line 21

intSetA.erase(59);

//Line 22

cout << "Line 23: After removing 59, intSetA: ";
copy(intSetA.begin(), intSetA.end(), screen);
cout << endl;

//Line 23
//Line 24
//Line 25

intGtIt = intSetA.begin();
++intGtIt;
++intGtIt;
++intGtIt;

//Line
//Line
//Line
//Line

intSetA.erase(intGtIt);

//Line 30

cout << "Line 31: After removing the fourth "
<< "element, " << endl
<< "
intSetA: ";
copy(intSetA.begin(), intSetA.end(), screen);
cout << endl;

//Line 31
//Line 32
//Line 33

set<int, greater<int> >

//Line 34

intSetB(intSetA);

14
15
16
17
18

26
27
28
29

cout << "Line 35: intSetB: ";
copy(intSetB.begin(), intSetB.end(), screen);
cout << endl;

//Line 35
//Line 36
//Line 37

intSetB.clear();

//Line 38

cout << "Line 39: After removing all elements, "
<< endl << "
intSetB: ";
copy(intSetB.begin(), intSetB.end(), screen);
cout << endl;

//Line 39
//Line 40
//Line 41

multiset<string, greater<string> > namesMultiSet;
multiset<string, greater<string> >::iterator iter;

//Line 42
//Line 43

ostream_iterator<string> pScreen(cout, " ");

//Line 44

namesMultiSet.insert("Donny");
namesMultiSet.insert("Zippy");
namesMultiSet.insert("Goofy");
namesMultiSet.insert("Hungry");

//Line
//Line
//Line
//Line

45
46
47
48

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Associative Containers

|

namesMultiSet.insert("Goofy");
namesMultiSet.insert("Donny");

//Line 49
//Line 50

cout << "Line 51: namesMultiSet: ";
copy(namesMultiSet.begin(), namesMultiSet.end(),
pScreen);
cout << endl;

//Line 51

1485

//Line 52
//Line 53

return 0;
}

Sample Run:
Line
Line
Line
Line

9: intSet: 3 8 16 20
19: intSetA: 238 156 84 59 39 36 30
23: After removing 59, intSetA: 238 156 84 39 36 30
31: After removing the fourth element,
intSetA: 238 156 84 36 30
Line 35: intSetB: 238 156 84 36 30
Line 39: After removing all the elements,
intSetB:
Line 51: namesMultiSet: Zippy Hungry Goofy Goofy Donny Donny

The statement in Line 1 declares intSet to be a set container. The statement in Line 2
declares intSetA to be a set container whose elements are to be arranged in descending
order. The statement in Line 3 declares intGtIt to be a set iterator. The iterator
intGtIt can process the elements of any set container whose elements are of type
int and are arranged in descending order. The statement in Line 4 declares screen to
be an ostream iterator that outputs the elements of any container whose elements are of
type int.
The statements in Lines 5 through 8 insert 16, 8, 20, and 3 into intSet, and the
statement in Line 10 outputs the elements of intSet. In the output, see the line marked
Line 9; it contains the output of the statements in Lines 9 through 11.
The statements in Lines 12 through 18 insert 36, 84, 30, 39, 59, 238, and 156 into
intSetA, and the statement in Line 20 outputs the elements of intSetA. In the output,
see the line marked Line 19. It contains the output of the statements in Lines 19 through
21. Notice that the elements of intSetA appear in descending order.
The statement in Line 22 removes 59 from intSetA. After the statement in Line 26
executes, intGtIt points to the first element of intSetA. The statement in Line 27
advances intGtIt to the next element of intSetA. After the statement in Line 29
executes, intGtIt points to the fourth element of intSetA. The statement in Line 30
removes the element of intSetA pointed to by intGtIt. The meanings of the statements in Lines 34 through 41 are similar.
The statement in Line 42 declares namesMultiSet to be a container of type multiset.
The elements in namesMultiSet are of type string and are arranged in descending
order. The statement in Line 43 declares iter to be a multiset iterator.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1486

| Chapter 21: Standard Template Library (STL)

The statements in Lines 45 through 50 insert Donny, Zippy, Goofy, Hungry, Goofy,
and Donny into namesMultiSet. The statement in Line 52 outputs the elements of
namesMultiSet.

Container Adapters
The previous sections discussed several types of containers. In addition to the containers
that work in a general framework, the STL provides containers to accommodate special
situations. These containers, called container adapters, are adapted standard STL containers to work in a specific environment. The three container adapters are:
•
•
•

Stacks
Queues
Priority queues

Container adapters do not support any type of iterator. That is, iterators cannot be used
with these types of containers. The next two sections describe two types of container
adapters: stack and queue.

Stack
Chapter 17 discussed the data structure stack in detail. Because a stack is an important
data structure, the STL provides a class to implement a stack in a program. The name of
the class defining a stack is stack; the name of the header file containing the definition of
the class stack is stack. Table 21-19 defines the various operations supported by the
stack container class.
TABLE 21-19 Various Operations on a stack Object

Operation

Description

size

Returns the actual number of elements in the stack.

empty

Returns true if the stack is empty, false otherwise.

push(item)

Inserts a copy of item onto the stack.

top

Returns the top element of the stack, but does not remove the element
from the stack. This operation is implemented as a value-returning
function.

pop

Removes the top element of the stack.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Container Adapters

|

1487

In addition to the operations size, empty, push, top, and pop, the stack container
class provides relational operators to compare two stacks. For example, the relational
operator == can be used to determine whether two stacks are identical.
The program in Example 21-10 illustrates how to use the stack container class.
EXAMPLE 21-10
#include <iostream>
#include <stack>
using namespace std;
int main()
{
stack<int> intStack;
intStack.push(16);
intStack.push(8);
intStack.push(20);
intStack.push(3);

//Line 1
//Line
//Line
//Line
//Line

2
3
4
5

cout << "Line 6: The top element of intStack: "
<< intStack.top() << endl;
//Line 6
intStack.pop();

//Line 7

cout << "Line 8: After the pop operation, "
<< "the top element of intStack: "
<< intStack.top() << endl;

//Line 8

cout << "Line 9: intStack elements: ";

//Line 9

while (!intStack.empty())
{
cout << intStack.top() << " ";
intStack.pop();
}

//Line 10

cout << endl;

//Line 13

//Line 11
//Line 12

return 0;
}

Sample Run:
Line 6: The top element of intStack: 3
Line 8: After the pop operation, the top element of intStack: 20
Line 9: intStack elements: 20 8 16

The preceding output is self-explanatory. The details are left as an exercise for you.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1488

| Chapter 21: Standard Template Library (STL)

Queue
Chapter 17 discussed the data structure queue in detail. Because a queue is an important
data structure, the STL provides a class to implement queues in a program. The name of
the class defining the queue is queue, and the name of the header file containing the
definition of the class queue is queue. Table 21-20 defines the various operations
supported by the queue container class.
TABLE 21-20 Various Operations on a queue Object

Operation

Description

size

Returns the actual number of elements in the queue.

empty

Returns true if the queue is empty, false otherwise.

push(item)

Inserts a copy of item into the queue.

front

Returns the next—that is, first— element in the queue, but does not
remove the element from the queue. This operation is implemented as
a value-returning function.

back

Returns the last element in the queue, but does not remove the
element from the queue. This operation is implemented as a
value-returning function.

pop

Removes the next element in the queue.

In addition to the operations size, empty, push, front, back, and pop, the queue
container class provides relational operators to compare two stacks. For example, the
relational operator == can be used to determine whether two stacks are identical.
The program in Example 21-11 illustrates how to use the queue container class.
EXAMPLE 21-11
#include <iostream>
#include <queue>
using namespace std;
int main()
{
queue<int> intQueue;
intQueue.push(26);
intQueue.push(18);

//Line 1
//Line 2
//Line 3

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Containers, Associated Header Files, and Iterator Support

intQueue.push(50);
intQueue.push(33);

|

1489

//Line 4
//Line 5

cout << "Line 6: The front element of intQueue: "
<< intQueue.front() << endl;
//Line 6
cout << "Line 7: The last element of intQueue: "
<< intQueue.back() << endl;
//Line 7
intQueue.pop();

//Line 8

cout << "Line 9: After the pop operation, "
<< "the front element of intQueue: "
<< intQueue.front() << endl;

//Line 9

cout << "Line 10: intQueue elements: ";

//Line 10

while (!intQueue.empty())
{
cout << intQueue.front() << " ";
intQueue.pop();
}

//Line 11

cout << endl;

//Line 14

//Line 12
//Line 13

return 0;
}

Sample Run:
Line
Line
Line
Line

6: The front element of intQueue: 26
7: The last element of intQueue: 33
9: After the pop operation, the front element of intQueue: 18
10: intQueue elements: 18 50 33

The preceding output is self-explanatory. The details are left as an exercise for you.

Containers, Associated Header Files,
and Iterator Support
The previous sections discussed various types of containers. Recall that every container is
a class. The definition of the class implementing a specific container is contained in the
header file. Table 21-21 describes the container, its associated header file, and the type of
iterator supported by the container.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1490

| Chapter 21: Standard Template Library (STL)

TABLE 21-21 Containers, Their Associated Header Files, and the Type of Iterator Supported

by Each Container
Sequence containers

Associated header file

Type of iterator support

vector

<vector>

Random access

deque

<deque>

Random access

list

<list>

Bidirectional

Associative containers

Associated header file

Type of iterator support

map

<map>

Bidirectional

multimap

<map>

Bidirectional

set

<set>

Bidirectional

multiset

<set>

Bidirectional

Adapters

Associated header file

Type of iterator support

stack

<stack>

No iterator support

queue

<queue>

No iterator support

priority queue

<queue>

No iterator support

Algorithms
Several operations can be defined for a container. Some of the operations are very specific
to a container and, therefore, are provided as part of the container definition (that is,
as member functions of the class implementing the container). However, several
operations—such as find, sort, and merge—are common to all containers. These
operations are provided as generic algorithms and can be applied to all containers, as well
as the built-in array type. The algorithms are bound to a particular container through an
iterator pair.
The generic algorithms are contained in the header file algorithm. This section
describes several of these algorithms and shows how to use them in a program. Because
algorithms are implemented with the help of functions, in this section, the terms function
and algorithm mean the same thing.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1491

STL Algorithm Classification
In earlier sections, you applied various operations on a sequence container, such as
clear, sort, merge, and so on. However, those algorithms were tied to a specific
container in terms of the members of a specific class. All of those algorithms and a few
others are also available in more general forms, called generic algorithms, and can be
applied in a variety of situations. This section discusses some of these generic algorithms.
The STL contains algorithms that look only at the elements in a container and that move
the elements of a container. It also has algorithms that can perform specific calculations,
such as finding the sum of the elements of a numeric container. In addition, the STL
contains algorithms for basic set theory operations, such as set union and intersection. You
have already encountered some of the generic algorithms, such as the copy algorithm.
This algorithm copies the elements from a given range of elements to another place, such
as another container or the screen. The algorithms in the STL can be classified into the
following categories:
•
•
•
•

Nonmodifying algorithms
Modifying algorithms
Numeric algorithms
Heap algorithms

2
1

The next four sections describe these algorithms. Most of the generic algorithms are
contained in the header file algorithm. Certain algorithms, such as the numeric
algorithms, are contained in the header file numeric.
NONMODIFYING ALGORITHMS
Nonmodifying algorithms do not modify the elements of the container; they merely
investigate the elements. Table 21-22 lists the nonmodifying algorithms.
TABLE 21-22 Nonmodifying Algorithms

adjacent_find

find_end

max

binary_search

find_first_of

max_element

count

find_if

min

count_if

for_each

min_element

equal

includes

search

equal_range

lower_bound

search_n

find

mismatch

upper_bound

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1492

| Chapter 21: Standard Template Library (STL)

MODIFYING ALGORITHMS
Modifying algorithms, as the name implies, modify the elements of the container by
rearranging, removing, or changing the values of the elements. Table 21-23 lists the
modifying algorithms.
TABLE 21-23 Modifying Algorithms

copy

prev_permutation

rotate_copy

copy_backward

random_shuffle

set_difference

fill

remove

set_intersection

fill_n

remove_copy

set_symmetric_difference

generate

remove_copy_if

set_union

generate_n

remove_if

sort

inplace_merge

replace

stable_partition

iter_swap

replace_copy

stable_sort

merge

replace_copy_if

swap

next_permutation

replace_if

swap_ranges

nth_element

reverse

transform

partial_sort

reverse_copy

unique

partial_sort_copy

rotate

unique_copy

partition

Modifying algorithms that change the order of the elements, not their values, are
also called mutating algorithms. For example, next_permutation, partition,
prev_permutation, random_shuffle, reverse, reverse_copy, rotate,
rotate_copy, and stable_partition are mutating algorithms.
NUMERIC ALGORITHMS
Numeric algorithms are designed to perform numeric calculations on the elements of a
container. Table 21-24 lists these algorithms.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1493

TABLE 21-24 Numeric Algorithms

accumulate

inner_product

adjacent_difference

partial_sum

HEAP ALGORITHMS
A special type of sorting algorithm, called the heap sort algorithm, is used to sort the data
stored in an array. In the heap sort algorithm, the array containing the data is viewed as a
binary tree. Thus, a heap is a form of binary tree represented as an array. In a heap, the
first element is the largest element, and the element at the ith position (if it exists) is larger
than the elements at positions 2i and 2i + 1 (if they exist). In the heap sort algorithm, first
the array containing the data is converted into a heap, and then the array is sorted using a
special type of sorting algorithm. Table 21-25 lists the basic algorithms required by the
heap sort algorithm.
TABLE 21-25 Heap Algorithms

make_heap

push_heap

pop_heap

sort_heap

Most of the STL algorithms are explained later in this chapter. For the most part, the
function prototypes of these algorithms are given along with a brief explanation of what
each algorithm does. You will then learn how to use these algorithms with the help of a
C++ program. The STL algorithms are very powerful and accomplish amazing results.
Furthermore, they have been made general, in the sense that other than using the natural
operations to manipulate containers, they allow the user to specify the manipulating criteria.
For example, the natural sorting order is ascending, but the user can specify criteria to sort
the container in descending order. Thus, every algorithm is typically implemented with the
help of overloaded functions. Before starting to describe these algorithms, we discuss
function objects, which allow the user to specify the manipulating criteria.

Function Objects
To make the generic algorithms flexible, the STL usually provides two forms of an
algorithm using the mechanism of function overloading. The first form of an algorithm
uses the natural operation to accomplish this goal. In the second form, the user can specify
criteria based on which algorithm processes the elements. For example, the algorithm
adjacent_find searches the container and returns the position of the first two elements
that are equal. In the second form of this algorithm, we can specify criteria (say, less than) to
look for the first two elements, such that the second element is less than the first element.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1494

| Chapter 21: Standard Template Library (STL)

These criteria are passed as a function object. More formally, a function object contains a
function that can be treated as a function using the function call operator, (). In fact, a
function object is a class template that overloads the function call operator, operator().
In addition to allowing you to create your own function objects, the STL provides
arithmetic, relational, and logical function objects, which are described in Table 21-26.
The STL’s function objects are contained in the header file functional.
TABLE 21-26 Arithmetic STL Function Objects

Function object name

Description

plus<Type>

plus<int> addNum;
int sum = addNum(12, 35);
The value of sum is 47.

minus<Type>

minus<int> subtractNum;
int difference = subtractNum(56, 35);
The value of difference is 21.

multiplies<Type>

multiplies<int> multiplyNum;
int product = multiplyNum(6, 3);
The value of product is 18.

divides<Type>

divides<int> divideNum;
int quotient = divideNum(16, 3);
The value of quotient is 5.

modulus<Type>

modulus<int> remainder;
int rem = remainder(16, 7);
The value of rem is 2.

negate<Type>

negate<int> num;
int opposite = num(-25);
The value of opposite is 25.

Example 21-12 shows how to use the STL’s function objects.
EXAMPLE 21-12
#include
#include
#include
#include
#include
#include

<iostream>
<string>
<algorithm>
<numeric>
<iterator>
<vector>

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1495

#include <functional>
using namespace std;
int funcAdd(plus<int>, int, int);
int main()
{
plus<int> addNum;
int num = addNum(34, 56);

//Line 1
//Line 2

cout << "Line 3: num = " << num << endl;

//Line 3

plus<string> joinString;

//Line 4

string str1 = "Hello ";
string str2 = "There";

//Line 5
//Line 6

string str = joinString(str1, str2);

//Line 7

cout << "Line 8: str = " << str << endl;

//Line 8

cout << "Line 9: Sum of 34 and 26 = "
<< funcAdd(addNum, 34, 26) << endl;

//Line 9

int list[8] = {1, 2, 3, 4, 5, 6, 7, 8};

//Line 10

vector<int> intList(list, list + 8);
ostream_iterator<int> screenOut(cout, " ");

//Line 11
//Line 12

cout << "Line 13: intList: ";
copy(intList.begin(), intList.end(), screenOut);
cout << endl;

//Line 13
//Line 14
//Line 15

//accumulate function
int sum = accumulate(intList.begin(),
intList.end(), 0);

//Line 16

cout << "Line 17: Sum of the elements of "
<< "intList = " << sum << endl;

//Line 17

int product = accumulate(intList.begin(),
intList.end(),
1, multiplies<int>());

//Line 18

cout << "Line 19: Product of the elements of "
<< "intList = " << product << endl;

//Line 19

return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1496

| Chapter 21: Standard Template Library (STL)

int funcAdd(plus<int> sum, int x, int y)
{
return sum(x, y);
}

Sample Run:
Line
Line
Line
Line
Line
Line

3: num = 90
8: str = Hello There
9: Sum of 34 and 26 = 60
13: intList: 1 2 3 4 5 6 7 8
17: Sum of the elements of intList = 36
19: Product of the elements of intList = 40320

Table 21-27 describes the relational STL function objects.
TABLE 21-27 Relational STL Function Objects

Function object name

Description
Returns true if the two arguments are equal, and
false otherwise. For example,

equal_to<Type>

equal_to<int> compare;
bool isEqual = compare(5, 5);.
The value of isEqual is true.
Returns true if the two arguments are not equal, and
false otherwise. For example,

not_equal_to<Type>

not_equal_to<int> compare;
bool isNotEqual = compare(5, 6);.
The value of isNotEqual is true.
Returns true if the first argument is greater than the
second argument, and false otherwise. For example,

greater<Type>

greater_equal<Type>

greater<int> compare;
bool isGreater = compare(8, 5);.
The value of isGreater is true.
Returns true if the first argument is greater than or
equal to the second argument, and false otherwise.
For example,

greater_equal<int> compare;
bool isGreaterEqual = compare(8, 5);.
The value of isGreaterEqual is true.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1497

TABLE 21-27 Relational STL Function Objects (continued)

Function object name

Description
Returns true if the first argument is less than the
second argument, and false otherwise. For example,

less<Type>

less_equal<Type>

less<int> compare;
bool isLess = compare(3, 5);.
The value of isLess is true.
Returns true if the first argument is less than or
equal to the second argument, and false otherwise.
For example,

less_equal<int> compare;
bool isLessEqual = compare(8, 15);.
The value of isLessEqual is true.

The STL relational function objects can also be applied to containers, as shown next. The
STL algorithm adjacent_find searches a container and returns the position in the
container where the two elements are equal. This algorithm has a second form that allows
the user to specify the comparison criteria. For example, consider the following vector,
vecList:
vecList = {2, 3, 4, 5, 1, 7, 8, 9};

The elements of vecList are supposed to be in ascending order. To see if the elements
are out of order, we can use the algorithm adjacent_find as follows:
intItr = adjacent_find(vecList.begin(), vecList.end(),
greater<int>());

in which intItr is an iterator of the vector type. The function adjacent_find starts
at the position vecList.begin()—that is, at the first element of vecList—and looks
for the first set of consecutive elements such that the first element is greater than the
second. The function returns a pointer to element 5, which is stored in intItr.
The program in Example 21-13 further illustrates how to use the relational function objects.
EXAMPLE 21-13
This example shows how the relational STL function objects work.
#include
#include
#include
#include
#include
#include

<iostream>
<string>
<algorithm>
<iterator>
<vector>
<functional>

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1498

| Chapter 21: Standard Template Library (STL)

using namespace std;
int main()
{
equal_to<int> compare;
bool isEqual = compare(6, 6);

//Line 1
//Line 2

cout << "Line 3: isEqual = " << isEqual << endl;

//Line 3

greater<string> greaterStr;

//Line 4

string str1 = "Hello";
string str2 = "There";

//Line 5
//Line 6

if (greaterStr(str1, str2))
cout << "Line 8: \"" << str1 << "\" is "
<< "greater than \"" << str2 << "\""
<< endl;
else
cout << "Line 10: \"" << str1 << "\" is "
<< "not greater than \"" << str2
<< "\"" << endl;

//Line 7

int temp[8] = {2, 3, 4, 5, 1, 7, 8, 9};

//Line 11

vector<int> vecList(temp, temp + 8);
vector<int>::iterator intItr1, intItr2;
ostream_iterator<int> screen(cout, " ");

//Line 12
//Line 13
//Line 14

cout << "Line 15: vecList: ";
copy(vecList.begin(), vecList.end(), screen);
cout << endl;

//Line 15
//Line 16
//Line 17

intItr1 = adjacent_find(vecList.begin(),
vecList.end(),
greater<int>());
intItr2 = intItr1 + 1;

//Line 18
//Line 19

cout <<
<<
<<
cout <<
<<
<<

"Line 20: In vecList, the first set of "
"out-of-order elements is: " << *intItr1
" " << *intItr2 << endl;
"Line 21: In vecList, the first out-of-"
"order element is at position "
vecList.end() - intItr2 << endl;

//Line 8
//Line 9
//Line 10

//Line 20
//Line 21

return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1499

Sample Run:
Line
Line
Line
Line
Line

3: isEqual = 1
10: "Hello" is not greater than "There"
15: vecList: 2 3 4 5 1 7 8 9
20: In vecList, the first set of out-of-order elements is: 5 1
21: In vecList, the first out-of-order element is at position 4

Table 21-28 describes the logical STL function objects.
TABLE 21-28 Logical STL Function Objects

Function object name

Effect

logical_not<Type>

Returns true if its operand evaluates to false; otherwise,
it returns false. This is a unary function object.

logical_and<Type>

Returns true if both of its operands evaluate to true;
otherwise, it returns false. This is a binary function object.

logical_or<Type>

Returns true if at least one of its operands evaluates to
true; otherwise, it returns false. This is a binary function
object.

PREDICATES
Predicates are special types of function objects that return Boolean values. There are two
types of predicates: unary and binary. Unary predicates check a specific property for a
single argument; binary predicates check a specific property for a pair—that is, two
arguments. Predicates are typically used to specify searching or sorting criteria. In the
STL, a predicate must always return the same result for the same value. Therefore, the
functions that modify their internal states cannot be considered predicates.

Insert Iterator
Consider the following statements:
int list[5] = {1, 3, 6, 9, 12}; //Line 1
vector<int> vList;
//Line 2

The statement in Line 1 declares and initializes list to be an array of five components.
The statement in Line 2 declares vList to be a vector. Because no size is specified for
vList, no memory space is reserved for the elements of vList. Now suppose that we
want to copy the elements of list into vList. The statement:
copy(list, list + 8, vList.begin());

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1500

| Chapter 21: Standard Template Library (STL)

will not work because no memory space is allocated for the elements of vList, and the copy
function uses the assignment operator to copy the elements from the source to the destination.
One solution to this problem is to use a for loop to step through the elements of list and
use the function push_back of vList to copy the elements of list. However, there is a
better solution, which is convenient and applicable whenever no memory space is allocated at
the destination. The STL provides three iterators, called insert iterators, to insert the
elements at the destination: back_inserter, front_inserter, and inserter.
•

back_inserter: This inserter uses the push_back operation of the

container in place of the assignment operator. The argument to this iterator
is the container itself. For example, for the preceding problem, we can copy
the elements of list into vList by using back_inserter as follows:
copy(list, list + 5, back_inserter(vList));

•

front_inserter: This inserter uses the push_front operation of the

container in place of the assignment operator. The argument to this
iterator is the container itself. Because the vector class does not support
the push_front operation, this iterator cannot be used for the vector
container.
• inserter: This inserter uses the container’s insert operation in place
of the assignment operator. There are two arguments to this iterator: the
first argument is the container itself; the second argument is an iterator to
the container specifying the position at which the insertion should begin.
The program in Example 21-14 illustrates the effect of inserters on a container.
EXAMPLE 21-14
//Inserters
#include
#include
#include
#include
#include

<iostream>
<algorithm>
<iterator>
<vector>
<list>

using namespace std;
int main()
{
int temp[8] = {1, 2, 3, 4, 5, 6, 7, 8};

//Line 1

vector<int> vecList1;
vector<int> vecList2;

//Line 2
//Line 3

ostream_iterator<int> screenOut(cout, " ");

//Line 4

copy(temp, temp + 8, back_inserter(vecList1));

//Line 5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

cout << "Line 6: vecList1: ";
copy(vecList1.begin(), vecList1.end(),
screenOut);
cout << endl;
copy(vecList1.begin(), vecList1.end(),
inserter(vecList2, vecList2.begin()));

1501

//Line 6
//Line 7
//Line 8
//Line 9

cout << "Line 10: vecList2: ";
copy(vecList2.begin(), vecList2.end(),
screenOut);
cout << endl;

//Line 10

list<int> tempList;

//Line 13

copy(vecList2.begin(), vecList2.end(),
front_inserter(tempList));

//Line 14

cout << "Line 15: tempList: ";
copy(tempList.begin(), tempList.end(),
screenOut);
cout << endl;

|

//Line 11
//Line 12

//Line 15
//Line 16
//Line 17

return 0;
}

Sample Run:
Line 6: vecList1: 1 2 3 4 5 6 7 8
Line 10: vecList2: 1 2 3 4 5 6 7 8
Line 15: tempList: 8 7 6 5 4 3 2 1

STL Algorithms
The following sections describe most of the STL algorithms. For each algorithm, we give
the function prototypes, a brief description of what the algorithm does, and a program
showing how to use it. In the function prototypes, the parameter types indicate for which
type of container the algorithm is applicable. For example, if a parameter is of type
randomAccessIterator, then the algorithm is applicable only on random access type
containers, such as vectors. Throughout, we use abbreviations such as outputItr to
mean output iterator, inputItr to mean input iterator, forwardItr to mean forward
iterator, and so on.

The Functions fill and fill_n
The function fill is used to fill a container with elements; the function fill_n is used
to fill in the next n elements. The element that is used as a filling element is passed as a
parameter to these functions. Both of these functions are defined in the header file
algorithm. The prototypes of these functions are:
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1502

| Chapter 21: Standard Template Library (STL)

template <class forwardItr, class Type>
void fill(forwardItr first, forwardItr last, const Type& value);
template <class forwardItr, class size, class Type>
void fill_n(forwardItr first, size n, const Type& value);

The first two parameters of the function fill are forward iterators specifying the starting
and ending positions of the container; the third parameter is the filling element. The first
parameter of the function fill_n is a forward iterator that specifies the starting position
of the container, the second parameter specifies the number of elements to be filled,
and the third parameter specifies the filling element. The program in Example 21-15
illustrates how to use these functions.
EXAMPLE 21-15
//STL functions fill and fill_n
#include
#include
#include
#include

<iostream>
<algorithm>
<iterator>
<vector>

using namespace std;
int main()
{
vector<int> vecList(8);
ostream_iterator<int> screen(cout, " ");

//Line 1
//Line 2

fill(vecList.begin(), vecList.end(), 2);

//Line 3

cout << "Line 4: After filling vecList "
<< "with 2s: ";
copy(vecList.begin(), vecList.end(), screen);
cout << endl;

//Line 4
//Line 5
//Line 6

fill_n(vecList.begin(), 3, 5);

//Line 7

cout << "Line 8: After filling the first three "
<< "elements with 5s: "
<< endl << "
";
copy(vecList.begin(), vecList.end(), screen);
cout << endl;

//Line 8
//Line 9
//Line 10

return 0;
}

Sample Run:
Line 4: After filling vecList with 2s: 2 2 2 2 2 2 2 2
Line 8: After filling first three elements with 5s:
5 5 5 2 2 2 2 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1503

The statements in Lines 1 and 2 declare vecList to be a sequence container of size 8 and
screen to be an ostream iterator initialized to cout with the delimit character space.
The statement in Line 3 uses the function fill to fill vecList with 2; that is, all eight
elements of vecList are set to 2. Recall that vecList.begin() returns an iterator to
the first element of vecList, and vecList.end() returns an iterator to one past the last
element of vecList. The statement in Line 5 outputs the elements of vecList using the
copy function. The statement in Line 7 uses the function fill_n to store 5 in the
elements of vecList. The first parameter of fill_n is vecList.begin(), which
specifies the starting position to begin copying. The second parameter of fill_n is 3,
which specifies the number of elements to be filled. The third parameter, 5, specifies the
filling character. Therefore, 5 is copied into the first three elements of vecList. The
statement in Line 9 outputs the elements of vecList.

The Functions generate and generate_n
The functions generate and generate_n are used to generate elements and fill a
sequence. These functions are defined in the header file algorithm. The prototypes of
these functions are:
template <class forwardItr, class function>
void generate(forwardItr first, forwardItr last, function gen);
template <class forwardItr, class size, class function>
void generate_n(forwardItr first, size n, function gen);

The function generate fills a sequence in the range first...last-1, with successive
calls to the function gen(). The function generate_n fills a sequence in the range
first...first+n-1—that is, starting at position first, with n successive calls to the
function gen(). Note that gen can also be a pointer to a function. Moreover, if gen is a
function, it must be a value-returning function without parameters. The program in
Example 21-16 illustrates how to use these functions.
EXAMPLE 21-16
//STL Functions generate and generate_n
#include
#include
#include
#include

<iostream>
<algorithm>
<iterator>
<vector>

using namespace std;
int nextNum();

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1504

| Chapter 21: Standard Template Library (STL)

int main()
{
vector<int>

vecList(8);

ostream_iterator<int> screen(cout, " ");

//Line 1
//Line 2

generate(vecList.begin(), vecList.end(), nextNum); //Line 3
cout << "Line 4: vecList after filling with "
<< "numbers: ";

//Line 4

copy(vecList.begin(), vecList.end(), screen);
cout << endl;

//Line 5
//Line 6

generate_n(vecList.begin(), 3, nextNum);

//Line 7

cout << "Line 8: vecList after filling the "
<< "first three elements " << endl
<< "
with the next number: ";

//Line 8

copy(vecList.begin(), vecList.end(), screen);
cout << endl;

//Line 9
//Line 10

return 0;
}
int nextNum()
{
static int n = 1;
return n++;
}

Sample Run:
Line 4: vecList after filling with numbers: 1 2 3 4 5 6 7 8
Line 8: vecList after filling the first three elements
with the next number: 9 10 11 4 5 6 7 8

This program contains a value-returning function, nextNum, which contains a static
variable n initialized to 1. A call to this function returns the current value of n and then
increments the value of n. Therefore, the first call of nextNum returns 1, the second call
returns 2, and so on.
The statements in Lines 1 and 2 declare vecList to be a sequence container of size 8 and
screen to be an ostream iterator initialized to cout with the delimit character space.
The statement in Line 3 uses the function generate to fill vecList by successively
calling the function nextNum. Notice that after the statement in Line 3 executes, the value
of the static variable n of nextNum is 9. The statement in Line 5 outputs the elements of
vecList. The statement in Line 7 calls the function generate_n to fill the first three
elements of vecList by calling the function nextNum three times. The starting position is

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1505

vecList.begin(), which is the first element of vecList, and the number of elements
to be filled is 3, given by the second parameter of generate_n (see Line 7). The statement
in Line 9 outputs the elements of vecList.

The Functions find, find_if, find_end, and
find_first_of
The functions find, find_if, find_end, and find_first_of are used to find the
elements in a given range. These functions are defined in the header file algorithm.
The prototypes of the functions find and find_if are:
template <class inputItr, class size, class Type>
inputItr find(inputItr first, inputItr last,
const Type& searchValue);
template <class inputItr, class unaryPredicate>
inputItr find_if(inputItr first, inputItr last, unaryPredicate op);

The function find searches the range of elements first...last-1 for the element
searchValue. If searchValue is found in the range, the function returns the position
in the range where searchValue is found; otherwise, it returns last. The function
find_if searches the range of elements first...last-1 for the element for which
op(rangeElement) is true. If an element satisfying op(rangeElement) is true is
found, it returns the position in the given range where such an element is found;
otherwise, it returns last.
The program in Example 21-17 illustrates how to use the functions find and find_if.
EXAMPLE 21-17
//STL Functions find and find_if
#include
#include
#include
#include
#include

<iostream>
<cctype>
<algorithm>
<iterator>
<vector>

using namespace std;
int main()
{
char cList[10] = {'a', 'i', 'C', 'd', 'e',
'f', 'o', 'H', 'u', 'j'};
vector<char> charList(cList, cList + 10);

//Line 1
//Line 2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1506

| Chapter 21: Standard Template Library (STL)

ostream_iterator<char> screen(cout, " ");

//Line 3

cout << "Line 4: Character list: ";
copy(charList.begin(), charList.end(), screen);
cout << endl;

//Line 4
//Line 5
//Line 6

vector<char>::iterator position;

//Line 7

//find
position = find(charList.begin(),
charList.end(), 'd');

//Line 8

if (position != charList.end())
cout << "Line 10: The element is found at "
<< "position "
<< (position - charList.begin())
<< endl;
else
cout << "Line 12: The element is not in "
<< "the list." << endl;
//find_if
position = find_if(charList.begin(),
charList.end(), isupper);
if (position != charList.end())
cout << "Line 15: The first uppercase "
<< "letter is found at position "
<< (position - charList.begin())
<< endl;
else
cout << "Line 17: The element is not in "
<< "the list." << endl;

//Line 9

//Line 10
//Line 11
//Line 12

//Line 13
//Line 14

//Line 15
//Line 16
//Line 17

return 0;
}

Sample Run:
Line 4: Character list: a i C d e f o H u j
Line 10: The element is found at position 3
Line 15: The first uppercase letter is found at position 2

The statement in Line 1 creates and initializes a character array, cList, of 10 components. The statement in Line 2 creates the vector container charList and initializes it
using the character array cList. The statement in Line 3 creates an ostream iterator.
The statement in Line 5 outputs charList. (In the output, the line marked Line 4
contains the output of Lines 4 through 6 of the program.) The statement in Line 7
declares the iterator position of type vector<char>. The statement in Line 8
searches charList for the first occurrence of 'd' and returns an iterator, which is
stored in position. The statements in Lines 9 through 12 output the result of the
search. Because 'd' is the fourth character in charList, its position is 3. (In the output,
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1507

see the line marked Line 10.) The statement in Line 13 uses the function find_if to
find the first uppercase character in charList. Note that the function isupper from
the header file cctype is passed as the third parameter to the function find_if (see Line
13). The statements in Lines 14 through 17 output the result of the search. The first
uppercase character in charList is 'C', which is the third element of charList; its
position is 2. (In the output, see the line marked Line 15.)
Next, we describe the functions find_end and find_first_of. Both of these functions have two forms. The prototypes of the function find_end are:
template <class forwardItr1, class forwardItr2>
forwardItr1 find_end(forwardItr1 first1, forwardItr1 last1,
forwardItr2 first2, forwardItr2 last2);
template <class forwardItr1, class forwardItr2,
class binaryPredicate>
forwardItr1 find_end(forwardItr1 first1, forwardItr1 last1,
forwardItr2 first2, forwardItr2 last2,
binaryPredicate op);

Both forms of the function find_end search the range first1...last1-1 for the last
occurrence as a subrange of the range first2...last2-1. If the search is successful, the
function returns the position in first1..last1-1 where the match occurs; otherwise, it
returns last1. That is, the function find_end returns the position of the last element in
the range first1...last1-1 where the range first2...last2-1 is a subrange of
first1...last1-1. In the first form, the elements are compared for equality; in the
second form, the comparison op(elementFirstRange, elementSecondRange)
must be true.
The prototypes of the function find_first_of are:
template <class forwardItr1, class forwardItr2>
forwardItr1 find_first_of(forwardItr1 first1, forwardItr1 last1,
forwardItr2 first2, forwardItr2 last2);
template <class forwardItr1, class forwardItr2,
class binaryPredicate>
forwardItr1 find_first_of(forwardItr1 first1, forwardItr1 last1,
forwardItr2 first2, forwardItr2 last2,
binaryPredicate op);

The first form returns the position, within the range first1...last1-1, of the first
element of first2...last2-1 that is also in the range first1...last1-1. The
second form returns the position, within the range first1...last1-1, of the first
element of first2...last2-1 for which op(elemRange1, elemRange2) is true.
If no match is found, both forms return last1-1.
The program in Example 21-18 illustrates how to use the functions find_end and
find_first_of.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1508

| Chapter 21: Standard Template Library (STL)

EXAMPLE 21-18
//STL Functions find_end and find_first_of
#include <iostream>
#include <algorithm>
#include <iterator>
using namespace std;
int main()
{
int list1[10] = {12, 34, 56, 21, 34,
78, 34, 56, 12, 25};
int list2[2] = {34, 56};
int list3[3] = {56, 21, 35};
int list4[5] = {33, 48, 21, 34, 73};

//Line
//Line
//Line
//Line

1
2
3
4

int* location;

//Line 5

ostream_iterator<int> screenOut(cout, " ");

//Line 6

cout << "Line 7: list1: ";
copy(list1, list1 + 10, screenOut);
cout << endl;

//Line 7
//Line 8
//Line 9

cout << "Line 10: list2: ";
copy(list2, list2 + 2, screenOut);
cout << endl;

//Line 10
//Line 11
//Line 12

//find_end
location = find_end(list1, list1+10,
list2, list2 + 2);

//Line 13

if (location != list1
cout << "Line 15:
<< "The last
<< "list2 in
<< (location
else
cout << "Line 17:
<< endl;

+ 10)
list2 is found in list 1. "
occurrence of \n
"
list 1 is at position "
- list1) << endl;

//Line 14

//Line 15
//Line 16

list2 is not in list1."
//Line 17

cout << "Line 18: list3: ";
copy(list3, list3 + 3, screenOut);
cout << endl;

//Line 18
//Line 19
//Line 20

location = find_end(list1, list1 + 10,
list3, list3 + 3);

//Line 21

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

if (location != list1 + 10)
cout << "Line 23: list3 is found in list 1. "
<< "The last occurrence of list3 in "
<< endl << "list 1 is at position "
<< (location - list1) << endl;
else
cout << "Line 25: list3 is not in list1."
<< endl;

|

//Line 22

//Line 23
//Line 24
//Line 25

//find_first_of
cout << "Line 26: list4: ";
copy(list4, list4 + 5, screenOut);
cout << endl;

//Line 26
//Line 27
//Line 28

location = find_first_of(list1, list1 + 10,
list4, list4 + 5);

//Line 29

if (location != list1 + 10)
cout << "Line 31: The first element "
<< *location << " of list4 is found in "
<< endl << "
list 1 at position "
<< (location - list1) << endl;
else
cout << "Line 33: No element of list4 is "
<< "in list1." << endl;

1509

//Line 30

//Line 31
//Line 32
//Line 33

return 0;
}

Sample Run:
Line 7: list1: 12 34 56 21 34 78 34 56 12 25
Line 10: list2: 34 56
Line 15: list2 is found in list 1. The last occurrence of
list2 in list 1 is at position 6
Line 18: list3: 56 21 35
Line 25: list3 is not in list1.
Line 26: list4: 33 48 21 34 73
Line 31: The first element 34 of list4 is found in
list 1 at position 1

The statements in Lines 1 through 4 create and initialize the int arrays list1, list2,
list3, and list4. The statements in Lines 5 and 6 declare an int pointer and an ostream
iterator, respectively. The statements in Lines 8 and 11 output the values of list1 and
list2. (In the output, see the lines marked Line 7 and Line 10.) The statement in Line 13
uses the function find_end to find the last occurrence of list2, as a subsequence, within
list1. The last occurrence of list2 in list1 starts at position 6 (that is, at the seventh
element). The statements in Lines 14 through 17 output the result of the search. (In the
output, see Line 15.) The statement in Line 19 outputs list3. The statement in Line 21
uses the function find_end to find the last occurrence of list3, as a subsequence, within
list1. Because list3 does not appear as a subsequence in list1, it is an unsuccessful
search.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1510

| Chapter 21: Standard Template Library (STL)

The statement in Line 27 outputs list4. The statement in Line 29 uses the function
find_first_of to find the position in list1 where the first element of list4 is also
an element of list1. The first element of list4, which is also an element of list1, is
33. Its position in list1 is 1, the second element of list1. The statements in Lines 30
through 33 output the result of the search. (In the output, see Line 31.)

The Functions remove, remove_if, remove_copy,
and remove_copy_if
The function remove is used to remove certain elements from a sequence, and the function
remove_if is used to remove elements from a sequence by using some criteria. The
function remove_copy copies the elements of a sequence into another sequence by
excluding certain elements of the first sequence. Similarly, the function remove_copy_if
copies the elements of a sequence into another sequence by excluding certain elements,
using some criteria, of the first sequence. These functions are defined in the header file
algorithm.
The prototypes of the functions remove and remove_if are:
template <class forwardItr, class Type>
forwardItr remove(forwardItr first, forwardItr last,
const Type& value);
template <class forwardItr, class unaryPredicate>
forwardItr remove_if(forwardItr first, forwardItr last,
unaryPredicate op);

The function remove removes each occurrence of a given element in the range
first. . .last-1. The element to be removed is passed as the third parameter to
this function. The function remove_if removes those elements, in the range
first. . .last-1, for which the op(element) is true. Both of these functions
return forwardItr, which points to the position after the last element of the new
range of elements. These functions do not modify the size of the container; in fact, the
elements are moved to the beginning of the container. For example, if the sequence is
{3, 7, 2, 5, 7, 9} and the element to be removed is 7, then after removing 7, the
resulting sequence is {3, 2, 5, 9, 9, 9}. The function returns a pointer to element 9
(which is after 5).
The program in Example 21-18 further illustrates the importance of this returned
forwardItr. (See Lines 8, 10, 12, and 14.)
Let us now look at the prototypes of the functions remove_copy and remove_copy_if.
template <class inputItr, class outputItr, class Type>
outputItr remove_copy(inputItr first1, inputItr last1,
outputItr destFirst, const Type& value);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1511

template <class inputItr, class outputItr, class unaryPredicate>
outputItr remove_copy_if(inputItr first1, inputItr last1,
outputItr destFirst,
unaryPredicate op);

The function remove_copy copies all of the elements in the range first1...last1-1,
except the elements specified by value, into the sequence starting at the position
destFirst. Similarly, the function remove_copy_if copies all of the elements in
the range first1...last1-1, except the elements for which op(element) is true,
into the sequence starting at the position destFirst. Both of these functions return an
outputItr, which points to the position after the last element copied.
The program in Example 21-19 shows how to use the functions remove, remove_if,
remove_copy, and remove_copy_if.
EXAMPLE 21-19
//STL Functions remove, remove_if, remove_copy, and
//
remove_copy_if
#include
#include
#include
#include
#include

2
1

<iostream>
<cctype>
<algorithm>
<iterator>
<vector>

using namespace std;
bool lessThanEqualTo50(int num);
int main()
{
char cList[10] = {'A', 'a', 'A', 'B', 'A',
'c', 'D', 'e', 'F', 'A'};

//Line 1

vector<char> charList(cList, cList + 10);
vector<char>::iterator lastElem, newLastElem;

//Line 2
//Line 3

ostream_iterator<char> screen(cout, " ");

//Line 4

cout << "Line 6: Character list: ";
copy(charList.begin(), charList.end(), screen);
cout << endl;

//Line 5
//Line 6
//Line 7

//remove
lastElem = remove(charList.begin(),
charList.end(), 'A');

//Line 8

cout << "Line 9: Character list after "
<< "removing A: ";

//Line 9

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1512

| Chapter 21: Standard Template Library (STL)

copy(charList.begin(), lastElem, screen);
cout << endl;

//Line 10
//Line 11

//remove_if
newLastElem = remove_if(charList.begin(),
lastElem, isupper);
cout << "Line 13: Character list after "
<< "removing the uppercase " << endl
<< "
letters: ";
copy(charList.begin(), newLastElem, screen);
cout << endl;

//Line 13
//Line 14
//Line 15

int list[10] = {12, 34, 56, 21, 34,
78, 34, 55, 12, 25};

//Line 16

vector<int> intList(list, list + 10);
vector<int>::iterator endElement;

//Line 17
//Line 18

ostream_iterator<int> screenOut(cout, " ");

//Line 19

cout << "Line 20: intList: ";
copy(intList.begin(), intList.end(), screenOut);
cout << endl;

//Line 20
//Line 21
//Line 22

vector<int> temp1(10);

//Line 23

//remove_copy
endElement = remove_copy(intList.begin(),
intList.end(),
temp1.begin(), 34);

//Line 24

cout << "Line 25: temp1 list after copying "
<< "all the elements of intList "
<< endl << "
except 34: ";
copy(temp1.begin(), endElement, screenOut);
cout << endl;

//Line 25
//Line 26
//Line 27

vector<int> temp2(10, 0);

//Line 28

//remove_copy_if
remove_copy_if(intList.begin(), intList.end(),
temp2.begin(), lessThanEqualTo50);

//Line 29

cout << "Line 30: temp2 after copying all the "
<< "elements of intList except " << endl
<< "
numbers less than 50: ";
copy(temp2.begin(), temp2.end(), screenOut);
cout << endl;

//Line 30
//Line 31
//Line 32

//Line 12

return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1513

bool lessThanEqualTo50(int num)
{
return (num <= 50);
}

Sample Run:
Line 6: Character list: A a A B A c D e F A
Line 9: Character list after removing A: a B c D e F
Line 13: Character list after removing the uppercase
letters: a c e
Line 20: intList: 12 34 56 21 34 78 34 55 12 25
Line 25: temp1 list after copying all the elements of intList
except 34: 12 56 21 78 55 12 25
Line 30: temp2 after copying all the elements of intList except
numbers less than 50: 56 78 55 0 0 0 0 0 0 0

The statement in Line 2 creates a vector list, charList, of type char and initializes
charList using the array cList created in Line 1. The statement in Line 3 declares two
vector iterators: lastElem and newLastElem. The statement in Line 4 declares an
ostream iterator, screen. The statement in Line 6 outputs the value of charList.
The statement in Line 8 uses the function remove to remove all occurrences of 'A' from
charList. The function returns a pointer to one past the last element of the new range,
which is stored in lastElem. The statement in Line 10 outputs the elements in the
new range. (Note that the statement in Line 10 outputs the elements in the range
charList.begin(). . .lastElem-1.) The statement in Line 12 uses the function
remove_if to remove the uppercase letters from the list charList and stores the
pointer returned by the function remove_if in newLastElem. The statement in
Line 14 outputs the elements in the new range.
The statement in Line 17 creates a vector, intList, of type int and initializes intList
using the array list, created in Line 16. The statement in Line 21 outputs the elements
of intList. The statement in Line 24 copies all of the elements, except the occurrences of
34, of intList into temp1. The list intList is not modified. The statement in Line
26 outputs the elements of temp1. The statement in Line 28 creates a vector, temp2, of
type int of 10 components and initializes all of the elements of temp2 to 0. The statement
in Line 29 uses the function remove_copy_if to copy those elements of intList that
are greater than 50. The statement in Line 31 outputs the elements of temp2.

The Functions replace, replace_if, replace_copy,
and replace_copy_if
The function replace is used to replace all occurrences, within a given range, of a given
element with a new value. The function replace_if is used to replace the values of the
elements, within a given range, satisfying certain criteria with a new value. The prototypes of these functions are:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1514

| Chapter 21: Standard Template Library (STL)

template <class forwardItr, class Type >
void replace(forwardItr first, forwardItr last,
const Type& oldValue, const Type& newValue);
template <class forwardItr, class unaryPredicate, class Type>
void replace_if(forwardItr first, forwardItr last,
unaryPredicate op, const Type& newValue);

The function replace replaces all of the elements in the range first...last-1 whose
values are equal to oldValue with the value specified by newValue. The function
replace_if replaces all of the elements in the range first...last-1, for which
op(element) is true, with the value specified by newValue.
The function replace_copy is a combination of replace and copy. Similarly, the
function replace_copy_if is a combination of replace_if and copy. Let us first
look at the prototypes of the functions replace_copy and replace_copy_if.
template <class forwardItr, class outputItr, class Type>
outputItr replace_copy(forwardItr first, forwardItr last,
outputItr destFirst,
const Type& oldValue,
const Type& newValue);
template <class forwardItr, class outputItr,
class unaryPredicate, class Type>
outputItr replace_copy_if(forwardItr first, forwardItr last,
outputItr destFirst,
unaryPredicate op,
const Type& newValue);

The function replace_copy copies all of the elements in the range first...last-1
into the container starting at destFirst. If the value of an element in this range is
equal to oldValue, it is replaced by newValue. The function replace_copy_if
copies all of the elements in the range first...last-1 into the container starting at
destFirst. If, for any element in this range, op(element) is true, at the destination,
its value is replaced by newValue. Both of these functions return an outputItr
(a pointer) positioned one past the last element copied at the destination.
The program in Example 21-20 shows how to use the functions replace, replace_if,
replace_copy, and replace_copy_if.
EXAMPLE 21-20
//STL Functions replace, replace_if, replace_copy, and
//
replace_copy_if
#include
#include
#include
#include
#include

<iostream>
<cctype>
<algorithm>
<iterator>
<vector>

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1515

using namespace std;
bool lessThanEqualTo50(int num);
int main()
{
char cList[10] = {'A', 'a', 'A', 'B', 'A',
'c', 'D', 'e', 'F', 'A'};
vector<char>

charList(cList, cList + 10);

//Line 1
//Line 2

ostream_iterator<char> screen(cout, " ");

//Line 3

cout << "Line 4: Character list: ";
copy(charList.begin(), charList.end(), screen);
cout << endl;

//Line 4
//Line 5
//Line 6

//replace
replace(charList.begin(), charList.end(),
'A', 'Z');

//Line 7

cout << "Line 8: Character list after replacing "
<< "A with Z: " << endl
<< "
";
//Line 8
copy(charList.begin(), charList.end(), screen);
//Line 9
cout << endl;
//Line 10
//replace_if
replace_if(charList.begin(), charList.end(),
isupper, '*');
cout << "Line 12: Character list after "
<< "replacing the uppercase " << endl
<< "
letters with *: ";
copy(charList.begin(), charList.end(), screen);
cout << endl;

//Line 12
//Line 13
//Line 14

int list[10] = {12, 34, 56, 21, 34,
78, 34, 55, 12, 25};

//Line 15

vector<int>

//Line 16

intList(list, list + 10);

//Line 11

ostream_iterator<int> screenOut(cout, " ");

//Line 17

cout << "Line 18: intList: ";
copy(intList.begin(), intList.end(), screenOut);
cout << endl;

//Line 18
//Line 19
//Line 20

vector<int> temp1(10);

//Line 21

//replace_copy
replace_copy(intList.begin(), intList.end(),
temp1.begin(), 34, 0);

//Line 22

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1516

| Chapter 21: Standard Template Library (STL)

cout << "Line 23: temp1 list after copying "
<< "intList and " << endl
<< "
replacing 34 with 0: ";
copy(temp1.begin(), temp1.end(), screenOut);
cout << endl;

//Line 23
//Line 24
//Line 25

vector<int> temp2(10);

//Line 26

//replace_copy_if
replace_copy_if(intList.begin(), intList.end(),
temp2.begin(), lessThanEqualTo50, 50);

//Line 27

cout << "Line 28: temp2 after copying intList "
<< "and replacing any " << endl
<< "
numbers less than 50 "
<< "with 50: " << endl << "
";
copy(temp2.begin(), temp2.end(), screenOut);
cout << endl;

//Line 28
//Line 29
//Line 30

return 0;
}
bool lessThanEqualTo50(int num)
{
return (num <= 50);
}

Sample Run:
Line 4: Character list: A a A B A c D e F A
Line 8: Character list after replacing A with Z:
Z a Z B Z c D e F Z
Line 12: Character list after replacing the uppercase
letters with *: * a * * * c * e * *
Line 18: intList: 12 34 56 21 34 78 34 55 12 25
Line 23: temp1 list after copying intList and
replacing 34 with 0: 12 0 56 21 0 78 0 55 12 25
Line 28: temp2 after copying intList and replacing any
numbers less than 50 with 50:
50 50 56 50 50 78 50 55 50 50

The statement in Line 2 creates a vector list, charList, of type char and initializes
charList using the array cList created in Line 1. The statement in Line 3 declares an
ostream iterator, screen. The statement in Line 5 outputs the value of charList. The
statement in Line 7 uses the function replace to replace all occurrences of 'A' with 'Z'
in charList. The statement in Line 9 outputs the elements of charList. In the output,
the line marked Line 8 contains the outputs of Lines 8 through 10. The statement in Line
11 uses the function replace_if to replace the uppercase letters with ' *' in the list
charList. The statement in Line 13 outputs the elements of charList. In the output,
the line marked Line 12 contains the output of Lines 12 through 14.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1517

The statement in Line 16 creates a vector, intList, of type int and initializes intList
using the array list, created in Line 15. The statement in Line 19 outputs the elements
of intList. The statement in Line 21 declares a vector temp1 of type int. The
statement in Line 22 copies all of the elements of intList and replaces 34 with 0. The
list intList is not modified. The statement in Line 24 outputs the elements of temp1.
The statement in Line 26 creates a vector, temp2, of type int, of 10 components. The
statement in Line 27 uses the function replace_copy_if to copy the elements of
intList and replaces all of the elements less than 50 with 50. The statement in Line
29 outputs the elements of temp2. In the output, the line marked Line 28 contains the
output of Lines 28 through 30.

The Functions swap, iter_swap, and swap_ranges
The functions swap, iter_swap, and swap_ranges are used to swap elements. These
functions are defined in the header file algorithm. The prototypes of these functions
are:
template <class Type>
void swap(Type& object1, Type& object2);
template <class forwardItr1, class forwardItr2>
void iter_swap(forwardItr1 first, forwardItr2 second);
template <class forwardItr1, class forwardItr2>
forwardItr2 swap_ranges(forwardItr1 first1, forwardItr1 last1,
forwardItr2 first2);

The function swap swaps the values of object1 and object2. The function
iter_swap swaps the values to which the iterators first and second point.
The function swap_ranges swaps the elements of the range first1...last1-1 with
the consecutive elements starting at position first2. It returns the iterator of the second
range positioned one past the last element swapped. The program in Example 21-21
illustrates how to use these functions.
EXAMPLE 21-21
//STL functions swap, iter_swap, and swap_ranges
#include
#include
#include
#include

<iostream>
<algorithm>
<vector>
<iterator>

using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1518

| Chapter 21: Standard Template Library (STL)

int main()
{
char cList[10] = {'A', 'B', 'C', 'D', 'F',
'G', 'H', 'I', 'J', 'K'};

//Line 1

vector<char> charList(cList, cList + 10);
vector<char>::iterator charItr;

//Line 2
//Line 3

ostream_iterator<char> screen(cout, " ");

//Line 4

cout << "Line 5: Character list: ";
copy(charList.begin(), charList.end(), screen);
cout << endl;

//Line 5
//Line 6
//Line 7

swap(charList[0], charList[1]);

//Line 8

cout << "Line 9: Character list after swapping "
<< "the first and second " << endl
<< "
elements: ";
copy(charList.begin(), charList.end(), screen);
cout << endl;

//Line 9
//Line 10
//Line 11

iter_swap(charList.begin() + 2,
charList.begin() + 3);

//Line 12

cout << "Line 13: Character list after swapping "
<< "the third and fourth " << endl
<< "
elements: ";

//Line 13

copy(charList.begin(), charList.end(), screen);
cout << endl;

//Line 14
//Line 15

charItr = charList.begin() + 4;
iter_swap(charItr, charItr + 1);

//Line 16
//Line 17

cout << "Line 18: Character list after swapping "
<< "the fifth and sixth " << endl
<< "
elements: ";
copy(charList.begin(), charList.end(), screen);
cout << endl;

//Line 18
//Line 19
//Line 20

int list[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

//Line 21

vector<int> intList(list, list + 10);

//Line 22

ostream_iterator<int> screenOut(cout, " ");

//Line 23

cout << "Line 24: intList: ";
copy(intList.begin(), intList.end(), screenOut);
cout << endl;

//Line 24
//Line 25
//Line 26

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

//swap_ranges
swap_ranges(intList.begin(), intList.begin() + 4,
intList.begin() + 5);

|

1519

//Line 27

cout << "Line 28: intList after swapping the first
<< "four elements " << endl
<< "
with four elements starting at "
<< "the sixth element " << endl
<< "
of intList: ";
copy(intList.begin(), intList.end(), screenOut);
cout << endl;

"

swap_ranges(list, list + 10, intList.begin());

//Line 31

cout << "Line 32: list and intList after "
<< "swapping their elements " << endl;
cout << "Line 33: list: ";
copy(list, list+10, screenOut);
cout << endl;
cout << "List 36: intList: ";
copy(intList.begin(), intList.end(), screenOut);
cout << endl;

//Line
//Line
//Line
//Line
//Line
//Line
//Line

//Line 28
//Line 29
//Line 30

32
33
34
35
36
37
38

return 0;
}

Sample Run:
Line 5: Character list: A B C D F G H I J K
Line 9: Character list after swapping the first and second
elements: B A C D F G H I J K
Line 13: Character list after swapping the third and fourth
elements: B A D C F G H I J K
Line 18: Character list after swapping the fifth and sixth
elements: B A D C G F H I J K
Line 24: intList: 1 2 3 4 5 6 7 8 9 10
Line 28: intList after swapping the first four elements
with four elements starting at the sixth element
of intList: 6 7 8 9 5 1 2 3 4 10
Line 32: list and intList after swapping their elements
Line 33: list: 6 7 8 9 5 1 2 3 4 10
List 36: intList: 1 2 3 4 5 6 7 8 9 10

The statement in Line 2 creates the vector charList and initializes it using the array
cList declared in Line 1. The statement in Line 6 outputs the values of charList. The
statement in Line 8 swaps the first and second elements of charList. The statement
in Line 12, using the function iter_swap, swaps the third and fourth elements of
charList. (Recall that the position of the first element in charList is 0.) After the
statement in Line 16 executes, charItr points to the fifth element of charList. The
statement in Line 17 uses the iterator charItr to swap the fifth and sixth elements of
charList. The statement in Line 19 outputs the values of the elements of charList.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1520

| Chapter 21: Standard Template Library (STL)

(In the output, the line marked Line 18 contains the output of Lines 18 through 20 of the
program.)
The statement in Line 22 creates the vector intList and initializes it using the array
declared in Line 21. The statement in Line 25 outputs the values of the elements of
intList. The statement in Line 27 uses the function swap_ranges to swap the first
four elements of intList with the four elements of intList, starting at the sixth
element of intList. The statement in Line 29 outputs the elements of intList. (In the
output, the line marked Line 28 contains the output of Lines 28 through 30 of the
program.)
The statement in Line 31 swaps the elements of the array list with the elements of the
vector intList. The statement in Line 34 outputs the elements of the array list, and
the statement in Line 37 outputs intList.

The Functions search, search_n, sort,
and binary_search
The functions search, search_n, sort, and binary_search are used to search and
sort elements. These functions are defined in the header file algorithm.
Watch
the Video

The prototypes of the function search are:
template <class forwardItr1, class forwardItr2>
forwardItr1 search(forwardItr1 first1, forwardItr1 last1,
forwardItr2 first2, forwardItr2 last2);
template <class forwardItr1, class forwardItr2,
class binaryPredicate>
forwardItr1 search(forwardItr1 first1, forwardItr1 last1,
forwardItr2 first2, forwardItr2 last2,
binaryPredicate op);

Given two ranges of elements, first1...last1-1 and first2...last2-1, the
function search searches the first element in the range first1...last1-1 where the
range first2...last2-1 occurs as a subrange of first1...last1-1. The first form
makes the equality comparison between the elements of the two ranges. For the second
form, the comparison op(elemFirstRange, elemSecondRange) must be true. If
a match is found, the function returns the position in the range first1...last1-1
where the match occurs; otherwise, the function returns last1.
The prototypes of the function search_n are:
template <class forwardItr, class size, class Type>
forwardItr search_n(forwardItr first, forwardItr last,
size count, const Type& value);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1521

template <class forwardItr, class size, class Type,
class binaryPredicate>
forwardItr search_n(forwardItr first, forwardItr last,
size count, const Type& value,
binaryPredicate op);

Given a range of elements first...last-1, the function search_n searches count
consecutive occurrences of value. The first form returns the position in the range
first...last-1 where a subsequence of count consecutive elements has values equal
to value. The second form returns the position in the range first...last-1 where a
subsequence of count consecutive elements exists for which op(elemRange, value)
is true. If no match is found, both forms return last.
The prototypes of the function sort are:
template <class randomAccessItr>
void sort(randomAccessItr first, randomAccessItr last);
template <class randomAccessItr, class compare>
void sort(randomAccessItr first, randomAccessItr last,
compare op);

The first form of the sort function reorders the elements in the range first...last-1
in ascending order. The second form reorders the elements according to the criteria
specified by op.
The prototypes of the function binary_search are:
template <class forwardItr, class Type>
bool binary_search(forwardItr first, forwardItr last,
const Type& searchValue);
template <class forwardItr, class Type, class compare>
bool binary_search(forwardItr first, forwardItr last,
const Type& searchValue, compare op);

The first form returns true if searchValue is found in the range first...last-1,
and false otherwise. The second form uses a function object, op, that specifies the
search criteria.
Example 21-22 illustrates how to use these searching and sorting functions.
EXAMPLE 21-22
//STL Functions search, search_n, sort, and binary_search
#include
#include
#include
#include

<iostream>
<algorithm>
<iterator>
<vector>

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1522

| Chapter 21: Standard Template Library (STL)

using namespace std;
int main()
{
int intList[15] = {12, 34, 56, 34, 34,
78, 38, 43, 12, 25,
34, 56, 62, 5, 49};

//Line 1

vector<int> vecList(intList, intList + 15);
int list[2] = {34, 56};

//Line 2
//Line 3

vector<int>::iterator location;

//Line 4

ostream_iterator<int> screenOut(cout, " ");

//Line 5

cout << "Line 6: vecList: ";
copy(vecList.begin(), vecList.end(), screenOut);
cout << endl;

//Line 6
//Line 7
//Line 8

cout << "Line 9: list: ";
copy(list, list + 2, screenOut);
cout << endl;

//Line 9
//Line 10
//Line 11

//search
location = search(vecList.begin(), vecList.end(),
list, list + 2);
//Line 12
if (location != vecList.end())
cout << "Line 14: list found in vecList. "
<< "The first occurrence of " << endl
<< "
list in vecList is at "
<< "the position "
<< (location - vecList.begin()) << endl;
else
cout << "Line 16: list is not in vecList."
<< endl;
//search_n
location = search_n(vecList.begin(),
vecList.end(), 2, 34);
if (location != vecList.end())
cout << "Line 19: two consecutive "
<< "occurrences of 34 found in " << endl
<< "
vecList at the position "
<< (location - vecList.begin()) << endl;
else
cout << "Line 21: vecList does not contain "
<< "two consecutive occurrences of 34."
<< endl;
//sort
sort(vecList.begin(), vecList.end());

//Line 13

//Line 14
//Line 15
//Line 16

//Line 17
//Line 18

//Line 19
//Line 20
//Line 21
//Line 22

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

cout << "Line 23: vecList after sorting:"
<< endl << "
";
copy(vecList.begin(), vecList.end(), screenOut);
cout << endl;

//Line 23
//Line 24
//Line 25

//binary_search
bool found;

//Line 26

found = binary_search(vecList.begin(),
vecList.end(), 78);

//Line 27

if (found)
cout <<
<<
else
cout <<
<<

|

1523

//Line 28
"Line 29: 78 found in vecList."
endl;
"Line 31: 78 not in vecList."
endl;

//Line 29
//Line 30
//Line 31

return 0;
}

Sample Run:
Line 6: vecList: 12 34 56 34 34 78 38 43 12 25 34 56 62 5 49
Line 9: list: 34 56
Line 14: list found in vecList. The first occurrence of
list in vecList is at the position 1
Line 19: two consecutive occurrences of 34 found in
vecList at the position 3
Line 23: vecList after sorting:
5 12 12 25 34 34 34 34 38 43 49 56 56 62 78
Line 29: 78 found in vecList.

The statement in Line 2 creates a vector, vecList, and initializes it using the array
intList created in Line 1. The statement in Line 3 creates an array, list, of two
components and initializes list. The statement in Line 7 outputs vecList. The
statement in Line 12 uses the function search and searches vecList to find the
position (of the first occurrence) in vecList where list occurs as a subsequence.
The statements in Lines 13 through 16 output the result of the search; see the line marked
Line 14 in the output.
The statement in Line 17 uses the function search_n to find the position in vecList
where two consecutive instances of 34 occur. The statements in Lines 18 through 21
output the result of the search.
The statement in Line 22 uses the function sort to sort vecList. The statement in Line
24 outputs vecList. In the output, the line marked Line 23 contains the output of the
statements in Lines 23 through 25.
The statement in Line 27 uses the function binary_search to search vecList. The
statements in Lines 28 through 31 output the search result.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1524

| Chapter 21: Standard Template Library (STL)

The Functions adjacent_find, merge,
and inplace_merge
The algorithm adjacent_find is used to find the first occurrence of consecutive
elements that meet certain criteria. The prototypes of the functions implementing this
algorithm are:
template <class forwardItr>
forwardItr adjacent_find(forwardItr first, forwardItr last);
template <class forwardItr, class binaryPredicate>
forwardItr adjacent_find(forwardItr first, forwardItr last,
binaryPredicate op);

The first form of adjacent_find uses the equality criteria; that is, it looks for the first
consecutive occurrences of the same element. In the second form, the algorithm returns
an iterator to the element in the range first...last-1 for which op(elem,
nextElem) is true, in which elem is an element in the range first...last-1
and nextElem is an element in this range next to elem. If no matching elements are
found, both algorithms return last.
The algorithm merge merges the sorted lists. The result is a sorted list. Both lists must be
sorted according to the same criteria. For example, both lists should be in either ascending
or descending order. The prototypes of the functions to implement the merge algorithms
are:
template <class inputItr1, class inputItr2, class outputItr>
outputItr merge(inputItr1 first1, inputItr1 last1,
inputItr2 first2, inputItr2 last2,
outputItr destFirst);
template <class inputItr1, class inputItr2,
class outputItr, class binaryPredicate>
outputItr merge(inputItr1 first1, inputItr1 last1,
inputItr2 first2, inputItr2 last2,
outputItr destFirst, binaryPredicate op);

Both forms of the algorithm merge merge the elements of the sorted ranges
first1...last1-1 and first2...last2-1. The destination range, beginning with
the iterator destFirst, contains the merged elements. The first form uses the less-than
operator, <, for ordering the elements. The second form uses the binary predicate op to
order the elements; that is, op(elemRange1, elemRange2) must be true. Both forms
return the position after the last copied element in the destination range. Moreover, the
source ranges are not modified, and the destination range should not overlap with the
source ranges.
The algorithm inplace_merge is used to combine the sorted consecutive sequences.
The prototypes of the functions implementing this algorithm are:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1525

template <class biDirectionalItr>
void inplace_merge(biDirectionalItr first,
biDirectionalItr middle,
biDirectionalItr last);
template <class biDirectionalItr, class binaryPredicate>
void inplace_merge(biDirectionalItr first,
biDirectionalItr middle,
biDirectionalItr last,
binaryPredicate op);

Both forms merge the sorted consecutive sequences first...middle-1 and
middle...last-1. The merged elements overwrite the two ranges beginning at
first. The first form uses the less-than criterion to merge the two consecutive
sequences. The second form uses the binary predicate op to merge the sequences; that
is, for the elements of the two sequences, op(elemSeq1, elemSeq2) must be true.
For example, suppose that:
vecList = {1, 3, 5, 7, 9, 2, 4, 6, 8}

in which vecList is a vector container. Further suppose that vecItr is a vector iterator
pointing to element 2. Then, after the execution of the statement:
inplace_merge(vecList.begin(), vecItr, vecList.end());

the elements in vecList are in the following order:
vecList = {1, 2, 3, 4, 5, 6, 7, 8, 9}

The program in Example 21-23 illustrates how these algorithms work.
EXAMPLE 21-23
//STL Functions adjacent_find, merge, and inplace_merge
#include
#include
#include
#include
#include
#include

<iostream>
<functional>
<algorithm>
<iterator>
<vector>
<list>

using namespace std;
int main()
{
int list1[10] = {1, 3, 5, 7, 9, 0, 2, 4, 6, 8};
int list2[10] = {0, 1, 1, 2, 3, 4, 4, 5, 6, 6};
int list3[5] = {0, 2, 4, 6, 8};
int list4[5] = {1, 3, 5, 7, 9};

//Line 1
//Line 2
//Line 3
//Line 4

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1526

| Chapter 21: Standard Template Library (STL)

list<int> intList(list2, list2 + 10);
list<int>::iterator listItr;

//Line 5
//Line 6

vector<int> vecList(list1, list1 + 10);
vector<int>::iterator
intItr;

//Line 7
//Line 8

ostream_iterator<int> screen(cout, " ");

//Line 9

cout << "Line 10: intList : ";
copy(intList.begin(), intList.end(), screen);
cout << endl;

//Line 10
//Line 11
//Line 12

//adjacent_find
listItr = adjacent_find(intList.begin(),
intList.end());

//Line 13

if (listItr
cout <<
<<
<<
<<
<<
else
cout <<
<<

!= intList.end())
"Line 15: Adjacent equal "
"elements are found " << endl
"
The first set of "
"adjacent equal elements: "
*listItr << endl;
"Line 17: No adjacent equal "
"element found" << endl;

//Line 14

//Line 15
//Line 16
//Line 17

intList.clear();

//Line 18

//merge
merge(list3, list3 + 5, list4, list4 + 5,
back_inserter(intList));

//Line 19

cout << "Line 20: intList after merging list3 "
<< "and " << "list4:\n"
<< "
";
copy(intList.begin(), intList.end(), screen);
cout << endl;

//Line 20
//Line 21
//Line 22

//adjacent_find; second form
intItr = adjacent_find(vecList.begin(),
vecList.end(),
greater<int>());

//Line 23

cout << "Line 24: Last element of first "
<< "sorted sublist: " << *intItr << endl;
intItr++;
cout << "Line 26: First element of second "
<< "sorted sublist: " << *intItr << endl;
cout << "Line 27: vecList before "
<< "inplace_merge: ";
copy(vecList.begin(), vecList.end(), screen);
cout << endl;

//Line 24
//Line 25
//List 26
//Line 27
//Line 28
//Line 29

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

//inplace_merge
inplace_merge(vecList.begin(), intItr,
vecList.end());

|

1527

//Line 30

cout << "Line 31: vecList after inplace_merge: "; //Line 31
copy(vecList.begin(), vecList.end(), screen);
//Line 32
cout << endl;
//Line 33
return 0;
}

Sample Run:
Line 10: intList : 0 1 1 2 3 4 4 5 6 6
Line 15: Adjacent equal elements are found
The first set of adjacent equal elements: 1
Line 20: intList after merging list3 and list4:
0 1 2 3 4 5 6 7 8 9
Line 24: Last element of first sorted sublist: 9
Line 26: First element of second sorted sublist: 0
Line 27: vecList before inplace_merge: 1 3 5 7 9 0 2 4 6 8
Line 31: vecList after inplace_merge: 0 1 2 3 4 5 6 7 8 9

The statement in Line 5 creates an intList of type list<int> and initializes intList
using list2. Thus, intList is a linked list. The statement in Line 7 creates the vector
vecList of type int and initializes it using list1. The statement in Line 11 outputs
intList. The statement in Line 13 uses the function adjacent_find to find the
position of the (first set of) consecutive identical elements. The function returns a pointer
to the first set of consecutive elements, which is stored in listItr. The statements in
Lines 14 through 17 output those consecutive identical elements, if any are found. Notice
that the statement in Line 15 outputs *listItr—the contents of the memory space to
which listItr is pointing.
The statement in Line 18 clears intList by deleting all of the elements of intList.
The statement in Line 19 uses the function merge to merge list3 and list4. The
third parameter of the function merge, in Line 19, is a call to back_inserter, which
places the merged list into intList. After the statement in Line 19 executes, intList
contains the merged list. The statement in Line 21 outputs intList. In the output,
see the line marked Line 20, which contains the output of the statements in Lines 20
through 22.
Notice that vecList is {1, 3, 5, 7, 9, 0, 2, 4, 6, 8}, which contains two sorted
subsequences. The statement in Line 23 uses the second form of the function
adjacent_find to find the starting position of the second subsequence. Notice that
the third parameter of the function adjacent_find is the binary predicate greater,
which returns the position in vecList where the first element is greater than the second
element. The returned position is stored in the iterator intItr, which now points to
element 9. The statement in Line 25 advances intItr to point to element 0, which is
the first element of the second subsequence. The statement in Line 30 uses the function

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1528

| Chapter 21: Standard Template Library (STL)

inplace_merge and the iterator intItr to merge the sorted subsequences of
vecList. Notice that vecList contains the resulting sequence. In the output, the line

marked Line 27 contains the output of the statements in Lines 27 through 29; the line
marked Line 31 contains the output of the statements in Lines 31 through 33.

The Functions reverse, reverse_copy, rotate,
and rotate_copy
The algorithm reverse reverses the order of the elements in a given range. The
prototype of the function to implement the algorithm reverse is:
template <class biDirectionalItr>
void reverse(biDirectionalItr first, biDirectionalItr last);

The elements in the range first...last-1 are reversed. For example, if vecList =
{1, 2, 5, 3, 4}, then the elements in reverse order are vecList = {4, 3, 5, 2, 1}.
The algorithm reverse_copy reverses the elements of a given range while copying into
a destination range. The source is not modified. The prototype of the function implementing the algorithm reverse_copy is:
template <class biDirectionalItr, class outputItr>
outputItr reverse_copy(biDirectionalItr first,
biDirectionalItr last,
outputItr destFirst);

The elements in the range first...last-1 are copied in the reverse order at the
destination, beginning with destFirst. The function also returns the position one past
the last element copied at the destination.
The algorithm rotate rotates the elements of a given range. Its prototype is:
template <class forwardItr>
void rotate(forwardItr first, forwardItr newFirst,
forwardItr last);

The elements in the range first...newFirst-1 are moved to the end of the range.
The element specified by newFirst becomes the first element of the range. For
example, suppose that:
vecList = {3, 5, 4, 0, 7, 8, 2, 5}

and the iterator vecItr points to 0. Then, after the statement:
rotate(vecList.begin(), vecItr, vecList.end());

executes, vecList is as follows:
vecList = {0, 7, 8, 2, 5, 3, 5, 4}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1529

The algorithm rotate_copy is a combination of rotate and copy. That is, the
elements of the source are copied at the destination in a rotated order. The source is
not modified. The prototype of the function implementing this algorithm is:
template <class forwardItr, class outputItr>
outputItr rotate_copy(forwardItr first, forwardItr middle,
forwardItr last,
outputItr destFirst);

The elements in the range first...last-1 are copied into the destination range
beginning with destFirst in the rotated order, so that the element specified by
middle in the range first...last-1 becomes the first element of the destination.
The function also returns the position one past the last element copied at the destination.
The algorithms reverse, reverse_copy, rotate, and rotate_copy are contained
in the header file algorithm. The program in Example 21-24 illustrates how to use
these algorithms.
EXAMPLE 21-24
//STL Functions: reverse, reverse_copy, rotate, and rotate_copy
#include
#include
#include
#include

<iostream>
<algorithm>
<iterator>
<list>

using namespace std;
int main()
{
int temp[10] = {1, 3, 5, 7, 9, 0, 2, 4, 6, 8};

//Line 1

list<int> intList(temp, temp + 10);
list<int> resultList;
list<int>::iterator listItr;

//Line 2
//List 3
//Line 4

ostream_iterator<int> screen(cout, " ");

//Line 5

cout << "Line 6: intList: ";
copy(intList.begin(), intList.end(), screen);
cout << endl;

//Line 6
//Line 7
//Line 8

//reverse
reverse(intList.begin(), intList.end());

//Line 9

cout << "Line 10: intList after reversal: ";
copy(intList.begin(), intList.end(), screen);
cout << endl;

//Line 10
//Line 11
//Line 12

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1530

| Chapter 21: Standard Template Library (STL)

//reverse_copy
reverse_copy(intList.begin(), intList.end(),
back_inserter(resultList));

//Line 13

cout << "Line 14: resultList: ";
copy(resultList.begin(), resultList.end(),
screen);
cout << endl;

//Line 14

listItr = intList.begin();
listItr++;
listItr++;

//Line 17
//Line 18
//Line 19

cout << "Line 20: intList before rotating: ";
copy(intList.begin(), intList.end(), screen);
cout << endl;

//Line 20
//Line 21
//Line 22

//rotate
rotate(intList.begin(), listItr, intList.end());

//Line 23

cout << "Line 24: intList after rotating: ";
copy(intList.begin(), intList.end(), screen);
cout << endl;

//Line 24
//Line 25
//Line 26

//rotate_copy
resultList.clear();

//Line 27

rotate_copy(intList.begin(), listItr,
intList.end(),
back_inserter(resultList));

//Line 28

cout << "Line 29: intList after rotating and "
<< "copying:\n"
<< "
";
copy(intList.begin(), intList.end(), screen);
cout << endl;

//Line 29
//Line 30
//Line 31

//Line 15
//Line 16

cout << "Line 32: resultList after rotating "
<< "and copying:\n"
<< "
";
copy(resultList.begin(), resultList.end(),
screen);
cout << endl;

//Line 33
//Line 34

resultList.clear();

//Line 35

//Line 32

rotate_copy(intList.begin(),
find(intList.begin(), intList.end(), 6),
intList.end(),
back_inserter(resultList));
//Line 36

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1531

cout << "Line 37: resultList after rotating and "
<< "copying:\n"
<< "
";
//Line 37
copy(resultList.begin(), resultList.end(), screen); //Line 38
cout << endl;
//Line 39
return 0;
}

Sample Run:
Line
Line
Line
Line
Line
Line

6: intList: 1 3 5 7 9 0 2 4 6 8
10: intList after reversal: 8 6 4 2 0 9 7 5 3 1
14: resultList: 1 3 5 7 9 0 2 4 6 8
20: intList before rotating: 8 6 4 2 0 9 7 5 3 1
24: intList after rotating: 4 2 0 9 7 5 3 1 8 6
29: intList after rotating and copying:
4 2 0 9 7 5 3 1 8 6
Line 32: resultList after rotating and copying:
0 9 7 5 3 1 8 6 4 2
Line 37: resultList after rotating and copying:
6 4 2 0 9 7 5 3 1 8

The Functions count, count_if, max, max_element,
min, min_element, and random_shuffle
The algorithm count counts the occurrences of a given value in a given range. The
prototype of the function implementing this algorithm is:
template <class inputItr, class type>
iterator_traits<inputItr>:: difference_type
count(inputItr first, inputItr last, const Type& value);

The function count returns the number of times the value specified by the parameter
value occurs in the range first...last-1.
The algorithm count_if counts the occurrences of a given value in a given range,
satisfying a certain criterion. The prototype of the function implementing this algorithm is:
template <class inputItr, class unaryPredicate>
iterator_traits<inputItr>::difference_type
count_if(inputItr first, inputItr last, unaryPredicate op);

The function count_if returns the number of elements in the range first...last-1
for which op(elemRange) is true.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1532

| Chapter 21: Standard Template Library (STL)

The algorithm max is used to determine the maximum of two values. It has two forms, as
shown by the following prototypes:
template <class Type>
const Type& max(const Type& aVal, const Type& bVal);
template <class Type, class compare>
const Type& max(const Type& aVal, const Type& bVal, compare comp);

In the first form, the greater-than operator associated with Type is used. The second form
uses the comparison operation specified by comp.
The algorithm max_element is used to determine the largest element in a given range.
This algorithm has two forms, as shown by the following prototypes:
template <class forwardItr>
forwardItr max_element(forwardItr first, forwardItr last);
template <class forwardItr, class compare>
forwardItr max_element(forwardItr first, forwardItr last,
compare comp);

The first form uses the greater-than operator associated with the data type of the elements
in the range first...last-1. In the second form, the comparison operation specified
by comp is used. Both forms return an iterator to the element containing the largest value
in the range first...last-1.
The algorithm min is used to determine the minimum of two values. It has two forms, as
shown by the following prototypes:
template <class Type>
const Type& min(const Type& aVal, const Type& bVal);
template <class Type, class compare>
const Type& min(const Type& aVal, const Type& bVal, compare comp);

In the first form, the less-than operator associated with Type is used. In the second form,
the comparison operation specified by comp is used.
The algorithm min_element is used to determine the smallest element in a given range.
This algorithm has two forms, as shown by the following prototypes:
template <class forwardItr>
forwardItr min_element(forwardItr first, forwardItr last);
template <class forwardItr, class compare>
forwardItr min_element(forwardItr first, forwardItr last,
compare comp);

The first form uses the less-than operator associated with the data type of the elements in
the range first...last-1. The second form uses the comparison operation specified
by comp. Both forms return an iterator to the element containing the smallest value in the
range first...last-1.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1533

The algorithm random_shuffle is used to randomly order the elements in a given
range. There are two forms of this algorithm, as shown by the following prototypes:
template <class randomAccessItr>
void random_shuffle(randomAccessItr first,
randomAccessItr last);
template <class randomAccessItr, class randomAccessGenerator>
void random_shuffle(randomAccessItr first,
randomAccessItr last,
randomAccessGenerator rand);

The first form reorders the elements in the range first...last-1 using a uniform
distribution random number generator. The second form reorders the elements in the
range first...last-1 using a random number-generating function object or a pointer
to a function.
Example 21-25 illustrates how to use these functions.
EXAMPLE 21-25

2
1

//STL Functions count, count_if, min_element,
//
max_element, random_shuffle
#include
#include
#include
#include
#include

<iostream>
<cctype>
<algorithm>
<iterator>
<vector>

using namespace std;
void doubleNum(int num);
int main()
{
char cList[10] = {'Z', 'a', 'Z', 'B', 'Z',
'c', 'D', 'e', 'F', 'Z'};
vector<char>

charList(cList, cList + 10);

//Line 1
//Line 2

ostream_iterator<char> screen(cout, " ");

//Line 3

cout << "Line 4: charList: ";
copy(charList.begin(), charList.end(), screen);
cout << endl;

//Line 4
//Line 5
//Line 6

//count
int noOfZs = count(charList.begin(),
charList.end(), 'Z');

//Line 7

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1534

| Chapter 21: Standard Template Library (STL)

cout << "Line 8: Number of Zs in charList = "
<< noOfZs << endl;

//Line 8

//count_if
int noOfUpper = count_if(charList.begin(),
charList.end(), isupper); //Line 9
cout << "Line 10: Number of uppercase letters "
<< "in charList = " << noOfUpper << endl;

//Line 10

int list[10] = {12, 34, 56, 21, 34,
78, 34, 55, 12, 25};

//Line 11

ostream_iterator<int> screenOut(cout, " ");

//Line 12

cout << "Line 13: list: ";
copy(list, list + 10, screenOut);
cout << endl;

//Line 13
//Line 14
//Line 15

//max_element
int *maxLoc = max_element(list, list + 10);

//Line 16

cout << "Line 17: Largest element in list = "
<< *maxLoc << endl;

//Line 17

//min_element
int *minLoc = min_element(list, list + 10);

//Line 18

cout << "Line 19: Smallest element in list = "
<< *minLoc << endl;

//Line 19

//random_shuffle
random_shuffle(list, list + 10);

//Line 20

cout << "Line 21: list after random shuffle:\n"
<< "
";
copy(list, list + 10, screenOut);
cout << endl;

//Line 21
//Line 22
//Line 23

return 0;
}
void doubleNum(int num)
{
cout << 2 * num << " ";
}

Sample Run:
Line
Line
Line
Line

4: charList: Z a Z B Z c D e F Z
8: Number of Zs in charList = 4
10: Number of uppercase letters in charList = 7
13: list: 12 34 56 21 34 78 34 55 12 25

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1535

Line 17: Largest element in list = 78
Line 19: Smallest element in list = 12
Line 21: list after random shuffle:
12 34 25 56 12 78 55 21 34 34

The preceding output is self-explanatory. The details are left as an exercise for you.

The Functions for_each and transform
The algorithm for_each is used to access and process each element in a given range by
applying a function, which is passed as a parameter. The prototype of the function
implementing this algorithm is:
template <class inputItr, class function>
function for_each(inputItr first, inputItr last, function func);

The function specified by the parameter func is applied to each element in the range
first...last-1. The function func can modify the element. The returned value of
the function for_each is usually ignored.
The algorithm transform has two forms. The prototypes of the functions implementing
this algorithm are:
template <class inputItr, class outputItr,
class unaryOperation>
outputItr transform(inputItr first, inputItr last,
outputItr destFirst,
unaryOperation op);
template <class inputItr1, class inputItr2,
class outputItr, class binaryOperation>
outputItr transform(inputItr1 first1, inputItr1 last,
inputItr2 first2,
outputItr destFirst,
binaryOperation bOp);

The first form of the function transform has four parameters. This function creates a
sequence of elements at the destination, beginning with destFirst, by applying the
unary operation op to each element in the range first1...last-1. This function
returns the position one past the last element copied at the destination.
The second form of the function transform has five parameters. This function creates a
sequence of elements by applying the binary operation bOp—that is, bOp(elemRange1,
elemRange2)—to the corresponding elements in the range first1...last1-1 and
the range beginning with first2. The resulting sequence is placed at the destination
beginning with destFirst. The function returns the position one element past the last
element copied at the destination.
Example 21-26 illustrates how to use these functions.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1536

| Chapter 21: Standard Template Library (STL)

EXAMPLE 21-26
//STL Functions for_each and transform
#include
#include
#include
#include
#include

<iostream>
<cctype>
<algorithm>
<iterator>
<vector>

using namespace std;
void doubleNum(int& num);
int main()
{
char cList[5] = {'a', 'b', 'c', 'd', 'e'};

//Line 1

charList(cList, cList + 5);

//Line 2

ostream_iterator<char> screen(cout, " ");

//Line 3

cout << "Line 4: cList: ";
copy(charList.begin(), charList.end(), screen);
cout << endl;

//Line 4
//Line 5
//Line 6

//transform
transform(charList.begin(), charList.end(),
charList.begin(), toupper);

//Line 7

cout << "Line 8: cList after changing all "
<< "lowercase letters to \n"
<< "
uppercase: ";
copy(charList.begin(), charList.end(), screen);
cout << endl;

//Line 8
//Line 9
//Line 10

int list[7] = {2, 8, 5, 1, 7, 11, 3};

//Line 11

ostream_iterator<int> screenOut(cout, " ");

//Line 12

cout << "Line 13: list: ";
copy(list, list + 7, screenOut);
cout << endl;

//Line 13
//Line 14
//Line 15

cout << "Line 16: The effect of for_each "
<< "function:\n
";

//Line 16

//for_each
for_each(list, list + 7, doubleNum);
cout << endl;

//Line 17
//Line 18

vector<char>

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

cout << "Line 19: list after a call to "
<< "for_each function:\n
";
copy(list, list + 7, screenOut);
cout << endl;

|

1537

//Line 19
//Line 20
//Line 21

return 0;
}
void doubleNum(int& num)
{
num = 2 * num;
cout << num << " ";
}

Sample Run:
Line 4: cList: a b c d e
Line 8: cList after changing all lowercase letters to
uppercase: A B C D E
Line 13: list: 2 8 5 1 7 11 3
Line 16: The effect of for_each function:
4 16 10 2 14 22 6
Line 19: list after a call to for_each function:
4 16 10 2 14 22 6

The statement in Line 7 uses the function transform to change every lowercase letter of
charList into its uppercase counterpart. The statement in Line 9 outputs the elements
of charList. In the output, the line marked Line 8 contains the output of the statements
in Lines 8 through 10 in the program. Notice that the fourth parameter of the function
transform (in Line 7) is the function toupper from the header file cctype.
The statement in Line 17 calls the function for_each to process each element in the list
using the function doubleNum. The function doubleNum has a reference parameter,
num, of type int. Moreover, this function doubles the value of num and then outputs the
value of num. Because num is a reference parameter, the value of the actual parameter is
changed. In the output, the line marked Line 16 contains the output produced by
the cout statement in the function doubleNum, which is passed as the third parameter
of the function for_each (see Line 17). The statement in Line 20 outputs the values of
the elements of list. In the output, Line 19 contains the output of the statements in
Lines 19 through 20.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1538

| Chapter 21: Standard Template Library (STL)

The Functions includes, set_intersection, set_union,
set_difference, and set_symmetric_difference
This section describes the set theory operations includes (subset), set_intersection,
set_union, set_difference, and set_symmetric_difference. All of these algorithms assume that the elements within each given range are already sorted.
The algorithm includes determines whether the elements in one range appear in
another range. This function has two forms, as shown by the following prototypes:
template <class inputItr1, class inputItr2>
bool includes(inputItr1 first1, inputItr1 last1,
inputItr2 first2, inputItr2 last2);
template <class inputItr1, class inputItr2,
class binaryPredicate>
bool includes(inputItr1 first1, inputItr1 last1,
inputItr2 first2, inputItr2 last2,
binaryPredicate op);

Both forms of the function includes assume that the elements in the ranges first1. . .
last1-1 and first2. . .last2-1 are sorted according to the same sorting criterion.
The function returns true if all of the elements in the range first2. . .last2-1 are
also in first1. . .last1-1. In other words, the function returns true if first1. . .
last1-1 contains all of the elements in the range first2. . .last2-1. The first form
assumes that the elements in both ranges are in ascending order. The second form uses the
operation op to determine the ordering of the elements.
Example 21-27 illustrates how the function includes works.
EXAMPLE 21-27
//STL function includes
//This function assumes that the elements in the given ranges
//are ordered according to some sorting criteria
#include <iostream>
#include <algorithm>
#include <iterator>
using namespace std;
int main()
{
char setA[5] = {'A', 'B', 'C', 'D', 'E'};
char setB[10] = {'A', 'B', 'C', 'D', 'E',
'F', 'I', 'J', 'K', 'L'};
char setC[5] = {'A', 'E', 'I', 'O', 'U'};
ostream_iterator<char> screen(cout, " ");
cout << "Line 5: setA: ";

//Line 1
//Line 2
//Line 3
//Line 4
//Line 5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

copy(setA, setA + 5, screen);
cout << endl;

//Line 6
//Line 7

cout << "Line 8: setB: ";
copy(setB, setB + 10, screen);
cout << endl;

//Line 8
//Line 9
//Line 10

cout << "Line 11: setC: ";
copy(setC, setC + 5, screen);
cout << endl;

//Line 11
//Line 12
//Line 13

if (includes(setB, setB + 10, setA, setA + 5))
cout << "Line 15: setA is a subset of "
<< "setB." << endl;
else
cout << "Line 17: setA is not a subset "
<< "of setB." << endl;

//Line 14

if (includes(setB, setB + 10, setC, setC + 5))
cout << "Line 19: setC is a subset of "
<< "setB." << endl;
else
cout << "Line 21: setC is not a subset "
<< "of setB." << endl;

//Line 18

|

1539

//Line 15
//Line 16
//Line 17

//Line 19
//Line 20
//Line 21

return 0;
}

Sample Run:
Line
Line
Line
Line
Line

5: setA: A B C D E
8: setB: A B C D E F I J K L
11: setC: A E I O U
15: setA is a subset of setB
21: setC is not a subset of setB

The preceding output is self-explanatory. The details are left as an exercise for you.
The algorithm set_intersection is used to find the elements that are common to
two ranges of elements. This algorithm has two forms, as shown by the following
prototypes:
template <class inputItr1, class inputItr2,
class outputItr>
outputItr set_intersection(inputItr1 first1, inputItr1 last1,
inputItr2 first2, inputItr2 last2,
outputItr destFirst);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1540

| Chapter 21: Standard Template Library (STL)

template <class inputItr1, class inputItr2,
class outputItr, class binaryPredicate>
outputItr set_intersection(inputItr1 first1, inputItr1 last1,
inputItr2 first2, inputItr2 last2,
outputItr destFirst,
binaryPredicate op);

Both forms create a sequence of sorted elements that are common to two sorted ranges,
first1. . .last1-1 and first2. . .last2-1. The created sequence is placed in the
container beginning with destFirst. Both forms return an iterator positioned one past
the last element copied at the destination range. The first form assumes that the elements
are in ascending order; the second form assumes that both ranges are sorted using the
operation specified by op. The elements in the source ranges are not modified.
Suppose that:
setA[5]
setB[7]
setC[5]
setD[6]
setE[7]

=
=
=
=
=

{2,
{1,
{2,
{1,
{2,

4,
2,
5,
4,
3,

5,
3,
8,
4,
4,

7,
4,
8,
6,
4,

8};
5, 6, 7};
15};
7, 12};
5, 6, 10};

Then:
AintersectB = {2, 4, 5, 7}
AintersectC = {2, 5, 8}
DintersectE = {4, 4, 6}

Notice that because 8 appears only once in setA, 8 appears only once in AintersectC,
even though 8 appears twice in setC. However, because 4 appears twice in both setD
and setE, 4 also appears twice in DintersectE.
The algorithm set_union is used to find the elements that are contained in two ranges
of elements. This algorithm has two forms, as shown by the following prototypes:
template <class inputItr1, class inputItr2,
class outputItr>
outputItr set_union(inputItr1 first1, inputItr1 last1,
inputItr2 first2, inputItr2 last2,
outputItr destFirst);
template <class inputItr1, class inputItr2,
class outputItr, class binaryPredicate>
outputItr set_union(inputItr1 first1, inputItr1 last1,
inputItr2 first2, inputItr2 last2,
outputItr result,
binaryPredicate op);

Both forms create a sequence of sorted elements that appear in either two sorted ranges,
first1. . .last1-1 or first2. . .last2-1. The created sequence is placed in the
container beginning with destFirst. Both forms return an iterator positioned one past
the last element copied at the destination range. The first form assumes that the elements

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1541

are in ascending order. The second form assumes that both ranges are sorted using the
operation specified by op. The elements in the source ranges are not modified.
Suppose that you have setA, setB, setC, setD, and setE as defined previously. Then:
AunionB
AunionC
BunionD
DunionE

=
=
=
=

{1,
{2,
{1,
{1,

2,
4,
2,
2,

3,
5,
3,
3,

4,
7,
4,
4,

5,
8,
4,
4,

6,
8,
5,
5,

7, 8}
15}
6, 7, 12}
6, 7, 10, 12}

Notice that because 8 appears twice in setC, it appears twice in AunionC. Because 4
appears twice in setD and setE, 4 appears twice in DunionE.
Example 21-28 illustrates how the functions set_union and set_intersection work.
EXAMPLE 21-28
//STL set theory functions set_union and set_intersection
//These functions assume that the elements in the given ranges
//are ordered according to some sorting criteria.

2
1

#include <iostream>
#include <algorithm>
#include <iterator>
using namespace std;
int main()
{
int setA[5]
int setB[7]
int setC[5]
int setD[6]
int
int
int
int
int

=
=
=
=

{2,
{1,
{2,
{1,

4,
2,
5,
4,

5,
3,
8,
4,

7,
4,
8,
6,

8};
5, 6, 7};
15};
7, 12};

AunionB[10];
AunionC[10];
BunionD[15];
AintersectB[10];
AintersectC[10];

//Line
//Line
//Line
//Line

1
2
3
4

//Line
//Line
//Line
//Line
//Line

5
6
7
8
9

int *lastElem;

//Line 10

ostream_iterator<int> screen(cout, " ");

//Line 11

cout << "Line 12: setA = ";
copy(setA, setA + 5, screen);
cout << endl;

//Line 12
//Line 13
//Line 14

cout << "Line 15: setB = ";
copy(setB, setB + 7, screen);
cout << endl;

//Line 15
//Line 16
//Line 17

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1542

| Chapter 21: Standard Template Library (STL)

cout << "Line 18: setC = ";
copy(setC, setC + 5, screen);
cout << endl;

//Line 18
//Line 19
//Line 20

cout << "Line 21: setD = ";
copy(setD, setD + 6, screen);
cout << endl;

//Line 21
//Line 22
//Line 23

lastElem = set_union(setA, setA + 5,
setB, setB + 7,
AunionB);

//Line 24

cout << "Line 25: Set AunionB: ";
copy(AunionB, lastElem, screen);
cout << endl;

//Line 25
//Line 26
//Line 27

lastElem = set_union(setA, setA + 5,
setC, setC + 5,
AunionC);

//Line 28

cout << "Line 29: Set AunionC: ";
copy(AunionC, lastElem, screen);
cout << endl;

//Line 29
//Line 30
//Line 31

lastElem = set_union(setB, setB + 7,
setD, setD + 6,
BunionD);

//Line 32

cout << "Line 33: Set BunionD: ";
copy(BunionD, lastElem, screen);
cout << endl;

//Line 33
//Line 34
//Line 35

lastElem = set_intersection(setA, setA + 5,
setB, setB + 7,
AintersectB);

//Line 36

cout << "Line 37: Set AintersectB: ";
copy(AintersectB, lastElem, screen);
cout << endl;

//Line 37
//Line 38
//Line 39

lastElem = set_intersection(setA, setA + 5,
setC, setC + 5,
AintersectC);

//Line 40

cout << "Line 41: Set AintersectC: ";
copy(AintersectC, lastElem, screen);
cout << endl;

//Line 41
//Line 42
//Line 43

return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1543

Sample Run:
Line
Line
Line
Line
Line
Line
Line
Line
Line

12:
15:
18:
21:
25:
29:
33:
37:
41:

setA = 2 4 5 7 8
setB = 1 2 3 4 5 6 7
setC = 2 5 8 8 15
setD = 1 4 4 6 7 12
Set AunionB: 1 2 3 4
Set AunionC: 2 4 5 7
Set BunionD: 1 2 3 4
Set AintersectB: 2 4
Set AintersectC: 2 5

5
8
4
5
8

6 7 8
8 15
5 6 7 12
7

The preceding output is self-explanatory. The details are left as an exercise for you.
The algorithm set_difference is used to find the elements in one range of elements
that do not appear in another range of elements. This algorithm has two forms, as shown
by the following prototypes:
template <class inputItr1, class inputItr2,
class outputItr>
outputItr set_difference(inputItr1 first1, inputItr1 last1,
inputItr2 first2, inputItr2 last2,
outputItr destFirst);
template <class inputItr1, class inputItr2,
class outputItr, class binaryPredicate>
outputItr set_difference(inputItr1 first1, inputItr1 last1,
inputItr2 first2, inputItr2 last2,
outputItr destFirst,
binaryPredicate op);

Both forms create a sequence of sorted elements that are in the sorted range
first1. . .last1-1 but not in the sorted range first2. . .last2-1. The created
sequence is placed in the container beginning with destFirst. Both forms return an
iterator positioned one past the last element copied at the destination range. The first
form assumes that the elements are in ascending order. The second form assumes that
both ranges are sorted using the operation specified by op. The elements in the source
ranges are not modified.
Suppose that:
setA
setC
setD
setE

=
=
=
=

{2,
{1,
{2,
{1,

4,
5,
5,
5,

5,
6,
5,
7,

7,
8,
6,
9,

8}
15}
9}
12}

Then:
AdifferenceC = {2, 4, 7}
DdifferenceE = {2, 5, 6}

Because 5 appears twice in setD but only once in setE, 5 appears once in DdifferenceE.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1544

| Chapter 21: Standard Template Library (STL)

The algorithm set_symmetric_difference has two forms, as shown by the following prototypes:
template <class inputItr1, class inputItr2,
class outputItr>
outputItr set_symmetric_difference(inputItr1
inputItr1
inputItr2
inputItr2
outputItr

first1,
last1,
first2,
last2,
destFirst);

template <class inputItr1, class inputItr2,
class outputItr, class binaryPredicate>
outputItr set_symmetric_difference(inputItr1 first1,
inputItr1 last1,
inputItr2 first2,
inputItr2 last2,
outputItr destFirst,
binaryPredicate op);

Both forms create a sequence of sorted elements that are in the sorted range
first1. . .last1-1 but not in first2. . .last2-1, or elements that are in
the sorted range first2. . .last2-1 but not in first1. . .last1-1. In other words,
the sequence of elements created by set_symmetric_difference contains the elements
that are in range1_difference_range2 union range2_difference_range1. The
created sequence is placed in the container beginning with destFirst. Both forms
return an iterator positioned one past the last element copied at the destination range.
The first form assumes that the elements are in ascending order. The second form
assumes that both ranges are sorted using the operation specified by op. The elements
in the source ranges are not modified. It can be shown that the sequence created by
set_symmetric_difference contains elements that are in range1_union_range2
but not in range1_intersection_range2.
Suppose that:
setB = {3, 4, 5, 6, 7, 8, 10}
setC = {1, 5, 6, 8, 15}
setD = {2, 5, 5, 6, 9}

Notice that BdifferenceC = {3, 4, 7, 10} and CdifferenceB = {1, 15}.
Therefore:
BsymDiffC = {1, 3, 4, 7, 10, 15}

Now DdifferenceC = {2, 5, 9} and CdifferenceD = {1, 8, 15}. Therefore:
DsymDiffC = {1, 2, 5, 8, 9, 15}

Example

21-29

illustrates

how

the

functions

set_difference

and

set_symmetric_difference work.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1545

EXAMPLE 21-29
//STL set theory functions: set_difference and
//
set_symmetric_difference.
//These functions assume that the elements in the given
//ranges are ordered according to some sorting criteria.
#include <iostream>
#include <algorithm>
#include <iterator>
using namespace std;
int main()
{
int setA[5] = {2, 4, 5, 7, 8};
int setB[7] = {3, 4, 5, 6, 7, 8, 10};
int setC[5] = {1, 5, 6, 8, 15};

//Line 1
//Line 2
//Line 3

int AdifferenceC[5];
int BsymDiffC[10];

//Line 4
//Line 5

int *lastElem;

//Line 6

ostream_iterator<int> screen(cout, " ");

//Line 7

cout << "Line 8: setA = ";
copy(setA, setA + 5, screen);
cout << endl;

//Line 8
//Line 9
//Line 10

cout << "Line 11: setB = ";
copy(setB, setB + 7, screen);
cout << endl;

//Line 11
//Line 12
//Line 13

cout << "Line 14: setC = ";
copy(setC, setC + 5, screen);
cout << endl;

//Line 14
//Line 15
//Line 16

lastElem = set_difference(setA, setA + 5,
setC, setC + 5,
AdifferenceC);

//Line 17

cout << "Line 18: AdifferenceC: ";
copy(AdifferenceC, lastElem, screen);
cout << endl;

//Line 18
//Line 19
//Line 20

lastElem = set_symmetric_difference(setB, setB + 7,
setC, setC + 5,
BsymDiffC);
//Line 21

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1546

| Chapter 21: Standard Template Library (STL)

cout << "Line 22: BsymDiffC: ";
copy(BsymDiffC, lastElem, screen);
cout << endl;

//Line 22
//Line 23
//Line 24

return 0;
}

Sample Run:
Line
Line
Line
Line
Line

8: setA = 2 4 5 7 8
11: setB = 3 4 5 6 7 8 10
14: setC = 1 5 6 8 15
18: AdifferenceC: 2 4 7
22: BsymDiffC: 1 3 4 7 10 15

The preceding output is self-explanatory. The details are left as an exercise for you.

The Functions accumulate, adjacent_difference,
inner_product, and partial_sum
The algorithms accumulate, adjacent_difference, inner_product, and
partial_sum are numerical functions and thus manipulate numeric data. Each of these
functions has two forms. The first form uses the natural operation to manipulate the data.
For example, the algorithm accumulate finds the sum of all of the elements in a given
range. In the second form, we can specify the operation to be applied to the elements of
the range. For example, rather than add the elements of a given range, we can specify the
multiplication operation to the algorithm accumulate to multiply the elements of the
range. Next, we give the prototype of each of these algorithms followed by a brief
explanation. The algorithms are contained in the header file numeric.
template<class inputItr, class Type>
Type accumulate(inputItr first, inputItr last, Type init);
template<class inputItr, class Type, class binaryOperation>
Type accumulate(inputItr first, inputItr last,
Type init, binaryOperation op);

The first form of the algorithm accumulate adds all of the elements to an initial value
specified by the parameter init in the range first. . .last-1. For example, if the
value of init is 0, the algorithm returns the sum of all of the elements. In the second
form, we can specify a binary operation, such as multiplication, to be applied to the
elements of the range. For example, if the value of init is 1 and the binary operation is
multiplication, the algorithm returns the products of the elements of the range.
Next, we describe the algorithm adjacent_difference. Its prototypes are:
template <class inputItr, class outputItr>
outputItr adjacent_difference(inputItr first, inputItr last,
outputItr destFirst);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1547

template <class inputItr, class outputItr,
class binaryOperation>
outputItr adjacent_difference(inputItr first, inputItr last,
outputItr destFirst,
binaryOperation op);

The first form creates a sequence of elements in which the first element is the same as the
first element in the range first. . .last-1, and all other elements are the differences
of the current and previous elements. For example, if the range of elements is:
{2, 5, 6, 8, 3, 7}

then the sequence created by the function adjacent_difference is:
{2, 3, 1, 2, -5, 4}

The first element is the same as the first element in the original range. The second
element is equal to the second element in the original range minus the first element in the
original range. Similarly, the third element is equal to the third element in the original
range minus the second element in the original range, and so on.
In the second form of adjacent_difference, the binary operation op is applied to
the elements in the range. The resulting sequence is copied at the destination specified by
destFirst. For example, if the sequence is {2, 5, 6, 8, 3, 7} and the operation is
multiplication, the resulting sequence is {2, 10, 30, 48, 24, 21}.
Both forms return an iterator positioned one past the last element copied at the destination.
The algorithm inner_product is used to manipulate the elements of two ranges. The
prototypes of this algorithm are:
template <class inputItr1, class inputItr2, class Type>
Type inner_product(inputItr1 first1, inputItr1 last,
inputItr2 first2, Type init);
template <class inputItr1, class inputItr2, class Type
class binaryOperation1, class binaryOperation2>
Type inner_product(inputItr1 first1, inputItr1 last,
inputItr2 first2, Type init,
binaryOperation1 op1, binaryOperation2 op2);

The first form multiplies the corresponding elements in the range first1. . .last-1
and the range of elements starting with first2. The products of the elements are then
added to the value specified by the parameter init. To be specific, suppose that elem1
ranges over the first range and elem2 ranges over the second range starting with
first2. The first form computes:
init = init + elem1 * elem2

for all of the corresponding elements. For example, suppose that the two ranges are
{2, 4, 7, 8} and {1, 4, 6, 9} and that init is 0. The function computes and returns:
0 + 2 * 1 + 4 * 4 + 7 * 6 + 8 * 9 = 132

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1548

| Chapter 21: Standard Template Library (STL)

In the second form, the default addition can be replaced by the operation specified by
op1, and the default multiplication can be replaced by the operation specified by op2.
This form, in fact, computes:
init = init op1 (elem1 op2 elem2);

The algorithm partial_sum has two forms, as shown by the following prototypes:
template <class inputItr, class outputItr>
outputItr partial_sum(inputItr first, inputItr last,
outputItr destFirst);
template <class inputItr, class outputItr,
class binaryOperation>
outputItr partial_sum(inputItr first, inputItr last,
outputItr destFirst, binaryOperation op);

The first form creates a sequence of elements in which each element is the sum of all of
the previous elements in the range first. . .last-1 up to the position of the element.
For example, the first element of the new sequence is the same as the first element in the
range first. . .last-1, the second element is the sum of the first two elements in the
range first. . .last-1, the third element of the new sequence is the sum of the first
three elements in the range first. . .last-1, and so on. For example, for the
sequence of elements:
{1, 3, 4, 6}

the function partial_sum generates the following sequence:
{1, 4, 8, 14}

In the second form, the default addition can be replaced by the operation specified by op.
For example, if the sequence is:
{1, 3, 4, 6}

and the operation is multiplication, the function partial_sum generates the following
sequence:
{1, 3, 12, 72}

The created sequence is copied at the destination specified by destFirst and returns an
iterator positioned one past the last copied element at the destination.
Example 21-30 illustrates how the functions of this section work.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Algorithms

|

1549

EXAMPLE 21-30
//Numeric algorithms: accumulate, adjacent_difference,
//
inner_product, and partial_sum
#include
#include
#include
#include
#include
#include

<iostream>
<algorithm>
<numeric>
<iterator>
<vector>
<functional>

using namespace std;
void print(vector<int>

vList);

int main()
{
int list[8] = {1, 2, 3, 4, 5, 6, 7, 8};

//Line 1

vector<int> vecList(list, list + 8);
vector<int>
newVList(8);

//Line 2
//Line 3

cout << "Line 4: vecList: ";
print(vecList);

//Line 4
//Line 5

//accumulate function
int sum = accumulate(vecList.begin(),
vecList.end(), 0);

//Line 6

cout << "Line 7: Sum of the elements of "
<< "vecList = " << sum << endl;

//Line 7

int product = accumulate(vecList.begin(),
vecList.end(),
1, multiplies<int>());

//Line 8

cout << "Line 9: Product of the elements of "
<< "vecList = " << product << endl;

//Line 9

//adjacent_difference function
adjacent_difference(vecList.begin(),
vecList.end(),
newVList.begin());

//Line 10

cout << "Line 11: newVList: ";
print(newVList);

//Line 11
//Line 12

adjacent_difference(vecList.begin(), vecList.end(),
newVList.begin(),
multiplies<int>());
//Line 13

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1550

| Chapter 21: Standard Template Library (STL)

cout << "Line 14: newVList: ";
print(newVList);

//Line 14
//Line 15

//inner_product function
sum = inner_product(vecList.begin(), vecList.end(),
newVList.begin(), 0);
//Line 16
cout << "Line 17: Inner product of vecList "
<< "and newVList: " << sum << endl;

//Line 17

sum = inner_product(vecList.begin(), vecList.end(),
newVList.begin(), 0,
plus<int>(), minus<int>());
//Line 18
cout << "Line 19: Inner product of vecList and "
<< "newVList, using - for *: "
<< sum << endl;

//Line 19

//partial_sum function
partial_sum(vecList.begin(), vecList.end(),
newVList.begin());

//Line 20

cout << "Line 21: newVList with partial sum : ";
print(newVList);

//Line 21
//Line 22

//partial_sum: the default + is replaced by *
partial_sum(vecList.begin(), vecList.end(),
newVList.begin(), multiplies<int>()); //Line 23
cout << "Line 24: newVList with partial "
<< "multiplication: " << endl
<< "
";
print(newVList);

//Line 24
//Line 25

return 0;
}
void print(vector<int> vList)
{
ostream_iterator<int> screenOut(cout, " ");
copy(vList.begin(), vList.end(), screenOut);
cout << endl;

//Line 26
//Line 27
//Line 28

}

Sample Run:
Line
Line
Line
Line
Line

4: vecList: 1
7: Sum of the
9: Product of
11: newVList:
14: newVList:

2 3 4 5 6 7 8
elements of vecList = 36
the elements of vecList = 40320
1 1 1 1 1 1 1 1
1 2 6 12 20 30 42 56

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

Line
Line
Line
Line

17:
19:
21:
24:

1551

Inner product of vecList and newVList: 1093
Inner product of vecList and newVList, using - for *: -133
newVList with partial sum: 1 3 6 10 15 21 28 36
newVList with partial multiplication:
1 2 6 24 120 720 5040 40320

The preceding output is self-explanatory. The details are left as an exercise for you.

QUICK REVIEW
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13.

14.
15.
16.

The three main components of the STL are containers, iterators, and
algorithms.
STL containers are class templates.
Iterators are used to step through the elements of a container.
Algorithms are used to manipulate the elements in a container.
The main categories of containers are sequence containers, associative
containers, and container adapters.
The three predefined sequence containers are vector, deque, and list.
A vector container stores and manages its objects in a dynamic array.
Because an array is a random access data structure, elements of a vector can
be accessed randomly.
The name of the class that implements the vector container is vector.
Item insertion in a vector container is accomplished by using the operations
insert and push_back.
Item deletion in a vector container is accomplished by using the operations
pop_back, erase, and clear.
An iterator to a vector container is declared using the typedef iterator,
which is declared as a public member of the class vector.
Member functions common to all containers are the default constructor,
constructors with parameters, the copy constructor, the destructor, empty,
size, max_size, swap, begin, end, rbegin, rend, insert, erase,
clear, and the relational operator functions.
The member function begin returns an iterator to the first element into
the container.
The member function end returns an iterator to one past the last element
into the container.
In addition to the member functions listed in item 13 above, the other
member functions common to all sequence containers are insert,
push_back, pop_back, erase, clear, and resize.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1552

17.
18.
19.
20.
21.
22.
23.

24.

25.
26.

27.
28.
29.
30.
31.
32.
33.
34.

| Chapter 21: Standard Template Library (STL)

The copy algorithm is used to copy the elements in a given range to
another place.
The function copy, using an ostream iterator, can also be used to output
the elements of a container.
When we create an iterator of type ostream, we also specify the type of
element that the iterator will output.
Deque containers are implemented as dynamic arrays in such a way that the
elements can be inserted at both ends of the array.
A deque can expand in either direction.
The name of the class containing the definition of the class deque is
deque.
In addition to the operations that are common to all containers, other
operations that can be used to manipulate the elements of a deque are
assign, push_front, pop_front, at, the array subscripting operator
[], front, and back.
List containers are implemented as doubly linked lists. Thus, every element
in the list points to its immediate predecessor and its immediate successor
(except the first and last elements).
The name of the class containing the definition of the class list is
list.
In addition to the operations that are common to sequence containers,
other operations that can be used to manipulate the elements in a list
container are assign, push_front, pop_front, front, back,
remove, remove_if, unique, splice, sort, merge, and reverse.
The five categories of iterators are input, output, forward, bidirectional,
and random access iterator.
Input iterators are used to input data from an input stream.
Output iterators are used to output data to an output stream.
A forward iterator can refer to the same element in the same collection and
process the same element more than once.
Bidirectional iterators are forward iterators that can also iterate backward
over the elements.
Bidirectional iterators can be used with containers of type list, set,
multiset, multimap, map, and multimap.
Random access iterators are bidirectional iterators that can randomly process the elements of a container.
Random access iterators can be used with containers of type vector,
dequeue, and string, as well as arrays.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Quick Review |

35.

36.
37.
38.
39.
40.
41.

42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.

1553

Elements in an associative container are automatically sorted according
to some various ordering criteria. The default ordering criterion is the
relational operator less-than, <.
The predefined associative containers in the STL are set, multiset, map,
and multimap.
Containers of the type set do not allow duplicates.
Containers of the type multiset allow duplicates.
The name of the class defining the container set is set.
The name of the class defining the container multiset is multiset.
The name of the header file containing the definition of the classes set
and multiset, and the definitions of the functions to implement the
various operations on these containers, is set.
The operations insert, erase, and clear can be used to insert or delete
elements from sets.
Most of the generic algorithms are contained in the header file algorithm.
The main categories of STL algorithms are nonmodifying, modifying,
numeric, and heap.
Nonmodifying algorithms do not modify the elements of the container.
Modifying algorithms modify the elements of the container by rearranging,
removing, and/or changing the values of the elements.
Modifying algorithms that change the order of the elements, not their
values, are also called mutating algorithms.
Numeric algorithms are designed to perform numeric calculations on the
elements of a container.
A function object is a class template that overloads the function call
operator, operator().
The predefined arithmetic function objects are plus, minus, multiplies,
divides, modulus, and negate.
The predefined relational function objects are equal_to, not_equal_to,
greater, greater_equal, less, and less_equal.
The predefined logical function objects are logical_not, logical_and,
and logical_or.
Predicates are special types of function objects that return Boolean values.
Unary predicates check a specific property for a single argument; binary
predicates check a specific property for a pair—that is, two arguments.
Predicates are typically used to specify a searching or sorting criteria.
In the STL, a predicate must always return the same result for the same
value.
The functions that modify their internal states cannot be considered predicates.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1554

58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.

70.
71.
72.
73.
74.
75.
76.
77.
78.
79.

| Chapter 21: Standard Template Library (STL)

The STL provides three iterators—back_inserter, front_inserter, and
inserter—called insert iterators to insert the elements at the destination.
The back_inserter uses the push_back operation of the container in
place of the assignment operator.
The front_inserter uses the push_front operation of the container
in place of the assignment operator.
Because the vector class does not support the push_front operation, this
iterator cannot be used for the vector container.
The inserter iterator uses the container’s insert operation in place of
the assignment operator.
The function fill is used to fill a container with elements, and the
function fill_n is used to fill in the next n elements.
The functions generate and generate_n are used to generate elements
and fill a sequence.
The functions find, find_if, find_end, and find_first_of are used
to find the elements in a given range.
The function remove is used to remove certain elements from a sequence.
The function remove_if is used to remove elements from a sequence
using a specified criterion.
The function remove_copy copies the elements in a sequence into
another sequence by excluding certain elements from the first sequence.
The function remove_copy_if copies the elements in a sequence into
another sequence by excluding certain elements, using a specified criterion,
from the first sequence.
The functions swap, iter_swap, and swap_ranges are used to swap
elements.
The functions search, search_n, sort, and binary_search are used
to search elements.
The function adjacent_find is used to find the first occurrence of
consecutive elements satisfying a certain criterion.
The algorithm merge merges two sorted lists.
The algorithm inplace_merge is used to combine two sorted, consecutive sequences.
The algorithm reverse reverses the order of the elements in a given range.
The algorithm reverse_copy reverses the elements in a given range
while copying into a destination range. The source is not modified.
The algorithm rotate rotates the elements in a given range.
The algorithm rotate_copy copies the elements of the source at the
destination in a rotated order.
The algorithm count counts the occurrences of a given value in a given range.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.

93.

|

1555

The algorithm count_if counts the occurrences of a given value in a
given range, satisfying a certain criterion.
The algorithm max is used to determine the maximum of two values.
The algorithm max_element is used to determine the largest element in a
given range.
The algorithm min is used to determine the minimum of two values.
The algorithm min_element is used to determine the smallest element in
a given range.
The algorithm random_shuffle is used to randomly order the elements
in a given range.
The algorithm for_each is used to access and process each element in a
given range by applying a function, which is passed as a parameter.
The function transform creates a sequence of elements by applying
certain operations to each element in a given range.
The algorithm includes determines whether the elements of one range
appear in another range.
The algorithm set_intersection is used to find the elements that are
common to two ranges of elements.
The algorithm set_union is used to find the elements that are contained
in two ranges of elements.
The algorithm set_difference is used to find the elements in one range
of elements that do not appear in another range of elements.
Given two ranges of elements, the algorithm set_symmetric_difference
determines the elements that are in the first range but not the second range
or the elements that are in the second range but not the first range.
The algorithms accumulate, adjacent_difference, inner_product,
and partial_sum are numerical functions and manipulate numeric data.

EXERCISES
The number in parentheses at the end of an exercise refers to the learning objective listed
at the beginning of the chapter.
1.

Mark the following statements as true or false.
a.
b.

c.
d.

Containers and iterators are class templates. (1, 2)
The STL containers are classified into the following categories:
sequence and associative. (2)
A vector container stores and manages its objects in a dynamic array. (3)
When you declare a vector object and specify its size as 10, then only
10 elements can be stored in the object. (4)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1556

| Chapter 21: Standard Template Library (STL)

Suppose vecList is avector object. The expression vecList.capacity()
returns the number of elements that can be currently added to
vecList. (4)
f.
The function resize is common to all containers. (4)
g. The function end returns the position of the last element in the
container. (5)
h. The function copy is used to copy the elements from one place to
another. (6)
i.
A range-based for loop can be used on sequence containers even if
they are declared as formal parameters to a function. (7)
j.
In a deque container, elements cannot be inserted in the middle. (8)
k. List containers are implemented as single linked lists. (8)
l.
Elements in an associative container are sorted according to some
ordering criteria. (10)
m. You can use iterators to step through the elements of container
adapters. (11)
n. A function object is a class template that overloads the function call
operator. (13)
o. Predicate function objects return int values. (13)
p. The function replace_if replaces all occurrences, within a given
range, of a given element with a new value. (14)
q. The function adjacent_find is used to find the first occurrence of
consecutive elements that meet certain criteria. (14)
What is the difference between an STL container and an STL iterator? (2)
What is the difference between an STL container and an STL algorithm? (2)
What is the difference between a set and a multiset? (10)
What is an STL function object? (13)
Suppose that vecList is a vector container and:
e.

2.
3.
4.
5.
6.

vecList = {22, 44, 3, 90, 13, 5, 75, 80, 10, 60}

Show vecList after the following statement executes: (3)
copy(vecList.begin() + 4, vecList.end(), vecList.begin() + 2);
7.

Suppose that vecList is a vector container and:
vecList = {14, 22, 60, 55, 12, 9, 45, 16, 25, 92, 11, 6}

Show vecList after the following statement executes: (3)
copy(vecList.rbegin() + 1, vecList.rend(), vecList.rbegin());

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

8.

|

1557

What is the output of the following C++ code? (7, 8)
list<int> intList;
int i;
for (i = 0; i < 5; i++)
intList.push_back(i * (i + 1));
for (auto p : intList)
cout << p << " ";
cout << endl;

9.

What is the output of the following C++ code? (7, 8)
list<int> intList(5);
int x = 0;
for (auto
{
if (x
p
else
p

&p : intList)
% 2 == 0)
= x * (x + 2);
= (x - 1) * (x + 3);

x++;
}
for (auto p : intList)
cout << p << " ";
cout << endl;
10.

Suppose that intList is a list container and: (8)
intList = {7, 12, 12, 7, 38, 27, 12, 38, 38, 70, 45}

Show intList after the following statement executes:
intList.unique();
11.

Suppose that intList1, intList2, and intList3 are list containers
and: (8)
intList1 = {13, 15, 16, 18, 90, 30, 11, 88, 26}
intList2 = {7, 8, 19, 90, 15}
intList3 = {12, 12, 14, 20, 20, 13, 13, 13}
a.

Show intList1 after the following statement executes:
intList1.splice(intList1.begin(), intList2);

b.

Show intList1 after the following statements execute. (Note that this
part is independent of part a.)
intList1.splice(intList1.begin(), intList3);
intList1.unique();

12.
13.

What is a predicate? (13)
What is the difference between a back_inserter and a front_inserter? (14)

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1558

14.

| Chapter 21: Standard Template Library (STL)

Suppose that you have the following statements:
int numList[] = {7, 6, 9, 1, 2, 3, 4};
vector<int> intVec;
list<int> intList;
a.

What are the contents of intVec after the following statement
executes? (14)
copy(numList, numList + 7, back_inserter(intVec));

b.

What are the contents of intList after the following statement
executes? (14)
copy(numList, numList + 7, front_inserter(intList));

15.

Suppose that you have the following statements:
vector<int> vec;
vector<int>::iterator intItr;

Suppose that vec ¼ {10, 9, 8, 7, 6, 5, 5, 8, 2}. What is the output of the
following statements? (15)
intItr = adjacent_find(vec.begin(), vec.end(), less_equal<int>());
cout << *intItr << endl;
16.

Suppose that you have the following statements:
char list[10] ¼ {'A', 'B', 'C', 'D', 'E', 'F', '*', '%', '$', '&'};
ostream_iterator<char> screen(cout, " ");
vector<char> charVec(list, list + 10);
swap_ranges(charVec.begin(), charVec.begin() + 3,
charVec.begin() + 6);

What is the output of the following statement? (15)
copy(charVec.begin(), charVec.end(), screen);
17.

Suppose that you have the following statements:
char list[10] = {'A', 'B', 'C', '*', 'E', '%', 'F', '$', 'H', '8'};
vector<char> charVec(list, list + 10);
ostream_iterator<char> screen(cout, " ");
transform(charVec.begin(), charVec.end(),
charVec.begin(), tolower);

What is the output of the following statement? (15)
copy(charVec.begin(), charVec.end(), screen);
18.

Suppose that charList is a vector container and:
charList = {' ', 'A', '\t', 'B', '\n', 'c', '*',
'9', '\r', 'h', '8'}

Further suppose that:
lastElem = remove_if(charList.begin(), charList.end(), isspace);
ostream_iterator<char> screen(cout, " ");

in which lastElem is a vector iterator into a vector container of type char.
What is the output of the following statement? (15)
copy(charList.begin(), lastElem, screen);
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Exercises

19.

|

1559

Suppose that intList is a vector container and:
numList[] = {18, 24, 24, 5, 11, 56, 27, 24, 11, 2, 24, 18,
78, 30, 24, 35, 48, 18, 11, 36, 11};

Furthermore, suppose that:
vector<int>::iterator lastElem = intList.end();
ostream_iterator<int> screen(cout, " ");
int tempList[] = {11, 18, 24};

What is the output of the following statement? (15)
for (int i = 0; i < 3; i++)
lastElem = remove_copy(intList.begin(), lastElem,
intList.begin(), tempList[i]);
copy(intList.begin(), lastElem, screen);
cout << endl;
20.

Suppose that intList is a vector container and:
intList = {8, 2, 9, 11, 15, 14, 6}

What is the value of result after the following statement executes? (15)
result = accumulate(intList.begin(), intList.end(), -5);
21.

Suppose that intList is a vector container and:
intList = {3, 3, 3, 3}

What is the value of result after the following statement executes? (15)
result = accumulate(intList.begin(), intList.end(),
729, divides<int>());
22.

Suppose that setA, setB, setC, and setD are defined as follows:
int
int
int
int

setA[]
setB[]
setC[]
setD[]

=
=
=
=

{1,
{2,
{2,
{3,

3,
5,
6,
5,

4,
7,
7,
5,

6, 7, 9, 10, 12};
8, 10, 12, 15};
7, 11};
11, 15, 18};

Further suppose that you have the following declarations:
int
int
int
int
int

AunionB[12];
AunionC[11];
BunionD[11];
AintersectB[3];
AintersectC[2];

What is stored in AunionB, AunionC, BunionD, AintersectB, and
AintersectC after the following statements execute? (15)
set_union(setA, setA +
set_union(setA, setA +
set_union(setB, setB +
set_intersection(setA,
set_intersection(setA,

8, setB, setB +
8, setC, setC +
7, setD, setD +
setA + 8, setB,
setA + 8, setC,

7, AunionB);
5, AunionC);
6, BunionD);
setB + 7, AintersectB);
setC + 5, AintersectC);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

2
1

1560

| Chapter 21: Standard Template Library (STL)

PROGRAMMING EXERCISES
1.

2.

3.

4.

5.

6.

7.

8.

Redo the Election Results programming example of Chapter 18 so that it
uses the STL class list to process candidates data.
Redo the DVD Store programming example of Chapter 16 so that it uses
the STL class list to process a list of DVDs.
Redo Programming Exercise 14 of Chapter 16 so that it uses the STL class
list to process the list of DVDs rented by the customer and the list of store
members.
Redo Programming Exercise 15 of Chapter 16 so that it uses the STL class
list to process the list of DVDs owned by the store, the list of DVDs
rented by each customer, and the list of store members.
Redo the Postfix Expression Calculator program of Chapter 17 so that it uses
the STL class stack to evaluate the postfix expressions.
Redo Programming Exercise 10 of Chapter 17 so that it uses the STL
class stack to convert the infix expressions to postfix expressions.
Redo the simulation program of Chapter 17 so that it uses the STL
class queue to maintain the list of waiting customers.
Write a program to play the Card Guessing Game. Your program must give
the user the following choices:
a.
b.
c.

Guess only the face value of the card.
Guess only the suit of the card.
Guess both the face value and suit of the card.

Before the start of the game, create a deck of cards. Before each guess, use
the function random_shuffle to randomly shuffle the deck.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

APPENDIX A

R ESERVED W ORDS

ª HunThomas/Shutterstock.com

and_eq
and
asm
auto
bitand
bitor
bool
break
case
catch
char
class
compl
const_cast
const
continue
default
delete
do

double
dynamic_cast
else
enum
explicit
export
extern
false
float
for
friend
goto
if
include
inline
int
long
mutable
namespace

new
not_eq
not
nullptr
operator
or_eq
or
private
protected
public
register
reinterpret_cast
return
short
signed
sizeof
static_cast
static
struct

switch
template
this
throw
true
try
typedef
typeid
typename
union
unsigned
using
virtual
void
volatile
wchar_t
while
xor_eq
xor

1561
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

APPENDIX B

O PERATOR P RECEDENCE

ª HunThomas/Shutterstock.com

The following table shows the precedence (highest to lowest) and associativity of the
operators in C++.
Operator

Associativity

:: (binary scope resolution)

Left to right

:: (unary scope resolution)

Right to left

()

Left to right

[]

->

++
typeid

.

Left to right

(as postfix operators)

Right to left
Right to left

dynamic_cast

static_cast

Right to left

const_cast

Right to left

reinterpret_cast
(as prefix operators)

++
~

& (address of)

new

delete

->*
*
+

!

+ (unary)

* (dereference)

Left to right
Left to right

>>

<

<=

==

!=

Right to left

Left to right

%

<<

Right to left

Right to left

sizeof
.*

/

- (unary)

Left to right

>

>=

Left to right
Left to right

&

Left to right

^

Left to right
1563

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1564

| Appendix B: Operator Precedence

Operator

Associativity

|

Left to right

&&

Left to right

||

Left to right

?:

Right to left

=
<<=

+=
>>=

-=

*=
&=

|=

/=
^=

%=

Right to left
Right to left

throw

Right to left

, (the sequencing operator)

Left to right

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

APPENDIX C

C HARACTER S ETS

ª HunThomas/Shutterstock.com

ASCII (American Standard Code for Information
Interchange)
The following table shows the ASCII character set.
ASCII
0

1

2

3

4

5

6

7

8

9

0

nul

soh

stx

etx

eot

enq

ack

bel

bs

ht

1

lf

vt

ff

cr

so

si

dle

dc1

dc2

dc3

2

dc4

nak

syn

etb

can

em

sub

esc

fs

gs

3

rs

us

b

!

"

#

$

%

&

'

4

(

)

*

+

,

-

.

/

0

1

5

2

3

4

5

6

7

8

9

:

;

6

<

=

>

?

@

A

B

C

D

E

7

F

G

H

I

J

K

L

M

N

O

8

P

Q

R

S

T

U

V

W

X

Y

9

Z

[

\

]

^

_

a

b

c

10

d

e

f

g

h

i

`
j

k

l

m

11

n

o

p

q

r

s

t

u

v

w

12

x

y

z

{

|

}

~

del

The numbers 0-12 in the first column specify the left digit(s), and the numbers 0-9 in the
second row specify the right digit of each character in the ASCII data set. For example,
1565
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1566

| Appendix C: Character Sets

the character in the row marked 6 (the number in the first column) and the column
marked 5 (the number in the second row) is A. Therefore, the character at position 65
(which is the 66th character) is A. Moreover, the character b at position 32 represents the
space character.
The first 32 characters, that is, the characters at positions 00-31 and at position 127 are
nonprintable characters. The following table shows the abbreviations and meanings of
these characters.
nul

null character

ff

form feed

can

cancel

soh

start of header

cr

carriage return

em

end of medium

stx

start of text

so

shift out

sub

substitute

etx

end of text

si

shift in

esc

escape

eot

end of transmission

dle

data link escape

fs

file separator

enq

enquiry

dc1

device control 1

gs

group separator

ack

acknowledge

dc2

device control 2

rs

record separator

bel

bell

dc3

device control 3

us

unit separator

bs

back space

dc4

device control 4

b

space

ht

horizontal tab

nak

negative acknowledge

del

delete

lf

line feed

syn

synchronous idle

vt

vertical tab

etb

end of transmitted block

EBCDIC (Extended Binary Coded Decimal
Interchange Code)
The following table shows some of the characters in the EBCDIC character set.
EBCDIC
0

1

2

3

6

4

6

7

8

9

.

<

(

+

|

Ø

-

/
%

_

b

7
8

&

9

!

10

5

$

*

)

;

,

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

EBCDIC (Extended Binary Coded Decimal Interchange Code) |

1567

EBCDIC
11

>

?

b

`
c

12
13

:

#

@

‘

=

"

d

e

f

g

h

i

j

k

l

m

n

14
15

o

16

a

p

q

r

~

s

t

u

v

w

x

y

z

A

B

C

D

E

F

G

17
18

[

]

19
20

H

I

21

K

L

J
M

N

O

P

22
23

W

X

Y

Z

24

0

1

2

3

4

5

Q

R

S

T

U

V

6

7

8

9

The numbers 6-24 in the first column specify the left digit(s), and the numbers 0-9 in the
second row specify the right digits of the characters in the EBCDIC data set. For
example, the character in the row marked 19 (the number in the first column) and the
column marked 3 (the number in the second row) is A. Therefore, the character at
position 193 (which is the 194th character) is A. Moreover, the character b at position 64
represents the space character. The preceding table does not show all the characters in the
EBCDIC character set. In fact, the characters at positions 00-63 and 250-255 are
nonprintable control characters.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

APPENDIX D

O PERATOR
O VERLOADING
ª HunThomas/Shutterstock.com

The following table lists the operators that can be overloaded.

Operators that can be overloaded
+

-

*

/

%

^

&

|

!

&&

||

=

==

<

<=

>

>=

!=

+=

-=

*=

/=

%=

^=

|=

&=

<<

>>

>>=

<<=

++

->*

,

->

[]

()

~

new

delete

The following table lists the operators that cannot be overloaded.

Operators that cannot be overloaded
.

.*

::

?:

sizeof

1569
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

APPENDIX E

ADDITIONAL C++
TOPICS
ª HunThomas/Shutterstock.com

Binary (Base 2) Representation
of a Nonnegative Integer
Converting a Base 10 Number to a Binary Number (Base 2)
Chapter 1 remarked that A is the 66th character in the ASCII character set, but its position
is 65 because the position of the first character is 0. Furthermore, the binary number
1000001 is the binary representation of 65. The number system that we use daily is
called the decimal number system or base 10 system. The number system that the
computer uses is called the binary number system or base 2 system. In this section,
we describe how to find the binary representation of a nonnegative integer and vice versa.
Consider 65. Note that:
65 ¼ 1  26 þ 0  25 þ 0  24 þ 0  23 þ 0  22 þ 0  21 þ 1  20
Similarly:
711 ¼ 1  29 þ 0  28 þ 1  27 þ 1  26 þ 0  25 þ 0  24 þ 0  23 þ 1  22 þ
1  21 þ 1  20
In general, if m is a nonnegative integer, then m can be written as:
m ¼ ak  2k þ ak1  2k1 þ ak2  2k2 þ    þ a1  21 þ a0  20 ;
for some nonnegative integer k, and where ai = 0 or 1, for each i = 0, 1, 2, . . ., k. The
binary number akak1ak2. . .a1a0 is called the binary or base 2 representation of m. In
this case, we usually write:
m10 ¼ ðak ak1 ak2    a1 a0 Þ2
and say that m to the base 10 is akak-1ak-2. . .a1a0 to the base 2.
For example, for the integer 65, k = 6, a6 = 1, a5 = 0, a4 = 0, a3 = 0, a2 = 0, a1 = 0, and
a0 = 1. Thus, a6a5a4a3a2a1a0 = 1000001, so the binary representation of 65 is 1000001, that is:
6510 ¼ ð1000001Þ2 :
If no confusion arises, then we write (1000001)2 as 10000012.
1571
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1572

| Appendix E: Additional C++ Topics

Similarly, for the number 711, k = 9, a9 = 1, a8 = 0, a7 = 1, a6 = 1, a5 = 0, a4 = 0, a3 = 0,
a2 = 1, a1 = 1, and a0 = 1. Thus:
71110 ¼ 10110001112 :
It follows that to find the binary representation of a nonnegative, we need to find the
coefficients, which are 0 or 1, of various powers of 2. However, there is an easy algorithm,
described next, that can be used to find the binary representation of a nonnegative integer.
First, note that:
010 ¼ 02 ; 110 ¼ 12 ; 210 ¼ 102 ; 310 ¼ 112 ; 410 ¼ 1002 ; 510 ¼ 1012 ; 610 ¼ 1102 ;
and 710 ¼ 1112 :
Let us consider the integer 65. Note that 65 / 2 = 32 and 65 % 2 = 1, where % is
the mod operator. Next, 32 / 2 = 16, and 32 % 2 = 0, and so on. It can be shown that
a0 = 65 % 2 = 1, a1 = 32 % 2 = 0, and so on. We can show this continuous division and
obtaining the remainder with the help of Figure E-1.

dividend / quotient

dividend / quotient
remainder

65
2

65 / 2 = 32 65 % 2 = 1 = a 0

2

32

2

32 / 2 = 16 32 % 2 = 0 = a 1

2

16

1 = a0
0 = a1

2

16 / 2 = 8

16 % 2 = 0 = a 2

2

8

0 = a2

2

8/2=4

8 % 2 = 0 = a3

2

4

0 = a3

2

4/2=2

4 % 2 = 0 = a4

2

2

0 = a4

2

2/2=1

2 % 2 = 0 = a5

2

1

0 = a5

1/2=0

1 % 2 = 1 = a6

0

1 = a6

(a)

FIGURE E-1

remainder

65

(b)

Determining the binary representation of 65

Notice that in Figure E-1(a), starting at the second row, the second column contains the
quotient when the number in the previous row is divided by 2 and the third column
contains the remainder of that division. For example, in the second row, 65 / 2 = 32, and
65 % 2 = 1. In the third row, 32 / 2 = 16 and 32 % 2 = 0, and so on. For each row, the
number in the second column is divided by 2, the quotient is written in the next row,
below the current row, and the remainder is written in the third column. When using a

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary (Base 2) Representation of a Nonnegative Integer

|

1573

figure, such as E-1, to find the binary representation of a nonnegative integer, typically,
we show only the quotients and remainders as in Figure E-1(b). You can write the binary
representation of the number starting with the last remainder in the third column,
followed by the second to last remainder, and so on. Thus:
6510 ¼ 10000012 :
Next, consider the number 711. Figure E-2 shows the quotients and the remainders.

dividend / quotient
remainder

711

FIGURE E-2

2

355

1 = a0

2

177

1 = a1

2

88

1 = a2

2

44

0 = a3

2

22

0 = a4

2

11

0 = a5

2

5

1 = a6

2

2

1 = a7

2

1

0 = a8

0

1 = a9

Determining the binary representation of 711

From Figure E-2, it follows that:
71110 ¼ 10110001112 :

Converting a Binary Number (Base 2) to Base 10
To convert a number from base 2 to base 10, we first find the weight of each bit in the
binary number. The weight of each bit in the binary number is assigned from right to left.
The weight of the rightmost bit is 0. The weight of the bit immediately to the left of the
rightmost bit is 1, the weight of the bit immediately to the left of it is 2, and so on.
Consider the binary number 1001101. The weight of each bit is as follows:
weight

6

5 4 3

2 1

0

1

0 0 1

1 0

1

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1574

| Appendix E: Additional C++ Topics

We use the weight of each bit to find the equivalent decimal number. For each bit, we
multiply the bit by 2 to the power of its weight and then we add all of the numbers. For
the above binary number, the equivalent decimal number is:
1  26 þ 0  25 þ 0  24 þ 1  23 þ 1  22 þ 0  21 þ 1  20
¼ 64 þ 0 þ 0 þ 8 þ 4 þ 0 þ 1
¼ 77:

Converting a Binary Number (Base 2) to Octal (Base 8)
and Hexadecimal (Base 16)
The previous sections described how to convert a binary number to a decimal number
(base 2). Even though the language of a computer is binary, if the binary number is too
long, then it will be hard to manipulate it manually. To effectively deal with binary
numbers, two more number systems, octal (base 8) and hexadecimal (base 16), are of
interest to computer scientists.
The digits in the octal number system are 0, 1, 2, 3, 4, 5, 6, and 7. The digits in the
hexadecimal number system are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F. So A in
hexadecimal is 10 in decimal, B in hexadecimal is 11 in decimal, and so on.
The algorithm to convert a binary number into an equivalent number in octal (or
hexadecimal) is quite simple. Before we describe the method to do so, let us review
some notations. Suppose ab represents the number a to the base b. For example, 2A016
means 2A0 to the base 16, and 638 means 63 to the base 8.
First we describe how to convert a binary number into an equivalent octal number and
vice versa. Table E-1 describes the first eight octal numbers.
TABLE E-1

Binary representation of first eight octal numbers

Binary

Octal

Binary

Octal

000

0

100

4

001

1

101

5

010

2

110

6

011

3

111

7

Consider the binary number 1101100010101. To find the equivalent octal number,
starting from right to left we consider three digits at a time and write their octal
representation. Note that the binary number 1101100010101 has only 13 digits. So when

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Binary (Base 2) Representation of a Nonnegative Integer

|

1575

we consider three digits at a time, at the end we will be left with only one digit. In this
case, we just add two 0s to the left of the binary number; the equivalent binary number is
001101100010101. Thus,
11011000101012 ¼ 0011011000101012
¼ 001 101 100 010 101
¼ 154258 because 0012 ¼ 18, 1012 ¼58, 1002 ¼ 48, 0102 ¼ 28,
and 1012 ¼ 58

Thus, 11011000101012 ¼ 154258.
To convert an octal number into an equivalent binary number, using Table E-1, write
the binary representation of each octal digit in the number. For example,
37618 ¼ 011 111 110 0012
¼ 0111111100012
¼ 111111100012

Thus, 37618 ¼ 111111100012.
Next we discuss how to convert a binary number into an equivalent hexadecimal number
and vice versa. The method to do so is similar to converting a number from binary to
octal and vice versa, except that here we work with four binary digits. Table E-2 gives
the binary representation of the first 16 hexadecimal numbers.
TABLE E-2

Binary representation of first 16 hexadecimal numbers

Binary

Hexadecimal

Binary

Hexadecimal

0000

0

1000

8

0001

1

1001

9

0010

2

1010

A

0011

3

1011

B

0100

4

1100

C

0101

5

1101

D

0110

6

1110

E

0111

7

1111

F

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1576

| Appendix E: Additional C++ Topics

Consider the binary number 11111010100010101012. Now,
11111010100010101012 ¼ 111 1101 0100 0101 01012
¼ 0111 1101 0100 0101 01012, add one zero to the left
¼ 7D45516

Hence, 11111010100010101012 ¼ 7D45516.
Next, to convert a hexadecimal number into an equivalent binary number, write the
four-digit binary representation of each hexadecimal digit into that number. For example,
A7F3216 ¼ 1010 0111 1111 0011 00102
¼ 101001111111001100102

Thus, A7F3216 ¼ 101001111111001100102.

More on File Input/Output
In Chapter 3, you learned how to read data from and write data to a file. This section
expands on the concepts introduced in that chapter.

Binary Files
In Chapter 3, you learned how to make a program read data from and write data to a file.
However, the files that the programs have used until now are called text files. Data in a
text file is stored in the character format. For example, consider the number 45. If 45 is
stored in a file, then it is stored as a sequence of two characters—the character '4'
followed by the character '5'. The eight-bit machine representation of '4' is
00000100 and the eight-bit machine representation of '5' is 00000101. Therefore,
in a text file, 45 is stored as 0000010000000101. When this number is read by a C++
program, it must first be converted to its binary format. Suppose that the integers are
represented as 16-bit binary numbers. The 16-bit binary representation of 45 is then
0000000000101101. Similarly, when a program stores the number 45 in a text file, it
first must be converted to its text format. It thus follows that reading data from and
writing data to a text file is not efficient, because the data must be converted from the text
to the binary format and vice versa.
On the other hand, when data is stored in a file in the binary format, reading and writing
data is faster because no time is lost in converting the data from one format to another
format. Such files are called binary files. More formally, binary files are files in which
data is stored in the binary format. Data in a text file is also called formatted data, and in
a binary file it is called raw data.
C++ allows a programmer to create binary files. This section explains how to create
binary files and also how to read data from binary files.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More on File Input/Output

|

1577

To create a binary file, the file must be opened in the binary mode. Suppose outFile is
an ofstream variable (object). Consider the following statement:
outFile.open("employee.dat", ios::binary);

This statement opens the file employee.dat. Data in this file will be written in its
binary format. Therefore, the file opening mode ios::binary specifies that the file is
opened in the binary mode.
Next, you use the stream function write to write data to the file employee.dat. The
syntax to use the function write is:
fileVariableName.write(reinterpret_cast<const char *> (buffer),
sizeof(buffer));

where fileVariableName is the object used to open the output file, and the first argument
buffer specifies the starting address of the location in memory where the data is stored. The
expression sizeof(buffer)specifies the size of the data, in bytes, to be written.
For example, suppose num is an int variable. The following statement writes the value of
num in the binary format to the file associated with outFile:
outFile.write(reinterpret_cast<const char *> (&num),
sizeof(num));

Similarly, suppose empSalary is an array of, say, 100 components and the component
type is double. The following statement writes the entire array to the file associated with
outFile:
outFile.write(reinterpret_cast<const char *> (empSalary),
sizeof(empSalary));

Next, let us discuss how to read data from a binary file. The operation of reading data
from a binary file is similar to writing data to a binary file. First, the binary file must be
opened. For example, suppose inFile is an ifstream variable, and a program has
already created the binary file employee.dat. The following statement opens this file:
inFile.open("employee.dat");

or:
inFile.open("employee.dat", ios::binary);

To read data in the binary format, the stream function read is used. The syntax to use
the function read is:
fileVariableName.read(reinterpret_cast<char *> (buffer),
sizeof(buffer));

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1578

| Appendix E: Additional C++ Topics

The first argument buffer specifies the starting address of the location in memory where
the data is to be stored. The expression sizeof(buffer) specifies the size of the data,
in bytes, to be read.
The program in the following example further explains how to create binary files and
read data from a binary file.
EXAMPLE E-1
//Creating and reading binary files
#include <iostream>
#include <fstream>
using namespace std;
struct studentType
{
char firstName[15];
char lastName[15];
int ID;
};
int main()
{
//create and initialize an array of students’ IDs
int studentIDs[5] = {111111, 222222, 333333,
444444, 555555};
//Line 1
//declare and initialize the struct newStudent
studentType newStudent = {"John", "Wilson",
777777};
//Line 2
ofstream outFile;

//Line 3

//open the output file as a binary file
outFile.open("ids.dat", ios::binary);

//Line 4

//write the array in the binary format
outFile.write(reinterpret_cast<const char *> (studentIDs),
sizeof(studentIDs));
//Line 5
//write the newStudent data in the binary format
outFile.write(reinterpret_cast<const char *> (&newStudent),
sizeof(newStudent));
//Line 6
outFile.close();

//close the file

ifstream inFile;
int arrayID[5];
studentType student;

//Line 7
//Line 8
//Line 9
//Line 10

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More on File Input/Output

//open the input file
inFile.open("ids.dat");

|

1579

//Line 11

if (!inFile)
//Line 12
{
cout << "The input file does not exist. "
<< "The program terminates!!!!" << endl; //Line 13
return 1;
//Line 14
}
//input the data into the array arrayID
inFile.read(reinterpret_cast<char *> (arrayID),
sizeof(arrayID));
//output the data of the array arrayID
for (int i = 0; i < 5; i++)
cout << arrayID[i] << " ";
cout << endl;

//Line 15
//Line 16
//Line 17
//Line 18

//read the student's data
inFile.read(reinterpret_cast<char *> (&student),
sizeof(student));

//Line 19

//output studentData
cout << student.ID << " " << student.firstName
<< " " << student.lastName << endl;

//Line 20

inFile.close();

//close the file

return 0;

//Line 21
//Line 22

}

Sample Run:
111111 222222 333333 444444 555555
777777 John Wilson

The output of the preceding program is self-explanatory. The details are left as an exercise
for you.

In the program in Example E-1, the statement in Line 2 declares the struct variable
newStudent and also initializes it. Because newStudent has three components and
we want to initialize all the components, three values are specified in braces separated by
commas. In other words, struct variables can also be initialized when they are
declared.

The program in the following example further explains how to create binary files and
then read the data from the binary files.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1580

| Appendix E: Additional C++ Topics

EXAMPLE E-2
//Creating and reading a binary file consisting of
//bank customers' data
#include <iostream>
#include <fstream>
#include <iomanip>
using namespace std;
struct customerType
{
char firstName[15];
char lastName[15];
int ID;
double balance;
};
int main()
{
customerType cust;
ifstream inFile;
ofstream outFile;
inFile.open("customerData.txt");

//Line 1
//Line 2
//Line 3
//Line 4

if (!inFile)
//Line 5
{
cout << "The input file does not exist. "
<< "The program terminates!!!!" << endl; //Line 6
return 1;
//Line 7
}
outFile.open("customer.dat", ios::binary);

//Line 8

inFile >> cust.ID >> cust.firstName >> cust.lastName
>> cust.balance;
//Line 9
while (inFile)
//Line 10
{
outFile.write(reinterpret_cast<const char *> (&cust),
sizeof(cust));
//Line 11
inFile >> cust.ID >> cust.firstName >> cust.lastName
>> cust.balance;
//Line 12
}
inFile.close();
inFile.clear();
outFile.close();

//Line 13
//Line 14
//Line 15

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More on File Input/Output

inFile.open("customer.dat", ios::binary);

|

1581

//Line 16

if (!inFile)
//Line 17
{
cout << "The input file does not exist. "
<< "The program terminates!!!!" << endl; //Line 18
return 1;
//Line 19
}
cout <<
<<
<<
<<
cout <<

left << setw(8) << "ID"
setw(16) << "First Name"
setw(16) << "Last Name"
setw(10) << " Balance" << endl;
fixed << showpoint << setprecision(2);

//read and output the data from the binary
//file customer.dat
inFile.read(reinterpret_cast<char *> (&cust),
sizeof(cust));
while (inFile)
{
cout << left << setw(8) << cust.ID
<< setw(16) << cust.firstName
<< setw(16) << cust.lastName
<< right << setw(10) << cust.balance
<< endl;
inFile.read(reinterpret_cast<char *> (&cust),
sizeof(cust));
}
inFile.close();

//close the file

//Line 20
//Line 21

//Line 22
//Line 23

//Line 24
//Line 25
//Line 26

return 0;

//Line 27

}

Sample Run:
ID
77234
12345
87123
81234
11111
23422
22222
54234
55555
23452
32657
82722

First Name
Ashley
Brad
Lisa
Sheila
Rita
Ajay
Jose
Sheila
Tommy
Salma
Jennifer
Steve

Last Name
White
Smith
Johnson
Robinson
Gupta
Kumar
Ramey
Duffy
Pitts
Quade
Ackerman
Sharma

Balance
4563.50
128923.45
2345.93
674.00
14863.50
72682.90
25345.35
65222.00
892.85
2812.90
9823.89
78932.00

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1582

| Appendix E: Additional C++ Topics

Random File Access
In Chapter 3 and the preceding section, you learned how to read data from and write data
to a file. More specifically, you used ifstream objects to read data from a file and
ofstream objects to write data to a file. However, the files were read and/or written
sequentially. Reading data from a file sequentially does not work very well for a variety of
applications. For example, consider a program that processes customers’ data in a bank.
Typically, there are thousands or even millions of customers in a bank. Suppose we want
to access a customer’s data from the file that contains such data, say, for an account
update. If the data is accessed sequentially, starting from the first position and read until
the desired customer’s data is found, this process might be extremely time consuming.
Similarly, in an airline’s reservation system to access a passenger’s reservation information
sequentially, this might also be very time consuming. In such cases, the data retrieval must
be efficient. A convenient way to do this is to be able to read the data randomly from a
file, that is, randomly access any record in the file.
In the preceding section, you learned how to use the stream function read to read a
specific number of bytes, and the function write to write a specific number of bytes.
The stream function seekg is used to move the read position to any byte in the file. The
general syntax to use the function seekg is:
fileVariableName.seekg(offset, position);

The stream function seekp is used to move the write position to any byte in the file.
The general syntax to use the function seekp is:
fileVariableName.seekp(offset, position);

The offset specifies the number of bytes the reading/writing positions are to be
moved, and position specifies where to begin the offset. The offset can be calculated
from the beginning of the file, end of the file, or the current position in the file.
Moreover, offset is a long integer representation of an offset. Table E-3 shows the
values that can be used for position.
TABLE E-3

Values of position

position

Description

ios::beg

The offset is calculated from the beginning of the file.

ios::cur

The offset is calculated from the current position of the reading marker
in the file.

ios::end

The offset is calculated from the end of the file.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More on File Input/Output

|

1583

EXAMPLE E-3
Suppose

you

have

the

following

line

of

text

stored

in

a

file,

say,

digitsAndLetters.txt:
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ

Also, suppose that inFile is an ifstream object and the file digitsAndLetters.txt
has been opened using the object inFile. One byte is used to store each character of this
line of text. Moreover, the position of the first character is 0.
Statement

Explanation

inFile.seekp(10L, ios::beg);

Sets the reading position of inFile to the 11th
byte (character), which is at position 10. That is, it
sets the reading position just after the digit 9 or
just before the letter A.

inFile.seekp(5L, ios::cur);

Moves the reading position of inFile five bytes
to the right of its current position.

inFile.seekp(-6L, ios::end);

Sets the reading position of inFile to the sixth
byte (character) from the end. That is, it sets the
reading position just before the letter U.

The program in the following example further explains how the functions seekg and
seekp work.
EXAMPLE E-4
#include <iostream>
#include <fstream>
using namespace std;
int main()
{
char ch;
ifstream inFile;

//Line 1
//Line 2

inFile.open("digitsAndAlphabet.txt");

//Line 3

if (!inFile)
{
cout << "The input file does not exist. "
<< "The program terminates!!!!" << endl;
return 1;
}

//Line 4
//Line 5
//Line 6

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1584

| Appendix E: Additional C++ Topics

inFile.get(ch);
//Line 7
cout << "Line 8: The first byte: " << ch << endl; //Line 8
//position the reading marker six bytes to the
//right of its current position
inFile.seekg(6L, ios::cur);
//Line 9
inFile.get(ch); //read the character
//Line 10
cout << "Line 11: Current byte read: " << ch
<< endl;
//Line 11
//position the reading marker seven bytes
//from the beginning
inFile.seekg(7L, ios::beg);
//Line 12
inFile.get(ch); //read the character
//Line 13
cout << "Line 14: Seventh byte from the beginning: "
<< ch << endl;
//Line 14
//position the reading marker 26 bytes
//from the end
inFile.seekg(-26L, ios::end);
inFile.get(ch); //read the character
cout << "Line 17: Byte 26 from the end: " << ch
<< endl;

//Line 15
//Line 16

return 0;

//Line 18

//Line 17

}

Sample Run:
Line
Line
Line
Line

8: The first byte: 0
11: Current byte read: 7
14: Seventh byte from the beginning: 7
17: Byte 26 from the end: A

The input file contains the following line of text:
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ

The following program illustrates how the function seekg works with structs.
EXAMPLE E-5
Suppose customerType is a struct defined as follows:
struct customerType
{
char firstName[15];
char lastName[15];
int ID;
double balance;
};

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More on File Input/Output

|

1585

The program in Example E-2 created the binary file customer.dat consisting of
certain customers’ data. You can use the function seekg to move the reading position
of this file to any record. Suppose inFile is an ifstream object used to open the
binary file customer.dat.
The following statement calculates the size of a customerType struct and stores it in
the variable custSize:
long custSize = sizeof(cust);

We can use the value of the variable custSize to move the reading position to a specific
record in the file. For example, consider the following statement:
inFile.seekg(6 * custSize, ios::beg);

This statement moves the reading position just after the sixth customer’s record, that is,
just before the seventh customer’s record.
The following program further illustrates how the function seekg works with structs.
EXAMPLE E-6
//Reading a file randomly
#include <iostream>
#include <fstream>
#include <iomanip>
using namespace std;
struct customerType
{
char firstName[15];
char lastName[15];
int ID;
double balance;
};
void printCustData(const customerType& customer);
int main()
{
customerType cust;
ifstream inFile;

//Line 1
//Line 2

long custSize = sizeof(cust);

//Line 3

inFile.open("customer.dat", ios::binary);
if (!inFile)

//Line 4
//Line 5

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1586

| Appendix E: Additional C++ Topics

{
cout << "The input file does not exist. "
<< "The program terminates!!!!" << endl; //Line 6
return 1;
//Line 7
}
cout << fixed << showpoint << setprecision(2);
//randomly read the records and output them
inFile.seekg(6 * custSize, ios::beg);
inFile.read(reinterpret_cast<char *> (&cust),
sizeof(cust));
cout << "Seventh customer's data: " << endl;
printCustData(cust);
inFile.seekg(8 * custSize, ios::beg);
inFile.read(reinterpret_cast<char *> (&cust),
sizeof(cust));
cout << "Ninth customer's data: " << endl;
printCustData(cust);

//Line 8
//Line 9
//Line 10
//Line 11
//Line 12
//Line 13
//Line 14
//Line 15

inFile.seekg(-8 * custSize, ios::end);
//Line 16
inFile.read(reinterpret_cast<char *> (&cust),
sizeof(cust));
//Line 17
cout << "Eighth (from the end) customer's data: "
<< endl;
//Line 18
printCustData(cust);
//Line 19
inFile.close();

//close the file

return 0;

//Line 20
//Line 21

}
void printCustData(const customerType& customer)
{
cout << " ID: " << customer.ID <<endl
<< " First Name: " << customer.firstName <<endl
<< " Last Name: " << customer.lastName <<endl
<< " Account Balance: $" << customer.balance
<< endl;
}

Sample Run:
Seventh customer's data:
ID: 22222
First Name: Jose
Last Name: Ramey
Account Balance: $25345.35
Ninth customer's data:
ID: 55555
First Name: Tommy
Last Name: Pitts

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More on File Input/Output

|

1587

Account Balance: $892.85
Eighth (from the end) customer's data:
ID: 11111
First Name: Rita
Last Name: Gupta
Account Balance: $14863.50

The program in Example E-6 illustrates how the function seekg works. Using the
function seekg, the reading position in a file can be moved to any location in the file.
Similarly, the function seekp can be used to move the write position in a file to any
location. Furthermore, these functions can be used to create a binary file in which the
data is organized according to the values of either a variable or a particular component of
a struct. For example, suppose there are at most, say, 100 students in a class. Each
student has a unique ID in the range 1 to 100. Using the students’ IDs, we can create a
random access binary file in such a way that in the file, a student’s data is written at the
location specified by its ID. This is like treating the file as an array. The advantage is that,
once the file is created, a student’s data from the file can be read, directly, using the
student’s ID. Another advantage is that in the file, the data is sorted according to the IDs.
Here, we are assuming that the student IDs are in the range 1 to 100. However, if you use,
say, a three-, four-, or five-digit number as a student ID and there are only a few students in
the class, the data in the file could be scattered. In other words, a lot of space could be used
just to store only a few students’ data. In such cases, more advanced techniques are used to
organize the data so that it can be accessed efficiently.
The program in Example E-7 illustrates how to use the students’ IDs to organize the data
in a binary file. The program also shows how to output the file.

EXAMPLE E-7
//Creating and reading a random access file.
#include <iostream>
#include <fstream>
#include <iomanip>
using namespace std;
struct studentType
{
char firstName[15];
char lastName[15];
int ID;
double GPA;
};
void printStudentData(const studentType& student);

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1588

| Appendix E: Additional C++ Topics

int main()
{
studentType st;
ifstream inFile;
ofstream outFile;

//Line 1
//Line 2
//Line 3

long studentSize = sizeof(st);

//Line 4

//open the input file, which is a text file
inFile.open("studentData.txt");

//Line 5

if (!inFile)
//Line 6
{
cout << "The input file does not exist. "
<< "The program terminates!!!!" << endl; //Line 7
return 1;
//Line 8
}
//open a binary output file
outFile.open("student.dat", ios::binary);

//Line 9

inFile >> st.ID >> st.firstName
>> st.lastName >> st.GPA;

//Line 10

while (inFile)
//Line
{
outFile.seekp((st.ID - 1) * studentSize,
ios::beg);
//Line
outFile.write(reinterpret_cast<const char *> (&st),
sizeof(st));
//Line
inFile >> st.ID >> st.firstName
>> st.lastName >> st.GPA;
//Line
};

11
12
13
14

inFile.close();
inFile.clear();
outFile.close();

//Line 15
//Line 16
//Line 17

cout <<
<<
<<
<<
cout <<

//Line 18
//Line 19

left << setw(3) << "ID"
setw(16) << "First Name"
setw(16) << "Last Name"
setw(12) << "Current GPA" << endl;
fixed << showpoint << setprecision(2);

//open the input file, which is a binary file
inFile.open("student.dat", ios::binary);
//Line 20
if (!inFile)
{
cout << "The input file does not exist. "
<< "The program terminates!!!!" << endl;
return 1;
}

//Line 21
//Line 22
//Line 23

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

More on File Input/Output

//read the data at location 0 in the file
inFile.read(reinterpret_cast<char *> (&st),
sizeof(st));
while (inFile)
{
if (st.ID != 0)
printStudentData(st);

|

1589

//Line 24
//Line 25
//Line 26
//Line 27

//read the data at the current reading position
inFile.read(reinterpret_cast<char *> (&st),
sizeof(st));
//Line 28
};
return 0;

//Line 29

}
void printStudentData(const studentType& student)
{
cout << left << setw(3) << student.ID
<< setw(16) << student.firstName
<< setw(16) << student.lastName
<< right << setw(10)<< student.GPA
<< endl;
}

Sample Run:
ID
2
10
12
16
23
34
36
41
45
56
67
75

First Name
Sheila
Ajay
Ashley
Tommy
Rita
Brad
Salma
Steve
Sheila
Lisa
Jose
Jennifer

Last Name
Duffy
Kumar
White
Pitts
Gupta
Smith
Quade
Sharma
Robinson
Johnson
Ramey
Ackerman

Current GPA
4.00
3.60
3.90
2.40
3.40
3.50
3.90
3.50
2.50
2.90
3.80
4.00

The data in the file studentData.txt is as follows:
12 Ashley White 3.9
34 Brad Smith 3.5
56 Lisa Johnson 2.9
45 Sheila Robinson 2.5
23 Rita Gupta 3.4
10 Ajay Kumar 3.6
67 Jose Ramey 3.8
2 Sheila Duffy 4.0
16 Tommy Pitts 2.4

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1590

| Appendix E: Additional C++ Topics

36 Salma Quade 3.9
75 Jennifer Ackerman 4.0
41 Steve Sharma 3.5

Naming Conventions of Header Files in ANSI/ISO
Standard C++ and Standard C++
The programs in this book are written using ANSI/ISO Standard C++. As indicated
in Chapter 1, there are two versions of C++—ANSI/ISO Standard C++ and
Standard C++. For the most part, these two standards are the same. The header
files in Standard C++ have the extension .h, while the header files in ANSI/ISO
Standard C++ have no extension. Moreover, the names of certain header files, such
as math.h, in ANSI/ISO Standard C++ start with the letter c. The language C++
evolved from C. Therefore, certain header files—such as math.h, stdlib.h, and
string.h—were brought from C into C++. The header files—such as
iostream.h, iomanip.h, and fstream.h—were specially designed for C++.
Recall that when a header file is included in a program, the global identifiers of
the header file also become the global identifiers of the program. In ANSI/ISO
Standard C++, to take advantage of the namespace mechanism, all of the header
files were modified so that the identifiers are declared within a namespace. Recall
that the name of this namespace is std.
In ANSI/ISO Standard C++, the extension .h of the header files that were specially
designed for C++ was dropped. For the header files that were brought from C into C++,
the extension .h was dropped and the names of these header files start with the letter c.
Following are the names of the most commonly used header files in Standard C++ and
ANSI/ISO Standard C++:
Standard C++ Header File Name

ANSI/ISO Standard C++ Header File Name

assert.h
ctype.h
float.h
fstream.h
iomanip.h
iostream.h
limits.h
math.h
stdlib.h
string.h

cassert
cctype
cfloat
fstream
iomanip
iostream
climits
cmath
cstdlib
cstring

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Naming Conventions of Header Files in ANSI/ISO Standard C++ and Standard C++ |

1591

To include a header file, say, iostream, the following statement is required:
#include <iostream>

Furthermore, to use identifiers, such as cin, cout, endl, and so on, the program should
use either the statement:
using namespace std;

or the prefix std:: before the identifier.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

APPENDIX F

HEADER FILES

ª HunThomas/Shutterstock.com

The C++ standard library contains many predefined functions, named constants, and
specialized data types. This appendix discusses some of the most widely used library
routines (and several named constants). For additional explanation and information on
functions, named constants, and so on, check your system documentation. The names of
the Standard C++ header files are shown in parentheses.

Header File cassert (assert.h)
The following table describes the function assert. Its specification is contained in the
header file cassert (assert.h).
assert(expression)

expression is any
int expression;
expression is usually

• If the value of expression

a logical expression

•

is nonzero (true), the
program continues to execute.
If the value of expression
is 0 (false), execution of
the program terminates
immediately. The expression,
the name of the file containing
the source code, and the line
number in the source code are
displayed.

To disable all of the assert statements, place the preprocessor directive #define
NDEBUG before the directive #include <cassert>.

1593
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1594

| Appendix F: Header Files

Header File cctype (ctype.h)
The following table shows various functions from the header file cctype (ctype.h).
Function Name
and Parameters

Parameter(s) Types

isalnum(ch)

ch is a char value

Function Return Value
Function returns an int value as follows:

• If ch is a letter or a digit character, that is
('A'-'Z', 'a'-'z', '0'-'9'), it
returns a nonzero value (true)
• 0 (false), otherwise
iscntrl(ch)

ch is a char value

Function returns an int value as follows:

• If ch is a control character (in ASCII, a
character value 0-31 or 127), it returns a
nonzero value (true)

• 0 (false), otherwise
isdigit(ch)

ch is a char value

Function returns an int value as follows:

• If ch is a digit ('0'-'9'), it returns a
nonzero value (true)

• 0 (false), otherwise
islower(ch)

ch is a char value

Function returns an int value as follows:

• If ch is lowercase ('a'-'z'), it returns a
nonzero value (true)

• 0 (false), otherwise
isprint(ch)

ch is a char value

Function returns an int value as follows:

• If ch is a printable character, including blank
(in ASCII, ' ' through '~'), it returns
a nonzero value (true)

• 0 (false), otherwise
ispunct(ch)

ch is a char value

Function returns an int value as follows:

• If ch is a punctuation character, it returns a
nonzero value (true)

• 0 (false), otherwise
isspace(ch)

ch is a char value

Function returns an int value as follows:

• If ch is a whitespace character (blank,
newline, tab, carriage return, form feed), it
returns a nonzero value (true)

• 0 (false), otherwise

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Header File cfloat (float.h)

Function Name
and Parameters

Parameter(s) Types

Function Return Value

isupper(ch)

ch is a char value

Function returns an int value as follows:

|

1595

• If ch is an uppercase letter ('A'-'Z'), it
returns a nonzero value (true)

• 0 (false), otherwise
tolower(ch)

ch is a char value

Function returns an int value as follows:

• If ch is an uppercase letter, it returns the
ASCII value of the lowercase equivalent of ch

• ASCII value of ch, otherwise
toupper(ch)

ch is a char value

Function returns an int value as follows:

• If ch is a lowercase letter, it returns the ASCII
value of the uppercase equivalent of ch

• ASCII value of ch, otherwise

Header File cfloat (float.h)
In Chapter 2, we listed the largest and smallest values belonging to the floating-point data
types. We also remarked that these values are system dependent. These largest and
smallest values are stored in named constants. The header file cfloat contains many
such named constants. The following table lists some of these constants.

Named Constant

Description

FLT_DIG

Approximate number of significant digits in a float value

FLT_MAX

Maximum positive float value

FLT_MIN

Minimum positive float value

DBL_DIG

Approximate number of significant digits in a double value

DBL_MAX

Maximum positive double value

DBL_MIN

Minimum positive double value

LDBL_DIG

Approximate number of significant digits in a long double value

LDBL_MAX

Maximum positive long double value

LDBL_MIN

Minimum positive long double value

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1596

| Appendix F: Header Files

A program similar to the following can print the values of these named constants on your
system:
#include <iostream>
#include <cfloat>
using namespace std;
int main()
{
cout <<
<<
cout <<
<<
cout <<
<<
cout <<
<<
cout <<
<<
cout <<
<<
cout <<
<<
cout <<
<<
cout <<
<<

"Approximate number of significant digits "
"in a float value " << FLT_DIG << endl;
"Maximum positive float value " << FLT_MAX
endl;
"Minimum positive float value " << FLT_MIN
endl;
"Approximate number of significant digits "
"in a double value " << DBL_DIG << endl;
"Maximum positive double value " << DBL_MAX
endl;
"Minimum positive double value " << DBL_MIN
endl;
"Approximate number of significant digits "
"in a long double value " << LDBL_DIG << endl;
"Maximum positive long double value " << LDBL_MAX
endl;
"Minimum positive long double value " << LDBL_MIN
endl;

return 0;
}

Header File climits (limits.h)
In Chapter 2, we listed the largest and smallest values belonging to the integral data types.
We also remarked that these values are system dependent. These largest and smallest
values are stored in named constants. The header file climits contains many such
named constants. The following table lists some of these constants.
Named Constant

Description

CHAR_BIT

Number of bits in a byte

CHAR_MAX

Maximum char value

CHAR_MIN

Minimum char value

SHRT_MAX

Maximum short value

SHRT_MIN

Minimum short value

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Header File climits (limits.h)

Named Constant

Description

INT_MAX

Maximum int value

INT_MIN

Minimum int value

LONG_MAX

Maximum long value

LONG_MIN

Minimum long value

LLONG_MAX

Maximum long long value

LLONG_MIN

Minimum long long value

UCHAR_MAX

Maximum unsigned char value

USHRT_MAX

Maximum unsigned short value

UINT_MAX

Maximum unsigned int value

ULONG_MAX

Maximum unsigned long value

|

1597

A program similar to the following can print the values of these named constants on your system:
#include <iostream>
#include <climits>
using namespace std;
int main()
{
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
<<
cout <<
<<
cout <<
cout <<
<<

"Number of bits in a byte " << CHAR_BIT << endl;
"Maximum char value " << CHAR_MAX << endl;
"Minimum char value " << CHAR_MIN << endl;
"Maximum short value " << SHRT_MAX << endl;
"Minimum short value " << SHRT_MIN << endl;
"Maximum int value " << INT_MAX << endl;
"Minimum int value " << INT_MIN << endl;
"Maximum long value " << LONG_MAX << endl;
"Minimum long value " << LONG_MIN << endl;
"Maximum long long value " << LLONG_MAX << endl;
"Minimum long long value " << LLONG_MIN << endl;
"Maximum unsigned char value " << UCHAR_MAX
endl;
"Maximum unsigned short value " << USHRT_MAX
endl;
"Maximum unsigned int value " << UINT_MAX << endl;
"Maximum unsigned long value " << ULONG_MAX
endl;

return 0;
}
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1598

| Appendix F: Header Files

Header File cmath (math.h)
The following table shows various math functions.

Function Name
and Parameters

Parameter(s) Type

Function Return Value

acos(x)

x is a floating-point expression,
–1.0  x  1.0

Arc cosine of x, a value between 0.0 and p

asin(x)

x is a floating-point expression,
–1.0  x  1.0

Arc sine of x, a value between -p/2
and p/2

atan(x)

x is a floating-point expression

Arc tan of x, a value between -p/2 and p/2

ceil(x)

x is a floating-point expression

The smallest whole number  x,
(‘‘ceiling’’ of x)

cos(x)

x is a floating-point expression,
x is measured in radians

Trigonometric cosine of the angle

cosh(x)

x is a floating-point expression

Hyperbolic cosine of x

exp(x)

x is a floating-point expression

The value e raised to the power of x;
(e = 2.718. . .)

fabs(x)

x is a floating-point expression

Absolute value of x

floor(x)

x is a floating-point expression

The largest whole number  x; (‘‘floor’’ of x)

log(x)

x is a floating-point expression,
in which x > 0.0

Natural logarithm (base e) of x

log10(x)

x is a floating-point expression,
in which x > 0.0

Common logarithm (base 10) of x

pow(x,y)

x and y are floating-point
expressions. If x = 0.0,
y must be positive;
if x  0.0, y must

x raised to the power of y

be a whole number.

sin(x)

x is a floating-point expression;
x is measured in radians

Trigonometric sine of the angle

sinh(x)

x is a floating-point expression

Hyperbolic sine of x

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Header File cmath (math.h)

Function Name
and Parameters

Parameter(s) Type

Function Return Value

sqrt(x)

x is a floating-point expression,
in which x  0.0

Square root of x

tan(x)

x is a floating-point expression;
x is measured in radians

Trigonometric tangent of the angle

tanh(x)

x is a floating-point expression

Hyperbolic tangent of x

|

1599

Header File cstddef (stddef.h)
Among others, this header file contains the definition of the following symbolic constant:
NULL: The system-dependent null pointer (usually 0)

Header File cstring (string.h)
The following table shows various string functions.

Function Name and
Parameters

Parameter(s) Type

Function Return Value

strcat(destStr, srcStr)

destStr and srcStr
are null-terminated char
arrays; destStr must be

destStr is returned;
srcStr, including the

large enough to hold the
result

null character, is
concatenated to the end of

The base address of

destStr
strcmp(str1, str2)

str1 and str2 are nullterminated char arrays

The returned value is as
follows:

• An int value < 0 if
str1 < str2

• An int value 0 if
str1 = str2

• An int value > 0 if
str1 > str2

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1600

| Appendix F: Header Files

Function Name and
Parameters

Parameter(s) Type

strcpy(destStr, srcStr)

destStr and
srcStr are
null-terminated char
arrays

strlen(str)

str is a null-terminated
char array

Function Return Value

The base address of

destStr is returned;
srcStr is copied into
destStr
An integer value  0
specifying the length of
the str (excluding the
'\0') is returned

HEADER FILE string

This header file—not to be confused with the header file cstring—supplies a programmerdefined data type named string. Associated with the string type are a data type
string::size_type and a named constant string::npos. These are defined as follows:
string::size_type

An unsigned integer type

string::npos

The maximum value of type string::size_type

The type string contains several functions for string manipulation. In addition to the
string functions listed in Table 7-1, the following table describes additional string functions.
In this table, we assume that strVar is a string variable and str is a string variable, a
string constant, or a character array. The name of the function is shown in bold.
Expression

Effect

getline(istreamVar, strVar); istreamVar is an input stream variable (of type
istream or ifstream).
Characters until the newline character are input
from istreamVar and stored in strVar. (The
newline character is read but not stored into
strVar.) The value returned by this function is
usually ignored.

strVar.append(str, n);

The first n characters of the character array str are
appended to strVar.

strVar.c_str()

The base address of a null-terminated C-string
corresponding to the characters in strVar.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Header File cmath (math.h)

|

1601

Expression

Effect

strVar.capacity()

Returns the size of the storage allocated for strVar.

strVar.erase(pos);

pos is a parameter of type
string::size_type.
Removes all of the characters from strVar starting
at index pos.

strVar.resize(n, ch);

Changes the size of storage allocation for strVar
to n. If n is less than the current storage size of
strVar, the storage size of the string is truncated
to n. If n is greater than the current storage size, the
string is expanded to size n and the additional space
is filled with copies of the character specified by the
char variable ch.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

APPENDIX G

MEMORY SIZE ON A
SYSTEM AND RANDOM
NUMBER GENERATOR
ª HunThomas/Shutterstock.com

A program similar to the following prints the memory size of the built-in data types on
your system. (The output of the program shows the size of the built-in data type on
which this program was run.)
#include <iostream>
using namespace std;
int main()
{
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
cout <<
<<
cout <<
<<

"Size of char = " << sizeof(char) << endl;
"Size of int = " << sizeof(int) << endl;
"Size of short = " << sizeof(short) << endl;
"Size of unsigned int = " << sizeof(unsigned int) << endl;
"Size of long = " << sizeof(long) << endl;
"Size of long long = " << sizeof(long long) << endl;
"Size of bool = " << sizeof(bool) << endl;
"Size of float = " << sizeof(float) << endl;
"Size of double = " << sizeof(double) << endl;
"Size of long double = " << sizeof(long double) << endl;
"Size of unsigned short = "
sizeof(unsigned short) << endl;
"Size of unsigned long = "
sizeof(unsigned long) << endl;

return 0;
}

Sample Run:
Size
Size
Size
Size
Size
Size
Size
Size
Size
Size
Size
Size

of
of
of
of
of
of
of
of
of
of
of
of

char = 1
int = 4
short = 2
unsigned int = 4
long = 4
long long = 8
bool = 1
float = 4
double = 8
long double = 8
unsigned short = 2
unsigned long = 4
1603

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1604

| Appendix G: Memory Size on a System and Random Number Generator

Random Number Generator
To generate a random number, you can use the C++ function rand. To use the function
rand, the program must include the header file cstdlib. The header file cstdlib also
contains the constant RAND_MAX. Typically, the value of RAND_MAX is 32767. To find
the exact value of RAND_MAX, check your system’s documentation. The function rand
generates an integer between 0 and RAND_MAX. The following program illustrates how to
use the function rand. It also prints the value of RAND_MAX:
#include <iostream>
#include <cstdlib>
#include <iomanip>
using namespace std;
int main()
{
cout <<
cout <<
cout <<
cout <<
<<
cout <<
<<

fixed << showpoint << setprecision(5);
"The value of RAND_MAX: " << RAND_MAX << endl;
"A random number: " << rand() << endl;
"A random number between 0 and 9: "
rand() % 10 << endl;
"A random number between 0 and 1: "
static_cast<double> (rand())
/ static_cast<double>(RAND_MAX)
<< endl;

return 0;
}

Sample Run:
The value of RAND_MAX: 32767
A random number: 41
A random number between 0 and 9: 7
A random number between 0 and 1: 0.19330

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

APPENDIX H

REFERENCES

ª HunThomas/Shutterstock.com

1. G. Booch, Object-Oriented Analysis and Design, 2nd ed., Addison-Wesley, Reading, MA,
1995.
2. E. Horowitz, S. Sahni, and S. Rajasekaran, Computer Algorithms C++, Computer Science
Press, 1997.
3. N.M. Josuttis, The C++ Standard Library: A Tutorial and Reference, Addison-Wesley,
Reading, MA, 1999.
4. D.E. Knuth, The Art of Computer Programming, Volume 1: Fundamental Algorithms, 3rd ed.,
Addison-Wesley, Reading, MA, 1997.
5. D.E. Knuth, The Art of Computer Programming, Volume 2: Seminumerical Algorithms, 3rd ed.,
Addison-Wesley, Reading, MA, 1998.
6. D.E. Knuth, The Art of Computer Programming, Volume 3: Searching and Sorting, 2nd ed.,
Addison-Wesley, Reading, MA, 1998.
7. S.B. Lippman and J. Lajoie, C++ Primer, 3rd ed., Addison-Wesley, Reading, MA, 1998.
8. D.S. Malik and M.K. Sen, Discrete Mathematics: Theory and Applications (Revised Edition),
Cengage Learning Asia, Singapore, 2010.
9. E.M. Reingold and W.J. Hensen, Data Structures in Pascal, Little Brown and Company,
Boston, MA, 1986.
10. R. Sedgewick, Algorithms in C, 3rd ed., Addison-Wesley, Reading, MA, Parts 1-4, 1998;
Part 5, 2002.
11. B. Stroustrup, The Design and Evolution of C++, Addison-Wesley, Reading, MA, 1994.

1605
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

APPENDIX I

ANSWERS TO
ODD-NUMBERED
EXERCISES
ª HunThomas/Shutterstock.com

Chapter 1
1. a. true; b. true; c. false; d. true; e. true; f. true; g. false; h. true; i. true; j. false; k.
true; l. true; m. false; n. false
3. All programs must be loaded into main memory before they can be executed.
Similarly, all data must be brought into main memory before a program can
manipulate it.
5. The operating system monitors the overall activity of the computer and provides
services.
7. In machine language the programs are written using the binary codes while in
high-level language the programs are closer to the natural language. For execution, a high-level language program is translated into the machine language while
a machine language need not be translated into any other language.
9. To load an executable program into main memory.
11. A compiler reports syntax errors.
13. a. Analyze the problem, outline the problem and its solution requirements, and
design an algorithm to solve the problem.
b. Implement the algorithm in a programming language, such as C++, and verify
that the algorithm works.
c. Maintain the program by using and modifying it if the problem domain
changes.
15. To find the weighted average of the four test scores, first you need to know each
test score and its weight. Next, you multiply each test score with its weight and
then add these numbers to get the average. Therefore:
1.
2.
3.
4.

Get
Get
Get
Get

testScore1, weightTestScore1
testScore2, weightTestScore2
testScore3, weightTestScore3
testScore4, weightTestScore4

1607
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1608

| Appendix I: Answers to Odd-Numbered Exercises

5.

17.

19.

21.

weightedAverage = testScore1
testScore2
testScore3
testScore4

*
*
*
*

weightTestScore1 +
weightTestScore2 +
weightTestScore3 +
weightTestScore4;

To find the price per square inch, first we need to find the area of the pizza. Then
we divide the price of the pizza by the area of the pizza. Let radius denote the
radius, area denote the area of the circle, and price denote the price of the
pizza. Also, let pricePerSquareInch denote the price per square inch.
a. Get radius
b. area = p * radius * radius
c. Get price
d. pricePerSquareInch = price / area
Suppose that radius denotes radius of the sphere, volume denotes volume of the
sphere, and surfaceArea denotes the surface area of the sphere. The following
algorithm computes the volume and surface area of the sphere.
Algorithm

C++ Instruction (Code)

1. Get the radius.

cin >> radius;

2. Calculate the volume.

volume = (4.0 / 3.0) * 3.1416 *
radius * radius * radius;

3. Calculate the surface area.

surfaceArea = 4.0 * 3.1416 *
radius * radius;

Suppose that billingAmount denotes the total billing amount, numOfItemsOrdered
denotes the number of items ordered, shippingAndHandlingFee denotes the
shipping and handling fee, and price denotes the price of an item. The following
algorithm computes and outputs the billing amount.
a.
b.
c.
d.
e.

Enter the number of items bought.
Get numOfItemsOrdered
billingAmount = 0.0;
shippingAndHandlingFee = 0.0;

Repeat the following for each item bought.
i. Enter the price of the item
ii. Get price
iii. billingAmount = billingAmount + price;

f. if billingAmount < 200
shippingAndHandlingFee = 10 * numOfItemsOrdered;

g. billingAmount = billingAmount + shippingAndHandlingFee;
h. Print billingAmount

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 1 |

23.

1609

Suppose x1 and x2 are the real root of the quadratic equation.
a. Get a
b. Get b
c. Get c
d. if (b * b - 4 * a * c < 0)
Print "The equation has no real roots."
Otherwise
{
temp = b * b - 4 * a * c;
x1 = (-b + temp) / (2 * a);
x2 = (-b - temp) / (2 * a);
}

25.

Suppose averageTestScore denotes the average test score, highestScore
denotes the highest test score, testScore denotes a test score, sum denotes the
sum of all of the test scores, count denotes the number of students in class, and
studentName denotes the name of a student.
a. First, you design an algorithm to find the average test score. To find the average
test score, first you need to count the number of students in the class and add the
test score of each student. You then divide the sum by count to find the average
test score. The algorithm to find the average test score is as follows:
i. Set sum and count to 0.
ii. Repeat the following for each student in class.
1. Get testScore
2. Increment count and update the value of sum by adding the current
test score to sum.
iii. Use the following formula to find the average test score:
if (count is 0)
averageTestScore = 0;
otherwise
averageTestScore = sum / count;

b. The following algorithm determines and prints the names of all of the students
whose test score is below the average test score.
Repeat the following for each student in class:
i.
ii.

Get studentName and testScore
if (testScore is less than averageTestScore)
print studentName

c. The following algorithm determines the highest test score.
i. Get first student’s test score and call it highestTestScore.
ii. Repeat the following for each of the remaining students in class:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1610

| Appendix I: Answers to Odd-Numbered Exercises

1.
2.

Get testScore
if (testScore is greater than highestTestScore)
highestTestScore = testScore;

d. To print the names of all of the students whose test score is the same as the
highest test score, compare the test score of each student with the highest test
score, and if they are equal, print the name. The following algorithm accomplishes this. Repeat the following for each student in class:
i. Get studentName and testScore
ii. if (testScore is equal to highestTestScore)
print studentName

You can use the solutions of the subproblems obtained in parts a through d to design
the main algorithm as follows:
1.
2.
3.
4.

Use the algorithm in part a to find the average test score.
Use the algorithm in part b to print the names of all of the students whose score is
below the average test score.
Use the algorithm in part c to find the highest test score.
Use the algorithm in part d to print the names of all of the students whose test score
is the same as the highest test score.

Chapter 2
1. a. false; b. false; c. false; d. true; e. true; f. false; g. true; h. true; i. false; j. true; k. false
3. c, f
5. The identifiers quizNo1 and quizno1 are not the same. C++ is case sensitive.
The fifth letter of quizNo1 is uppercase N while the fifth character of quizno1 is
lowercase n. So these identifiers are different.
7. a. 3
b. -0.5
c. 7.85714
d. Not possible. Both the operands of the operator % must be integers. Because the
first operand, x * z, is a floating-point value, the expression is invalid.
e. 28.5
f. Not possible. Both the operands of the operator % must be integers. Because
the second operand, z, is a floating-point value, the expression is invalid.
g. Not possible. Both the operands of the operator % must be integers. Because
the second operand, y + z, is a floating-point value, the expression is invalid.
h. 3.57143
9. x = 5, y = 7, z = 4, w = 3, t = 6
11. b and c are valid
13. a. 5.0 / 9 * (F - 32)
b. 'A'
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 2 |

c.
d.
e.
f.
g.
h.
i.
j.
15.

1611

grade = "B+" ;
str = "seventh edition";
totalInches = 12 * feet + inches;
i = i + 1;
v = 4 / 3 * (3.1416 * r * r * r);
s = 2 * (3.1416 * r * r) + 2 * (3.1416 * r) * h;
(a + b) / c * (e * f) - g * h

(-b + (b * b - 4 * a * c)) / (2 * a)
= 101
= 28
= 28
= 117.3
= 29.25
a. -40; b. 11.5; c. 17.75; d. 18.7; e. 20; f. 88.25; g. 4.0;

x
y
z
w
t

17.
19. a and c are correct.
21. a. int num1;

int num2;
b. cout << "Enter two numbers separated by spaces." << endl;
c. cin >> num1 >> num2;
d. cout << "num1 = " << num1 << "num2 = " << num2
<< "2 * num1 - num2 = " << 2 * num1 - num2 << endl;

23.

A correct answer is:
#include <iostream>
using namespace std;
const char STAR = '*';
const int PRIME = 71;
int main()
{
int count, sum;
double x;
int newNum;

//declare newNum

count = 1;
sum = count + PRIME;
x = 25.67;
// x = 25.67;
newNum = count * 1 + 2; //newNum = count * ONE + 2;
sum++; //(x + sum)++;
sum = sum + count;
//sum + count = sum;
x = x + sum * count; // x = x + sum * COUNT;
sum += 3;
//sum += 3--;
cout << " count = " << count << ", sum = " << sum
<< ", PRIME = " << PRIME << endl;
return 0;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1612

25.
27.

| Appendix I: Answers to Odd-Numbered Exercises

A
a.
b.
c.
d.
e.

variable must be declared before it can be used.
x *= 2;
x += y - 2;
sum += num;
z *= x + 2;
y /= x + 5;

29.
a = (b++) + 3;
c = 2 * a + (++b);
b = 2 * (++c) – (a++);

31.

a
9
9
10

b
7
8
45

c
und
26
27

(The user input is shaded.)
firstNum = 62
Enter three numbers: 35 10.5 27
The numbers you entered are 35, 10.5, and 27
z = 33
Enter grade: B
The letter that follows your grade is: C

33.

#include <iostream>
#include <string>
using namespace std;
const double X = 13.45;
const int Y = 34;
const char BLANK = ' ';
int main()
{
string firstName, lastName;
int num;
double salary;
cout << "Enter first name: ";
cin >> firstName;
cout << endl;
cout << "Enter last name: ";
cin >> lastName;
cout << endl;
cout << "Enter a positive integer less than 70: ";
cin >> num;
cout << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 3 |

1613

salary = num * X;
cout
cout
cout
cout

<<
<<
<<
<<

"Name: " << firstName << BLANK << lastName << endl;
"Wages: $" << salary << endl;
"X = " << X << endl;
"X + Y = " << X + Y << endl;

return 0;
}

Chapter 3
1. a. false; b. true; c. false; d. false; e. false; f. false; g. true; h. false; i. true; j. false;
k. true
3. a. num1 = 28, num2 = 67, x = 35, y = 0.3
b. num1 = 35, num2 = 67, x = 28.3, y = 12.5
c. num1 = 67, num2 = 12, x = 35, y = 28.3
d. num1 = 35, num2 = 28, x = 0.3, y =67
e. num1 = 35, num2 = 12, x = 28.3, y = 67
f. Input failure: num1 = 28, x = 35, trying to read the . (period) into num2.
5. a. 12.8 15 Bill
b. 0.8 12 Bill
c. Input failure: Trying to read B into y, which is an int variable. x = 12.8,
y = 18, and name = "Lisa". The values of y and name are unchanged.
7. cmath
9. iomanip
11. iomanip
13. iostream
15. The function getline reads until it reaches the end of the current line. The
newline character is also read but not stored in the string variable.
17. a. name ¼ " Lance Grant", age ¼ 23
b. name ¼ " ", age ¼ 23
19. #include <iostream>
#include <fstream>
using namespace std;
int main()
{
int num1, num2;
ifstream infile;
ostream outfile;
infile.open("input.dat");
outfile.open("output.dat");

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1614

| Appendix I: Answers to Odd-Numbered Exercises

infile >> num1 >> num2;
outfile << "Sum = " << num1 + num2 << endl;
infile.close();
outfile.close();
return 0;
}

21.
23.

fstream

a. Same as before.
b. The file contains the output produced by the program.
c. The file contains the output produced by the program. The old contents are
erased.
d. The program would prepare the file and store the output in the file.
25. a. outfile.open("travel.dat ");
b. outfile >> fixed >> showpoint >> setprecision(2);
c. outfile >> day >> " " >> distance >> " " >> speed >> endl;
d. travelTime = distance / speed;
e.

outfile >> travelTime;
fstream and iomanip.

Chapter 4
1. a. false; b. false; c. false; d. true; e. false; f. false; g. false; h. false; i. false; j. true; k. true
3. a. true; b. false; c. true; d. false; e. true
5. a. x = = z: 0
b. y != z - 9: 0
c. x - y == z + 10: 1
d. !(z < w): 1
e. w - y < x - 2 *z: 0
7. a. //b. 8 12 - 4
c. ^:
d. ++C
e. Amy
f.

Amy < Bob
-12
**

9. a. ?%!!
b. a b c d
##

c. Flying Coding
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 4 |

1615

11. The value of done is: 0
13. Omit the semicolon after else. The correct statement is:
if (score >= 60)
cout << "You pass." << endl;
else
cout << "You fail." << endl;

15. The correct code is:
if (numOfItemsBought > 10)
shippingCharges = 0.0;
else if (5 <= numOfItemsBought && numOfItemsBought <= 10)
shippingCharges = 3.00 * numOfItemsBought;
else if (0 < numOfItemsBought && numOfItemsBought < 5)
shippingCharges = 7.00 * numOfItemsBought;

17. 1 18
19. if (sale > 20000)
bonus = 0.10
else if (sale > 10000 && sale <= 20000)
bonus = 0.05;
else
bonus = 0.0;

21. a. The output is: Discount ¼ 10%. The semicolon at the end of the if statement
terminates the if statement. So the cout statement is not part of the if
statement. The cout statement will execute regardless of whether the expression in the if statement evaluates to true or false.
b. The output is: Discount ¼ 10%. The semicolon at the end of the if statement
terminates the if statement. So the cout statement is not part of the if
statement. The cout statement will execute regardless of whether the expression in the if statement evaluates to true or false.
23. a. (x >= y) ? z = x – y : z = y – x;
b. (hours >= 40.0) ? wages = 40 * 7.50 + 1.5 * 7.5 * (hours - 40)
: wages = hours * 7.50;
(score >= 60) ? str = "Pass" : str = "Fail";

c.
25. a. 40.00
b. 40.00
c. 55.00
27. a. 0
b. 4
29. a. 3
b. -20
31. #include <iostream>

c. 10
c. 3

d. 25
d. 5

using namespace std;
const int SECRET = 5;
int main()

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1616

| Appendix I: Answers to Odd-Numbered Exercises

{
int x, y, w, z;
z = 9;
if (z
{
x
y
w
}
else
{
x
y
w
}

> 10)
= 12;
= 5;
= x + y + SECRET;

= 12;
= 4;
= x + y + SECRET;

cout << "w = " << w << endl;
return 0;
}

33.

switch (classStanding)
{
case 'f':
dues = 150.00;
break;
case 's':
if (gpa >= 3.75)
dues = 75.00;
else
dues = 120.00;
break;
case 'j':
if (gpa >= 3.75)
dues = 50.00;
else
dues = 100.00;
break;
case 'n':
if (gpa >= 3.75)
dues = 25.00;
else
dues = 75.00;
break;
default:
cout << "Invalid class standing code." << endl;
}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 5 |

1617

Chapter 5
1.
3.
5.
7.
9.
11.

a. true; b. false; c. true; d. false; e. true; f. true; g. true; h. false
13

if ch > 'Z' or ch < 'A'
Sum = 39
Sum = 37

a. 27
b. 7
c. 31 60 91 151
d. 50 93 143 236 379 615 994 1609 2603 4212
13. Replace the while loop statement with the following:
while (response = = 'Y' || response = = 'y')
Replace the cout statement:
cout << num1 << " + " << num2 << " = " << (num1 - num2)
<< endl;

with the following:
cout << num1 << " + " << num2 << " = " << (num1 + num2)
<< endl;

15. 5 4 3 2 1
17. 0 3 8 15 24
19. Loop control variable: j
The initialization statement: j = 1;
Loop condition: j <= 10;
Update statement: j++
The statement that updates the value of s: s = s + j * (j - 1);
21. -1 1 3 5 7 6
23. a. *
b. infinite loop
c. infinite loop
d. ****
e. ******
f. ***
25. The relationship between x and y is: 3y = x.
Output: x = 19683, y = 10

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1618

27.

| Appendix I: Answers to Odd-Numbered Exercises

0 - 24
25 - 49
50 - 74
75 - 99
100 - 124
125 - 149
150 - 174
175 - 200

29.

a. both
b. do . . . while
c. while
d. while
31. In a pretest loop, the loop condition is evaluated before executing the body of the
loop. In a posttest loop, the loop condition is evaluated after executing the body of
the loop. A posttest loop executes at least once, whereas a pretest loop may not
execute at all.
33. int num;
do
{
cout << "Enter a number less than 20 or greater than 75: ";
cin >> num;
}
while (20 <= num && num <= 75);

35.

int i = 0, value = 0;
do
{
if (i % 2 == 0 &&
value = value
else if (i % 2 ==
value = value
else
value = value
i = i + 1;
}
while (i <= 20);

i
+
0
+

<= 10)
i * i;
&& i > 10)
i;

- i;

cout << "value = " << value << endl;

37.

cin >> number;
while (number != -1)
{
total = total + number;
cin >> number;
}
cout << endl;
cout << total << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 6 |

39.

1619

a. number = 1;

b.

while (number <= 10)
{
cout << setw(3) << number;
number++;
}
number = 1;
do
{
cout << setw(3) << number;
number++;
}
while (number <= 10);

41.

a. 29
b. 2 8
c. 8 13 21 34
d. 28 43 71 114

43.
45.

-1 0 3 8 15 24
12 11 9 7 6 4 2 1

Chapter 6
1. a. false; b. true; c. true; d. true; e. false; f. false; g. true; h. false; i. true; j. true;
k. false; l. false; m. false; n. true
3. a. 25 b. 56.38 c. 13.00 d. 9.00 e. 15.44 f. 5.88
g. 12.00
h. 504.00 i. 13.00 j. 7.00 k. 11.00 l. -8.00
m. -85.00 n. -243.00 o. 0.00 p. 1.33

5. b and c
7. a, b, c, d, e are valid. In f, the second argument in the function call is missing.
In g and h, the function call requires one more argument.
9. a. 2; int
b. 3; double
c. 4; char
d. 2; string
e. The function func1 requires 2 actual parameters. The type and the order of
these parameters is: int, double
f. cout << func1(3, 8.5) << endl;
g. cout << join("John", "Project Manager") << endl;
h. cout << static_cast<char>(static_cast<int>
(func3(4, 3, 17.6, 'A')) + 1) << endl;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1620

| Appendix I: Answers to Odd-Numbered Exercises

11.

bool isUppercaseLetter(char ch)
{
if (isupper(ch))
return true;
else
return false;
}

13.

a. (i) 16 (ii) 27
b. The function computes mk  1, where m and n are
the arguments of the function and k ¼ abs(n).
15. a. 385
b. This function computes 1+4+9+16+25+36+49+64+81+100
17. double funcEx17(double x, double y, double z)
{
return x * pow(y, z);
}

19.

a. In a void function, a return statement is used without any value such as
return;.
b. In a void function, a return statement is used to exit the function early.
21. a. A variable declared in the heading of a function definition is called a formal
parameter. A variable or expression used in a function call is called an actual
parameter.
b. A value parameter receives a copy of the actual parameter’s data. A reference
parameter receives the address of the actual parameter.
c. A variable declared within a function or block is called a local variable. A variable
declared outside of every function definition is called a global variable.
23. void funcThreeTimes(double x)
{
cout << fixed << showpoint << setprecision(2);
cout << 3 * x << endl;
}

25.

void initialize(int& x, double& y, string& str)
{
x = 0;
y = 0;
str = "";
}

27.

3, 2, 8
3, 7, 24
1190, 7, 187
245157, 1131, 187

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 6 |

29.

1621

#include <iostream>
using namespace std;
int secret(int, int);
void func(int x, int& y);
int main()
{
int num1, num2;

__1__

num1 = 6;

__2__
__3__
__4__
__8__
__9__
_10__
_15__
_16__

cout << "Enter a positive integer: ";
cin >> num2;
cout << endl;
cout << secret(num1, num2) << endl;
num2 = num2 - num1;
cout << num1 << " " << num2 << endl;
func(num2, num1);
cout << num1 << " " << num2 << endl;

_17__
}

return 0;

int secret(int a, int b)
{
int d;
__5__
__6__

d = a + b;
b = a * d;

__7__
}

return b;

void func (int x, int& y)
{
int val1, val2;
_11__
_12__
_13__
_14__
}

val1 = x + y;
val2 = x * y;
y = val1 + val2;
cout << val1 << " " << val2 << endl;

If the input is 10, the output is:
96
6 4
10 24
34 4

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1622

| Appendix I: Answers to Odd-Numbered Exercises

31.

void traceMe(double& x, double y, double& z)
{
if (x != 0)
z = sqrt(y) / x;
else
{
cout << "Enter a nonzero number: ";
cin >> x;
cout << endl;
z = floor(pow(y, x));
}
}

33.

20 -100
5 -100

35.

11,
16,
19,
24,

37.

a, b, c, and e are correct.

3
2
3
2

Chapter 7
1. a. true; b. false; c. true; d. false; e. false; f. true; g. true; h. true; i. false; j. false; k. false
3. Only a and c are valid.
5. birdType readIn()
{
string str;
birdType bird = 0;
cin >> str;
if (str == "Peacock")
bird = PEACOCK;
else if (str == "Sparrow")
bird = SPARROW;
else if (str == "Canary")
bird == CANARY;
else if (str == "Parrot")
bird == PARROT;
else if (str == "Penguin")
bird = PENGUIN;
else if (str == "Ostrich")
bird = OSTRICH;
else if (str == "Eagle")
bird = EAGLE;
else if (str == "Cardinal")
bird = CARDINAL;
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 8 |

1623

else if (str == "Hummingbird")
bird = HUMMINGBIRD;
else
cout << "Invalid bird name." << endl;
return bird;
}

7. Because there is no name for an anonymous type, you cannot pass an anonymous
type as a parameter to a function and a function cannot return an anonymous type
value. Also, values used in one anonymous type can be used in another anonymous
type, but variables of those types are treated differently.
9. The statement in Line 2 should be:
using namespace std;

11.

using namespace std;

13.

//Line 2

The statement in Line 2 should be:
//Line 2

Either include the statement:
using namespace aaa;

before the function main or refer to the identifiers x and y in main as aaa::x
and aaa::y, respectively.
15. a. Heelo Thlre
b. Giamond Dold
c. Ca+ J+va
17. Regular exercise
Regular exercise and low fat diet
33
8
8
health insurance
insurance
Regular exercise can reduce health insurance $$$$.
$ocial Nedia!!
14
Social Media!!

Chapter 8
1. a. true; b. true; c. true; d. false; e. false; f. false; g. false; h. false; i. true; j. false;
k. false; l. false
3. a. This declaration is correct.
b. Array size must be positive. A correct answer is: int testScores[10];.
c. This declaration is correct.
d. Array size must be a positive integer not a range. A correct answer is:
int list100[100];

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1624

| Appendix I: Answers to Odd-Numbered Exercises

e. gpa is an array of size 50. The expression [50] should be after gpa. The
correct statement is: double gpa[50];
f. LENGTH must be declared as integral, such as int . A correct statement is:
const int LENGTH = 26;

g. This declaration is correct.
5. 0 to 98
7. 0 1 4 9 16
32 1 4 32 36

9. 1 2 2 4 8 32 224 6944
11. int myList[10];
for (int i = 0; i < 10; i++)
myList[i] = [i];

13. If array index is less than 0 or greater than arraySize – 1, we say that the array
index is out of bounds. C++ does not check for array indices within bound.
15. a. double heights[10] = {5.2, 6.3, 5.8, 4.9, 5.2, 5.7, 6.7, 7.1,
5.10, 6.0};

or
double heights[] = {5.2, 6.3, 5.8, 4.9, 5.2, 5.7, 6.7, 7.1, 5.10,
6.0};

b. int weights[7] = {120, 125, 137, 140, 150, 180, 210};
or
int weights[] = {120, 125, 137, 140, 150, 180, 210};
c. char specialSymbols[] = {'$ ', '# ', '% ', '@ ', '& ', '! ', '^ '};
d. string seasons[4] ¼ {"fall", "winter", "spring", "summer"};
or
17.

string seasons[] ¼ {"fall", "winter", "spring", "summer"};
list[0] ¼ 6, list[1] ¼ 10, list[2] ¼ 14, list[3] ¼ 18, list[4] ¼ 22,
list[5] ¼ 0, list[6] ¼ 0.

19.
21.

16 32 44 56 68 37 20

23.

1 25000.00 750.00

a.
b.
c.
d.
e.

Correct.
Correct.
Incorrect. The size of score is 50, so the call should be tryMe(score, 50);.
Correct.
Incorrect. The array gpa is of type double, whereas the parameter x of tryMe
is of type int. So there will be a mismatch data type error.

2 36500.00 1095.00
3 85000.00 2550.00
4 62500.00 1875.00
5 97000.00 2910.00
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 8 |

25.
27.

1625

List elements: 11 16 21 26 30
1 3.50 10.70 235.31
2 7.20 6.50 294.05
3 10.50 12.00 791.68
4 9.80 10.50 646.54
5 6.50 8.00 326.73

29.
31.
33.

No.
2 3 3 2 4 7 16 20

No, because during compile time the formal parameter list has no first or last
elements.
35. a. Invalid; the assignment operator is not defined for C-strings.
b. Invalid; the relational operators are not defined for C-strings.
c. Invalid; the assignment operator is not defined for C-strings.
d. Valid
37. a. strcpy(str1, "Sunny Day");
b. length = strlen(str1);
c. strcpy(str2, name);
d. if (strcmp(str1, str2) <= 0)
cout << str1 << endl;
else
cout << str2 << endl;

39.

int temp[3][4] = {{6, 8, 12, 9},
{17, 5, 10, 6},
{14, 13, 16, 20}};

41.
43.

a. 30; b. 5; c. 6; d. row; e. column
a. beta is initialized to 0.
b. First row of beta: 0 1 2
c.
d.
e.

Second row of beta: 1 2 3
Third row of beta: 2 3 4
First row of beta: 0 0 0
Second row of beta: 0 1 2
Third row of beta: 0 2 4
First row of beta: 0 2 0
Second row of beta: 2 0 2
Third row of beta: 0 2 0
First row of beta: 0 0 0
Second row of beta: 0 1 2
Third row of beta: 0 2 1

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1626

| Appendix I: Answers to Odd-Numbered Exercises

Chapter 9
1. a. false; b. true; c. false; d. false; e. false; f. false; g. false; h. true; i. false; j. true;
k. true
3. carType newCar;
newCar.manufacturer = "GMT";
newCar.model = " Cyclone";
newCar.modelType = "sedan";
newCar.color = "blue"
newCar.numOfDoors = 4;
newCar.cityMilesPerGallon = 28;
newCar.highwayMilesPerGallon = 32;
newCar.yearBuilt = 2006;
newCar.price = 25000.00;

5. fruitType fruit;
fruit.name = "banana";
fruit.color = "yellow";
fruit.fat = 1;
fruit.sugar = 15;
fruit.carbohydrate = 22;

7. if (firstHouse.style == secondHouse.style &&
firstHouse.price == secondHouse.price)
cout << "true" << endl;
else
cout << "false" << endl;

9. Assignment statement and function return value.
11. student.name.first = "Linda";
student.name.last = "Brown";
student.gpa = 3.78;
student.course.name: "Calculus";
student.course.callNum = 23827;
student.course.credits = 4;
student.course.grade = 'A';

13.

a. Invalid; the member name of newEmployee is a struct. Specify the member
names to store the value "John Smith". For example:
newEmployee.name.first = "John";
newEmployee.name.last = "Smith";

b.

Invalid; the member name of newEmployee is a struct. There are no aggregate
output operations on a struct. A correct statement is:
cout << newEmployee.name.first << " "
<< newEmployee.name.last << endl;

c. Valid
d. Valid
e. Invalid; employees is an array. There are no aggregate assignment operations
on arrays.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 10 |

15.
17.

1627

partsType inventory [100];
void getData(partsType& pType)
{
for (int j = 0; j < length; j++)
{
cin >> pType.partName;
cin >> pType.partNum;
cin >> pType.price;
cin >> pType.quantitiesInStock;
}
}
for (int j = 0; j < 100; j++)
getData(inventory [i]);

Chapter 10
1. a. false; b. false; c. true; d. false; e. false
3. The type of function print is missing. Also, a constructor has no type. The
statements in Lines 5 and 6 should be:
void print() const;
temp(int = 0, int = 0);

//Line 5
//Line 6

5. A class is not a function. The semicolon after private should be a colon, there is
a missing semicolon after }, and a constructor has no type. The statements in
Lines 1, 8, 9, and 13 should be:
class discover()

//Line 1

discover(string, int, int);
private:
};

//Line 8
//Line 9
//Line 13

7. a.

void bagType::set(string s, double a, double b, double c, double d)
{
style = s;
l = a;
w = b;
h = c;
price = d;
}

b. void bagType::print() const
{
cout << "Bag Type: " << style << ", length = " << l

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1628

| Appendix I: Answers to Odd-Numbered Exercises

<< ", width = " << w << ", height = " << h
<< ", price = $ " << price << endl;
}

c. bagType::bagType()
{
style = "";
l = 0.0;
w = 0.0;
h = 0.0;
price = 0.0;
}
newBag.print();
bagType tempBag("backPack", 15, 8, 20, 49.99);

d.
e.
9. The functions print, getSalary, and getNumOfServiceYears are accessors;
functions setData and updateSalary are mutators.
11. a. 27; b. 8; c. 1; d. 9
13. a. 14
b. 3
c. The class temporary has only one constructor. Because this is a constructor
with default parameters, it can be used to initialize an object without specifying
any parameters. For example, the following statement creates the object
newObject and its instance variables are initialized to " ", 0, and 0, respectively:
temporary newObject

15.

The statement in Line 1 creates object1 and initializes the instance variables of this
object to " ", 0, 0, that is, object1.description ¼ " ";, object1.first ¼ 0.0;,
and object1.second ¼ 0.0;. The statement in Line 2 creates object2 and
initializes the instance variables of this object as follows: object2.description ¼
"rectangle";, object2.first ¼ 3.0;, and object2.second ¼ 5.0;. The
statement in Line 3 creates object3 and initializes the instance variables of this object
as follows: object3.description ¼ "circle";, object3.first ¼ 6.5;, and
object3.second ¼ 0.0;. The statement in Line 4 creates object4 and
initializes the instance variables of this object as follows: object4.description
= "cylinder";, object4.first = 6.0;, and object4.second = 3.5;.
17. There are two built-in operations for class objects: Member access (.) and
assignment (=).
19. a. int testClass::sum()
{
return x + y;
}
void testClass::print() const
{

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 10 |

1629

cout << "x = " << x << ", y = " << y << endl;
}
testClass::testClass()
{
x = 0;
y = 0;
}
testClass::testClass(int a, int b)
{
x = a;
y = b;
}

b. One possible solution. (We assume that the name of the header file containing
the definition of the class testClass is Exercise19Ch10.h.)
#include <iostream>
#include "Exercise19Ch10.h"
int main()
{
testClass one;
testClass two(4, 5);
one.print();
two.print();
return 0;
}

21.

a. personType student("Buddy", "Arora");
b. student.print();
c. student.setName("Susan", "Gilbert");
23. A constructor is a member of a class, and it executes automatically when a class
object is instantiated and a call to the constructor is specified in the object declaration. A constructor is included in a class so that the objects are properly initialized
when they are declared.
25. A destructor is a member of a class, and if it is included in a class, it executes
automatically when a class object goes out of scope. Its main purpose is to deallocate
the dynamic memory created by an object.
27. a. myClass::count = 0;
b. myClass.incrementCount();
c. myClass.printCount();
d. int myClass::count = 0;
void myClass::setX(int a)
{

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1630

| Appendix I: Answers to Odd-Numbered Exercises

x = a;
}
void myClass::printX() const
{
cout << x;
}
void myClass::printCount()
{
cout << count;
}
void myClass::incrementCount()
{
count++;
}
myClass::myClass(int a)
{
x = a;
}
e. myClass myObject1(5);
f. myClass myObject2(7);

g. The statements in Lines 1 and 2 are valid.
The statement in Line 3 should be: myClass::printCount();.
The statement in Line 4 is invalid because the member function printX is not a
static member of the class, and so cannot be called by using the name of class.
The statement in Line 5 is invalid because count is a private static
member variable of the class.
h. 5
2
2
3
14
3
3

Chapter 11
1. a. false; b. false; c. true; d. true; e. true; f. true; g. true; h. true; i. false; j. false; k. true
3. Some of the member variables that can be added to the class employeeType are:
department, salary, employeeCategory (such as supervisor and president),
and employeeID. Some of the member functions are: setInfo, setSalary,

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 11 |

1631

getSalary, setDepartment, getDepartment, setCategory, getCategory,
setID, and getID.
class employeeType: public personType
{
public:
void setInfo(string, string, string, double, string, string);
void setSalary(double);
void setDepartment(string);
void setCategory(string);
void setID(string);
double getSalary() const;
string getDepartment(string) const;
string getCategory()const;
string getID()const;
private:
string
double
string
string
};

department;
salary;
employeeCategory;
employeeID;

5.

a. The base class is computers and the derived class is personalComputers.
b. This is a public inheritance.
7. Private members of the object newCylinder are xCoordinate, yCoordinate,
radius, and height.
9. Missing : in the first statement. The first statement should be:
class derivedFromTemp: public temp

Also missing ; after }. It should be
};

11.

a. void print() const;
b. void set(int, int, int);
void get(int&, int&, int&);

13.

First a constructor of class one will execute, then a constructor of class two
will execute, and finally a constructor of class three will execute.
15. a. Invalid. z is an instance variable of the derived class, it cannot be accessed by
the members of the class smart.
b. Invalid. secret is a private member of the class smart. It cannot be
accessed directly outside of the class. Also z is a private member of the class
superSmart. It cannot be accessed directly outside of the class.
c. Valid

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1632

| Appendix I: Answers to Odd-Numbered Exercises

d. Invalid. smart is the name of a class, not an object of this class. It cannot be
used to call its member function print.
e. Invalid. superSmart is the name of a class. It cannot be used to access its
members.
17. Between the preprocessor directive #ifndef and #endif. The definitions of the
classes one and two can be placed between these directives as follows:
#ifndef H_one
#define H_one

#ifndef H_two
#define H_two

//place the definition of the
//class one here

//place the definition of the
//class two here

#endif

#endif

19.

In a private inheritance, the public members of the base class are private
members of the derived class. They can be accessed by the member functions (and
friend functions) of the derived class. The protected members of the base class
are private members of the derived class. They can be accessed by the member
functions (and friend functions) of the derived class. The private members of
the base class are hidden in the derived class. They cannot be directly accessed in the
derived class. They can be accessed by the member functions (and friend functions) of the derived class through the public or protected members of the
base class.
21. In a public inheritance, the public members of the base class are public
members of the derived class. They can be directly accessed in the derived class.
The protected members of the base class are protected members of the derived
class. They can be directly accessed by the member functions (and friend functions) of the derived class. The private members of the base class are hidden in
the derived class. They cannot be directly accessed in the derived class. They can be
accessed by the member functions (and friend functions) of the derived class
through the public or protected members of the base class.
23. The protected members of a base class can be directly accessed by the member
functions of the derived class, but they cannot be directly accessed in a program that
uses that class. The public members of a class can be directly accessed by the
member functions of any derived class as well as in a program that uses that class.
25. The members setX, print, y, and setY are protected members in class
third. The private member x of class first is hidden in class third, and
it can be accessed in class third only through the protected and public
members of class first.
27. Because the memberAccessSpecifier is not specified, it is a private inheritance.
Therefore, all of the members of the class first become private members in
class fifth.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 12 |

29.

1633

a. void two::setData(int a, int b, int c)
{
one::setData(a, b);
z = c;

b.

}
void two::print() const
{
one::print();
cout << z << endl;
}

Chapter 12
1. a. false; b. false; c. false; d. true; e. false; f. true; g. false; h. false; i. true; j. false;
k. true; l. true; m. false; n. true; o. true; p. false
3. a. To create a pointer in the variable declaration, operator * is placed between the
data type and the variable name. For example the statement int *p; declares p
to be a pointer of type int.
b. To dereference a pointer in an expression, the operator * is placed to the left of
the pointer. For example, if p is a pointer of type int, the expression cout <<
*p << endl; outputs the data stored in the memory space to which p points.
5. *numPtr gives the address of the memory location to which numPtr points, while
&numPtr gives the address of numPtr.
7. numPtr = &num;
(*numPtr)++;

9.
11.
13.
15.

37 37 28
34 27
90.00 86.00 88.00

In Line 6, the operator delete deallocates the memory space to which nextPtr
points. So the expression *nextPtr, in Line 9, does not have a valid value.

17. 12 8 7 25 16 24 36
19. numPtr ¼ 1058 and gpaPtr ¼ 2024
21. The operator delete deallocates the memory space to which a pointer points.
23. a. num ¼ new int[10];
b. for (int j = 0; j < 10; j++)
cin >> num[j];
delete [] num;

25.
27.
29.

c.
Because at compile time dynamic arrays have no first and last elements, so the
functions begin and end cannot be called on dynamic arrays.
In a shallow copy of data, two or more pointers point to the same memory space. In
a deep copy of data, each pointer has its own copy of the data.
myList: 3 4 6 9 13
yourList: 7 8 10 13 17 10 6 3 1 0

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1634

| Appendix I: Answers to Odd-Numbered Exercises

31.
33.

The copy constructor makes a copy of the actual variable.
Classes with pointer data members should include the destructor, overload the
assignment operator, and explicitly provide the copy constructor by including it
in the class definition and providing its definition.

35.

ClassA x: 4
ClassA x: 6
ClassB y: 10

37.
39.

Yes.
a. Because employeeType is an abstract class, you cannot instantiate an object of
this class. Therefore, this statement is illegal.
b. This statement is legal.
c. This statement is legal.

Chapter 13
1.
3.
5.
7.
9.
11.
13.

15.

a. true; b. false; c. true; d. false; e. false; f. false; g. false; h. false; i. true;
j. false; k. false; l. true; m. true
., .*, ::, ?:, and sizeof
The statement return this; returns the address of the object while the statement return *this; returns the value of the object.
A friend function is a nonmember of a class, whereas a member function is a
member of a class.
Because the left operand of << is a stream object, which is not of the type mystery.
(), [], ->, and =
a. friend strange operator+(const strange&, const strange&);
b. friend bool operator==(const strange&, const strange&);
c. friend strange operator++(strange&, int);
In Line 4, the return type of the function operator* should be temp.
The correct statement is:
temp operator*(const temp& obj);

17.

In Line 3, the return type of the function operator< should be bool.
The correct statement is:
friend bool operator<(const mystery& a,
const mystery& b);

19.

//Line 4

//Line 3

In Lines 3 and 11, the return type of the function operator+ should be
discover. Also since operator+ is a friend function of the class, the name of
the class and the scope resolution operator in the heading of the function, in Line
11, are not needed. The correct statements are:

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 14 |

friend discover operator+(const discover&,
const discover&);
discover operator+(const discover& a,
const discover& b)

1635

//Line 3
//Line 11

21. A reference to an object of the class istream.
23. Suppose that a class, say temp, overloads the pre- and postincrement operator ++,
and tempObj is an object of the class temp. Then, the statement ++tempObj; is
compiled as tempObj.operator++();, and the statement tempObj++; is compiled as tempObj.operator++(0);. The dummy parameter distinguishes
between the pre- and post-increment operator functions. Similar conventions for
the pre- and post-increment operators.
25. None.
27. One.
29. The answer to this question is available at the Web site accompanying this book.
31. When the class has pointer data members.
33. Error in Line 4. A template instantiation can be for only a built-in type or a userdefined type. The word ‘‘type’’ between the angular brackets must be replaced
either with a built-in type or a user-defined type.
35. a. 12 b. Sunny Day
37. template <class Type>
void swap(Type &x, Type &y)
{
Type temp;
temp = x;
x = y;
y = temp;
}

Chapter 14
1. a. false; b. true; c. true; d. false; e. true; f. false; g. false; h. true; i. false; j. true;
k. false; l. true; m. false
3. The program will terminate with an error message.
5. If an exception is thrown in a try block, the remaining statements in that try
block are ignored. The program searches the catch blocks in the order that they
appear after the try block and looks for an appropriate exception handler. If the
type of thrown exception matches the parameter type in one of the catch blocks,
the code of that catch block executes, and the remaining catch blocks after this
catch block are ignored.
7. At most one.
9. throw expression;
where expression is a constant value, variable, or object.
Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1636

11.

| Appendix I: Answers to Odd-Numbered Exercises

The catch block has no associated try block, that is, the catch block does not follow
any try block. Also, the try block has no associated catch block, that is, there is no
catch block that follows the try block. The cout statement just before the catch
block disassociates the catch block from the try block. The correct code is:
double radius;
try
{
cout << "Enter the radius: ";
cin >> radius;
cout << endl;
if (radius < 0.0)
throw radius;
cout << "Area: " << 3.1416 * radius * radius << endl;
}
catch (double x)
{
cout << "Negative radius: " << x << endl;
}

13.

a. Leaving the try block.
b. Current balance: 975
Balance must be greater than 1000.00

c. Current balance: -2000
Balance must be greater than 1000.00

15.

a. Entering the try block.
b.
c.
d.

Exception: Lower limit violation.
After the catch block
Entering the try block.
Exception: 0
After the catch block
Entering the try block.
Exiting the try block.
After the catch block
Entering the try block.
Exception: 0
After the catch block

17. invalid_argument
19. A throw statement.
21. (Assume that the definition of the class tornadoException is in the header file
tornadoException.h.)
#include <iostream>
#include "tornadoException.h"
using namespace std;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 15 |

1637

int main()
{
int miles;
try
{
cout << "Enter the miles: ";
cin >> miles;
cout << endl;
if (miles < 5)
throw tornadoException();
else
throw tornadoException(miles);
}
catch (tornadoException tE)
{
cout << tE.what() << endl;
}
return 0;
}

23. A function specifies the exceptions it throws in its heading using the throw
clause.
25. (1) Do nothing; (2) Partially process the exception and throw the same exception
or a new exception; (3) Throw a new exception.

Chapter 15
1. a. true; b. true; c. false; d. false; e. false; f. false; g. true; h. true
3. The case in which the solution is defined in terms of smaller versions of itself.
5. A function that calls another function and eventually results in the original function
call is said to be indirectly recursive.
7. a. The statements in Lines 2 and 3.
b. The statements in Lines 4 and 5.
c. Any nonpositive integer.
d. It is a valid call. The value of mystery(0) is 0.
e. It is an invalid call. It will result in infinite recursion.
f. It is a valid call. The value of mystery(-3) is 6.
9. a. 8 5 2 b. 7 c. 6 3 d. -85
11. a. It does not produce any output.
b. 5 6 7 8 9
c. It does not produce any output.
d. It does not produce any output.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1638

| Appendix I: Answers to Odd-Numbered Exercises

13.
15.
17.

a. 2; b. 3; c. 5; d. 21
a. 10 b. 21 c. -23 d. 2 e. -56

8
<0
multiplyðm; nÞ ¼ m
:
m þ multiplyðm; n  1Þ

if n ¼ 0
if n ¼ 1
otherwise

The base cases are when n = 0 or n = 1. The general case is specified by the
option otherwise.

Chapter 16
1. a. true; b. false; c. false; d. false; e. false; f. true; g. true; h. false; i. false;
j. true; k. true; l. false; m. false; n. true
3. nullptr
5. Before deletion, the link field of the third node stores the address of the fourth
node. After deletion, the link field of the third node will store the address of the
next node, which is the old fifth node. If there was no fifth node, then after
deletion, the link field will store the value nullptr. Therefore, after deleting
the fourth node, the link field of the third node is changed. So a pointer to the third
node is needed.
7. a. false; b. true; c. true; d. true; e. true
9. a. current->link->info ¼ 52;
b. current ¼ temp->link;
c. trail ¼ current->link;
d. temp = nullptr;
e. temp->link->link->link->info ¼ 36;
f. while (current->info != 10)
current = current->link;

11.

a. while (current != nullptr)
current = current->link;
b. temp = new nodeType;
temp->info = 68;
temp->link = last;
trail->link = temp;
c. delete last;
trail->link = nullptr;
last = trail;
d. trail = temp->link;
temp->link = trail->link;
delete trail;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 16 |

13.

After the execution of the statement in Line 5, trail is nullptr, so
trail->info does not exist. This code will result in a run-time error.

15.
17.

33 62 28

1639

nodeType *head, *p, *q;
head = new nodeType;
head->info = 72;
head->link = nullptr;
p = new nodeType;
p->info = 43;
p->link = head;
head = p;
p = head->link;
q = new nodeType;
q->info = 8;
q->link = nullptr;
p->link = q;
q = new nodeType;
q->info = 12;
q->link = p;
head->link = q;
p = head;
while (p != nullptr)
{
cout << p->info << " ";
p = p->link;
}
cout << endl;

19.

The output of this code is: 43 12 72 8
a. The function begin returns an iterator to the first node of a linked list.
b. The function end returns an iterator one past the last node of a linked list.

21.

The item to be deleted is not in the list.
88 72 36 26 48 45

23.

The answer to this question is available at the Web site accompanying this
book.
The answer to this question is available at the Web site accompanying this
book.

25.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1640

| Appendix I: Answers to Odd-Numbered Exercises

Chapter 17
1.
3.
5.

a. true; b. false; c. false; d. true; e. false; f. true; g. false; h. false; i. true;
j. false; k. true; l. false; m. false; n. false
4
13 5 12
num1 = 15
num2 = 21

7. secretNum = 226
9. a. 40 b. 11
c. 2
d. 70
11. a. (x + y ) * z - w
b. x * y / z + w
c. x * (y + z) - w
13. 1 16 27 16 5
15. If the stack is nonempty, the statement stack.top(); returns the top element of
the stack, and the statement stack.pop(); removes the top element of the stack.
17. template <class elemType>
elemType second(stackType<elemType> stack)
{
elemType temp1, temp2;
if (stack.isEmptyStack())
{
cout << "Stack is empty." << endl;
exit(0); //terminate the program
}
temp1 = stack.top();
stack.pop();
if (stack.isEmptyStack())
{
cout << "Stack has only one element." << endl;
exit(0); //terminate the program
}
temp2 = stack.top();
stack.push(temp1);
return temp2;
}

19.

48 72 0 15
stack: 36
queue: 0 88 10 52 67

21.

a. queueFront = 50; queueRear = 0.
b. queueFront = 51; queueRear = 99.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 18 |

23.
25.
27.
29.

1641

a. queueFront = 25; queueRear = 76.
b. queueFront = 26; queueRear = 75.
51
5 -4 5 -7 1 2 1 4 1 -2 2 -7 7 -6
template <class Type>
void reverseStack(stackType<Type> &s)
{
linkedQueueType<Type> q;
Type elem;
while (!s.isEmptyStack())
{
elem = s.top();
s.pop();
q.addQueue(elem);
}
while (!q.isEmptyQueue())
{
elem = q.front();
q.deleteQueue();
s.push(elem);
}
}

31.

template <class Type>
int queueType<Type>::queueCount()
{
return count;
}

33.

The answer to this question is available at the Web site accompanying this
book.
The answer to this question is available at the Web site accompanying this
book.

35.

Chapter 18
1. a. true; b. false; c. true; d. false; e. false; f. true; g. false; h. true; i. true; j. true;
k. false; l. true; m. true; n. false
3. a.
template <class elemType>
int seqOrdSearch(const elemType list[], int length,
const elemType& item)
{
int loc;
bool found = false;

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1642

| Appendix I: Answers to Odd-Numbered Exercises

for (loc = 0; loc < length; loc++)
if (list[loc] >= item)
{
found = true;
break;
}
if (found)
if (list[loc] == item)
return loc;
else
return -1;
else
return -1;
} //end seqOrdSearch

b. i. 6 ii. 8 iii. 11 iv. 2
5. 26
7. 10
9. a.
Suppose that the list is of length n. Then length = n. Consider the first
iteration of the outer for loop, that is, when the value of iteration = 1.
Now the inner loop executes n – 1. Before the execution of the inner for
loop, the variable isSorted is set to true, assuming that the list is sorted. If
the list is already sorted, then the expression list[index] > list[index
+ 1] in the if statement always evaluates to false, so the body of the if
statement never executes. Because the inner loop executes n – 1 times, there
are n – 1 comparisons. In the second iteration of the outer loop, because the
variable isSorted is true, the loop condition, (iteration < length) &&
!isSorted, evaluates to false, so the outer for loop terminates. It follows
that, if the list is already sorted, the outer for loop executes only once. Hence,
the total number of comparisons is n – 1 = O(n).
b. 30
11.

4

13.
15.
17.

2, 11, 12, 15, 17, 55, 90, 80, 58, 98, 36

Bubble sort: 49,995,000; selection sort: 49,995,000; insertion sort: 25,007,499
In quick sort, the list is partitioned according to an element, called pivot, of the
list. After partitioning, elements in the first sublist are smaller than the pivot and
in the second sublist they are larger than the pivot. The merge sort partitions the
list by dividing it into two sublists of nearly equal size by breaking the list in the
middle.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 19 |

1643

19.

a. 9, 2, 13, 36, 55, 23, 62, 95, 86, 65, 75, 74, 89, 100, 98
b. 6
c. 2 and 3
21. a. 48
b. 22, 30, 9, 15, 25, 18, 3, 48, 66, 95, 94, 55, 80, 50, 62
c. 15
d. 7 and 7
23. The function partition is called 9 times and the number of comparisons to sort
the list is 37.
25. Quick sort: 10000  log2(10000) ¼ 132878; merge sort: 132878.

Chapter 19
1. a. false; b. true; c. false; d. true; e. false; f. true; g. false; h. true; i. true;
j. true; k. true
3. LA ¼ {B, D, E, H, I, J, L, M, O, P}.
5. LB ¼ {D, H, I, L, O, P}.
7. LE ¼ {J, M}.
9. 4
11. 5
13. 2
15. 3
17. A, B, D, H, and L
19. A, B, D, H, L, O, P, I, E, J, M, C, F, K, N, Q, R, G
21. 68-95-75-80-85-90

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1644

23.

| Appendix I: Answers to Odd-Numbered Exercises

Binary search tree after deleting 60.

68

95

50

40
28
10

75

55
62

72

99
96

80

35

85

30

98

90
88

25.

Delete node 75 and redraw the binary tree.

68

95

50

40
28
10

72

55
62

35
30

60

99
80

96
85

98
90

88

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 19 |

27.

1645

Each node has two pointers. Thus, there are 2n pointers in all the nodes of the
binary tree. The pointer pointing to the root node is an external pointer. Each of
the remaining n1 nodes has one pointer pointing to it, which is a pointer from the
parent node. The remaining pointers in all the nodes, which is 2n (n 1) = n + 1,
are nullptr. This implies that the binary tree has n + 1 empty subtrees.

29.

A

B

G

I

D
E

L

H

C

F

J

M
K

31.

a

a
Pop
e

33.

b
a

d
b
a

b
a
Pop
d

c
Pop
a

g
b
a

f
Pop
c

b
a
Pop
g

h
f

a
Pop
b

f
Pop
h

e
a

Pop
f

The answer to this question is available at the Web site accompanying this book.

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1646

| Appendix I: Answers to Odd-Numbered Exercises

Chapter 20
1.
3.
5.
7.
9.

11.

a. true; b. false; c. true; d. true; e. false; f. true; g. false; h. false; i. true
1-4-3-7-10; Length of this path is 4.
The vertices 0 and 9 are connected. A path from vertex 0 to vertex 9 is 0-4-3-8-9.
The vertices 0 and 5 are not connected.
0-6-10-9-8-7-11
2
3
0 1 1 0 0 0 0 0 0
60 0 0 0 1 0 0 0 07
6
7
60 1 0 0 0 1 0 0 07
6
7
60 1 1 0 1 1 0 0 07
6
7
60 0 0 0 0 0 0 0 07
6
7
60 0 0 0 1 0 0 0 07
6
7
60 0 0 0 0 0 0 1 17
6
7
40 0 0 0 0 0 0 0 15

0

0 0

0

0

0

0 0

0

13.
15.

0, 1, 4, 2, 5, 3, 6, 7, 8
0, 1, 2, 5, 7, 3, 6, 10, 11, 9, 4, 8
2
3
1 10 6 1 1 1 1
61 1 1 1 1 1 17
6
7
61 1 1 1 1 4
8 7
6
7
7
3
1
1
1
11
1
1
17. 6
6
7
61 1 1 1 1 1 17
6
7
4 1 6 1 1 1 1 10 5
1 1 1 1 1 1 1
19.

0

1
3

4

2
8

5
6

7

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Chapter 21 |

1647

21.

4

0

1
3

3
6

3

6

2

5

1
7

4

5

15

3

2

2

10

7

5

Source Vertex: 0
Edges
Weight
(3, 1)
3
(1, 2)
2
(6, 3)
2
(0, 4)
3
(2, 5)
1
(4, 6)
3
(5, 7)
5
A minimal spanning tree weight: 19

Chapter 21
1. a. true; b. false; c. true; d. false; e. true; f. false; g. false; h. true; i. true; j. false;
k. false; l. true; m. false; n. true; o. false; p. false; q. true
3. A container is used to store data, while an algorithm is used to manipulate the data
stored in a container.
5. An STL function object contains a function that can be treated as a function using
the function call operator.
7. vecList = {14, 22, 60, 60, 55, 12, 9, 45, 16, 25, 92, 11}
9. 0 0 8 12 24
11. a. intList1 = {7, 8, 19, 90, 15, 13, 15, 16, 18,
90, 30, 11, 88, 26}

b. intList1 = {12, 14, 20, 13, 15, 16, 18, 90, 30, 11, 88, 26}

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1648

| Appendix I: Answers to Odd-Numbered Exercises

13.

A back_inserter uses the push_back operation of the container, while a
front_inserter uses the push_front operation of the container to add elements to the container. Furthermore, a front_inserter cannot be used for the
vector container.

15.
17.
19.
21.

5
abc*e%f$h8
5 56 27 2 78 30 35 48 36
9

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

I NDEX

ª HunThomas/Shutterstock.com

N o t e : P a g e n u mb e r s i n b o l d fa c e i n d i c a t e k e y t e r m s.

A
abacus, 2
abs function, 347, 350–353
absolute value, 211
abstract classes, 860–867
abstract data type (ADT), 680–681, 774
binary search trees, 1369–1379
binary trees, 1359–1367
graphs, 1410–1413
implementing, 681–682
linked lists, 1085–1097, 1106–1117
lists, 681–682, 869
abstraction, 680
acceptAmount function, 705–706
accessor functions, 664–667, 780, 783
accumulate algorithm, 1493
accumulate function, 1546–1551
A class, 763
action statement, 190
actual parameter list, 354
actual parameters, 352
changing value, 384
corresponding to formal parameters, 354, 377
virtual functions, 856
Ada, 774
addFirst function, 395–397
additionalBonus variable, 16
addition compound operator (+=), 94–95
addition operator (+), 43, 45, 903, 922
overloading, 923–924
add operation, 1216–1217
addQueue function, 1216, 1218, 1220–1221, 1225,
1229–1230, 1232, 1246
addresses, 4–5
address of operator (&), 814, 881–883
addressOfX function, 882, 883
addressType struct, 624–625
addVotes function, 1333
adjacency lists, 1409
adjacency matrix, 1408
adjacent, 1407
adjacent_difference function, 1493, 1546–1551
adjacent_find function, 1491, 1493, 1497, 1524–1528
adjacent from, 1407
adjacent to, 1407
ADT. See abstract data type (ADT)

A function, 1042
age variable, 66, 141, 197, 210
aggregate operations, 531, 554
aggregation, 738, 767–772. See also composition (aggregation)
Aiken, Howard, 3
algorithm header file, 1455, 1490, 1501, 1505, 1510, 1517,
1520, 1529
algorithms, 11–13, 1442
classifications, 1491
dominant operations, 1277
function overloading, 1493
generic, 1491
heap sort algorithms, 1493
implementing, 21
modifying algorithms, 1492
nonmodifying algorithms, 1491
numeric algorithms, 1492–1493
recursive algorithms, 1041
repetition, 21
subproblems and, 13
aliases, 881–883
allocating memory. See memory allocation
American National Standards Institute (ANSI), 22
American Standard Code for Information Interchange (ASCII),
7, 40–41, 203
amountDue variable, 14–15, 57
analog signals, 6
analytical engine, 2
and (&&) logical operator, 197–203, 209–210, 213
and operator (&), 200
Android, 5
anitaHouse variable, 615
anonymous data types, 475
ANSI. See American National Standards Institute (ANSI)
ANSI/ISO Standard C++, 22, 485
namespace mechanism, 81, 485–490
Standard Template Library (STL), 1442–1551
string data type, 53
append function, 494
Apple computer, 3
apple object, 708
application programs, 5
areaAndPerimeter, 378
area function, 689–690, 742–745, 747, 752–753, 910
area variable, 19, 33
arguments, 131, 134
arithmetic expressions, 30, 45

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1650

|

Index

arithmetic expressions (Continued)
floating-point (decimal) expressions, 48–49
grouping with parentheses (), 46
infix notation, 1201
integral expressions, 48–49
mixed expressions, 48, 49–50
operands, 45
Polish notation, 1201
postfix notation, 1202
prefix notation, 1201
Reverse Polish notation, 1201
arithmetic function objects, 1494
arithmetic operators, 43–45
addition operator (+), 43, 45
associativity, 46
division operator (/), 43, 45
floating-point data type, 43
integral data type, 43–44
modulus (mod) operator (%), 43–45
multiplication operator (*), 43–45
negation operator (-), 43, 45
order of precedence, 46–47, 200
remainder operator (%), 43–45
subtraction operator (-), 43, 45
arithmetic overflow and underflow exceptions, 1010
arrayAsParameter function, 538
array-based lists, 868–875, 972–978
binary search algorithm, 1270
insertion sort, 1292–1297
pivot, 1299–1303
quick sort algorithm, 1298–1306
selection sort, 1290–1292
sequential search, 1267–1269
sequential search algorithm, 877
sublists, 1299
arrayClass class, 932–933
array index operator ([]), overloading, 958–966
arrayListType class, 869–872, 875, 879, 972, 975, 978
as abstract data type (ADT), 972
arrays, 21, 520, 521
accessing components, 523–524
aggregate operations, 531, 554
auto declaration of elements, 549–550
base address, 535–538, 1173
in bounds, 529
circular, 1220–1221
class objects, 658, 677–679
components, 523–524
component-wise copying, 532
constant arrays as formal parameters, 533–535
constructors, 677–679
copying elements between, 531–532, 535
C-strings and, 572–573
declaring, 542
default size, 874, 1222
dynamic, 525, 831–833, 868
elements, 521
implementing queues, 1218–1227
implementing stacks, 1170–1188
index, 523, 527, 535
index out of bounds, 529–530
initializing, 526, 534
initializing during declaration, 530, 552, 1461
integral data types and indexes, 541–542
largest element in, 526–528, 1043–1046

for loops, 22
manipulating lists, 868–875
memory location, 535–538
multidimensional, 574–575
number of components in, 522
one-dimensional, 521
outputting data, 525–526
parallel, 558–559
parameters to functions, 532–533
partial initialization during declaration, 530–531
passed by reference, 532–533
passed by value, 538
pointers to, 840
printing, 526, 534
processing, 525–529, 531–533
random access data structure, 1170
range-based for loops, 834–835
reading data into, 526, 534
searching for specific item, 542–549
selection sort, 545–549
sequential lists, 1072
size, 525, 530–531, 552, 831, 868–869, 872
smallest element in, 528
sorted and unsorted sublists, 1295
sorting, 545–549
static, 831
stepping through with loops, 525–528
strings, 572
struct data type in, 621–623
in structs, 619–621
versus structs, 618
summing elements, 534–535
two-dimensional, 560–574
variables, 524, 824–825
arraySize variable, 525
array subscript operator ([]), 491–492, 523
arrivalTimeEmp array, 677–678
arrivalTime variable, 1235, 1237
artificial intelligence, 3
ASCII. See American Standard Code for Information
Interchange (ASCII)
ASCII character set, 188, 280, 551
assemblers, 8
assembly languages, 8
assert function, 234–236, 961, 998, 1001–1002, 1094
assert statement, 235, 959
assign function, 1463, 1468
assignment operator (=), 43, 58–59, 187, 814, 844, 903,
1172, 1453
associativity, 61, 966
classes, 657–658, 843–844
versus equality relational operator (==), 220–221
order of precedence, 200
overloading, 929–937, 974, 1092, 1097, 1179–1180,
1197–1198, 1362, 1366–1367
pointer variables, 829–830
assignment statements, 43, 57–61
assigning value of struct variable, 615–616
compound, 94–95
initializing variables, 66–69
peek function, 137
simple, 94, 95
value-returning functions, 351
associative containers
automatically sorted elements, 1479–1480

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

binary search trees, 1480
multiset associative container, 1480–1486
set associative container, 1480–1486
associativity, 46, 200
assignment operator (=), 61
operators, 904
relational operators, 211–213
asymptotic notation, 1276–1284, 1280
at function, 494, 1445, 1463
Augusta, Ada, Countess of Lovelace, 2
auto declaration and range-based for loops, 549–550
automatic variables, 409–410, 698
a variable, 61, 71–72
averageAndGrade function, 379
average parameter, 379
average variable, 18, 301
AVL trees, 1386

B
Babbage, Charles, 2
back, 1215–1216
back function, 1094, 1125–1126, 1216, 1225, 1229–1230,
1445, 1463, 1468, 1488
back_inserter insert iterator, 1500, 1527
back pointer variable, 1122, 1126–1127
backslash escape sequence (\\), 78
backspace escape sequence (\b), 78
bad allocation error message, 1013
bad_alloc exception, 825, 1010–1013
bar graphs, 431–432
base 2, 7
base 10, 7
base cases, 1040–1041
baseClass class, 741, 754
base classes, 739–741, 855, 859–861
constructors, 748–756
copying values of derived class object into, 858
destructors, 757, 859
private members, 748, 750
redefining (overriding) member functions of, 741–748
virtual destructors, 859
baseSalary variable, 16
base 2 system, 1055, 1059
base 10 system, 1055, 1059
Basic, 8
bCh variable, 765–767
B class, 763
bClass class, 764–767
bDay object, 771
begin function, 835, 1094–1095, 1449, 1453, 1456, 1503,
1505
beg iterator, 1444, 1447, 1454, 1462, 1467, 1481
beg pointer, 1444
Bell Laboratories, 22
B function, 1042
bidDirectional bidirectional iterator, 1475–1476
bidirectional iterators, 1475–1476
Big-O notation, 1276–1280, 1281–1284
billingAmount function, 781, 786
binary code, 6
binary digits, 6
binary numbers, 6–7
converting decimal number to, 1059–1062
converting to decimal, 1055–1059

1651

binary operator (+), 491–492
binary operators, 45
overloading, 918–924
overloading as member functions, 918–922
overloading as nonmember functions, 922–924
relational operators, 187
binary search, 1269–1276
binary search algorithm, 1269
array-based lists, 1270
divide-and-conquer technique, 1269
key comparisons, 1271, 1274–1275
recursive algorithm, 1271
while loops, 1271, 1274–1275
binarySearch function, 1274
binary_search function, 1491, 1520–1523
binary search trees, 1368
abstract data type (ADT), 1369–1379
analysis, 1378–1379
associative containers, 1480
deleting nodes, 1373–1378
height, 1369
inserting items, 1371
key comparisons, 1378–1379
key in root node, 1369
left subtree, 1368–1369, 1373–1375
right subtree, 1368–1369, 1373–1375
root node, 1368, 1370
search algorithm, 1378–1379
searching, 1370–1371
traversing, 1370–1371
binary system, 7, 1055
binary trees, 1297, 1348
abstract data type (ADT), 1359–1367
binary search trees, 1368–1379
branches, 1348, 1351
breadth-first traversal, 1359
children, 1348, 1350
copying, 1353–1354, 1358, 1366
deleting nodes, 1358
destroying, 1365
directed branch, 1348
directed edge, 1348
empty, 1353
functions as parameters, 1383–1386
height, 1352–1353
implementing, 1359–1367
inorder sequence, 1355
inorder traversal, 1354–1359
leaf, 1351
left child, 1348, 1368
left subtree, 1348, 1349
length of path, 1351
level-by-level traversal, 1359
level of node, 1352
nodes, 1348–1351, 1353
nonrecursive inorder transversal, 1379–1381
nonrecursive postorder traversal, 1382–1383
nonrecursive preorder traversal, 1381–1382
nonrecursive traversal algorithms, 1379–1383
parent, 1348, 1351
paths, 1351
postorder sequence, 1355
postorder traversal, 1355–1359
preorder sequence, 1355
preorder traversal, 1354–1359

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1652

|

Index

binary trees (Continued)
right child, 1348, 1368
right subtree, 1348–1349
root node, 1348–1350, 1353
shallow copy of data, 1353
traversal algorithms, 1383–1386
traversing, 1354–1359, 1367
visiting nodes in sorted order, 1358
binaryTreeType class, 1360–1367, 1384–1385
binding, 854
binSearch function, 1275–1276, 1290
binToDec function, 1056–1059
bits, 6
bitWeight variable, 1056–1059
blank space (' '), 40
blanks parameter, 380
blank special symbol, 35
block of statements, 205
blocks, 398, 409
Bloodshed Software, 11
board array, 562, 571, 837, 839
board pointer, 837
*board pointer, 837
body, 351
bool data type, 38–40, 189, 196–197
Boolean alias, 476
bool reserved word, 40, 196
bool variables
flag variable, 281–284
logical (Boolean) expressions, 202–203
bottom-up design, 20
boxType class, 744–750, 752–754
brackets, 90
branch control structures, 189–192
branches, 186, 1298, 1348, 1351
breadth-first traversal, 1359
breadth first traversal algorithm, 1414, 1416–1418
breadthFirstTraversal function, 1417–1418
break reserved word, 225
break statement, 226–227, 229–230, 234, 311–313
breed variable, 856
bSearchTreeType class, 1369–1379, 1385–1386
bubble sort, 1284–1290
bubble sort algorithm, 1289–1290
bubbleSort function, 1287–1290
bugs
avoiding, 213–217, 232–234
patches, 319–322
build command, 11, 688
buildListBackward function, 1084–1085
buildListForward function, 1083
business function, 369–373
b variable, 61, 71–72
bX variable, 765–766
bytes, 6–7

C
C, 8
C#, 8
C++, 2, 8, 22, 80, 774
case sensitivity, 36
integrated development environments (IDEs), 10, 11
C++11, 22
calBurnedInAWeek variable, 265–266

calBurnedInOneDay variable, 265–266
calculateAverage function, 424–426
calculatePay function, 756, 861
calculateTotalVotes function, 1323
callPrint function, 853–854, 856
candidateList object, 1325–1329, 1331
candidateType class, 1317, 1320–1326, 1332
capacity function, 1446
carDealers multidimensional array, 575
carType enumeration type, 563
case reserved word, 225–226
case sensitivity, 36
case statements, 226–227, 229–231, 234
cashOnHand member variable, 706
cashRegister class, 705–707
cassert header file, 235, 961
cAssignmentOprOverload class, 933–937
casting, 51–53
cast operator, 51–53, 350, 469–470, 500
catch block parameter, 1003
catch blocks, 1002–1006, 1006, 1009, 1011, 1013–1014,
1017, 1022, 1024, 1027
catching exceptions, 1027
C++ Builder, 11, 688
cctype header file, 348, 350, 1507, 1537
cCustomer object, 1244
ceil function, 347
celsius variable, 158–159
CENTIMETERS_PER_INCH constant, 91
central processing units (CPUs), 4
cExpObject object, 822
cExpPtr pointer, 822–823
cfloat header file, 1425
change variable, 475
character arrays, 551–558, 572
characterCount function, 583, 584
characters, 40–41
arithmetic operations, 46
ASCII values, 280
bytes, 7
char variables, 67
collating sequence, 188–189
comparing, 40
encoding schemes, 7
maximum number ignored in line, 135–136
next available, 137–139
putting last from input stream back, 137–139
reading, 134, 137–139
relative position in strings, 53
storing in memory, 137–139
strings, 53–54
character sets, 40–41
char data type, 38–41, 470–471
arithmetic operations, 46
converting to int data type, 53
extraction operator (>>), 126–130
pointer variables, 813
reading values, 134
relational operators, 188–189
charItr iterator, 1519
charList vector, 1506–1507, 1519, 1537
charList vector list, 1513, 1516
char variables, 67, 584
checkTitle function, 1142
chExp variable, 135

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

children, 1350
chips, 3
ch pointer variable, 813
ch variable, 551, 582
cin (common input) statement, 19, 36, 63–66, 79, 80–81,
124–125, 161, 284, 488, 555, 762
extraction operator (>>) and, 125–130
get function, 133–134
ignore function, 135–136
cinget identifier, 139
cin variable, 139, 285
circle class, 739–740, 860
circle object, 1021
circle1 object, 691
circle2 object, 691
circleType class, 689–691, 1019–1021
circular array, 1220–1221
circular linked lists, 1131
circumference function, 689, 690
citySalesTax variable, 14–15
classes, 21, 139, 650, 773
abstract classes, 860–867
abstract data type (ADT), 681–682
address of operator (&), 881–883
assignment operator (=), 657–658
assignment operators, 843–844
base classes, 739
built-in operations on, 657
class templates, 967, 969–971
clients, 664
components, 650
constructors, 669–671, 675
copy constructor, 845–848, 847–848
declaring variables, 654–655
defining, 650–651, 768–772
derived classes, 738–739
destructors, 679–680, 842–843
examples of, 689–698
exception classes, 1009–1013
formal parameters, 855
friend functions, 912–914
functions, 658–659, 821–823
identifying, 774–775
inheritance, 738–767, 859
instance variables, 664
manipulating sets, 879
member access operator (.), 657
members, 650
nodes as, 1073
non-static member variables, 700–702
object-oriented design (OOD), 773
object-oriented programming (OOP), 773
pointers, 821–823
pointer variables, 841–852, 944
private members, 651–653, 668–669, 683, 763, 820,
881–882
protected members, 763
public members, 651–653, 668–669, 763
pure virtual functions, 860–861
relating, 738
reusing, 773
static members, 698–704
versus structs, 682–683
Unified Modeling Language (UML) diagrams, 654
virtual destructors, 859

1653

classExample class, 821–823
classifyDigits function, 695–698
classifyNumber function, 418–420
classIllusFriend class, 912
class instances, 654–655
class keyword, 967
class members, 650–651, 655–656, 658
class objects, 654–655, 658–659
arrays, 677–679
initializing, 677
class reserved word, 651
class templates, 967, 969–971
containers, 1443
classTest class, 958–959
clear function, 142–143, 156, 494, 496–497, 1447,
1453–1454, 1483
clearGraph function, 1413
clearList function, 874
clients, 664
C-like casting, 53
cList array, 1506, 1516, 1519
clocks array, 679
clockType abstract data type (ADT), 681
clockType class, 651–653, 655, 657, 659–660, 664–665,
668-670, 675–679, 683–687, 738, 902-903,
905–907, 944–952
clockType.h header file, 684, 687
clockType objects, 978
close file stream function, 162–163
cmath header file, 79, 81, 131–133, 211, 347–348, 350,
488, 490
cntItr iterator, 1473
COBOL, 3, 8
code, prewritten, 11
codeOk variable, 578
coins enumeration type, 475
collating sequence, 40, 203
colors enumeration type, 467
colorType enumeration type, 563
column processing, 565
columns variable, 839
commands, 3
commas (,), 35, 90
comments, 31, 34–35
common input, 124
common output, 124
compareCode function, 578–579
compare function, 494
compareThree function, 358–360
comparison-based search algorithms, 1284, 1297
comparison-based sorting algorithms, 1297–1298
comparison tree, 1297–1298
compilers, 9–11
error messages, 13
integral data types, 39
syntax errors, 85–89
compile-time binding, 854
complex numbers, 953–958
complexType class, 953–958
components, 1407
classes, 650
grouping different types, 610–626
composition (aggregation), 738, 767–772, 775–796
compound assignment statements, 94–95
compound statements, 205, 215

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1654

|

Index

compStudent enumeration type, 468
Computer History Museum, 2
computer programs, 28
computers, 3–5
language of, 5–7
machine language, 6
processing programs, 186
software, 5
concatenating strings, 491
conditional expressions, 221
conditional operator (?:), 221–222
connected vertices, 1407
constant functions, 665
constants
declaring references parameters as, 385
memory allocation, 54–57
named constants, 55–56
const reserved word, 55, 385, 533, 621, 653, 658–659,
780, 783
constructors, 669–671, 966
arguments, 672
arrays, 677–679
automatically executing, 670, 771
base classes, 748–756
containers, 1452
default, 670
default parameters, 675, 753
derived classes, 748–756
formal parameter list, 670
invoking, 671–674
name of, 670
number of arguments, 672
parameters, 670, 675–676
passing arguments to, 771–772
without parameters, 670, 675–676
contactType struct, 624–625
container adapters, 1486–1489
containers, 1442
associative containers, 1479–1489
class templates, 1443
constructor, 1452
copy constructor, 1452
copying elements, 1455–1458
default constructor, 1452
destructor, 1452
filling with elements, 1501–1503
header files, 1489–1490
iterators, 1477–1478, 1489–1490
for loops, 22
member functions, 1452–1453
number of elements in, 1446
operations, 1490
outputting elements of, 1455–1458
pointers, 1456
position of elements, 1449
sequence containers, 1443–1452, 1466–1472
stepping through elements, 1447
continue statement, 311–313
control statements, 206–210
control structures, 21, 186
associativity of relational operators, 211–213
block of statements, 205
bool data type and logical (Boolean) expressions, 196–197
comparing floating-point numbers, 210–211
compound statements, 205
do...while loops, 307–311

if statements, 189–192
int data type and logical (Boolean) expressions, 196
logical expressions, 187–222
for loops, 295–306
multiple selections, 205–208
nested, 278, 314–319
one-way selection, 189–192
relational operators and string data type, 203–204
repetition, 186–187, 264–266
selection, 186–222
switch structures, 225–232
two-way selection, 192–196
while loop, 267–295
conversion constructor, 964
CONVERSION named constant, 55
convertEnum function, 478, 481–482
copiesInStock variable, 1140, 1142
copy algorithm, 1455–1458, 1491–1492
copyArray element, 535
copy_backward algorithm, 1492
copy constructor, 845–848, 875
containers, 1452
overloading, 1362
copy function, 1455–1458, 1499–1500
copyList function, 1092, 1095–1096, 1123
copyStack function, 1172, 1178
copyText function, 583–584
copyTree function, 1354, 1365–1366
cos function, 347
cost member variable, 709
costOfOneBox variable, 274, 277
counted for loops, 295
counter-controlled while loops, 272–275, 316
counter variable, 43, 272, 274–275, 293, 304, 317, 380, 998
count function, 1491, 1521, 1531–1535
count_if function, 1491, 1531–1535
count variable, 70, 290, 398, 699–700, 703, 998, 1086,
1099, 1101, 1108–1110, 1123, 1128, 1222, 1224–1225
course enumeration type, 470
courseGrade array, 558–559
courseGrade function, 362–363
courseGrade variable, 474, 614, 617
courseScore parameter, 386–388
coursesEnrolled array, 783, 787
courses enumeration type, 473–474
courseType class, 650–651, 777–780, 783, 786–787
cout (common output) statement, 31, 72–81, 124–125, 138,
161, 488, 556, 762, 1457
debugging, 157–160
setprecision manipulator, 145
switch statement and break statement, 234
cout variable, 139
.cpp extension, 9, 82, 684
C++ programs
See also programs
creation, 81–85
expressions, 30
functions, 31–32, 34, 81
header files, 80–82
main function, 31–32, 34
multiple-line comments (/* */), 35
output statements, 29, 30–31
preprocessor directives, 82
processing, 9–11
single-line comments (//), 31, 34–35
subprograms, 34

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

CPUs. See central processing units (CPUs)
createDVDList function, 1145
createGraph function, 1412–1413
createSpanningGraph function, 1431
createWeightedGraph function, 1419–1420
creditCardBalance variable, 191
cScore formal parameter, 387
cstddef header file, 823
cstlib header file, 282
c_str function, 557
cstring header file, 552–553, 960
C-strings, 551–558, 572, 960–966
aggregate operations, 554
arrays of strings and, 572–573
character arrays, 551
comparing, 552–553
copying, 552
double quotation marks (''''), 554–555
functions, 552–553
length, 552, 554
null terminated, 551, 554
output, 556
reading, 555–556
storing in memory, 551
C-structs, 683
ct container, 1452–1453
ctime header file, 282
curly braces ({ }), 90
currentCustomer variable, 1238
current parameter, 1143
current pointer, 1074–1076, 1108–1109, 1111, 1113,
1122, 1129, 1141–1142, 1212–1214, 1308,
1370–1371, 1371
current variable, 292–293
customerNumber variable, 1235, 1237
customers, 1234–1238, 1246
customerType class, 1145, 1235–1238
c variable, 61
cycle, 1407, 1408
cylinders, 774–775
cylinderType class, 774–775

D
dangling, 827
pointers, 841
data
First In First Out (FIFO), 1442
fixed, 55–56
Last In First Out (LIFO), 1442
list form, 559
manipulating, 21, 38, 81, 124
member-wise copying, 844, 847
modifying, 56–57
nodes, 1072
operations on, 681
retrieving, 124
shallow copy, 844–847
table form, 559–560
writing to output stream, 1474–1475
data abstraction, 680
dataTypeName, 51
data types, 38–42
anonymous, 475
bool data type, 38–40

1655

char data type, 38–40
comparing values, 189
conversion, 51–53
defining, 611
domains, 812
double data type, 41–42
enumeration types, 38, 466–475
explicit type conversion, 51–53
float data type, 41–42
floating-point data type, 38, 41–42
formal parameter list, 377
implicit type conversion, 51
int data type, 38–40
integral, 38–41
long data type, 38
long double data type, 41
long long data type, 22, 38–39
names, 812
operators, 904
parameters, 351
short data type, 38
simple data types, 38–41, 57, 520
string data type, 53–54
structured, 520
synonyms or aliases, 475–476
unsigned char data type, 38
unsigned int data type, 38
unsigned long data type, 38
unsigned long long data type, 38
unsigned short data type, 38
user-defined, 38, 466–475
value-returning functions, 353
variables, 42–43, 61, 468
dateType class, 768–770
dateType struct, 624
.dat extension, 162
dA variable, 766
DBL_MAX constant, 1425
dClass class, 765–767
dDay variable, 769–770
debugging
cout statements, 157–160
drivers, 411–413
logic errors, 157–160
loops, 322
software patches, 319–322
stubbs, 412–413
syntax errors, 85–88
decimal alias, 476
decimal data type, 42
decimal numbers, 38, 41–42
converting binary number to, 1055–1059
converting to binary number, 1059–1062
decimal point and trailing zeros, 146–149
precision, 42
decimalNumber variable, 1056–1059
decimal reference parameter, 1056–1059
decimal system, 7, 1055
decision making, 190, 267
if statements, 220
programs, 21
declaration statements, 83
declarative statements, 82
decreaseTransactionTime function, 1241
decrement operator (--), 70–72, 830, 832–833
overloading, 937–938

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1656

|

Index

decToBin function, 1060–1062
deep copy, 841
versus shallow copy, 839–841
default constructor, 670, 675–676
automatically providing, 676
containers, 1452
invoking, 671–672
default parameters, 415–417, 675
default reserved word, 225
#define NDEBUG preprocessor statement, 236
#define statement, 759
definition, 352
deleteFromTree function, 1375–1377
deleteItem item, 1377
deleteNode function, 1092, 1097, 1100–1106,
1113–1114, 1130–1131, 1362, 1377–1378
delete operation, 1216–1217
delete operator, 825–827, 829, 842, 1092, 1365
deleteQueue function, 1216, 1218–1219, 1221,
1225–1226, 1229–1232, 1246
denominator variable, 235
departureTimeEmp array, 677, 679
depth first traversal algorithm, 1414–1416
depthFirstTraversal function, 1416
deq deque container, 1462
deqIt iterator, 1466
deque class, 1462
deque containers and bidirectional iterators, 1476
deque header file, 1462
deque objects, 1462
deque sequence container, 1454, 1462–1466
dereferencing operator (*), 815, 1087, 1449, 1478
iterators, 1473
precedence, 820–821
derivedClass class, 741, 754
derived classes, 738–739, 859, 860–861
actual parameter to formal parameter, 856
base class, 763
constructors, 748–756
copying values into base class object, 858
destructors, 757–758, 859
formal parameter of base class, 852–853
functions, 859–860
header files, 757–758
member variables, 741, 754
private members, 740
private member variables, 748
protected members, 764–767
public member function, 745, 746
public members of base class, 740
redefining (overriding) member functions of base class,
741–748
destFirst iterator, 1524
destination, 1405
destroy function, 1123, 1365–1365
destroyList function, 846, 848, 1092–1093, 1096
destroyTree function, 1365–1366
destructors, 679–680, 842–843
base classes, 757
containers, 1452
derived classes, 757–758
naming, 679
overloading, 1362
DevC++ IDE, 11
dftAtVertex function, 1416
dft function, 1415

die class, 691–693
die default constructor, 691–692
difference engine, 2
digital signals, 6
digraph, 1405
dimensions, 774–775
directed branch, 1348
directed edge, 1348
directed graphs, 1405–1410
directly recursive functions, 1042
discardExp function, 1204, 1208
Discrete Mathematics: Theory and Applications (Malik and
Sen), 322, 1405
discriminant, 257
dispenserType class, 707–709
displayMenu function, 1145
displayResults function, 478, 482
displayRules function, 478–479
divByZero class, 1014–1015
divByZeroObj parameter, 1017
divideList function, 1309–1310, 1312–1313
dividend variable, 1000, 1006, 1009
divides function object, 1494
division by zero, 234–236
divisionByZero class, 1016–1017, 1022
divisionByZero exception, 1024
division by zero exception, 998, 999–1002, 1005–1009
division compound operator (/=), 94–95
division operator (/), 43, 45, 903
divisor, 309
divisor variable, 999–1002, 1006, 1009, 1017, 1024
dMonth variable, 769–770
documenting programs, 92
doDivision function, 1018, 1024
dog object, 854, 856–859
dogType class, 853, 855–858
dogType.h header file, 855, 857
domains, 681, 812
do reserved word, 307
doSomething function, 550
dot notation, 139
dot operator (.), 820–821
double data type, 41–42, 56, 126–130, 355, 542
doubleDimensions function, 908
double-ended queues, 1462–1466
doubleFirst function, 395–397
doubleList function, 1459
doubleNum function, 1537
double precision, 42
double quotation escape sequence (\''), 78
doublyLinkedList class, 1120–1131
doubly linked lists
back pointer, 1120
deleting nodes, 1123, 1128–1131
empty state, 1123
first element, 1125–1126
initializing, 1124
inserting nodes, 1126–1128
last element, 1125–1126
length, 1124
list sequence container, 1466
pointers, 1120, 1122
printing, 1124
reverse order printing, 1124–1125
searching, 1125
traversing, 1120

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

do...while loops, 307–311, 313, 364, 408, 1027, 1054,
1296
draw function, 860
drivers, 411–413
drivingCode variable, 220–221
dummyClass class, 676
dummyExceptionClass class, 1013
dummy parameter, 939
d variable, 61
dvdBinaryTree class, 1390–1392
dvdCheckIn function, 1391
dvdCheckOut function, 1391
dvdCheckTitle function, 1391
dvdListType class, 1138–1140, 1143–1145, 1148–1151
dvdPrintTitle function, 1392
dvdSearch function, 1391
dvdSetCopiesInStock function, 1391
dvdTitle variable, 1140
dvdType class, 1133–1135, 1141, 1148–1151, 1387–1390
dvdUpdateInStock function, 1391
dYear variable, 769–770
dynamic arrays, 525, 831–833, 868
accessing components, 832
deallocating, 842
deque sequence container, 1462
list pointer variable pointing to, 834
new operator, 831
range-based for loops, 834–835, 1459
two-dimensional, 836–839
vector sequence container, 1443
dynamic binding, 854
dynamic memory, 757
dynamic two-dimensional arrays, 836–839
dynamic variables, 824–827

E
early binding, 854
EBCDIC. See Extended Binary-Coded Decimal Interchange
Code (EBCDIC)
edges, 1405–1407
edges array, 1430
edgeWeights array, 1430
Eiffel, 774
electrical signals, 6
Electronic Numerical Integrator and Calculator (ENIAC), 3
elem element, 1524
elements
auto declaration, 549–550
copying between arrays, 531–532
largest, 526–528
returning values, 1474
smallest, 528
sum of, 550
elemNext element, 1524
elemType parameter, 971, 1384
ellipse class, 860
else reserved word, 193
pairing with if statements, 206–208, 216
else statements, 195, 280
employee.dat file, 622
employees array, 621–622, 626
employeeType class, 861–862
employeeType struct data type, 621, 623–626
empty function, 494–497, 1446, 1452, 1486, 1488

1657

empty strings, 53
encapsulation, 773, 902
encoding schemes, 7
end function, 835, 1094–1095, 1449, 1453, 1456, 1503
#endif statement, 759
end iterator, 1444, 1447, 1454, 1462, 1467, 1481
endl keyword, 30–31, 488
endl manipulator, 72, 75, 144, 156
end-of-file (EOF)-controlled while loops, 284–290
end pointer, 1444
enumeration types, 38, 466, 477
arithmetic operations, 469
cast operator, 469–470
declaring variables, 468, 474–475
identifiers, 466–467
illegal, 467–468
increment and decrement operations, 469
indexes, 542
input/output (I/O), 470–472
legal, 468
loops, 470
operations on, 469
as parameter to functions, 473–474
relational operators, 469–470
two-dimensional arrays, 563–566
enumerators, 467
enum reserved word, 467
EOF-controlled while loops, 317–318
eof function, 285–290
equal algorithm, 1491
equal_range algorithm, 1491
equalTime function, 652–656, 660, 662–665, 686, 905
equal_to function object, 1496
equal to operator (==), 187, 830, 905–907, 1453,
1487–1488
versus assignment operator (=), 220–221
overloading, 923–924
erase function, 494–497, 1447, 1453–1454, 1483
error messages
compilers, 13
user-defined exception classes, 1015
error variable, 150–151
escape character (\), 73, 162
escape sequences, 78–79
evaluateExpression function, 1204–1205, 1208
evaluateOpr function, 1204, 1206–1208
evens variable, 304–305, 418–419
exabytes (EB), 6
example function, 534–535
exception class, 1009–1010
exception classes, 1009–1013
user-defined, 1013–1021
exception handling
division by zero exception, 999–1002
exception classes, 1009–1013
fixing error and continuing, 1026–1027
logging error and continuing, 1027–1028
mechanisms, 1002–1009
stack unwinding, 1028–1031
terminating program, 1026
try/catch blocks, 1002–1009
user-defined exception classes, 1013–1021
exceptions, 998
catching, 1027
division by zero, 999–1002

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1658

|

Index

exceptions (Continued)
logging, 1027–1028
processing thrown in function calling environment,
1029–1031
propagating, 1028–1029
throwing, 1003–1004, 1013–1021
throwing and rethrowing, 1022–1025
executable code, 82, 687–688
executable statements, 82–83
.exe file extension, 82
exit function, 1206
expert systems, 3
exp function, 347
explicit type conversion, 51–53
expN namespace, 490
expressions, 30
assigning value to variable, 61
columns exceeding required columns, 151–153
if statements, 220
left-justifying output, 154–155
outputting value in columns, 149–153
precedence, 202
right-justifying output, 151–152, 154–155
saving value of, 53, 61–62
switch statement, 225–227, 230
true or false, 187
while loops, 267, 269, 271, 290–291
extClockType class, 738
Extended Binary-Coded Decimal Interchange Code (EBCDIC),
7, 40, 551
external variables, 401
extern reserved word, 401
extraction operator (>>), 63–66, 133–134, 156–157, 161,
284, 318, 555, 762, 903
binary, 125
char data type, 126–130
cin (common input) statement, 125–130
double data type, 126–130
file stream variables, 162
int data type, 126–130
newline character, 130, 134
operands, 125
overloading, 924, 926–929
reading multiple data items, 126
white spaces, 130, 156

F
fabs function, 211, 347
fact function, 1041–1042, 1042
factorization function, 760
fahrenheit variable, 158–159
FALSE named constant, 476
false reserved word, 40, 196
feetAndInchesToMetersAndCent function, 406–408
feet variable, 64, 66
fenceCostPerFoot variable, 752
fertilizerCostPerSquareFoot variable, 752
Fibonacci number, 291–295, 366–368, 1047–1050
Fibonacci sequence, 291–292, 366
file I/O (input/output), 160–163
files, 160
appending, 164
closing, 162–163

end of, 284–290
opening, 161, 163
reading data from, 162
file stream variables, 161–163
fileStreamVariable variable, 161
fillArray function, 534
fill function, 156, 839, 1492, 1501–1503
fillNames function, 1327
fill_n function, 1492, 1501–1503
find_end function, 1491, 1507–510
find_first_of function, 495, 1491, 1507–1510
find function, 495, 498–500, 1490–1491, 1505–1507
find_if function, 1491, 1505–1507
finishedSquareFootage member, 611
first, 1072
first formal parameter, 395, 1304
First In First Out (FIFO), 1234, 1442
queues, 1215
first iterator, 1517
first member, 626
firstName variable, 65–66, 613, 1317
firstNum variable, 85, 350
firstOutOfOrder index, 1295, 1296
first1 parameter, 1455–1456
first2 parameter, 1455–1456
first1 pointer, 1310–1311
first2 pointer, 1310–1311
first pointer variable, 840–841, 1084, 1086, 1092–1093,
1096, 1099–1101, 1103, 1108–1109, 1113, 1123,
1126, 1128, 1131, 1232, 1313
first125000PrimeNum function, 760
firstRect variable, 924
first variable, 58, 62–63, 395, 1081–1082, 1091–1092,
1270–1273, 1290
fixed data, 55–56
fixed decimal format, 145–146, 194
fixed manipulator, 145–146, 147–149, 156, 371
flag-controlled while loops, 281–284, 290
flag variable, 281–284, 476
float data type, 41–42, 56
floating-point data type, 38, 41–43
floating-point (decimal) expressions, 48–49
floating-point notation, 41
floating-point numbers, 49
absolute value, 211
comparing for equality, 210–211
converting to integer, 51–52
decimal point and trailing zeros, 146–149
default type, 56, 145
division operator (/), 903
double data type, 42, 56
fixed decimal format, 145–147, 194
formatting, 144–145
precision, 144–145
scientific notation, 144–146
floor function, 347–348
for_each function, 1491, 1535–1537
foreignLanguages variable, 475
for indexed variable, 296
for loop control, 296
for loops, 22, 305, 316, 380, 527–528, 839, 1012, 1054,
1296, 1300, 1415, 1448–1449, 1451, 1456
auto declaration of elements, 549–550
body, 296
break statement, 311

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

component-wise copying, 532
continue statement, 313
counted, 295
counter, 303
counting backward, 299
immediately exiting, 311–312
indexed, 295
infinite, 298, 300
initializing array components, 832
initial statement, 296–298
inputting data, 567
largest element, 568
loop condition, 296–298, 300, 308
loop control variables (LCV), 299
nesting, 314–315, 1289
range-based, 550, 834–835, 1458–1461
scope of identifier, 398
simple or compound statements, 297
sorting lists, 547
stepping through array elements, 525–528
terminating, 300
two-dimensional arrays, 565–566
update statement, 296–298, 313
versus while loops, 301–302
formal parameter lists, 353–354, 413, 414
and&, 384
constructors, 670
data types, 377
formal parameters, 352, 834
actual parameters, 354, 377, 620
base address passed to, 537–538
base class objects, 852–853
changing value of, 659
constant arrays as, 533–535
const reserved word, 533
memory allocation, 388
as pointer, 852–853, 855–856
range-based for loops and, 1459
reference parameter, 378, 836, 852–853, 856
value parameter, 378, 856–857
virtual functions, 856
void functions, 376
formatting flags, 762
FORTRAN, 3, 8
forwardIterator forward iterator, 1475
forward iterators, 1475
forwardItr iterator, 1510
found parameter, 1140, 1143
fParamFunc1 function, 1384
free tree, 1427
friend functions, 912
extraction operator (>>), 915
insertion operator (<<), 915
operator functions as, 915–917
operator overloading, 943–944
pre-increment operator (++u), 939
friend reserved word, 912
front, 1215–1216
front function, 1094, 1125–1126, 1216, 1225,
1229–1230, 1445, 1463, 1488
front_inserter insert iterator, 1500
fstream class, 762
fstream header file, 160–161, 762–763
fullTimeEmployee class, 861–865
funcA function, 374

1659

funcArrayAsParam function, 533
funcB function, 374
funcExp function, 416
func parameter, 1535
functionABC function, 414
functionA function, 1030
functional header file, 1482
functionB function, 1030–1031
function call, 131, 357, 374
functionC function, 1030–1031
function header, 351
function objects, 1493, 1494–1499
arithmetic, 1494
logical, 1499
predicates, 1499
relational, 1496–1499
function overloading, 413–415, 966–969
algorithms, 1493
function prototypes, 358–360, 374, 416, 651, 659
functions, 21, 31–32, 34, 81, 186, 346
arguments, 131, 134
arrays as parameters to, 532–533
body, 351
calling, 353–354
classes and, 658
class members, 650–651
class templates, 971
constructors, 669–671
C-strings, 552–553
default parameters, 415–417
definition, 352, 659, 684
depending on another function, 411–413
derived classes, 859–860
destructors, 679–680
directly recursive, 1042
empty, 860
enumeration types parameter to, 473–474
exceptions thrown by, 1022
formal parameter lists, 354, 413–414
formal parameters, 352, 834
function templates, 967
global identifier access, 398
header files, 131
heading, 351, 352, 414
identifiers, 373
illegal arguments, 1010
immediately exiting, 218–219
inability to nest, 398
indirectly recursive, 1042
infinite recursion, 1042–1043
I/O, 347
istream (input stream) data type, 130
local variables, 388
mathematical, 347
names, 398, 413
overloaded operators, 903
overloading, 773–774
parameters, 131, 134, 347, 1383–1386
passing by reference, 388
pointers, 836, 1383
pointer variables, 836
predefined, 34, 131–140, 346–350
processing thrown exceptions, 1029–1031
pure virtual functions, 860–861
recursive, 1041–1042

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1660

|

Index

functions (Continued)
returning multiple values from, 384
reusing, 350
run-time binding, 860
search algorithm growth rate, 1278–1281
signatures, 414
stacks implementing calls, 1166
stack unwinding, 1028–1031
standard, 34
static, 698–704
string data type, 494–503
structured programming, 773
struct variables and, 617–618
tail recursive functions, 1042
testing, 411–413
throwing and rethrowing exceptions, 1022–1025
two-dimensional arrays as parameters, 568–571
user-defined, 350–351
value-returning, 351–375
virtual, 860
void functions, 351, 376–382
writing other functions with, 358
functionSeven function, 413
functionSix function, 413
function stub, 412–413
function templates, 902, 967–969, 971, 974, 976
function type, 347
functionXYZ function, 414
funcValueParam function, 383–384
funExample function, 401
funOne function, 390–393, 403
funTwo function, 392–393

G
gameCount variable, 478
gameResult function, 478, 480–481
gamewinner variable, 478
general cases, 1040
generate function, 1492, 1503–1505
generate_n function, 1492, 1503–1505
generic algorithms, 1491
gen function, 1503
getArrivalTime function, 1238
getCost function, 707, 709
getCourseName function, 778, 780
getCourseNumber function, 778, 780
getCredits function, 777, 780, 786
getCurrentBalance function, 705, 706
getCurrentCustomerArrivalTime function, 1241
getCurrentCustomerNumber function, 1241
getCurrentCustomerTransactionTime function, 1241
getCurrentCustomerWaitingTime function, 1241
getCustomerNumber function, 1238
getData function, 631–633
getDay function, 768–769
getEvensCount function, 695–698
getFirstName function, 694–695, 1317
getFreeServerID function, 1243–1244
get function, 130, 133–134, 137–139, 156, 161, 318, 555,
582, 762
getGpa function, 781, 787
getHeight function, 744, 747
getHoursEnrolled function, 781, 786
getLastName function, 694–695, 1317

getLength function, 742–743, 747, 910
getline function, 156–157, 318, 556
getMonth function, 768–769
getNoOfItems function, 707–708
getNumber function, 418–420, 422
getNumberOfBusyServers function, 1244
getNum function, 691–692, 695–698
getOddsCount function, 696–698
getRadius function, 689, 690
getRemainingTransactionTime function, 1241
getScore function, 385–388
getStudentData function, 789–790
getTime function, 652–653, 660–661, 664–665, 685, 949
getTotalVotes function, 1323
getTransactionTime function, 1238, 1241
getWaitingTime function, 1238
getWidth function, 742–743, 747, 910
getYear function, 768, 770
getZerosCount function, 696–698
gigabytes (GB), 6
global identifiers, 397–398
header files, 485
iostream header file, 488–489
global named constants, 403
global positioning satellites (GPS), 3
globalType namespace, 486–487
global variables, 401–403
memory allocation, 409
scope resolution operator (::), 401
static variables, 409
struct variables, 612
gpa component, 820–821
gpa variable, 153
grade enumeration type, 474
grade parameter, 379
grade variable, 18, 43, 227, 232, 290
graphics and binary trees, 1359
graphIt iterator, 1415
graph pointer, 1415
graphs, 1405
abstract data type (ADT), 1410–1413
adjacency lists, 1409–1410
adjacency matrix, 1408
applications, 1418
breadth first traversal algorithm, 1414, 1416–1418
cycle, 1407–1408
definitions, 1405–1408
depth first traversal algorithm, 1414–1416
destination, 1405
directed, 1405–1408
edges, 1405–1406
empty, 1411, 1413
free tree, 1427
minimal spanning tree, 1427–1433
notations, 1405–1408
operations on, 1409–1410
origin of edge, 1405
paths, 1407
printing, 1413
representations, 1408–1409
rooted tree, 1427
shortest path, 1418–1426
simple graphs, 1407
source vertex, 1428
spanning tree, 1427
strongly connected, 1407
subgraphs, 1405

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

traversing, 1414–1418
undirected, 1405–1407
vertices, 1405–1406, 1410
weight, 1418
weighted graphs, 1418
weighted tree, 1427
weight of the path, 1418
graph theory, 1404–1405, 1418
graphType class, 1410–1413, 1419
greater_equal function object, 1496
greater function, 1482, 1496
greater than operator (>), 187
greater than or equal to operator (>=), 187, 903
greedy algorithm, 1418
guess variable, 17, 284

H
Hamblin, Charles, 1201
hand-held devices, 3
hardware, 4–5
Harvard University, 3
‘‘has-a’’ relationship, 738, 767–772
head, 1072
header files, 80–82, 131, 684–686, 1489–1490
class templates, 971
derived classes, 757–758
functions, 131
global identifiers, 485
.h extension, 684
multiple inclusions of, 758–761
ordered linked lists, 1114–1115
predefined functions, 348, 350–351
system-provided, 684, 757
unordered linked lists, 1105–1106
user-defined, 684, 757
heading, 351–352
head pointer, 1074, 1076
heap sort algorithms, 1493
height
binary search trees, 1369
binary trees, 1352–1353
subtrees, 1353
height function, 1353, 1364
height variable, 141, 148–149, 197, 746, 749–750, 752
.h extension, 684
high-level languages, 8–10
Hollerith, Herman, 2–3
horizontal tab character (\t), 41
hours variable, 150–151, 193–194, 235
hoursWorked variable, 126
houseType struct, 611–612, 614–615
hr variable, 651–654, 656–657, 660, 663–664, 671, 675,
677–678, 902, 950
H_test preprocessor identifier, 759

I
IBM, 3
identifiers, 36–37, 80, 85
blanks in, 90
blocks, 398
cmath header file, 490
declaring before using, 57, 83

1661

enumeration data types, 466–467
functions, 373
global, 397
iomanip header file, 490
iostream header file, 490
legal and illegal, 37
local, 397
named constants, 55, 91
naming, 90–91
predefined, 36
rules to access, 397–399
run-together words, 91
scope of, 397–401
self-documenting, 91
std namespace, 80
switch structure, 226
undeclared, 358
user-defined, 36
IDEs. See integrated development environments (IDEs)
#ifdef statement, 759
if...else statements, 189, 192–196, 206, 225, 232, 388
comparing with if statements, 208–209
compound statements, 205
conditional operator (?:), 221–222
expressions and semicolon (;), 224
incorrect, 215
logical expressions, 193
nesting, 206, 278
range of values, 232
if reserved word, 190, 193
if statements, 189–192, 225, 280, 931, 1118, 1289, 1291
comparing with if...else statements, 208–209
compound statements, 205
decision maker, 220
ending, 195
exceptions, 998
expressions, 220
input failure, 217–219
input variables, 217
logical errors, 195
and (&&) logical operator, 213
nested, 205–208
one-way selection, 215
pairing else with, 206–208, 216
problems with expression in, 212–213
semantic errors, 192, 195–196
ifstream class, 763
ifstream data type, 160, 762
ifstream variables, 161, 290, 388
ignore function, 130, 135–136, 139, 156, 161, 762
illusObject1 object, 700–704
illusObject2 object, 700–704
illustrate class, 699, 703–704
immediate successors, 1410
implementation files, 684–686
class templates, 971
object code, 684
implicit type conversion, 51, 69
in bounds, 529
inches variable, 64, 66
incident, 1407
#include preprocessor directive, 80–81, 124
includes function, 1491, 1538–1546
include statement, 684
incrementHours function, 652–654, 662, 664, 685–686
incrementMinutes function, 652–654, 662, 664, 685

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1662

|

Index

increment operator (++), 70–72, 830, 832–833, 902, 1087
iterators, 1473
*increment operator (++)
overloading, 937–938
post-increment operator (u++), 937, 939–943
pre-increment operator (++u), 937–939
incrementSeconds function, 652–654, 660, 662, 664, 685
incrementWaitingTime function, 1238
incrementY function, 699–700, 703–704
inData variable, 161
indentation, 222
nested if statements, 206–208
indexed for loops, 295
indexes, 523, 527
enumeration type, 542
integral data types, 541–542
out of bounds, 529–530
two-dimensional arrays, 561–566
indexLargestElement function, 535, 538
index variable, 527, 1301, 1303
indirection operator (*), 815
indirectly recursive functions, 1042
infile stream variable, 316–318, 558, 582, 622, 789
inFile variable, 290
infile variable, 217–218, 286
infinite loops, 267, 270
for loops, 300
infinite recursion, 1042–1043
infix expressions, 1201–1202
infix notation, 1201
info component, 1074, 1094–1095, 1098, 1103–1104,
1107–1108, 1110, 1118, 1129, 1211–1212, 1310, 1351
information hiding, 683–687
inheritance, 738–767, 773, 775–796, 859
multiple, 739
private members, 739–740, 763–764
protected members, 763–764
public members, 740, 763–764
single, 739
stream classes, 762–763
initializeArray function, 534
initialize function, 418, 420, 533, 574, 583, 630
initializeList function, 1093, 1124, 1200, 1232
initializeQueue function, 1216, 1222, 1224, 1229, 1232
initializeStack function, 1168, 1173–1174, 1192, 1200
initializing variables, 58
init parameter, 1547
inner_product function, 1493, 1546–1551
inorder function, 1358, 1362, 1364, 1384
inorder sequence, 1355
inorderTitle function, 1392
inorder transversal nonrecursive algorithm, 1379–1381
inorderTraversal function, 1362–1363, 1384, 1386
inplace_merge function, 1492, 1524–1528
inpStr object, 1009
input
discarding portion of, 135–136
strings, 554–556
input devices, 5, 160–163
input failure, 130, 140–143
if statements, 217–219
input files
extensions, 162
nonexistent, 217, 998
reading beyond end of, 217
specifying at execution time, 557

input file stream, 160
inputIterator input iterator, 1474
input/output (I/O), 79, 85, 762
enumeration types, 470–472
files, 160–163
prewritten operations, 124
streams, 124
string data type, 156–157, 557–558
input/output (I/O) functions, 139
input (read) statement, 63–66
input streams, 124, 137–139
fail state, 140–143, 217, 285
next available character, 137–139
opening nonexistent input file, 217–218
reading invalid data, 217
restoring to working state, 142–143
input stream variables, 125
if statements, 217
inputting strings, 556
reading string into variables, 156–157
returning true or false, 285
returning value, 284–285
insertAt function, 872, 875–876, 879
insertEnd function, 872, 875–876, 879, 975, 978, 1327
inserter insert iterator, 1500
insertFirst function, 1092, 1097, 1099–1100, 1106,
1112–1113, 1200, 1232
insert function, 495, 500–501, 872, 875, 879–880, 971,
1106, 1111–1112, 1117, 1127–1128, 1362,
1371–1373, 1447, 1449–1450, 1453–1454, 1482
insertion operator (<<), 32, 59, 72, 161, 556, 762, 902–903
associativity, 926
file stream variables, 162
friend functions, 915
overloading, 924–929
setprecision manipulator, 145
syntax error, 87
insertion point, 72–76
insertion sort, 1292
analysis, 1296–1297
array-based lists, 1292–1297
average case behavior, 1297
key comparisons, 1292, 1296
insertionSort function, 1296
insertItem item, 1371
insert iterators, 1500–1501
insertLast function, 1092, 1097, 1099, 1106, 1112–1113
insertNode function, 1113
instance variables, 664
inStock array, 563–564
intArray array, 1455–1456
intConstVecIt iterator, 1478
int data type, 38–40, 681, 812
converting to char data type, 53
extraction operator (>>), 126–130
logical (Boolean) expressions, 196
pointer variables, 813
intDeq deque container, 1465–1466
integer alias, 476
integerManipulation class, 695–698, 759–760
integers, 38–40, 49
converting floating-point numbers to, 51–52
division operator (/), 903
larger of two, 223
relational operators, 187–188

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

integral data types, 38–41
arithmetic operators, 43–45
array indices, 541–542
integral expressions, 48–49
integrated circuits, 3
integrated development environments (IDEs), 10, 11
resources provided by, 82
.txt file creation, 162
interestRate variable, 43
interface files, 684
International Organization for Standardization (ISO), 22
intersection, 1405
intExp variable, 135
intGtIt iterator, 1485
intItr iteration, 1497, 1528
intList array, 1274, 1288, 1523, 1527
intList list, 971
intList1 list container, 1472, 1473
intList2 list container, 1472, 1473
intList3 list container, 1472, 1473
intList4 list container, 1472
intList object, 970
intList1 object, 936–937
intList2 object, 936–937
intList3 object, 936–937
intList struct variable, 619
intList vector, 1517, 1520
intList vector container, 1445, 1449, 1451, 1452, 1459,
1513
intList vector object, 1448, 1461
int pointer, 812
int reserved word, 92
intSetA set associative container, 1485
intSet set associative container, 1482, 1485
int variables
logical (Boolean) expressions, 202–203
memory allocation, 830
intVecIter iterator, 1448–1450
invalid_argument class, 1010
invalid string position error message, 1011
inventory class, 673–674
I/O functions, 347
iomanip header file, 81, 145, 148–149, 152, 156, 490
ios class, 762
iostream class, 762
iostream header file, 79–80, 85, 124–125, 156, 160, 347,
757, 762
global identifiers, 488–489
identifiers, 490
I/O stream variables, 139
‘‘is-a relationship,’’ 738–767
isDVDAvailable function, 1391
isEmpty function, 872, 1363, 1411–1412
isEmptyList function, 1092, 1123, 1200, 1232
isEmptyQueue function, 1216, 1229, 1232, 1246
isEmptyStack function, 1168, 1174, 1191–1192, 1200
isFound variable, 281
isFree function, 1240
isFull function, 872
isFullQueue function, 1216, 1229, 1246
isFullStack function, 1168, 1174, 1190–1192, 1200
isFull variable, 281
isGuessed variable, 282, 284
isIdentifier identifier, 1479
isItemAtEqual function, 873, 973
islower function, 348, 350–351

1663

isNegative variable, 312
ISO. See International Organization for Standardization (ISO)
isObject parameter, 927
isPalindrome function, 368–369
isstreamVar variable, 137
isTallEnough variable, 281
istream class, 762–763
istream class object, 1479
istream (input stream) data type, 124–125, 130, 139, 285
istream_iterator class, 1479
istream iterators, 1479
istream object, 139, 927
istreamVar input stream variable, 156, 285
isupper function, 348, 1507
isVowel function, 504, 505
iteration and problem solving, 1054
iterative control structures, 1053–1054
iterators, 1087–1089, 1442, 1489–1490
bidirectional iterators, 1475–1476
declaring, 1477–1478
dereferencing operator (*), 1473
forward iterators, 1475
increment operator (++), 1473
input iterators, 1474
linked lists, 1094–1095
output iterators, 1474–1475
random access iterators, 1476–1477
stream iterators, 1479
vector container declaration, 1448–1449
iter iterator, 1485
iter_swap function, 1492, 1517–1520
i variable, 269–271, 299–300, 308, 314–315, 321, 523, 1451

J
Jacquard, Joseph, 2
Java, 8, 774
Jobs, Steven, 3
j variable, 832

K
keyboard, 124
keys, 1267
keywords, 36
kilobytes (KB), 6
Kruskal’s algorithm, 1427–1428

L
languages variable, 475
larger function, 355–360, 374–376, 967
local declaration, 355
overloading, 414–415
larger function template, 968–969
largerInt function, 414
largest function, 1044–1046
largestInRows function, 570–571
largestVotes variable, 1333–1334
lastElem vector iterator, 1513
last formal parameter, 1304
Last In First Out (LIFO), 1167, 1170, 1212, 1442
last member, 626

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1664

|

Index

lastMerged pointer, 1310
lastName variable, 65–66, 613, 1317
last parameter, 1455–1456
last pointer variable, 1081, 1084, 1086, 1091–1093, 1096,
1099, 1101, 1103–1104, 1123, 1232, 1313
last variable, 1270–1273, 1290
late binding, 854
leaf, 1297, 1351
leavesCount function, 1365
left child, 1348, 1368
left manipulator, 154–156, 779
left subtree, 1348–1350, 1368–1369, 1373–1375
legalAge variable, 196–197
lenCodeOk variable, 577
length, 868, 1351
length_error class, 1010–1011
length function, 131–133, 495–498, 1094, 1124
length identifier, 30
lengthPtr pointer variable, 829
length variable, 19, 33, 742, 744, 746, 749–750, 752,
869, 872, 874, 876, 913, 917, 924, 935, 1271, 1290
less_equal function object, 1497
less function object, 1497
less than operator (<), 187, 1479–1480
less than or equal to operator (<=), 187
letterCount array, 583–584
letterCount variable, 582
letter variable, 280–281
level, 1352
level-by-level traversal, 1359
libraries, 11, 79–80
predefined functions, 347
linear searches, 542–545, 877, 1267
lineCount variable, 582–583
link component, 1074–1075, 1409
linked implementation of queue, 1227–1232
linked implementation of stacks, 1188–1201
adding node, 1192–1194
copying, 1196–1197
empty stack, 1191–1192
full stack, 1191–1192
initializing stack, 1192
overloading assignment operator (=), 1197–1198
removing element, 1194–1196
top element, 1194
linked list-based lists
merge sort algorithm, 1306–1315
merging sublists, 1310–1313
middle node, 1308
sublists, 1306–1315
linkedListIterator class, 1087–1089
linked lists, 1072
abstract data type (ADT), 1085–1097, 1106–1117
building backward, 1084–1085
building forward, 1080–1083
circular linked lists, 1131
copy constructor, 1096
copying, 1095–1096
deallocating memory, 1092–1093
deleting items, 1076, 1079–1080
destructor, 1096
doubly linked lists, 1120–1131
first, 1072
head, 1072
implementing stacks, 1188–1201
initializing, 1093

inserting items, 1076–1078
iterators, 1087–1089, 1094–1095
length, 1093–1094
links, 1072
nodes, 1072–1075
ordered, 1106–1117
overloading assignment operator (=), 1097
pointers, 1080
printing, 1093
printing backward, 1211–1215
printing in reverse order, 1117–1119
processing nodes, 1087
properties, 1073–1075
quick sort algorithm, 1299
retrieving data from nodes, 1094
selection sort, 1291
sequential search, 1267
sorted, 1085
structure of nodes, 1086
traversing, 1075–1076, 1087, 1096, 1211–1212
unordered, 1085, 1097–1106
linkedListType class, 1085, 1089–1097, 1106, 1200, 1232
default constructor, 1092
iterator, 1087–1089
member variables, 1086
linkedQueueType class, 1227–1233
linkedStackType class, 1189–1201
linkedStackType function, 1191
linker, 11
links, 1072, 1076
Linux, 5
list array, 525, 530–531, 535, 543, 546–549, 572–573,
832–834, 869, 933, 935, 970, 1012, 1043–1046,
1101, 1110, 1290, 1293–1295, 1300–1306, 1325,
1461, 1499–1500, 1517, 1520, 1523, 1537
list1 array, 959, 1509–1510
list2 array, 1509
list3 array, 959, 1509
list4 array, 1509, 1510
list class, 1466
list containers and bidirectional iterators, 1476
listCont list container, 1467
listElem member, 619–620
list formal parameter, 620, 835, 1459
list header file, 1466
listIt iterator, 1451–1452
listLength member, 619–620
list list container
bubble sort, 1285–1290
operations, 1468–1472
list objects, 1467
listOne object, 851–852
listOne parameter, 533
list pointer, 1173
list pointer variable, 834–835
lists, 619
abstract data type (ADT), 681–682, 869
array-based, 868–875, 972–978
empty, 872
equal items, 873
full, 872
index, 874
length, 868, 872
linked lists, 1072
maximum size, 872
operations performed on, 868

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

ordered, 879–880
outputting elements, 873
removing elements from, 873–874
repeating elements, 879
searching, 620
sequential, 1072
sorted or unsorted, 868, 872
sorting, 1284–1290
unordered, 875–879
list sequence container, 1454, 1466–1472
listSize function, 872
listTwo object, 852
listTwo parameter, 533
listType class, 682, 969–971, 1442
listType class template, 969–971
listType struct, 619
list variable, 832–833, 978, 1327, 1329, 1331–1332
lLink pointer, 1350–1351, 1370, 1375
loader, 11
local declaration, 355
local identifiers, 397–398
local variables, 388
logical_and function object, 1499
logical (Boolean) expressions, 40, 189, 196, 476
assert function, 235
associativity of relational operators, 211–213
bool data type, 196–197
bool variables, 202–203
evaluating, 209
int data type, 196
int variables, 202–203
logical expressions, 197–199
order of precedence, 199–203
reversing value, 198
short-circuit evaluation, 209–210
true and false values, 201
logical (Boolean) operators, 197
logical expressions, 197–199
logical values as operators, 197
order of precedence, 199–203
logical errors
if statement, 195
silent killer, 221
logical expressions, 187–222
if...else statements, 193
input stream variable in if statements, 217
logical (Boolean) operators, 197–199
logical function objects, 1499
logical_not function object, 1499
logical_or function object, 1499
logic_error class, 1010
logic errors, 157–160, 1010
long data type, 38
long double data type, 41
*long long data type, 22, 38–39
loop condition, 1212–1215
loop control variable (LCV), 270–272, 281, 298–299
loop invariants, 322
loops, 186, 1407
body, 267
break statement, 311
component-wise copying, 532
debugging, 322
do...while loops, 307–311
enumeration types, 470
exiting early from, 311

1665

index out of bounds, 530
infinite, 267, 270
iterative control structures, 1053–1054
for loops, 295–306
multidimensional arrays, 575
number of iterations, 301
‘‘off-by-one problem,’’ 322
posttest, 308
pretest, 308
sentinel, 275–278
stepping through array elements, 525–528
verifying with loop invariants, 322
while loop, 267–295
lower_bound algorithm, 1491
lowerSublist sublist, 1299–1306
Lukasiewicz, Jan, 1201, 1202
luxuryTax variable, 14–15

M
machine language, 6–9, 9, 62, 1055
Mac OS X, 5
main function, 31–34, 34, 81–82, 85, 89, 130, 217–218, 346,
351, 355, 359–360, 374, 376, 380, 382–383, 385–388,
390–393, 395, 401, 403, 424, 488–490, 577, 684,
712–713, 822, 839, 850–851, 853–854, 998, 1018,
1024, 1030–1031, 1145, 1204, 1250, 1327
main memory, 4–5, 62
make command, 688
make_heap algorithm, 1493
makeSale function, 707, 709
manipulating data, 81
manipulators, 72, 81, 156
map containers and bidirectional iterators, 1476
Mark I, 3
mathematical functions, 79, 81, 347
mathStudent enumeration type, 468
matrix array, 565–571, 574
max_element function, 1491, 1531–1535
max function, 1353, 1365, 1491
maxIndex variable, 527–528
maxListSize function, 872
maxQueueSize variable, 1218, 1224, 1226
maxSaleByPerson function, 635
maxSaleByQuarter function, 635–636
max_size function, 1446, 1453
maxSize variable, 869, 872, 935
maxStackSize variable, 1172, 1174
max variable, 355, 374
megabytes (MB), 6
member access operator (.), 139, 612, 655, 657
member access operator arrow (->), 821
member functions, 907–911
binary operators, 918–922
calling member functions, 662
constant functions, 665
definitions, 660
implementing, 659–664
member variables, 664–667, 907
objects, 655
operator functions as, 915–917
overloaded operators, 915, 943–944
post-increment operator (++) as, 940
pre-increment operator (++u) as, 938
redefining (overriding) from base class, 741–748

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1666

|

Index

member objects passing arguments to constructors, 771–772
member selection operator, 903
member variables
access by member functions without modifying, 664–667
base classes, 741
derived classes, 741
initializing, 675
member functions modifying, 664–667
member-wise copy, 929
objects, 655
memory
data transfer between devices and, 762
optimizing use of, 39
memory allocation
constants, 54–57
dynamic variables, 826
formal parameters, 388
global variables, 409
int variables, 830
new operator, 824–825
non-static member variables, 700–702
recursive functions, 1054
reference parameters, 388–397
static member variables, 700–702
value parameters, 388–397
variables, 54–57, 388, 409
memory cells, 4
memory leak, 826–827
merge function, 1313, 1469–1470, 1472, 1490, 1492,
1524–1528
mergeList function, 1311–1312, 1314–1315
merge sort algorithm
analysis, 1313–1315
divide-and-conquer technique, 1306
linked list-based lists, 1306–1315
merging sublists, 1310–1313
partitioning list, 1306–1310
pivot, 1306
mergeSort function, 1313
merging sorted lists, 1524–1528
message variable, 1020
metersAndCentToFeetAndInches function, 406–408
methodologies. See programming methodologies
microprocessors, 3
middle member, 626
middle pointer variable, 1308–1309
mid variable, 1272–1273
miles variable, 63, 150–151
min_element function, 1491, 1531–1535
min function, 1491, 1531–1535
minimalSpanning function, 1431–1432
minimal spanning tree, 1427–1433
minLocation function, 1291–1292
minus function object, 1494
min variable, 651–654, 656–657, 660, 663–664, 671, 675,
677–678, 902, 950
mismatch algorithm, 1491
mixed expressions, 48, 49–50
mnemonic, 8
mobile computing applications, 3
modifying algorithms, 1492
mod operator (%), 303
Modula-2, 774
modular programming, 20
modules, 346
modulus compound operator (%=), 94–95

modulus function object, 1494
modulus (mod) operator (%), 43–45, 48
month variable, 209
moveDisks function, 1053
move function, 860
movieDirector variable, 1140
movieProducer variable, 1140
movieProductionCompany variable, 1140
movieStar1 variable, 1140
movieStar2 variable, 1140
msTreeType class and abstract data type (ADT), 1430–1431
mstv array, 1430
multidimensional arrays, 574–575
dynamic, 836–839
multimap containers and bidirectional iterators, 1476
multiple inheritance, 739
multiple-line comments (/* */), 35
multiple selections, 205–208
multiplication compound operator (*=), 94–95
multiplication operator (*), 43–45
multiplies function object, 1494
multiset associative container, 1480–1486
multiset containers and bidirectional iterators, 1476
mutator functions, 664–667
m variable, 1283
myBox object, 749–750
myClass class, 700
myClock object, 655–658, 660–663, 672, 902, 907
myException class, 1028–1029
myList array, 531–532, 536–538
myList variable, 542
myRectangle object, 749, 911, 917–918, 922, 929,
931–932, 938
myRectangle parameter, 925–926
mySport variable, 468–470, 475
myStack class, 1186–1188
myStack.h header file, 1180–1183
myString variable, 157
myTime object, 677
myYard object, 914

N
name array, 551–552, 554
named constants, 55–56
declaring, 81
global, 403
identifiers, 55, 91
name member, 626
name object, 771
name pointer variable, 827, 854
namesMultiSet multiset associative container, 1485–1486
namespace mechanism, 80–81
namespace member, 486–487
namespace_name identifier, 485, 487
namespace reserved word, 81, 486
namespaces, 485–490
nameType struct, 624–625
name variable, 57, 141, 153, 156, 274, 277–278, 491, 556,
856–858
n-dimensional arrays, 574–575
negate function object, 1494
negation operator (-), 43, 45
negative integer operands and modulus (mod) operator (%), 48
negativeNumber class, 1019–1021

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

negative numbers, 45
nested, 207
blocks, 398
control statements, 206–208
control structures, 278, 314–319
if...else statements, 278
if statements, 205–208
for loops, 314–315, 566–568, 1289, 1432
switch statements, 231–232
while loops, 278
newElement variable, 1194
newEmployee struct variable, 625–626
newHead variable, 1310
newHouse struct variable, 611
newItem variable, 1174–1175
newLastElem vector iterator, 1513
newline escape sequence (\n), 40–41, 73, 75–76, 78), 156,
555–556
extraction operator (>>), 130
newNode node, 1078, 1081–1082, 1084, 1095, 1109
newNode variable, 1194
newNum variable, 301
new operator, 1010–1012
dynamic arrays, 831
memory allocation, 824–825
newString class, 958, 960–966, 998
newString data type, 964, 970
newStudent struct variable, 612–618
newYard object, 909
nextNum function, 1504
next_permutation algorithm, 1492
next pointer variable, 1122, 1127
nodeCount function, 1365
nodes, 1072–1075, 1297
binary trees, 1348–1351, 1353
children, 1350
as class or struct, 1073
comparison-based search algorithms, 1297
data, 1072
deallocating memory, 1079–1080, 1096
deleting, 1100–1104, 1113–1114, 1123, 1128–1131, 1358
info component, 1074, 1094–1095, 1098, 1103–1104,
1107–1108, 1110, 1118, 1129, 1211–1212, 1310,
1351
inserting, 1077–1078, 1108–1113, 1126–1128
iterators to first and last, 1094–1095
level, 1352
link component, 1074
linked lists, 1086
links, 1072
paths, 1351
pointers, 1212, 1350–1351
processing, 1087
retrieving data from, 1094
root node, 1348
visiting in sorted order, 1358
nodeType struct, 1086, 1350, 1359
nodeType type, 1351
nonmember functions
binary operators as, 922–924
operator functions as, 915–917
operator overloading, 915, 943–944
post-increment operator (++) as, 940–941
pre-increment operator (++u) as, 939
nonmodifying algorithms, 1491
nonprintable characters, 126

1667

nonrecursive algorithms
converting recursive algorithms to, 1166
printing linked list backward, 1211–1215
nonrecursive inorder transversal, 1379–1381
nonRecursiveInTraversal function, 1380–1381
nonrecursive postorder traversal, 1382–1383
nonrecursive preorder traversal, 1381–1382
nonRecursivePreTraversal function, 1381–1382
nonrecursive traversal algorithms
binary trees, 1379–1383
inorder transversal, 1379–1381
postorder traversal, 1382–1383
preorder traversal, 1381–1382
non-static member variables memory allocation, 700–702
noOfGuesses variable, 290
noOfServiceYears variable, 16
NO_OF_STUDENTS named constant, 55
noOfStudents variable, 789
Notepad, 162
not_equal_to function object, 1496
not equal to operator (!=), 187, 830, 1453
not operator (!), 197–198–203
nth_element algorithm, 1492
nthFibonacciNum function, 366–368
nthFibonacci variable, 293
null character (\0), 41, 551
NULL named constant, 823, 827
null pointer (0), 823
nullptr null pointer, 823, 1072, 1074, 1076, 1081–1082,
1084, 1092–1093, 1101, 1109, 1111, 1123, 1191–1192,
1212–1213, 1228, 1308–1309, 1311, 1363, 1375
null strings, 53
null-terminated strings, 557–558
num array, 522
NUMBER named constant, 85
numberOfBlanks variable, 380
numberOfItems variable, 707–709
numberOfStudents variable, 425
numbers
converting from binary to decimal, 1055–1059
converting from decimal to binary, 1059–1062
double data type, 355
inputting, 64
larger, 355–357
manipulating, 1546–1551
outputting in columns, 149–151
reading, 65–66
reading characters as, 137–139
number variable, 303–304, 383–384
numeric algorithms, 1492–1493
numeric header file, 1546
num identifier, 87
numOfBathrooms member, 611, 615
numOfBedrooms member, 611, 615
numOfBoxesSold variable, 274, 277
numOfCarsGarage member, 611
numOfVolunteers variable, 274–275, 277
numptr pointer variable, 814
num reference parameter, 1537
num variable, 17, 59, 74, 91, 134, 212–213, 229, 284, 310,
312, 316, 356, 364, 374, 384, 395, 550, 815, 1081
num1 variable, 58–60, 356–357, 814
num2 variable, 58, 60, 356–357, 814
num3 variable, 60
n variable, 303, 1283, 1504

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1668

|

Index

O
object code, 82, 684, 688
objectOne object, 842–847
object-oriented design (OOD), 20–21, 650, 772–775
object-oriented programming (OOP), 772–775
object-oriented programming (OOP) languages, 20, 774
Object Pascal, 774
objects, 21, 139, 650, 654, 774
accessing class members, 655–656
accessing implementation details, 687–688
aliases, 881–883
identifying, 20, 774–775
information hiding, 683–687
initializing, 677, 845
iterators, 1087
member functions, 655, 907–911
member variables, 655
operations performed on data, 20, 21
operator overloading, 903
out of scope, 843
passed by reference, 852
passed by value, 847, 852
pointer to itself, 907
private member variables, 683
relevant data, 20–21
objectThree object, 845, 847
objectTwo object, 843–844
objectType enumeration type, 477
.obj file extension, 82
odds variable, 304–305, 418–419
‘‘off-by-one problem,’’ 322
ofstream class, 763, 786
ofstream data type, 160, 762
ofstream variables, 161, 290, 388, 426, 431, 634–635
oldYard object, 909
one class, 757
one-dimensional arrays, 521
declaring, 521–525, 569
processing, 525–529
simulating table form data, 560
size, 532–533
one function, 401, 907
one value parameter, 395
ONE variable, 758–759
one-way selections, 189–192, 215
OOD. See object-oriented design
OOP. See object-oriented programming (OOP) language
open function, 557–758
open stream member function, 161
operands, 45
data types, 49–50
extraction operator (>>), 125
postfix expressions, 1206–1208
returning address of, 814
operating systems, 5
operations, 681
operator!= function, 920, 949
operator# function, 918, 922–923
operator* function, 920
operator+ function, 920, 923–924
operator++ function, 937–943, 947
operator< function, 949
operator<< function, 925–926, 950, 955–956
operator<= function, 948–949

operator= function, 929–937
operator== function, 905–907, 924, 947–949
operator>> function, 926–927, 950–951, 963
operator[] function, 958–966
operator() function call operator, 1494
operator functions, 903–904, 915–917
operator overloading, 902, 903
member functions, 943–944
nonmember functions, 943–944
restrictions, 904–907
this pointer, 907–911
operator reserved word, 903–904
operators
associativity, 200, 904
built-in data types, 904
explicitly overloading, 904
order of precedence, 200
overloading, 773–774, 1319–1320, 1324–1325
postfix expressions, 1203
precedence, 202, 213, 904, 1201
op operator, 915, 944
opOverClass class, 915
orderedArrayListType class, 872, 879–881, 972, 978,
1275–1276
orderedLinkedList class, 1085, 1091–1092, 1106–1117
ordered linked lists
deleting nodes, 1113–1114
header file, 1114–1115
insert first node, 1112–1113
inserting node, 1108–1112
insert last node, 1112–1113
operations on, 1116–1117
searching, 1107–1108
traversing, 1111
ordered lists, 879–880
orderedListType class, 1114–1115
ordered sets, 881
orderedSetType class, 881
origin, 1405
or logical operator (||), 197, 199–203, 209–210
osIdentifier identifier, 1479
osObject parameter, 925
ostream class, 762, 786
ostream class object, 1479
ostream_iterator class, 1479
ostream iterators, 1456, 1479
copy function and, 1456–1458
ostream object, 139, 925
ostream (output stream) data type, 124–125, 139
ostreamVar variable, 152, 154
otherClock object, 663–664
otherClock reference parameter, 659, 663–664
otherDeq deque container, 1462
otherIntSet set associative container, 1482
otherList list container, 1467
otherList object, 935
otherVecList vector container, 1444
outData variable, 161
.out extension, 162
outfile object, 786
outfile stream variable, 582
outFile variable, 290, 789
outF parameter, 779, 783, 786
out-of-bounds exception, 998
out_of_range class, 1010–1011

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

out_of_range exception, 1011
output, 72–79, 144–155
columns, 149–151
floating-point numbers, 144–145
formatting, 72, 81, 144–155
generating, 31
left-justified, 154–155
new line, 75–76, 144
right-justified, 151–152, 154–155
sending to output device, screen, or file, 786
output devices, 5, 152–153
output files
extensions, 162
specifying at execution time, 557
output file stream, 160
outputIterator output iterator, 1474
output iterators, 1474–1475
output operator (<<), overloading, 1135
output statements, 29–31, 59, 72–79, 351
output streams, 124
writing data to, 1474–1475
output stream variables, 125, 556
overflow, 1175
overflow_error class, 1010
overloaded operators, 903–904, 915
overloading
array index operator ([]), 958–966
assignment operator (=), 929–937, 974, 1092, 1097,
1179–1180, 1197–1198, 1362, 1366–1367
binary operators, 918–924
copy constructor, 1362
decrement operator (--), 937–938
destructor, 1362
extraction operator (>>), 924, 926–929
function name, 413–415
functions, 966–969
increment operator (++), 937–938
insertion operator (<<), 924–929
operators, 1319–1320, 1324–1325
output operator (<<), 1135
post-increment operator (u++), 939–943
pre-increment operator (++u), 937–939
unary operators, 937–943

P
package object, 752, 753
paintSale array, 541
palindromes, 368–369
parallel arrays, 558–559
parallel edges, 1407
parameterized stream manipulators, 156
parameterized types, 969
parameter passing, 389–397
parameters, 131, 134
arrays as, 532–533
data types, 351
default, 415–417
functions as, 1383–1386
manipulators, 156
names, 398
objects as, 658
passed by reference, 925
predefined functions, 351

1669

reference variables as, 384–388
struct variables, 617–618
two-dimensional arrays passing, 568–571
void functions, 377–378
parametric polymorphism, 774
paramObject formal parameter, 846–848
paramObject object, 848
parent, 1348, 1351
p array, 851–852
partial_sort algorithm, 1492
partial_sort_copy algorithm, 1492
partial_sum function, 1493, 1546–1551
partition function, 1303–1305, 1492
partTimeEmployee class, 738, 755–757, 861, 865–867
partTimeEmployee.h header file, 757–758
Pascal, Blaise, 2
Pascaline, 2
passed by reference
arrays, 532–533
struct data type, 621
struct variables, 617–618
two-dimensional arrays, 568–571
variables, 658
passed by value
arrays, 538
class objects, 658
struct data type, 621
struct variables, 617–618
variables, 620, 658
patches, 319–322
paths, 1298, 1351, 1407
payCheck variable, 622
payment variable, 192
payRate variable, 125–126, 162
PCs. See personal computers (PCs)
p dynamic array, 832
peek function, 130, 136–139, 161
perimeter function, 742, 744, 752, 910
perimeter variable, 19, 33
personal computers (PCs), 3
personalInfo class, 768, 770–772
personalInfo constructor, 770, 772
personType class, 693–695, 738, 755, 757, 767–768,
780, 783, 861, 1145, 1317–1320, 1320
personType.h header file, 757
petabytes (PB), 6
pet object, 854, 858
pet pointer, 859
petType class, 852–854, 856–858
petType.h header file, 855, 857
p formal parameter, 853–854, 856–858
pigLatinString function, 505, 506–507
PI named constant, 148–149
pivot, 1299–1304, 1306
play1 variable, 478
play2 variable, 478
plus function object, 1494
p member variable, 851
p object, 857–858
pointer arithmetic, 830–831
pointer data type, 812
pointerParameters function, 836
pointers, 1072
accessing class or struct components, 821
address of operator (&), 814

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1670

|

Index

pointers (Continued)
to arrays, 840
class member functions and, 821–823
dangling, 827, 841
data types, 812
dereferencing, 820, 825
dereferencing operator (*), 815
dynamic variables, 824–827
first container element, 1456
formal parameters as, 852–853
to functions, 1383
last container element, 1456
memory space, 827
nodes, 1212, 1350–1351
related memory, 839–840
return type of function, 836
root node, 1351, 1353
shallow versus deep copy, 839–841
value parameter, 836
pointer variables, 812
assigning value to another pointer variable, 829–830
assignment operator (=), 829–830
asterisk symbol (*) and, 812–813
char data type, 813
classes and, 841–852, 944
comparing for equality, 830
data types, 812
declaring, 812–813
functions, 836
increment and decrement operations, 830
initializing, 823
int data type, 813
integer values, 830–831
operations on, 829–831
root, 1351
storing memory addresses, 812, 881–883
value of, 812
point1X variable, 133
point2X variable, 133
point1Y variable, 133
point2Y variable, 133
Poisson distribution, 1248
Polish notation, 1201
polymorphism, 773–774
polynomials, factoring, 403–406
poolCapacity function, 412–413
poolFillTime function, 412
pop_back function, 1447, 1454, 1466
pop_front function, 1463, 1465, 1468
pop function, 1176–1178, 1192, 1194–1196, 1200, 1486,
1488
pop_heap algorithm, 1493
pop operation, 1167–1168
popularSport variable, 468–470
position iterator, 1447, 1454, 1506
positive integers, 40
postcondition, 685
post-decrement operator (variable--), 70
postfix expressions, 1201–1202
evaluating, 1204–1208
operands, 1206–1208
operators, 1203
printing result, 1208–1209
# symbol, 1203–1204
postfix notations, 1202

post-increment operator (u++), 70, 937
overloading, 939–943
postorder function, 1358, 1364
postorder sequence, 1355
postorder traversal and nonrecursive traversal algorithms,
1382–1383
postorderTraversal function, 1363
posttest loops, 308
pos variable, 1274
power function, 131
pow function, 131–133, 347–348, 350–352, 488
p pointer, 1353
p pointer variable, 813–815, 824–827, 831, 833, 835–836,
842–844, 1077–1078, 1080
precision, 42
precondition, 685
pre-decrement operator (--variable), 70
predefined functions, 34, 131–140, 346–351
predefined identifiers, 36
predicates, 1499
p reference parameter, 836
prefix notation, 1201
pre-increment operator (++u), 70
overloading, 937–939
preorder function, 1358, 1364
preorder sequence, 1355
preorder traversal and nonrecursive traversal algorithms,
1381–1382
preorderTraversal function, 1363
preprocessor, 9, 79–80
preprocessor directives, 10, 79–82, 759
pretest loops, 308
previous1 variable, 292–293
previous2 variable, 292–293
prev_permutation algorithm, 1492
prewritten code, 11
price member, 611, 615
primeFactorization class, 760–761
Prim’s algorithm, 1427–1433
printArray function, 534
printData function, 1323
printDate function, 768, 770
print function, 693–695, 699–702, 741–742, 744, 746,
749, 755–756, 766, 777, 779, 781, 783–786, 788,
839, 853–855, 857, 861, 873, 910, 928, 973, 1093,
1124, 1333, 1386
printGrade function, 385–388
printGradeReports function, 790
printGraph function, 1413
printHeading function, 432
printing
arrays, 526, 534
doubly linked lists, 1124
graphs, 1413
linked list backward, 1211–1215
linked lists, 1093
linked lists in reverse order, 1117–1119
postfix expression result, 1208–1209
reverse order doubly linked lists, 1124–1125
struct variables contents, 618
two-dimensional arrays, 566–567
printMatrix function, 570–571
printpersonalInfo function, 770, 772
printReport function, 634–635

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

printResult function, 424, 426, 431–432, 486, 490,
1204, 1208–1209
printResults function, 418–420, 1333–1334
printShortestDistance function, 1425
printStars function, 379–382
printTime function, 652–654, 656, 660–662, 664–665,
685, 950
printTreeAndWeight function, 1432
private access specifier, 651, 683
private inheritance, 739–740
private members, 651–653, 656, 668–669, 763–764, 774
private member variable, 881–882
problem analysis-coding-execution cycle, 11–19
problems
analysis, 19
object-oriented design (OOD), 21
structured design, 21
subproblems, 18
problem solving, 11
identifying objects, 20
iteration, 1054
largest element in array, 1043–1046
recursion, 1040, 1043–1054
subproblems, 20
problem-solving techniques, 11–13
processVotes function, 1331–1332
program development environment, 80
programming, 28
problem analysis-coding-execution cycle, 11–19
problem solving, 11
structured, 772–775
programming languages, 2, 3, 7–9, 34
equality operator (=), 220
high-level languages, 8–9
semantic rules, 34
semantics, 90
syntax, 10, 13
syntax errors, 10, 11
syntax rules, 34
programming methodologies
object-oriented design (OOD), 20–21
structured design, 20
programmingScore member, 614
programs, 2, 28, 774–775
See also C++ programs
altering sequential flow of execution, 186
basic operations, 124
blank spaces, 90, 92
brackets, 90
commas (,), 90
curly braces ({ }), 90
decision making, 21, 189
documentation, 92
error messages, 234–236, 530
executing, 13
expressions, 30
fixing exception and continuing, 1026–1027
functions, 31–32, 34, 186
handling exceptions, 998–1013
header files, 80–81
identifiers, 36–37, 90–91
indentation, 222
keywords, 36
line numbers, 74–75
logging exception and continuing, 1027–1028
logic errors, 1010

1671

machine language version of, 10
main function, 31–32, 34
menu-driven, 406–408
multiple-line comments (/* */), 35
numeric data, 64
object-oriented design (OOD), 773
output statements, 29, 30–31
placing and indenting braces ({}), 222
predefined functions, 131–140
processing, 9–11, 186
prompt lines, 91–92
proper structure, 89
pseudocode, 223–225
reading data from file, 162
repetitively processing, 186
reserved words, 36
runtime errors, 1010
selection, 21
selectively processing, 186
sequentially processing, 186
single-line comments (//), 31, 34–35
special symbols, 35
structured programming, 773
style and form, 89–94
subprograms, 34
syntax errors, 92
syntax rules, 89
terminating, 217–219, 234–236, 530, 1026
tokens, 35–36
translating pseudocode into, 223–224
try/catch blocks, 1005–1009
whitespaces, 37
progScore parameter, 379
project files, 688
prompt lines, 91–92
protected access specifier, 651, 763
protected members, 763–767
protected variables, 872
pseudo, 223
pseudocode, 223–225
ptrMemberVarType class, 841–850
ptrMemberVarType.h file, 850
public access specifier, 651, 668
public inheritance, 740
public member functions, 745–746
public members, 651–653, 656, 668–669, 763–764, 774
public static member, 699
pure virtual functions, 860–861
push_back function, 1447–1448, 1451, 1454, 1459, 1461,
1465, 1500
push_front function, 1463, 1468
push function, 1174–1176, 1192–1194, 1200, 1486, 1488
push_heap algorithm, 1493
push operation, 1167–1168
putback function, 130, 136–139, 161
p value parameter, 856

Q
q pointer variable, 813, 825, 836, 1078, 1080
queueADT class, 1217, 1222
abstract data type (ADT), 1217
queue class, 1488–1489
queueFront pointer variable, 1216, 1218, 1220, 1222,
1224–1228, 1230, 1232

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1672

|

Index

queue header file, 1488
queueRear pointer variable, 1216, 1218–1222, 1224–1227,
1229, 1232
queues, 1215–1233, 1488–1489
adding elements, 1216–1218, 1221, 1225, 1229–1230,
1246
back, 1215–1216
breadth first traversal algorithm, 1417
constructors, 1226–1227
deleting elements, 1216–1219, 1221, 1225–1226,
1230–1231, 1246
destructors, 1226–1227
double-ended, 1462–1466
empty, 1216, 1224, 1228–1229
first element, 1218, 1220, 1222, 1224–1225
First In First Out structure, 1215, 1234
front, 1215–1216
full, 1216, 1224, 1228–1229
implementation as arrays, 1218–1227
initializing, 1216, 1224, 1229
last element, 1218, 1220, 1222, 1225, 1230
linked implementation of, 1227–1232
maximum size, 1218, 1224
middle elements, 1216
operations, 1216–1217
rear, 1215
relational operators, 1488
temporary, 1246
waiting customers queue, 1245–1247
queues simulation, 1233–1251
queueType class, 1222–1227, 1245–1246
queuing systems, 1234
customers, 1234–1238
designing, 1234–1235
main program, 1247–1251
server list, 1241–1245
servers, 1234, 1238–1241
transaction time, 1234–1235
waiting customers queue, 1245–1247
waiting time, 1234–1235
quick sort algorithm
analysis, 1305–1306
array-based lists, 1298–1306
divide-and-conquer technique, 1299
key comparisons, 1305
for loops, 1300
partitioning list, 1299–1306
recursion, 1305
quotient variable, 235, 1006
q value parameter, 836

R
rAccessIterator random access iterator, 1476–1477
radiusPtr pointer variable, 819–820, 827, 829
radius variable, 148–149, 691, 819–820, 827, 1021
RAM. See random access memory (RAM)
rand function, 282
random access data structure, 1170
random access iterators, 1476–1477
random access memory (RAM), 4–5
random number generator, 363
random numbers, 17, 282
random_shuffle function, 1492, 1531–1535
range-based for loops, 550, 1458–1461

arrays, 834–835
auto declaration, 550
dynamic arrays, 834–835, 1459
formal parameters, 1459
sequence containers, 1473
syntax errors, 834–835
vector objects, 1459–1461, 1473
ranges
accessing and processing elements by applying function,
1535–1537
consecutive elements meeting criteria, 1524–1528
copying elements, 1513–1517
counting occurrences of values, 1531–1535
elements appearing in another range, 1538–1546
elements common to two ranges, 1538–1546
elements not appearing in another range, 1538–1546
element sum of previous elements, 1546–1551
finding elements, 1505–1507
largest element in, 1531–1535
last element, 1507–1510
maximum of values, 1531–1535
minimum of values, 1531–1535
multiplying elements in multiple, 1546–1551
randomly ordering values, 1531–1535
replacing elements, 1513–1517
reversing order of elements, 1528–1531
rotating elements, 1528–1531
searching elements, 1520–1523
sequence of elements, 1535–1537
smallest element in, 1531–1535
sorting elements, 1520–1523
subrange, 1507–1510
summing elements, 1546–1551
swapping elements, 1517–1520
RATE member, 486–487
rate variable, 146, 194, 235
rbegin function, 1453, 1456
readCode function, 577
readCourses function, 473–474
readIn function, 617–618
read statements, 66–69
real alias, 476
real numbers and relational operators, 187–188
rear, 1215
rebuild command, 1, 688
recFriendObject formal parameter, 913
recMergeSort function, 1312–1314
records, 610–626
recQuickSort function, 1305
rectangle class, 739, 750, 860–861
rectangleFriend function, 913–914
rectangle1 object, 922
rectangle2 object, 922
rectangle3 object, 922
rectangle4 object, 922
rectangleType class, 742–743, 745, 747–750, 752–753,
908–911, 914–918, 922–929, 937–944
overloading binary operators, 919–922
private members, 746
rectangleType constructor, 742, 744, 753–754
recursion, 1040
direct, 1042
Fibonacci number, 1047–1050
indirect, 1042
infinite, 1042–1043
largest element in array, 1043–1046

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

printing linked lists in reverse order, 1117–1119
problem solving, 1043–1054
quick sort algorithm, 1305
removing, 1211–1215
selection control structures, 1054
Tower of Hanoi, 1051–1053
recursive algorithms, 1041, 1043–1053, 1353
base cases, 1041
binary search algorithm, 1271
converting into nonrecursive algorithms, 1166
largest element in array, 1043–1046
sequential search algorithm, 1268
recursive definitions, 1040
base cases, 1040
directly recursive functions, 1042
general cases, 1040
indirectly recursive functions, 1042
infinite recursion, 1042–1043
recursive algorithms, 1041
recursive functions, 1041–1042
tail recursive functions, 1042
recursive functions, 1041
designing, 1043
local variables, 1054
memory allocation, 1054
parameters, 1054
unlimited copies of itself, 1042
reference parameters, 378, 406–408
and&, 378
changing values of parameter, 384
class objects, 658–659
declaring as constant, 385
formal parameters, 836, 852–853
manipulating actual parameters, 394–397
memory allocation, 388–397
value-returning functions, 397
reference variables as parameters, 384–388
ref formal parameter, 395
regionNumber variable, 1329
registered variable, 470–471
relational function objects, 1496–1499
relational operators, 187, 616–617, 902–903
associativity, 211–213
binary operators, 187
char data type, 188–189
enumeration types, 469–470
integers, 187–188
order of precedence, 200
queues, 1488
real numbers, 187–188
simple data types, 187–188
stacks, 1487
string data type, 203–204
remainder operator (%), 43–45
removeAt function, 873–874, 877, 973
remove_copy function, 1492, 1510–1513
remove_copy_if function, 1492, 1510–1513
remove function, 872, 875, 877, 975, 1468, 1492,
1510–1513
remove_if function, 1468, 1492, 1510–1513
rend function, 1453, 1456
re object, 1011
repetition, 21, 186–187, 264–266
do...while loops, 307–311
for loops, 295–306
while loop, 267–295

1673

replaceAt function, 872, 875, 877–879,
975, 1329
replace_copy function, 1492, 1513–1517
replace_copy_if function, 1492, 1513–1517
replace function, 495, 500–501, 1492, 1513–1517
replace_if function, 1492, 1513–1517
reserved words, 36, 90
residential function, 369–373
resize function, 1447–1448, 1454
rethrowing exceptions, 1022–1025
retrieveAt function, 874, 973, 1329, 1332
retrievePlay function, 478–480
return escape sequence (\r), 78
return reserved word, 355
return statement, 85, 217–218, 369
returning only one value, 361–362
secret function, 361
value-returning functions, 351, 354–355
void functions, 376
reverse_copy function, 1492, 1528–1531
reverse function, 1470, 1492, 1528–1531
reverseNum function, 695–698
Reverse Polish notation, 1201
reversePrint function, 1117–1119, 1124–1125
rFibNum function, 1047–1050
right child, 1348, 1368
right manipulator, 154–155, 779
rightmost bit, 1059
rightObject formal parameter, 932
right subtree, 1348–1350, 1368–1369, 1373–1375
rLink pointer, 1350–1351, 1370, 1375
rollDice function, 363–365, 691
roll function, 691–692
root, 1351
rooted tree, 1427
root node, 1298, 1348–1350
binary search trees, 1368, 1370
level of, 1352
pointer, 1351, 1353
root pointer, 1362–1363, 1370
rotate_copy function, 1492, 1528–1531
rotate function, 504–505, 1492, 1528–1531
row order form, 569
row processing, 565
rows variable, 839
runSimulation function, 1249–1250
run-time binding, 854, 860
runtime_error class, 1010
runtime errors, 1010
run-together words, 55, 91
ryanHouse variable, 615

S
saleByQuarter function, 633
salePrice variable, 14–15
sales array, 526, 527–528, 530, 560, 561
salesPersonList array, 628–631, 633–635
salesPersonRec struct data type, 628
salesTax variable, 14–15
sale variable, 58
scholarship variable, 153
scientific manipulator, 145–146, 156
scientific notation, 41, 144–146

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1674

|

Index

scope
class members, 658
function names, 398
identifiers, 397–401
namespace member, 486
scope resolution operator (::), 401, 486–487, 489, 660, 704,
745–747, 1449, 1477
score parameter, 386–388
score variable, 195–196, 207, 230, 232, 425, 614
screen, 124
screen ostream iterator, 1457, 1465, 1485, 1503–1504, 1513
search algorithms, 1266–1276, 1491
asymptotic notation, 1276–1284
binary search, 1269–1276
binary search trees, 1378–1379
comparison-based search algorithms, 1284
dominant operations, 1277–1278
growth rate of functions, 1278–1281
keys, 1267
number of comparisons, 1278–1281
sequential search algorithm, 877, 1267–1269
while loops, 1277
searchDVDList function, 1140, 1142, 1391–1392
search function, 1092, 1097–1099, 1106, 1108, 1125,
1362, 1371, 1520–1523
searching
arrays for specific item, 542–549
criteria, 1499
doubly linked lists, 1125
elements, 1520–1523
linear search, 542–545, 877
ordered linked lists, 1107–1108
sequential search, 542–545, 877
server list, 1243–1244
unordered linked lists, 1098–1099
searchItem function, 542, 544
searchItem variable, 620
search_n function, 1491, 1520–1523
searchValue element, 1505
second formal parameter, 395
second iterator, 1517
secondNum variable, 85, 350
second pointer variable, 840–841
secondRect variable, 924
second variable, 62–63, 395
secret function, 361
sec variable, 651–654, 656–657, 660, 663–664, 671, 675,
677–678, 902, 950
selection control structures, 1054
selections, 21, 186–222
multiple, 205–208, 232
one-way, 189–192, 215
two-way, 192–196
selection sort, 545–549, 1290–1292, 1297
selectionSort function, 548–549, 1291–1292
selection structures
if...else statements, 225
if statements, 225
switch structures, 225–232
selection1 variable, 478
selection2 variable, 478
selector, 226
self-assignment, 931–933
self-documenting identifiers, 91
sellProduct function, 710–712

semantic errors, 90
if statements, 192, 195–196
semicolon (;) at end of for loops, 298
semantic rules, 34
semantics, 90
semicolons (;), 35
sentence object, 1011
sentinel, 275–278, 316, 318
sentinel-controlled while loops, 275–281, 316
seqCont sequence container, 1454
seqSearch function, 543–545, 620–621, 872, 875, 877,
975, 978
sequence containers
deque sequence container, 1462–1466
list sequence container, 1466–1472
member functions, 1454
range-based for loops, 1459–1461, 1473
vector sequence container, 1443–1449
sequences
copying elements, 1510–1513
filling, 1503–1505
removing elements, 1510–1513
sequential lists, 1072
sequential search, 542–545, 877
array-based lists, 1267–1269
linked lists, 1267
sequential search algorithm, 1267–1269
array-based lists, 877
serverID variable, 1244
server list, 1241–1245
serverListType class, 1241–1245
servers, 1234, 1238–1241
busy, 1244–1245
set of, 1241–1245
serverType class, 1238–1241
set associative container
declaring, 1480–1482
inserting and deleting items, 1482–1483
operations on, 1483–1486
setBusy function, 1240
set containers and bidirectional iterators, 1476
setCopiesInStock function, 1142
setCourseInfo function, 777–779
setCurrentCustomer function, 1241
setCustomerInfo function, 1237
setData function, 765–766
setDate function, 768–769
set_difference function, 1492, 1538–1546
setDimension function, 742–744, 747, 752–753, 910
setfill manipulator, 152–153, 156, 161
setFree function, 1241
setInfo function, 781, 783
set_intersection function, 1492, 1538–1546
setLength function, 910
setName function, 694–695, 783, 1317
setNameRateHours function, 756
setNum function, 695–698
setpersonalInfo function, 770, 772
setprecision manipulator, 144–145, 147–149, 156
setRadius function, 689, 691, 1019–1020
sets, 879
manipulating, 879
ordered, 881
setServerBusy function, 1244
setSimulationParameters function, 1247–1248

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

set_symmetric_difference function, 1492, 1538–1546
setTime function, 652–654, 656, 660–661, 664, 669, 685,
949
setTransactionTime function, 1241
set_union function, 1492, 1538–1546
setVotes function, 1323
setWaitingTime function, 1238
setWidth function, 910
setw manipulator, 149–152, 156, 963
setX function, 699–700
shallow copy, 841
versus deep copy, 839–841
shape class, 739–740, 860–861
shift operator (>>), 1482
short-circuit evaluation, 209–210
short data type, 38
shortest path, 1418–1426
shortest path algorithm, 1418–1426
shortestPath function, 1424–1425
showChoices function, 406–408
showpoint manipulator, 146–149, 156, 371
showSelection function, 710
signatures, 414
significant digits precision, 42
silent killer, 221
simple assignment statements, 94, 95
simple data types, 38–41, 57, 520
initializing during declaration, 1461
relational operators, 187–188
valid input, 127–130
variables, 125–127
simple graphs, 1407
simple paths, 1407
Simula, 774
simulation parameters, 1247
simulations
implementing, 1249–1250
queues, 1233–1251
time-driven, 1234
single inheritance, 739
single-line (//) comments, 31, 34–35
single precision, 42
single quotation escape sequence (\'), 78
size function, 495–497, 1446, 1452, 1486, 1488
slicing problem, 858
smallestWeight array, 1420–1423
smallIndex variable, 1300–1303
Smalltalk, 774
software, 2, 5
patches, 319–322
sortCourses function, 782–783, 787–788
sorted linked lists, 1085–1086
sorted lists, 868, 872
binary search, 1269–1276
merging, 1524–1528
sort function, 1289–1290, 1328, 1469, 1490, 1492,
1520–1523
sort_heap algorithm, 1493
sorting
arrays, 545–549
criteria, 1499
elements, 1520–1523
lists, 1284–1290
selection sort, 545–549
sorting algorithms, 1266, 1284–1316
bubble sort, 1284–1290

1675

comparison-based, 1297–1298
insertion sort, 1292–1297
key comparisons, 1288–1289
merge sort algorithm, 1306–1315
quick sort algorithm, 1298–1306
selection sort, 1290–1292
source, 1418
source code, 9, 82, 688
source code file, 82
source file, 82
sourceName file, 161
source program, 9
source vertex, 1428
spanning tree, 1427
special symbols, 35
speed variable, 150–151
sphereRadius variable, 133
sphereVolume variable, 133
splice function, 1469, 1472
sports enumeration type, 468–469
sqrt function, 131–133, 347–348, 350
square class, 739
squareFirst function, 395
srand function, 282
stable_partition algorithm, 1492
stable_sort algorithm, 1492
stackADT class, 1168–1169, 1189–1190, 1192
stack class, 1486–1487
stack header file, 1486
stack object, 1172, 1175, 1178, 1190, 1212
stacks, 1166–1168, 1486–1487
adding elements, 1168, 1192–1194
base address of array, 1173
comparing, 1487
converting recursive algorithms into nonrecursive algorithms,
1166
copying, 1172, 1178
empty, 1172, 1174, 1191–1192
full, 1191–1192
implementing as arrays, 1170–1188
implementing function calls, 1166
initializing, 1173–1174, 1192
Last In First Out (LIFO) data structure, 1167, 1170
linked implementation of, 1188–1201
overflow, 1175
pop operation, 1167–1168
push operation, 1167–1168, 1174–1176
relational operators, 1487
removing elements, 1168, 1176–1178
top element, 1172, 1176, 1194
top operation, 1166–1168
underflow, 1178
unorderedLinkedList class, 1200–1201
unwinding, 1028–1031
stackTop variable, 1170, 1172–1174, 1176, 1178–1179,
1189, 1191–1192
stackType class, 1170–1184
stand-alone else statements, 195
Standard C++, 22, 398, 485
standard functions, 34
standard input device, 63–66, 124
standard output device, 72, 124
Standard Template Library (STL), 1442
algorithms, 1442, 1490–1551
associative containers, 1479–1489

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1676

|

Index

Standard Template Library (STL) (Continued)
components, 1442–1473
container adapters, 1486–1489
containers, 1442–1473
function objects, 1493, 1494–1499
insert iterators, 1500–1501
iterators, 1442, 1473–1479
standing enumeration type, 467
starsInLine parameter, 380
statements, 81–82
repetition, 264–266
self-assignment, 931–933
statement terminator (;), 90
statement terminator (;), 90
stateSalesTax variable, 14–15
static arrays, 831
static binding, 854
static_cast reserved word, 51–53
static functions, 698–704
static members, 698–704
static member variables memory allocation, 700–702
static reserved word, 409, 698–699
static variables, 409–410, 698–704
status variable, 1238
stdexcept header file, 1010
std namespace, 80–81, 490
stepwise refinement, 20
STL. See Standard Template Library (STL)
strcmp function, 552–554
strcpy function, 552–554
stream classes, 762–763
stream extraction operator (>>), 63–66, 903
overloading, 924, 926–929
stream functions, 130, 156
stream insertion operator (<<), 32, 59, 72, 903
overloading, 924, 925–926
syntax error, 87
stream manipulators, 156
stream member functions, 130
stream objects, 139
streams, 124
stream variables, 125
passing by reference to functions, 388
string concatenation operator (+), 1010
string data type, 53–54, 471–474, 572
additional operations, 494–503
binary operator (+), 491–492
functions, 494–503
input/output (I/O), 156–157, 557–558
predefined operations, 573
processing array of strings, 572
relational operators, 203–204
usage, 81
variables, 558
string header file, 81, 131–133, 490, 557
stringList object, 970, 978
stringList vector container, 1443
string::npos named constant, 494
string objects, 1010
strings, 30–31, 31, 53–54, 551
accessing individual character in, 492
arrays, 572
character-by-character comparison, 203–204
clearing, 496–497
concatenating, 491

containing blanks, 156
containing message, 1010
converting to null-terminated string, 557–558
empty, 53, 496–497
input, 554–556
inserting, 500–501
length, 53–54, 131–133, 496–498
manipulating, 54
multiple-line, 78
null, 53
null-terminated, 557–558
output, 77–78, 149–151, 556
output statements, 77–78
palindromes, 368–369
reading, 65–66, 156–157, 554–555, 555
relative position of characters, 53
replacing, 500–501
searching, 498–500
size, 496–497
slash (\) within, 162
storing in string variable, 67
subscript out of range error, 1010
substrings, 502–503
writing, 554
string::size_type data type, 494, 498, 500
string variables, 67, 491–492, 503
strlen function, 552–554
strongly connected, 1407
Stroustrup, Bjarne, 22
str pointer, 827
str string variable, 494
struct data type
accessing members, 612–615
arrays, 619–623
versus arrays, 618
versus classes, 682–683
components, 682
defining, 611–612
length, 619–621
members, 610
passing by reference, 621
passing by value, 621
public members, 683
struct data type, 623–626
values, 619–621
struct reserved word, 610
structs
accessing components with pointer, 821
declaring, 820
nodes as, 1073, 1086
public members, 820
struct statement, 610–611
structured data types, 520
structured design, 20–21
structured programming, 20, 772–775
struct variables
assigning value, 615–616
comparing member-wise, 616–617
declaring, 611–612
functions and, 617–618
as global variables, 612
input/output (I/O), 617
name, 612
passing as parameter by value or by reference, 617–618
printing contents, 618
reading and writing, 617

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

str variable, 58, 978
str1 variable, 491, 498, 966
str2 variable, 491, 498, 966
str3 variable, 491, 966
strVar string variable, 156, 494, 557
stubbs, 412–413
studentID array, 558–559
studentList array, 789
studentName array, 552
student object, 771, 820
studentPtr pointer variable, 820–821
student struct variable, 616
studentType class, 780–788
studentType struct, 820–821
studentType struct variable, 618
style member, 611
subgraphs, 1405
subproblems, 18, 20
subprograms, 34
subscript operator ([]), 1448, 1451
overloading, 958–966
subset, 1405
substr function, 495, 502–503, 1010–1011
subtraction compound operator (-=), 94–95
subtraction operator (-), 43, 45, 903
subtrees, 1353
sumArray function, 534–535, 538
sumDigits function, 696–698
sumRows function, 569–571
sum variable, 290, 301, 303, 310, 312, 316, 364, 998
sumVotes variable, 1333–1334
surface area, 774–775
swap function, 495, 503, 1291–1292, 1304, 1453, 1492,
1517–1520
swap_ranges function, 1492, 1517–1520
switch reserved word, 225
switch statements, 189, 281, 290, 303, 471
break statement, 227, 234, 311
case statement, 226–227
default label, 227
evaluating expression to logical value, 231
expressions, 225–227, 230
general rules for, 226–227
identifier, 226
immediately exiting, 227, 311
multiple selections, 232
nesting, 231–232
range of values, 232
selector, 226
skipping remainder of, 311
switch structures, 225–232
syntax, 13
syntax errors, 10–11, 92, 157
correcting in top-down fashion, 87
detecting, 89
identifying, 85
range-based for loops, 834–835
semicolon (;) after expressions in if...else statements, 224
two-way selections, 194–195
understanding and fixing, 85–88
syntax rules, 34, 89
system programs, 5
system-provided header files, 684, 757

1677

T
tab escape sequence (\t), 78, 79
tableType data type, 574
tail recursive functions, 1042
target, 1269
tax member, 611
temp array, 963
temperature variable, 208
temp formal parameter, 852
tempHouse variable, 612
template instantiations, 971
template reserved word, 967
templates, 774, 902, 967–978
class templates, 967, 969–971
function templates, 967–969
tempNum variable, 87
temp object, 1330–1331, 1334
temporary queue, 1246
tempRect object, 917
tempRect variable, 924
temp variable, 939, 1293
temp1 vector, 1513, 1517
temp2 vector, 1513, 1517
terabytes (TB), 6
terminate function, 1028
ternary operator, 221
testAddress class, 881–883
testA.h header file, 758–759
test class, 907
testCopyConstr function, 852
testExp() function, 836
testFunc function, 835
test function, 410
test.h header file, 758–759
testScore member, 614
testScore parameter, 379
testScore variable, 173, 233–234, 290
testTime function, 659
test1 variable, 173
test2 variable, 173
test3 variable, 173
test4 variable, 173
test5 variable, 173
text editors, 9, 11
TextPad, 162
t global variable, 401
this pointer, 931–932, 938
operator overloading, 907–911
this reserved word, 907
three class, 757
three function, 401
throwing exceptions, 1003–1004, 1013–1025
throw reserved word, 1004
throw statement, 1003, 1006, 1013, 1022
time-driven simulations, 1234
time function, 282
timeZone variable, 738
title parameter, 1142
t member, 490
tokens, 35–36
tolerance variable, 146
tolower function, 348
top-down design, 20
top function, 1176, 1192, 1194, 1486

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1678

|

Index

topological ordering, 1433
top operation, 1166–1168
totalAverage variable, 18–19
totalNumOfBoxesSold variable, 274–275, 277
totalSaleByPerson function, 633–634
totalSaleByQuarter array, 628, 633–635
totalSales variable, 16
totalScore variable, 425
totalVotes variable, 1326
toupper function, 348, 350–351, 1537
trailCurrent pointer, 1108–1109, 1111, 1113, 1122,
1371, 1375
transaction time, 1234–1235
transactionTime function, 1241
transactionTime variable, 1235, 1237–1238, 1244–1245
transform function, 1492, 1535–1537
transistors, 3
traversal algorithms and binary trees, 1383–1386
treeHeight function, 1363
treeLeavesCount function, 1364
treeNodeCount function, 1363
treeRoot object, 1386
TRUE named constant, 476
true reserved word, 40, 196
try blocks, 1002–1003, 1005–1006, 1010, 1022, 1027
try/catch blocks, 1002–1009, 1013, 1028, 1031
tTime parameter, 1244
tuitionRate variable, 789
Turbo Pascal, 774
t variable, 403, 489–490
two class, 757
two-dimensional arrays, 560
accessing components, 561–562
column processing, 565
declaring, 569, 573–574
dynamic, 836–839
entering elements, 839
enumeration types, 563–566
indexes, 561–566
initialization during declaration, 562–563
initializing, 566
outputting elements, 839
passing as parameters to functions, 568–571
passing by reference, 568–571
printing, 566–567
processing, 564–566
row order form, 569
row processing, 565
single-element processing, 565
storing in memory, 569
table-form data, 560
two formal parameter, 912
two function, 912
two local variable, 912
two value parameter, 395
TWO variable, 758, 759
two-way selections, 192–196
.txt extension, 162
type casting, 51–53
type conversion, 51–53
Type data type, 959
typedef const_iterator iterator, 1478
typedef const_reference iterator, 1478
typedef const_reverse_iterator iterator, 1478
typedef difference_type iterator, p1478

typedef iterator, 1448–1449, 1477–1478
typedef pointer iterator, 1478
typedef reference iterator, 1478
typedef reserved word, 475, 574
typedef reverse_iterator iterator, 1478
typedef size_type iterator, 1478
typedef statement, 475–476
typedef value_type iterator, 1478
Type formal parameter, 967
type name, 681
typename keyword, 967

U
u member, 490
unary operators, 45
overloading, 937–943
underflow, 1178
underflow_error class, 1010
undirected graphs, 1405–1408
Unicode, 7
Unified Modeling Language (UML) diagram, 654
union, 1405
unique_copy algorithm, 1492
unique function, 1468, 1472, 1492
Universal Automatic Computer (UNIVAC), 3
University of Pennsylvania, 3
UNIX, end-of-file marker, 286
unorderedArrayListType class, 872, 875–879, 972,
975, 978, 1320
bubble sort algorithm, 1289–1290
function templates, 976
unorderedLinkedList class, 1085, 1091, 1097–1106,
1138, 1266, 1313, 1410
queue derived from, 1232–1233
stacks derived from, 1200–1201
unordered linked lists, 1085
deleting nodes, 1100–1104
elements unordered, 1085
header file, 1105–1106
inserting first node, 1099–1100
inserting items, 1086
inserting last node, 1099
searching, 1098–1099
unordered lists, 868, 872, 875–879
inserting item, 875–876
length, 876
removing item from, 877
replacing items, 877–878
traversing, 1104
unorderedListType class, 1105–1106
unordered sets, 879
unorderedSetType class, 879
unorderLinkedList class, 1139
unsetf stream member function, 145, 154
unsigned char data type, 38
unsigned int data type, 38
unsigned long data type, 38
unsigned long long data type, 38
unsigned short data type, 38
unwinding stack, 1028–1031
update function, 1386
updateServers function, 1244–1245
updateVotesByRegion function, 1323

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

Index |

updateWaitingQueue function, 1246–1247
upper_bound algorithm, 1491
upperSublist sublist, 1299–1306
U.S. Census Bureau, 3
usCoins variable, 475
user-defined data types, 38, 466–475
user-defined exception classes
anonymous object of, 1014–1015
error messages, 1015
throwing exceptions, 1013–1021
user-defined functions, 350–351
order in programs, 358
scope of identifier, 397–401
value-returning functions, 351–375
void functions, 351, 376–382
user-defined header files, 684, 757
user-defined identifiers, 36
user-defined variables, 161
using namespace statement, 85
using reserved word, 81
using statement, 486–489
u variable, 490

V
validSelection function, 478–479
value parameters, 378, 382–384, 406–408
class objects as, 659
formal parameters as, 856–857
memory allocation, 388–397
not passing results to calling function, 384
value-returning functions
actual parameter list, 354
assignment statements, 351
calling, 353–354
data types, 353
formal parameter list, 353–354
function prototypes, 358–360
function stub, 412
local declaration, 355
output statements, 351
as parameter in function call, 351
reference parameters, 397
returning value, 360–361, 374
return statements, 351, 354–355, 361, 397
return type, 353
syntax, 353
using value, 351
values
functions unable to return value of type array, 538–541
ordered set of, 467
tracing through sequence, 61
val value parameter, 395
varChar variable, 134
variables, 33, 56–57
allocating, 824–825
arrays, 524
assigning value to, 57–61
auto declaration, 22
automatic, 409–410, 698
changing value, 68–69
as class members, 650–651
data types, 42–43, 61, 468
declared within block, 409

1679

declaring, 42–43, 56–57, 61, 81, 83, 92, 194
declaring and initializing, 62–63, 549–550
declaring when defining enumeration type, 474–475
dynamic, 824–827
incrementing and decrementing values, 70–72
initializing, 58, 66–69, 418
input stream, 125
int data type, 812
invalid data, 998
memory allocation, 54–57, 388, 409
naming, 57
not initialized, 224, 669
output stream, 125
passed by reference, 658
passed by value, 620, 658
protected, 872
putting data into, 57–61
reading string into, 156–157
simple data types, 125–127
standard input device, 63–66
static, 409–410, 698–704
storing value in, 43, 468–469
string data type, 203–204, 558
using value without initializing, 67
using without declaring or initializing, 213
vecCount container, 1446
vecItr iterator, 1525, 1528
vecList vector, 1497, 1503–1505, 1523, 1525,
1527–1528
vecList vector container, 1444, 1446, 1450, 1456–1457
vector class, 1443–1449
vector containers, 1455, 1478
bidirectional iterators, 1476
declaring iterator, 1448–1449
first element 0 (zero), 1445
manipulating data, 1445–1447
number of elements in, 1446
processing elements, 1450–1452
vector header file, 1443
vector objects
declaring, 1444–1445
initializing during declaration, 1461
inserting element, 1449–1450
multiplying each element by 2, 1459
range-based for loops, 1459–1461, 1473
vector sequence container, 1443–1449, 1454
vertex component, 1409, 1420
vertices, 1405, 1406
adjacent, 1407
adjacent from, 1407
adjacent to, 1407
component, 1407
connected, 1407
cycle, 1407, 1408
depth first ordering, 1414–1415
incident, 1407
labeling, 1410
loops, 1407
simple paths, 1407
source, 1418
weight of the edge, 1418
virtual destructors, 859
virtual functions, 774, 854–856, 859–860
virtual reserved word, 854
visited array, 1415

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

1680

|

Index

visit pointer, 1384
Visual C++ 2012 Express, 11, 688
Visual Studio 2012, 11, 688
Visual Studio .NET, 162
vList vector, 1499–1500
void functions, 351, 376–382, 660
function stub, 412
volume, 774–775
volume function, 744, 747
volume variable, 148–149
von Leibniz, Gottfried, 2
von Neumann, John, 3
votesByRegion array, 1326
votesByRegion variable, 1329, 1332

W
wages variable, 193, 235
waitingCustomerQueueType class, 1245–1247
waiting customers queue, 1245–1247
waitingCustomersQueue variable, 1249
waitingTime variable, 1235, 1237
walk-through, 61, 69
weight, 1418
weighted graphs, 1418
weightedGraphType class, 1419–1420
weighted tree, 1427
weightFound array, 1420–1424
weight of the edge, 1418
weight of the path, 1418
weight reference parameter, 1056–1059
weight variable, 66, 141, 197
w global variable, 401
what function, 1009–1011, 1015, 1017
while loops, 267–295, 1054, 1213, 1215
binary search algorithm, 1271, 1274–1275
body, 267, 269, 271
break statement, 311
continue statement, 313
counter-controlled, 272–275, 316
decision maker, 267
empty or null, 270
EOF-controlled, 284–290, 317–318
equivalent to for loops, 301–302
expressions, 267, 269, 271, 290–291
Fibonacci number, 291–295
flag-controlled, 281–284, 290
flow of execution, 267
immediately exiting, 311–312
iterations, 269
loop condition, 308
loop control variable (LCV), 270–271
loop entry condition, 267, 271
nesting, 278
never executing, 308–309
positive numbers, 312

repeating statements, 267–268
search algorithms, 1277
sentinel-controlled, 275–281, 316
sequential search algorithm, 1268
while reserved word, 267
white spaces, 37, 126
extraction operator (>>), 130, 156
inputting, 134
width variable, 19, 33, 742, 744, 746, 749–750, 752, 913,
917
winCount1 variable, 478
winCount2 variable, 478
Windows 8, 5
Windows console environment, 286
winLoc variable, 1333–1334
winningObject function, 478, 482
Wordpad, 162
Wozniak, Stephen, 3
wrappingCostPerSquareFeet variable, 752
writeTotal function, 583, 584–585

X
x
x
x
x
x
x

array, 534–535
catch block parameter, 1003
formal parameter, 967
member, 490
object, 907
variable, 57, 61, 71, 94, 211, 221, 409–410, 656,
700–704, 814–815, 824, 881, 1461

Y
y alias, 881
yard object, 752–753
y array, 534–535
yearBuilt member, 611
yearToDatePaid variable, 622
y formal parameter, 967
y object, 907
yourClock object, 655–658, 662, 667, 669, 672, 902, 907
yourList array, 531–532, 537
yourList variable, 542
yourRectangle object, 911, 917–918, 922, 929–930, 938
yourTime object, 677
y private static variable, 699–700
y static member variable, 700, 703
y variable, 57, 61, 71, 94, 211, 221, 410, 656, 700–704

Z
zeros variable, 304–305, 418–419
zettabytes (ZB), 6
z variable, 221, 656

Copyright 2015 Cengage Learning. All Rights Reserved. May not be copied, scanned, or duplicated, in whole or in part. Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience. Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.

